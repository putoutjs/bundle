var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, '__esModule')) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			var isInstance = false;
      try {
        isInstance = this instanceof a;
      } catch {}
			if (isInstance) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var putout$1 = {exports: {}};

var global$1 = (typeof global !== "undefined" ? global :
  typeof self !== "undefined" ? self :
  typeof window !== "undefined" ? window : {});

// shim for using process in browser
// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === 'function') {
    cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === 'function') {
    cachedClearTimeout = clearTimeout;
}

function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
}
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
var title = 'browser';
var platform = 'browser';
var browser$1 = true;
var env = {};
var argv = [];
var version = ''; // empty string to avoid regexp issues
var versions = {};
var release = {};
var config = {};

function noop$6() {}

var on = noop$6;
var addListener = noop$6;
var once$a = noop$6;
var off = noop$6;
var removeListener = noop$6;
var removeAllListeners = noop$6;
var emit = noop$6;

function binding(name) {
    throw new Error('process.binding is not supported');
}

function cwd () { return '/' }
function chdir (dir) {
    throw new Error('process.chdir is not supported');
}function umask() { return 0; }

// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
var performance = global$1.performance || {};
var performanceNow =
  performance.now        ||
  performance.mozNow     ||
  performance.msNow      ||
  performance.oNow       ||
  performance.webkitNow  ||
  function(){ return (new Date()).getTime() };

// generate timestamp or delta
// see http://nodejs.org/api/process.html#process_process_hrtime
function hrtime(previousTimestamp){
  var clocktime = performanceNow.call(performance)*1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor((clocktime%1)*1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds<0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds,nanoseconds]
}

var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1000;
}

var browser$1$1 = {
  nextTick: nextTick,
  title: title,
  browser: browser$1,
  env: env,
  argv: argv,
  version: version,
  versions: versions,
  on: on,
  addListener: addListener,
  once: once$a,
  off: off,
  removeListener: removeListener,
  removeAllListeners: removeAllListeners,
  emit: emit,
  binding: binding,
  cwd: cwd,
  chdir: chdir,
  umask: umask,
  hrtime: hrtime,
  platform: platform,
  release: release,
  config: config,
  uptime: uptime
};

var _polyfillNode_process = /*#__PURE__*/Object.freeze({
	__proto__: null,
	addListener: addListener,
	argv: argv,
	binding: binding,
	browser: browser$1,
	chdir: chdir,
	config: config,
	cwd: cwd,
	default: browser$1$1,
	emit: emit,
	env: env,
	hrtime: hrtime,
	nextTick: nextTick,
	off: off,
	on: on,
	once: once$a,
	platform: platform,
	release: release,
	removeAllListeners: removeAllListeners,
	removeListener: removeListener,
	title: title,
	umask: umask,
	uptime: uptime,
	version: version,
	versions: versions
});

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;
function init$2 () {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
}

function toByteArray (b64) {
  if (!inited) {
    init$2();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = (tmp >> 16) & 0xFF;
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
    output.push(tripletToBase64(tmp));
  }
  return output.join('')
}

function fromByteArray (uint8) {
  if (!inited) {
    init$2();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[(tmp << 4) & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
    output += lookup[tmp >> 10];
    output += lookup[(tmp >> 4) & 0x3F];
    output += lookup[(tmp << 2) & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('')
}

function read (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? (nBytes - 1) : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

function write (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
  var i = isLE ? 0 : (nBytes - 1);
  var d = isLE ? 1 : -1;
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
}

var toString = {}.toString;

var isArray$f = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */


var INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
  ? global$1.TYPED_ARRAY_SUPPORT
  : true;

/*
 * Export kMaxLength after typed array support is determined.
 */
kMaxLength();

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr
};

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) ;
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
};

function allocUnsafe (that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
};

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that
}

function fromObject (that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len);
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray$f(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}
Buffer.isBuffer = isBuffer;
function internalIsBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
};

Buffer.concat = function concat (list, length) {
  if (!isArray$f(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer
};

function byteLength (string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString (encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Array.isArray` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap (b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this
};

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this
};

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this
};

Buffer.prototype.toString = function toString () {
  var length = this.length | 0;
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
};

Buffer.prototype.equals = function equals (b) {
  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
};

Buffer.prototype.inspect = function inspect () {
  var str = '';
  var max = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>'
};

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1);
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (internalIsBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
};

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
};

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
};

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed;
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
};

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf)
  } else {
    return fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val
};

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val
};

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset]
};

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | (this[offset + 1] << 8)
};

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return (this[offset] << 8) | this[offset + 1]
};

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
};

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
};

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
};

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | (this[offset + 1] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | (this[offset] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
};

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
};

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4)
};

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4)
};

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8)
};

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8)
};

function checkInt (buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = (value & 0xff);
  return offset + 1
};

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24);
    this[offset + 2] = (value >>> 16);
    this[offset + 1] = (value >>> 8);
    this[offset] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = (value & 0xff);
  return offset + 1
};

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
    this[offset + 2] = (value >>> 16);
    this[offset + 3] = (value >>> 24);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
};

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
};

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    );
  }

  return len
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        }

        // valid lead
        leadSurrogate = codePoint;

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray
}


function base64ToBytes (str) {
  return toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i];
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}


// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
}

function isFastBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
}

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value,
}) : obj[key] = value;

var __commonJS = (cb, mod) => function __require() {
    return (mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
        exports: {},
    }).exports, mod), mod.exports);
};

var __export = (target, all) => {
    for (var name in all)    __defProp(target, name, {
        get: all[name],
        enumerable: true,
    });
};

var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === 'object' || typeof from === 'function') {
        for (let key of __getOwnPropNames(from))
            if (!__hasOwnProp.call(to, key) && key !== except)
                __defProp(to, key, {
                    get: () => from[key],
                    enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,
                });
    }
    
    return to;
};

var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
// file that has been converted to a CommonJS file using a Babel-
// compatible transform (i.e. "__esModule" has not been set), then set
// "default" to the CommonJS "module.exports" for node compatibility.
__defProp(target, 'default', {
    value: mod,
    enumerable: true,
}) , mod));

var __toCommonJS = (mod) => __copyProps(__defProp({}, '__esModule', {
    value: true,
}), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== 'symbol' ? key + '' : key, value);

// node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS({
    'node_modules/picocolors/picocolors.js'(exports2, module2) {
        var p = browser$1$1 || {};
        var argv = p.argv || [];
        var env = p.env || {};
        var isColorSupported2 = !(!!env.NO_COLOR || argv.includes('--no-color'))
            && (!!env.FORCE_COLOR
            || argv.includes('--color')
            || p.platform === 'win32'
            || (p.stdout || {}).isTTY
            && env.TERM !== 'dumb'
            || !!env.CI);
        
        var formatter = (open, close, replace = open) => (input) => {
            let string = '' + input, index2 = string.indexOf(close, open.length);
            return ~index2 ? open + replaceClose(string, close, replace, index2) + close : open + string + close;
        };
        
        var replaceClose = (string, close, replace, index2) => {
            let result = '', cursor = 0;
            
            do {
                result += string.substring(cursor, index2) + replace;
                cursor = index2 + close.length;
                index2 = string.indexOf(close, cursor);
            } while (~index2)
            
            return result + string.substring(cursor);
        };
        
        var createColors2 = (enabled = isColorSupported2) => {
            let f = enabled ? formatter : () => String;
            
            return {
                isColorSupported: enabled,
                reset: f('\x1B[0m', '\x1B[0m'),
                bold: f('\x1B[1m', '\x1B[22m', '\x1B[22m\x1B[1m'),
                dim: f('\x1B[2m', '\x1B[22m', '\x1B[22m\x1B[2m'),
                italic: f('\x1B[3m', '\x1B[23m'),
                underline: f('\x1B[4m', '\x1B[24m'),
                inverse: f('\x1B[7m', '\x1B[27m'),
                hidden: f('\x1B[8m', '\x1B[28m'),
                strikethrough: f('\x1B[9m', '\x1B[29m'),
                black: f('\x1B[30m', '\x1B[39m'),
                red: f('\x1B[31m', '\x1B[39m'),
                green: f('\x1B[32m', '\x1B[39m'),
                yellow: f('\x1B[33m', '\x1B[39m'),
                blue: f('\x1B[34m', '\x1B[39m'),
                magenta: f('\x1B[35m', '\x1B[39m'),
                cyan: f('\x1B[36m', '\x1B[39m'),
                white: f('\x1B[37m', '\x1B[39m'),
                gray: f('\x1B[90m', '\x1B[39m'),
                bgBlack: f('\x1B[40m', '\x1B[49m'),
                bgRed: f('\x1B[41m', '\x1B[49m'),
                bgGreen: f('\x1B[42m', '\x1B[49m'),
                bgYellow: f('\x1B[43m', '\x1B[49m'),
                bgBlue: f('\x1B[44m', '\x1B[49m'),
                bgMagenta: f('\x1B[45m', '\x1B[49m'),
                bgCyan: f('\x1B[46m', '\x1B[49m'),
                bgWhite: f('\x1B[47m', '\x1B[49m'),
                blackBright: f('\x1B[90m', '\x1B[39m'),
                redBright: f('\x1B[91m', '\x1B[39m'),
                greenBright: f('\x1B[92m', '\x1B[39m'),
                yellowBright: f('\x1B[93m', '\x1B[39m'),
                blueBright: f('\x1B[94m', '\x1B[39m'),
                magentaBright: f('\x1B[95m', '\x1B[39m'),
                cyanBright: f('\x1B[96m', '\x1B[39m'),
                whiteBright: f('\x1B[97m', '\x1B[39m'),
                bgBlackBright: f('\x1B[100m', '\x1B[49m'),
                bgRedBright: f('\x1B[101m', '\x1B[49m'),
                bgGreenBright: f('\x1B[102m', '\x1B[49m'),
                bgYellowBright: f('\x1B[103m', '\x1B[49m'),
                bgBlueBright: f('\x1B[104m', '\x1B[49m'),
                bgMagentaBright: f('\x1B[105m', '\x1B[49m'),
                bgCyanBright: f('\x1B[106m', '\x1B[49m'),
                bgWhiteBright: f('\x1B[107m', '\x1B[49m'),
            };
        };
        
        module2.exports = createColors2();
        module2.exports.createColors = createColors2;
    },
});

// node_modules/js-tokens/index.js
var require_js_tokens = __commonJS({
    'node_modules/js-tokens/index.js'(exports2, module2) {
        var Identifier3;
        var JSXIdentifier3;
        var JSXPunctuator;
        var JSXString;
        var JSXText3;
        var KeywordsWithExpressionAfter;
        var KeywordsWithNoLineTerminatorAfter;
        var LineTerminatorSequence;
        var MultiLineComment;
        var Newline;
        var NumericLiteral4;
        var Punctuator;
        var RegularExpressionLiteral;
        var SingleLineComment;
        var StringLiteral4;
        var Template;
        var TokensNotPrecedingObjectLiteral;
        var TokensPrecedingExpression;
        var WhiteSpace;
        
        RegularExpressionLiteral = /\/(?![*\/])(?:\[(?:[^\]\\\n\r\u2028\u2029]+|\\.)*\]|[^\/\\\n\r\u2028\u2029]+|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/yu;
        Punctuator = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y;
        Identifier3 = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]+|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/yu;
        StringLiteral4 = /(['"])(?:[^'"\\\n\r]+|(?!\1)['"]|\\(?:\r\n|[^]))*(\1)?/y;
        NumericLiteral4 = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y;
        Template = /[`}](?:[^`\\$]+|\\[^]|\$(?!\{))*(`|\$\{)?/y;
        WhiteSpace = /[\t\v\f\ufeff\p{Zs}]+/yu;
        LineTerminatorSequence = /\r?\n|[\r\u2028\u2029]/y;
        MultiLineComment = /\/\*(?:[^*]+|\*(?!\/))*(\*\/)?/y;
        SingleLineComment = /\/\/.*/y;
        JSXPunctuator = /[<>.:={}]|\/(?![\/*])/y;
        JSXIdentifier3 = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/yu;
        JSXString = /(['"])(?:[^'"]+|(?!\1)['"])*(\1)?/y;
        JSXText3 = /[^<>{}]+/y;
        TokensPrecedingExpression = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;
        TokensNotPrecedingObjectLiteral = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;
        KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;
        KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/;
        Newline = RegExp(LineTerminatorSequence.source);
        module2.exports =
        function*(input, {jsx: jsx2 = false} = {}) {
            var braces,
                firstCodePoint,
                isExpression4,
                lastIndex,
                lastSignificantToken,
                length,
                match,
                mode,
                nextLastIndex,
                nextLastSignificantToken,
                parenNesting,
                postfixIncDec,
                punctuator,
                stack;
            
            ({length} = input);
            lastIndex = 0;
            lastSignificantToken = '';
            stack = [{
                tag: 'JS',
            }];
            braces = [];
            parenNesting = 0;
            postfixIncDec = false;
            while (lastIndex < length) {
                mode = stack[stack.length - 1];
                switch(mode.tag) {
                case 'JS':                
                case 'JSNonExpressionParen':                
                case 'InterpolationInTemplate':                
                case 'InterpolationInJSX':
                    if (input[lastIndex] === '/' && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
                        RegularExpressionLiteral.lastIndex = lastIndex;
                        
                        if (match = RegularExpressionLiteral.exec(input)) {
                            lastIndex = RegularExpressionLiteral.lastIndex;
                            lastSignificantToken = match[0];
                            postfixIncDec = true;
                            yield {
                                type: 'RegularExpressionLiteral',
                                value: match[0],
                                closed: match[1] !== void 0 && match[1] !== '\\',
                            };
                            continue;
                        }
                    }
                    
                    Punctuator.lastIndex = lastIndex;
                    
                    if (match = Punctuator.exec(input)) {
                        punctuator = match[0];
                        nextLastIndex = Punctuator.lastIndex;
                        nextLastSignificantToken = punctuator;
                        switch(punctuator) {
                        case '(':
                            if (lastSignificantToken === '?NonExpressionParenKeyword') {
                                stack.push({
                                    tag: 'JSNonExpressionParen',
                                    nesting: parenNesting,
                                });
                            }
                            
                            parenNesting++;
                            postfixIncDec = false;
                            break;
                        
                        case ')':
                            parenNesting--;
                            postfixIncDec = true;
                            
                            if (mode.tag === 'JSNonExpressionParen' && parenNesting === mode.nesting) {
                                stack.pop();
                                nextLastSignificantToken = '?NonExpressionParenEnd';
                                postfixIncDec = false;
                            }
                            
                            break;
                        
                        case '{':
                            Punctuator.lastIndex = 0;
                            isExpression4 = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken));
                            braces.push(isExpression4);
                            postfixIncDec = false;
                            break;
                        
                        case '}':
                            switch(mode.tag) {
                            case 'InterpolationInTemplate':
                                if (braces.length === mode.nesting) {
                                    Template.lastIndex = lastIndex;
                                    match = Template.exec(input);
                                    lastIndex = Template.lastIndex;
                                    lastSignificantToken = match[0];
                                    
                                    if (match[1] === '${') {
                                        lastSignificantToken = '?InterpolationInTemplate';
                                        postfixIncDec = false;
                                        yield {
                                            type: 'TemplateMiddle',
                                            value: match[0],
                                        };
                                    } else {
                                        stack.pop();
                                        postfixIncDec = true;
                                        yield {
                                            type: 'TemplateTail',
                                            value: match[0],
                                            closed: match[1] === '`',
                                        };
                                    }
                                    
                                    continue;
                                }
                                
                                break;
                            
                            case 'InterpolationInJSX':
                                if (braces.length === mode.nesting) {
                                    stack.pop();
                                    lastIndex += 1;
                                    lastSignificantToken = '}';
                                    yield {
                                        type: 'JSXPunctuator',
                                        value: '}',
                                    };
                                    continue;
                                }
                            }
                            
                            postfixIncDec = braces.pop();
                            nextLastSignificantToken = postfixIncDec ? '?ExpressionBraceEnd' : '}';
                            break;
                        
                        case ']':
                            postfixIncDec = true;
                            break;
                        
                        case '++':                        
                        case '--':
                            nextLastSignificantToken = postfixIncDec ? '?PostfixIncDec' : '?UnaryIncDec';
                            break;
                        
                        case '<':
                            if (jsx2 && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
                                stack.push({
                                    tag: 'JSXTag',
                                });
                                lastIndex += 1;
                                lastSignificantToken = '<';
                                yield {
                                    type: 'JSXPunctuator',
                                    value: punctuator,
                                };
                                continue;
                            }
                            
                            postfixIncDec = false;
                            break;
                        
                        default:
                            postfixIncDec = false;
                        }
                        
                        lastIndex = nextLastIndex;
                        lastSignificantToken = nextLastSignificantToken;
                        yield {
                            type: 'Punctuator',
                            value: punctuator,
                        };
                        continue;
                    }
                    
                    Identifier3.lastIndex = lastIndex;
                    
                    if (match = Identifier3.exec(input)) {
                        lastIndex = Identifier3.lastIndex;
                        nextLastSignificantToken = match[0];
                        switch(match[0]) {
                        case 'for':                        
                        case 'if':                        
                        case 'while':                        
                        case 'with':
                            if (lastSignificantToken !== '.' && lastSignificantToken !== '?.') {
                                nextLastSignificantToken = '?NonExpressionParenKeyword';
                            }
                        }
                        
                        lastSignificantToken = nextLastSignificantToken;
                        postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]);
                        yield {
                            type: match[1] === '#' ? 'PrivateIdentifier' : 'IdentifierName',
                            value: match[0],
                        };
                        continue;
                    }
                    
                    StringLiteral4.lastIndex = lastIndex;
                    
                    if (match = StringLiteral4.exec(input)) {
                        lastIndex = StringLiteral4.lastIndex;
                        lastSignificantToken = match[0];
                        postfixIncDec = true;
                        yield {
                            type: 'StringLiteral',
                            value: match[0],
                            closed: match[2] !== void 0,
                        };
                        continue;
                    }
                    
                    NumericLiteral4.lastIndex = lastIndex;
                    
                    if (match = NumericLiteral4.exec(input)) {
                        lastIndex = NumericLiteral4.lastIndex;
                        lastSignificantToken = match[0];
                        postfixIncDec = true;
                        yield {
                            type: 'NumericLiteral',
                            value: match[0],
                        };
                        continue;
                    }
                    
                    Template.lastIndex = lastIndex;
                    
                    if (match = Template.exec(input)) {
                        lastIndex = Template.lastIndex;
                        lastSignificantToken = match[0];
                        
                        if (match[1] === '${') {
                            lastSignificantToken = '?InterpolationInTemplate';
                            stack.push({
                                tag: 'InterpolationInTemplate',
                                nesting: braces.length,
                            });
                            postfixIncDec = false;
                            yield {
                                type: 'TemplateHead',
                                value: match[0],
                            };
                        } else {
                            postfixIncDec = true;
                            yield {
                                type: 'NoSubstitutionTemplate',
                                value: match[0],
                                closed: match[1] === '`',
                            };
                        }
                        
                        continue;
                    }
                    
                    break;
                
                case 'JSXTag':                
                case 'JSXTagEnd':
                    JSXPunctuator.lastIndex = lastIndex;
                    
                    if (match = JSXPunctuator.exec(input)) {
                        lastIndex = JSXPunctuator.lastIndex;
                        nextLastSignificantToken = match[0];
                        switch(match[0]) {
                        case '<':
                            stack.push({
                                tag: 'JSXTag',
                            });
                            break;
                        
                        case '>':
                            stack.pop();
                            
                            if (lastSignificantToken === '/' || mode.tag === 'JSXTagEnd') {
                                nextLastSignificantToken = '?JSX';
                                postfixIncDec = true;
                            } else {
                                stack.push({
                                    tag: 'JSXChildren',
                                });
                            }
                            
                            break;
                        
                        case '{':
                            stack.push({
                                tag: 'InterpolationInJSX',
                                nesting: braces.length,
                            });
                            nextLastSignificantToken = '?InterpolationInJSX';
                            postfixIncDec = false;
                            break;
                        
                        case '/':
                            if (lastSignificantToken === '<') {
                                stack.pop();
                                
                                if (stack[stack.length - 1].tag === 'JSXChildren') {
                                    stack.pop();
                                }
                                
                                stack.push({
                                    tag: 'JSXTagEnd',
                                });
                            }
                        }
                        
                        lastSignificantToken = nextLastSignificantToken;
                        yield {
                            type: 'JSXPunctuator',
                            value: match[0],
                        };
                        continue;
                    }
                    
                    JSXIdentifier3.lastIndex = lastIndex;
                    
                    if (match = JSXIdentifier3.exec(input)) {
                        lastIndex = JSXIdentifier3.lastIndex;
                        lastSignificantToken = match[0];
                        yield {
                            type: 'JSXIdentifier',
                            value: match[0],
                        };
                        continue;
                    }
                    
                    JSXString.lastIndex = lastIndex;
                    
                    if (match = JSXString.exec(input)) {
                        lastIndex = JSXString.lastIndex;
                        lastSignificantToken = match[0];
                        yield {
                            type: 'JSXString',
                            value: match[0],
                            closed: match[2] !== void 0,
                        };
                        continue;
                    }
                    
                    break;
                
                case 'JSXChildren':
                    JSXText3.lastIndex = lastIndex;
                    
                    if (match = JSXText3.exec(input)) {
                        lastIndex = JSXText3.lastIndex;
                        lastSignificantToken = match[0];
                        yield {
                            type: 'JSXText',
                            value: match[0],
                        };
                        continue;
                    }
                    
                    switch(input[lastIndex]) {
                    case '<':
                        stack.push({
                            tag: 'JSXTag',
                        });
                        lastIndex++;
                        lastSignificantToken = '<';
                        yield {
                            type: 'JSXPunctuator',
                            value: '<',
                        };
                        continue;
                    
                    case '{':
                        stack.push({
                            tag: 'InterpolationInJSX',
                            nesting: braces.length,
                        });
                        lastIndex++;
                        lastSignificantToken = '?InterpolationInJSX';
                        postfixIncDec = false;
                        yield {
                            type: 'JSXPunctuator',
                            value: '{',
                        };
                        continue;
                    }
                }
                
                WhiteSpace.lastIndex = lastIndex;
                
                if (match = WhiteSpace.exec(input)) {
                    lastIndex = WhiteSpace.lastIndex;
                    yield {
                        type: 'WhiteSpace',
                        value: match[0],
                    };
                    continue;
                }
                
                LineTerminatorSequence.lastIndex = lastIndex;
                
                if (match = LineTerminatorSequence.exec(input)) {
                    lastIndex = LineTerminatorSequence.lastIndex;
                    postfixIncDec = false;
                    
                    if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
                        lastSignificantToken = '?NoLineTerminatorHere';
                    }
                    
                    yield {
                        type: 'LineTerminatorSequence',
                        value: match[0],
                    };
                    continue;
                }
                
                MultiLineComment.lastIndex = lastIndex;
                
                if (match = MultiLineComment.exec(input)) {
                    lastIndex = MultiLineComment.lastIndex;
                    
                    if (Newline.test(match[0])) {
                        postfixIncDec = false;
                        
                        if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
                            lastSignificantToken = '?NoLineTerminatorHere';
                        }
                    }
                    
                    yield {
                        type: 'MultiLineComment',
                        value: match[0],
                        closed: match[1] !== void 0,
                    };
                    continue;
                }
                
                SingleLineComment.lastIndex = lastIndex;
                
                if (match = SingleLineComment.exec(input)) {
                    lastIndex = SingleLineComment.lastIndex;
                    postfixIncDec = false;
                    yield {
                        type: 'SingleLineComment',
                        value: match[0],
                    };
                    continue;
                }
                
                firstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex));
                lastIndex += firstCodePoint.length;
                lastSignificantToken = firstCodePoint;
                postfixIncDec = false;
                yield {
                    type: mode.tag.startsWith('JSX') ? 'JSXInvalid' : 'Invalid',
                    value: firstCodePoint,
                };
            }
            
            return void 0;
        };
    },
});

// node_modules/jsesc/jsesc.js
var require_jsesc = __commonJS({
    'node_modules/jsesc/jsesc.js'(exports2, module2) {
        
        var object = {};
        var hasOwnProperty = object.hasOwnProperty;
        var forOwn = (object2, callback) => {
            for (const key in object2) {
                if (hasOwnProperty.call(object2, key)) {
                    callback(key, object2[key]);
                }
            }
        };
        
        var extend = (destination, source) => {
            if (!source) {
                return destination;
            }
            
            forOwn(source, (key, value) => {
                destination[key] = value;
            });
            return destination;
        };
        
        var forEach = (array, callback) => {
            const length = array.length;
            let index2 = -1;
            
            while (++index2 < length) {
                callback(array[index2]);
            }
        };
        
        var fourHexEscape = (hex) => {
            return '\\u' + ('0000' + hex).slice(-4);
        };
        
        var hexadecimal = (code2, lowercase) => {
            let hexadecimal2 = code2.toString(16);
            
            if (lowercase)
                return hexadecimal2;
            
            return hexadecimal2.toUpperCase();
        };
        
        var toString = object.toString;
        var isArray = Array.isArray;
        
        var isBuffer = (value) => {
            return typeof Buffer === 'function' && Array.isArray(value);
        };
        
        var isObject = (value) => {
            return toString.call(value) == '[object Object]';
        };
        
        var isString = (value) => {
            return typeof value == 'string' || toString.call(value) == '[object String]';
        };
        
        var isNumber2 = (value) => {
            return typeof value == 'number' || toString.call(value) == '[object Number]';
        };
        
        var isBigInt = (value) => {
            return typeof value == 'bigint';
        };
        
        var isFunction5 = (value) => {
            return typeof value == 'function';
        };
        
        var isMap = (value) => {
            return toString.call(value) == '[object Map]';
        };
        
        var isSet = (value) => {
            return toString.call(value) == '[object Set]';
        };
        
        var singleEscapes = {
            '\\': '\\\\',
            '\b': '\\b',
            '\f': '\\f',
            '\n': '\\n',
            '\r': '\\r',
            '	': '\\t',
            // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.

            // '\v': '\\x0B'
        };
        
        var regexSingleEscape = /[\\\b\f\n\r\t]/;
        var regexDigit = /[0-9]/;
        var regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
        var escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g;
        var escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g;
        
        var jsesc2 = (argument, options) => {
            const increaseIndentation = () => {
                oldIndent = indent;
                ++options.indentLevel;
                indent = options.indent.repeat(options.indentLevel);
            };
            
            const defaults = {
                'escapeEverything': false,
                'minimal': false,
                'isScriptContext': false,
                'quotes': 'single',
                'wrap': false,
                'es6': false,
                'json': false,
                'compact': true,
                'lowercaseHex': false,
                'numbers': 'decimal',
                'indent': '	',
                'indentLevel': 0,
                '__inline1__': false,
                '__inline2__': false,
            };
            
            const json = options && options.json;
            
            if (json) {
                defaults.quotes = 'double';
                defaults.wrap = true;
            }
            
            options = extend(defaults, options);
            
            if (options.quotes != 'single' && options.quotes != 'double' && options.quotes != 'backtick') {
                options.quotes = 'single';
            }
            
            const quote = options.quotes == 'double' ? '"' : options.quotes == 'backtick' ? '`' : '\'';
            const compact = options.compact;
            const lowercaseHex = options.lowercaseHex;
            let indent = options.indent.repeat(options.indentLevel);
            let oldIndent = '';
            const inline1 = options.__inline1__;
            const inline2 = options.__inline2__;
            const newLine = compact ? '' : '\n';
            let result;
            let isEmpty = true;
            const useBinNumbers = options.numbers == 'binary';
            const useOctNumbers = options.numbers == 'octal';
            const useDecNumbers = options.numbers == 'decimal';
            const useHexNumbers = options.numbers == 'hexadecimal';
            
            if (json && argument && isFunction5(argument.toJSON)) {
                argument = argument.toJSON();
            }
            
            if (!isString(argument)) {
                if (isMap(argument)) {
                    if (argument.size == 0) {
                        return 'new Map()';
                    }
                    
                    if (!compact) {
                        options.__inline1__ = true;
                        options.__inline2__ = false;
                    }
                    
                    return 'new Map(' + jsesc2(Array.from(argument), options) + ')';
                }
                
                if (isSet(argument)) {
                    if (argument.size == 0) {
                        return 'new Set()';
                    }
                    
                    return 'new Set(' + jsesc2(Array.from(argument), options) + ')';
                }
                
                if (isBuffer(argument)) {
                    if (argument.length == 0) {
                        return 'Buffer.from([])';
                    }
                    
                    return 'Buffer.from(' + jsesc2(Array.from(argument), options) + ')';
                }
                
                if (isArray(argument)) {
                    result = [];
                    options.wrap = true;
                    
                    if (inline1) {
                        options.__inline1__ = false;
                        options.__inline2__ = true;
                    }
                    
                    if (!inline2) {
                        increaseIndentation();
                    }
                    
                    forEach(argument, (value) => {
                        isEmpty = false;
                        
                        if (inline2) {
                            options.__inline2__ = false;
                        }
                        
                        result.push((compact || inline2 ? '' : indent) + jsesc2(value, options));
                    });
                    
                    if (isEmpty) {
                        return '[]';
                    }
                    
                    if (inline2) {
                        return '[' + result.join(', ') + ']';
                    }
                    
                    return '[' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + ']';
                } else if (isNumber2(argument) || isBigInt(argument)) {
                    if (json) {
                        return JSON.stringify(Number(argument));
                    }
                    
                    let result2;
                    
                    if (useDecNumbers) {
                        result2 = String(argument);
                    } else if (useHexNumbers) {
                        let hexadecimal2 = argument.toString(16);
                        
                        if (!lowercaseHex) {
                            hexadecimal2 = hexadecimal2.toUpperCase();
                        }
                        
                        result2 = '0x' + hexadecimal2;
                    } else if (useBinNumbers) {
                        result2 = '0b' + argument.toString(2);
                    } else if (useOctNumbers) {
                        result2 = '0o' + argument.toString(8);
                    }

                    
                    if (isBigInt(argument)) {
                        return result2 + 'n';
                    }
                    
                    return result2;
                } else if (isBigInt(argument)) {
                    if (json) {
                        return JSON.stringify(Number(argument));
                    }
                    
                    return argument + 'n';
                } else if (!isObject(argument)) {
                    if (json) {
                        return JSON.stringify(argument) || 'null';
                    }
                    
                    return String(argument);
                } else {
                    result = [];
                    options.wrap = true;
                    increaseIndentation();
                    forOwn(argument, (key, value) => {
                        isEmpty = false;
                        result.push((compact ? '' : indent) + jsesc2(key, options) + ':' + (compact ? '' : ' ') + jsesc2(value, options));
                    });
                    
                    if (isEmpty) {
                        return '{}';
                    }
                    
                    return '{' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + '}';
                }


            }
            
            const regex = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
            
            result = argument.replace(regex, (char, pair, lone, quoteChar, index2, string) => {
                if (pair) {
                    if (options.minimal)
                        return pair;
                    
                    const first = pair.charCodeAt(0);
                    const second = pair.charCodeAt(1);
                    
                    if (options.es6) {
                        const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
                        const hex2 = hexadecimal(codePoint, lowercaseHex);
                        
                        return '\\u{' + hex2 + '}';
                    }
                    
                    return fourHexEscape(hexadecimal(
                        first,
                        lowercaseHex,
                    )) + fourHexEscape(hexadecimal(
                        second,
                        lowercaseHex,
                    ));
                }
                
                if (lone) {
                    return fourHexEscape(hexadecimal(
                        lone.charCodeAt(0),
                        lowercaseHex,
                    ));
                }
                
                if (char == '\0' && !json && !regexDigit.test(string.charAt(index2 + 1))) {
                    return '\\0';
                }
                
                if (quoteChar) {
                    if (quoteChar == quote || options.escapeEverything) {
                        return '\\' + quoteChar;
                    }
                    
                    return quoteChar;
                }
                
                if (regexSingleEscape.test(char)) {
                    return singleEscapes[char];
                }
                
                if (options.minimal && !regexWhitespace.test(char)) {
                    return char;
                }
                
                const hex = hexadecimal(char.charCodeAt(0), lowercaseHex);
                
                if (json || hex.length > 2) {
                    return fourHexEscape(hex);
                }
                
                return '\\x' + ('00' + hex).slice(-2);
            });
            
            if (quote == '`') {
                result = result.replace(/\$\{/g, '\\${');
            }
            
            if (options.isScriptContext) {
                result = result
                    .replace(/<\/(script|style)/gi, '<\\/$1')
                    .replace(/<!--/g, json ? '\\u003C!--' : '\\x3C!--');
            }
            
            if (options.wrap) {
                result = quote + result + quote;
            }
            
            return result;
        };
        
        jsesc2.version = '3.0.2';
        module2.exports = jsesc2;
    },
});

// node_modules/debug/src/browser.js
var require_browser = () => () => ({
    enabled: false,
});

// node_modules/debug/src/node.js
var require_node = () => () => ({
    enabled: false,
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
    'node_modules/debug/src/index.js'(exports2, module2) {
        if (typeof browser$1$1 === 'undefined' || browser$1$1.type === 'renderer' || browser$1$1.browser === true || browser$1$1.__nwjs) {
            module2.exports = require_browser();
        } else {
            module2.exports = require_node();
        }
    },
});

// lib/index.mjs
var index_exports = {};

__export(index_exports, {
    codeFrameColumns: () => codeFrameColumns$2,
    generate: () => generate$6,
    parse: () => parse$6,
    parseExpression: () => parseExpression$1,
    template: () => index$1,
    tokTypes: () => tokTypes,
    traverse: () => traverse3,
    types: () => lib_exports,
});
var bundle = __toCommonJS(index_exports);
// node_modules/@babel/types/lib/index.js
var lib_exports = {};

__export(lib_exports, {
    ACCESSOR_TYPES: () => ACCESSOR_TYPES,
    ALIAS_KEYS: () => ALIAS_KEYS,
    ASSIGNMENT_OPERATORS: () => ASSIGNMENT_OPERATORS,
    AnyTypeAnnotation: () => AnyTypeAnnotation,
    ArgumentPlaceholder: () => ArgumentPlaceholder,
    ArrayExpression: () => ArrayExpression$1,
    ArrayPattern: () => ArrayPattern$1,
    ArrayTypeAnnotation: () => ArrayTypeAnnotation,
    ArrowFunctionExpression: () => ArrowFunctionExpression$1,
    AssignmentExpression: () => AssignmentExpression$1,
    AssignmentPattern: () => AssignmentPattern$1,
    AwaitExpression: () => AwaitExpression,
    BINARY_OPERATORS: () => BINARY_OPERATORS,
    BINARY_TYPES: () => BINARY_TYPES,
    BLOCKPARENT_TYPES: () => BLOCKPARENT_TYPES,
    BLOCK_TYPES: () => BLOCK_TYPES,
    BOOLEAN_BINARY_OPERATORS: () => BOOLEAN_BINARY_OPERATORS,
    BOOLEAN_NUMBER_BINARY_OPERATORS: () => BOOLEAN_NUMBER_BINARY_OPERATORS,
    BOOLEAN_UNARY_OPERATORS: () => BOOLEAN_UNARY_OPERATORS,
    BUILDER_KEYS: () => BUILDER_KEYS,
    BigIntLiteral: () => BigIntLiteral,
    BinaryExpression: () => BinaryExpression$1,
    BindExpression: () => BindExpression,
    BlockStatement: () => BlockStatement$1,
    BooleanLiteral: () => BooleanLiteral,
    BooleanLiteralTypeAnnotation: () => BooleanLiteralTypeAnnotation,
    BooleanTypeAnnotation: () => BooleanTypeAnnotation,
    BreakStatement: () => BreakStatement$1,
    CLASS_TYPES: () => CLASS_TYPES,
    COMMENT_KEYS: () => COMMENT_KEYS,
    COMPARISON_BINARY_OPERATORS: () => COMPARISON_BINARY_OPERATORS,
    COMPLETIONSTATEMENT_TYPES: () => COMPLETIONSTATEMENT_TYPES,
    CONDITIONAL_TYPES: () => CONDITIONAL_TYPES,
    CallExpression: () => CallExpression$2,
    CatchClause: () => CatchClause,
    ClassAccessorProperty: () => ClassAccessorProperty$1,
    ClassBody: () => ClassBody,
    ClassDeclaration: () => ClassDeclaration$1,
    ClassExpression: () => ClassExpression$1,
    ClassImplements: () => ClassImplements,
    ClassMethod: () => ClassMethod$2,
    ClassPrivateMethod: () => ClassPrivateMethod$1,
    ClassPrivateProperty: () => ClassPrivateProperty$1,
    ClassProperty: () => ClassProperty$1,
    ConditionalExpression: () => ConditionalExpression$1,
    ContinueStatement: () => ContinueStatement$1,
    DECLARATION_TYPES: () => DECLARATION_TYPES,
    DEPRECATED_ALIASES: () => DEPRECATED_ALIASES,
    DEPRECATED_KEYS: () => DEPRECATED_KEYS,
    DebuggerStatement: () => DebuggerStatement$1,
    DeclareClass: () => DeclareClass,
    DeclareExportAllDeclaration: () => DeclareExportAllDeclaration,
    DeclareExportDeclaration: () => DeclareExportDeclaration,
    DeclareFunction: () => DeclareFunction,
    DeclareInterface: () => DeclareInterface,
    DeclareModule: () => DeclareModule,
    DeclareModuleExports: () => DeclareModuleExports,
    DeclareOpaqueType: () => DeclareOpaqueType,
    DeclareTypeAlias: () => DeclareTypeAlias,
    DeclareVariable: () => DeclareVariable,
    DeclaredPredicate: () => DeclaredPredicate,
    Decorator: () => Decorator$1,
    Directive: () => Directive,
    DirectiveLiteral: () => DirectiveLiteral$1,
    DoExpression: () => DoExpression,
    DoWhileStatement: () => DoWhileStatement$1,
    ENUMBODY_TYPES: () => ENUMBODY_TYPES,
    ENUMMEMBER_TYPES: () => ENUMMEMBER_TYPES,
    EQUALITY_BINARY_OPERATORS: () => EQUALITY_BINARY_OPERATORS,
    EXPORTDECLARATION_TYPES: () => EXPORTDECLARATION_TYPES,
    EXPRESSIONWRAPPER_TYPES: () => EXPRESSIONWRAPPER_TYPES,
    EXPRESSION_TYPES: () => EXPRESSION_TYPES,
    EmptyStatement: () => EmptyStatement$1,
    EmptyTypeAnnotation: () => EmptyTypeAnnotation,
    EnumBooleanBody: () => EnumBooleanBody,
    EnumBooleanMember: () => EnumBooleanMember,
    EnumDeclaration: () => EnumDeclaration,
    EnumDefaultedMember: () => EnumDefaultedMember,
    EnumNumberBody: () => EnumNumberBody,
    EnumNumberMember: () => EnumNumberMember,
    EnumStringBody: () => EnumStringBody,
    EnumStringMember: () => EnumStringMember,
    EnumSymbolBody: () => EnumSymbolBody,
    ExistsTypeAnnotation: () => ExistsTypeAnnotation,
    ExportAllDeclaration: () => ExportAllDeclaration$1,
    ExportDefaultDeclaration: () => ExportDefaultDeclaration$1,
    ExportDefaultSpecifier: () => ExportDefaultSpecifier,
    ExportNamedDeclaration: () => ExportNamedDeclaration,
    ExportNamespaceSpecifier: () => ExportNamespaceSpecifier$1,
    ExportSpecifier: () => ExportSpecifier$1,
    ExpressionStatement: () => ExpressionStatement$1,
    FLATTENABLE_KEYS: () => FLATTENABLE_KEYS,
    FLIPPED_ALIAS_KEYS: () => FLIPPED_ALIAS_KEYS,
    FLOWBASEANNOTATION_TYPES: () => FLOWBASEANNOTATION_TYPES,
    FLOWDECLARATION_TYPES: () => FLOWDECLARATION_TYPES,
    FLOWPREDICATE_TYPES: () => FLOWPREDICATE_TYPES,
    FLOWTYPE_TYPES: () => FLOWTYPE_TYPES,
    FLOW_TYPES: () => FLOW_TYPES,
    FORXSTATEMENT_TYPES: () => FORXSTATEMENT_TYPES,
    FOR_INIT_KEYS: () => FOR_INIT_KEYS,
    FOR_TYPES: () => FOR_TYPES,
    FUNCTIONPARAMETER_TYPES: () => FUNCTIONPARAMETER_TYPES,
    FUNCTIONPARENT_TYPES: () => FUNCTIONPARENT_TYPES,
    FUNCTION_TYPES: () => FUNCTION_TYPES,
    File: () => File,
    ForInStatement: () => ForInStatement$1,
    ForOfStatement: () => ForOfStatement$1,
    ForStatement: () => ForStatement$1,
    FunctionDeclaration: () => FunctionDeclaration$1,
    FunctionExpression: () => FunctionExpression$1,
    FunctionTypeAnnotation: () => FunctionTypeAnnotation,
    FunctionTypeParam: () => FunctionTypeParam,
    GenericTypeAnnotation: () => GenericTypeAnnotation,
    IMMUTABLE_TYPES: () => IMMUTABLE_TYPES,
    IMPORTOREXPORTDECLARATION_TYPES: () => IMPORTOREXPORTDECLARATION_TYPES,
    INHERIT_KEYS: () => INHERIT_KEYS,
    Identifier: () => Identifier$1,
    IfStatement: () => IfStatement$1,
    Import: () => Import,
    ImportAttribute: () => ImportAttribute,
    ImportDeclaration: () => ImportDeclaration,
    ImportDefaultSpecifier: () => ImportDefaultSpecifier,
    ImportExpression: () => ImportExpression$1,
    ImportNamespaceSpecifier: () => ImportNamespaceSpecifier,
    ImportSpecifier: () => ImportSpecifier,
    IndexedAccessType: () => IndexedAccessType,
    InferredPredicate: () => InferredPredicate,
    InterfaceDeclaration: () => InterfaceDeclaration,
    InterfaceExtends: () => InterfaceExtends,
    InterfaceTypeAnnotation: () => InterfaceTypeAnnotation,
    InterpreterDirective: () => InterpreterDirective,
    IntersectionTypeAnnotation: () => IntersectionTypeAnnotation,
    JSXAttribute: () => JSXAttribute$1,
    JSXClosingElement: () => JSXClosingElement,
    JSXClosingFragment: () => JSXClosingFragment,
    JSXElement: () => JSXElement$1,
    JSXEmptyExpression: () => JSXEmptyExpression,
    JSXExpressionContainer: () => JSXExpressionContainer,
    JSXFragment: () => JSXFragment,
    JSXIdentifier: () => JSXIdentifier,
    JSXMemberExpression: () => JSXMemberExpression,
    JSXNamespacedName: () => JSXNamespacedName,
    JSXOpeningElement: () => JSXOpeningElement$1,
    JSXOpeningFragment: () => JSXOpeningFragment,
    JSXSpreadAttribute: () => JSXSpreadAttribute,
    JSXSpreadChild: () => JSXSpreadChild,
    JSXText: () => JSXText$1,
    JSX_TYPES: () => JSX_TYPES,
    LITERAL_TYPES: () => LITERAL_TYPES,
    LOGICAL_OPERATORS: () => LOGICAL_OPERATORS,
    LOOP_TYPES: () => LOOP_TYPES,
    LVAL_TYPES: () => LVAL_TYPES,
    LabeledStatement: () => LabeledStatement$1,
    LogicalExpression: () => LogicalExpression$1,
    METHOD_TYPES: () => METHOD_TYPES,
    MISCELLANEOUS_TYPES: () => MISCELLANEOUS_TYPES,
    MODULEDECLARATION_TYPES: () => MODULEDECLARATION_TYPES,
    MODULESPECIFIER_TYPES: () => MODULESPECIFIER_TYPES,
    MemberExpression: () => MemberExpression,
    MetaProperty: () => MetaProperty,
    MixedTypeAnnotation: () => MixedTypeAnnotation,
    ModuleExpression: () => ModuleExpression,
    NODE_FIELDS: () => NODE_FIELDS$1,
    NODE_PARENT_VALIDATIONS: () => NODE_PARENT_VALIDATIONS,
    NUMBER_BINARY_OPERATORS: () => NUMBER_BINARY_OPERATORS,
    NUMBER_UNARY_OPERATORS: () => NUMBER_UNARY_OPERATORS,
    NewExpression: () => NewExpression$1,
    NullLiteral: () => NullLiteral,
    NullLiteralTypeAnnotation: () => NullLiteralTypeAnnotation,
    NullableTypeAnnotation: () => NullableTypeAnnotation,
    NumberLiteralTypeAnnotation: () => NumberLiteralTypeAnnotation,
    NumberTypeAnnotation: () => NumberTypeAnnotation,
    NumericLiteral: () => NumericLiteral,
    OBJECTMEMBER_TYPES: () => OBJECTMEMBER_TYPES,
    ObjectExpression: () => ObjectExpression$1,
    ObjectMethod: () => ObjectMethod$1,
    ObjectPattern: () => ObjectPattern$1,
    ObjectProperty: () => ObjectProperty$1,
    ObjectTypeAnnotation: () => ObjectTypeAnnotation,
    ObjectTypeCallProperty: () => ObjectTypeCallProperty,
    ObjectTypeIndexer: () => ObjectTypeIndexer,
    ObjectTypeInternalSlot: () => ObjectTypeInternalSlot,
    ObjectTypeProperty: () => ObjectTypeProperty,
    ObjectTypeSpreadProperty: () => ObjectTypeSpreadProperty,
    OpaqueType: () => OpaqueType,
    OptionalCallExpression: () => OptionalCallExpression$1,
    OptionalIndexedAccessType: () => OptionalIndexedAccessType,
    OptionalMemberExpression: () => OptionalMemberExpression,
    PATTERNLIKE_TYPES: () => PATTERNLIKE_TYPES,
    PATTERN_TYPES: () => PATTERN_TYPES,
    PLACEHOLDERS: () => PLACEHOLDERS,
    PLACEHOLDERS_ALIAS: () => PLACEHOLDERS_ALIAS,
    PLACEHOLDERS_FLIPPED_ALIAS: () => PLACEHOLDERS_FLIPPED_ALIAS,
    PRIVATE_TYPES: () => PRIVATE_TYPES,
    PROPERTY_TYPES: () => PROPERTY_TYPES,
    PUREISH_TYPES: () => PUREISH_TYPES,
    ParenthesizedExpression: () => ParenthesizedExpression$1,
    PipelineBareFunction: () => PipelineBareFunction,
    PipelinePrimaryTopicReference: () => PipelinePrimaryTopicReference,
    PipelineTopicExpression: () => PipelineTopicExpression,
    Placeholder: () => Placeholder,
    PrivateName: () => PrivateName$1,
    Program: () => Program$1,
    QualifiedTypeIdentifier: () => QualifiedTypeIdentifier,
    RecordExpression: () => RecordExpression,
    RegExpLiteral: () => RegExpLiteral,
    RestElement: () => RestElement$1,
    ReturnStatement: () => ReturnStatement$1,
    SCOPABLE_TYPES: () => SCOPABLE_TYPES,
    STANDARDIZED_TYPES: () => STANDARDIZED_TYPES,
    STATEMENT_OR_BLOCK_KEYS: () => STATEMENT_OR_BLOCK_KEYS,
    STATEMENT_TYPES: () => STATEMENT_TYPES,
    STRING_UNARY_OPERATORS: () => STRING_UNARY_OPERATORS,
    SequenceExpression: () => SequenceExpression$1,
    SpreadElement: () => SpreadElement$1,
    StaticBlock: () => StaticBlock$1,
    StringLiteral: () => StringLiteral$1,
    StringLiteralTypeAnnotation: () => StringLiteralTypeAnnotation,
    StringTypeAnnotation: () => StringTypeAnnotation,
    Super: () => Super,
    SwitchCase: () => SwitchCase,
    SwitchStatement: () => SwitchStatement$1,
    SymbolTypeAnnotation: () => SymbolTypeAnnotation,
    TERMINATORLESS_TYPES: () => TERMINATORLESS_TYPES,
    TSAnyKeyword: () => TSAnyKeyword,
    TSArrayType: () => TSArrayType,
    TSAsExpression: () => TSAsExpression$1,
    TSBASETYPE_TYPES: () => TSBASETYPE_TYPES,
    TSBigIntKeyword: () => TSBigIntKeyword,
    TSBooleanKeyword: () => TSBooleanKeyword,
    TSCallSignatureDeclaration: () => TSCallSignatureDeclaration$1,
    TSClassImplements: () => TSClassImplements,
    TSConditionalType: () => TSConditionalType$1,
    TSConstructSignatureDeclaration: () => TSConstructSignatureDeclaration$1,
    TSConstructorType: () => TSConstructorType$1,
    TSDeclareFunction: () => TSDeclareFunction$1,
    TSDeclareMethod: () => TSDeclareMethod$1,
    TSENTITYNAME_TYPES: () => TSENTITYNAME_TYPES,
    TSEnumBody: () => TSEnumBody,
    TSEnumDeclaration: () => TSEnumDeclaration$1,
    TSEnumMember: () => TSEnumMember$1,
    TSExportAssignment: () => TSExportAssignment$1,
    TSExternalModuleReference: () => TSExternalModuleReference,
    TSFunctionType: () => TSFunctionType$1,
    TSImportEqualsDeclaration: () => TSImportEqualsDeclaration,
    TSImportType: () => TSImportType$1,
    TSIndexSignature: () => TSIndexSignature,
    TSIndexedAccessType: () => TSIndexedAccessType,
    TSInferType: () => TSInferType$1,
    TSInstantiationExpression: () => TSInstantiationExpression,
    TSInterfaceBody: () => TSInterfaceBody$1,
    TSInterfaceDeclaration: () => TSInterfaceDeclaration$1,
    TSInterfaceHeritage: () => TSInterfaceHeritage,
    TSIntersectionType: () => TSIntersectionType$1,
    TSIntrinsicKeyword: () => TSIntrinsicKeyword,
    TSLiteralType: () => TSLiteralType,
    TSMappedType: () => TSMappedType$1,
    TSMethodSignature: () => TSMethodSignature$1,
    TSModuleBlock: () => TSModuleBlock$1,
    TSModuleDeclaration: () => TSModuleDeclaration$1,
    TSNamedTupleMember: () => TSNamedTupleMember$1,
    TSNamespaceExportDeclaration: () => TSNamespaceExportDeclaration,
    TSNeverKeyword: () => TSNeverKeyword,
    TSNonNullExpression: () => TSNonNullExpression,
    TSNullKeyword: () => TSNullKeyword,
    TSNumberKeyword: () => TSNumberKeyword,
    TSObjectKeyword: () => TSObjectKeyword,
    TSOptionalType: () => TSOptionalType,
    TSParameterProperty: () => TSParameterProperty$1,
    TSParenthesizedType: () => TSParenthesizedType$1,
    TSPropertySignature: () => TSPropertySignature$1,
    TSQualifiedName: () => TSQualifiedName,
    TSRestType: () => TSRestType,
    TSSatisfiesExpression: () => TSSatisfiesExpression,
    TSStringKeyword: () => TSStringKeyword,
    TSSymbolKeyword: () => TSSymbolKeyword,
    TSTYPEELEMENT_TYPES: () => TSTYPEELEMENT_TYPES,
    TSTYPE_TYPES: () => TSTYPE_TYPES,
    TSTemplateLiteralType: () => TSTemplateLiteralType,
    TSThisType: () => TSThisType,
    TSTupleType: () => TSTupleType$1,
    TSTypeAliasDeclaration: () => TSTypeAliasDeclaration$1,
    TSTypeAnnotation: () => TSTypeAnnotation,
    TSTypeAssertion: () => TSTypeAssertion,
    TSTypeLiteral: () => TSTypeLiteral$1,
    TSTypeOperator: () => TSTypeOperator,
    TSTypeParameter: () => TSTypeParameter$1,
    TSTypeParameterDeclaration: () => TSTypeParameterDeclaration,
    TSTypeParameterInstantiation: () => TSTypeParameterInstantiation,
    TSTypePredicate: () => TSTypePredicate,
    TSTypeQuery: () => TSTypeQuery$1,
    TSTypeReference: () => TSTypeReference$1,
    TSUndefinedKeyword: () => TSUndefinedKeyword,
    TSUnionType: () => TSUnionType$1,
    TSUnknownKeyword: () => TSUnknownKeyword,
    TSVoidKeyword: () => TSVoidKeyword,
    TYPES: () => TYPES$4,
    TYPESCRIPT_TYPES: () => TYPESCRIPT_TYPES,
    TaggedTemplateExpression: () => TaggedTemplateExpression$1,
    TemplateElement: () => TemplateElement,
    TemplateLiteral: () => TemplateLiteral$1,
    ThisExpression: () => ThisExpression,
    ThisTypeAnnotation: () => ThisTypeAnnotation,
    ThrowStatement: () => ThrowStatement,
    TopicReference: () => TopicReference,
    TryStatement: () => TryStatement,
    TupleExpression: () => TupleExpression,
    TupleTypeAnnotation: () => TupleTypeAnnotation,
    TypeAlias: () => TypeAlias,
    TypeAnnotation: () => TypeAnnotation,
    TypeCastExpression: () => TypeCastExpression,
    TypeParameter: () => TypeParameter,
    TypeParameterDeclaration: () => TypeParameterDeclaration,
    TypeParameterInstantiation: () => TypeParameterInstantiation,
    TypeofTypeAnnotation: () => TypeofTypeAnnotation,
    UNARYLIKE_TYPES: () => UNARYLIKE_TYPES,
    UNARY_OPERATORS: () => UNARY_OPERATORS,
    UPDATE_OPERATORS: () => UPDATE_OPERATORS,
    USERWHITESPACABLE_TYPES: () => USERWHITESPACABLE_TYPES,
    UnaryExpression: () => UnaryExpression,
    UnionTypeAnnotation: () => UnionTypeAnnotation,
    UpdateExpression: () => UpdateExpression,
    V8IntrinsicIdentifier: () => V8IntrinsicIdentifier,
    VISITOR_KEYS: () => VISITOR_KEYS,
    VariableDeclaration: () => VariableDeclaration$1,
    VariableDeclarator: () => VariableDeclarator,
    Variance: () => Variance,
    VoidPattern: () => VoidPattern$1,
    VoidTypeAnnotation: () => VoidTypeAnnotation,
    WHILE_TYPES: () => WHILE_TYPES,
    WhileStatement: () => WhileStatement$1,
    WithStatement: () => WithStatement,
    YieldExpression: () => YieldExpression,
    __internal__deprecationWarning: () => deprecationWarning,
    addComment: () => addComment,
    addComments: () => addComments,
    anyTypeAnnotation: () => anyTypeAnnotation,
    appendToMemberExpression: () => appendToMemberExpression,
    argumentPlaceholder: () => argumentPlaceholder,
    arrayExpression: () => arrayExpression$4,
    arrayPattern: () => arrayPattern$1,
    arrayTypeAnnotation: () => arrayTypeAnnotation,
    arrowFunctionExpression: () => arrowFunctionExpression$1,
    assertAccessor: () => assertAccessor,
    assertAnyTypeAnnotation: () => assertAnyTypeAnnotation,
    assertArgumentPlaceholder: () => assertArgumentPlaceholder,
    assertArrayExpression: () => assertArrayExpression,
    assertArrayPattern: () => assertArrayPattern,
    assertArrayTypeAnnotation: () => assertArrayTypeAnnotation,
    assertArrowFunctionExpression: () => assertArrowFunctionExpression,
    assertAssignmentExpression: () => assertAssignmentExpression,
    assertAssignmentPattern: () => assertAssignmentPattern,
    assertAwaitExpression: () => assertAwaitExpression,
    assertBigIntLiteral: () => assertBigIntLiteral,
    assertBinary: () => assertBinary,
    assertBinaryExpression: () => assertBinaryExpression,
    assertBindExpression: () => assertBindExpression,
    assertBlock: () => assertBlock,
    assertBlockParent: () => assertBlockParent,
    assertBlockStatement: () => assertBlockStatement,
    assertBooleanLiteral: () => assertBooleanLiteral,
    assertBooleanLiteralTypeAnnotation: () => assertBooleanLiteralTypeAnnotation,
    assertBooleanTypeAnnotation: () => assertBooleanTypeAnnotation,
    assertBreakStatement: () => assertBreakStatement,
    assertCallExpression: () => assertCallExpression,
    assertCatchClause: () => assertCatchClause,
    assertClass: () => assertClass,
    assertClassAccessorProperty: () => assertClassAccessorProperty,
    assertClassBody: () => assertClassBody,
    assertClassDeclaration: () => assertClassDeclaration,
    assertClassExpression: () => assertClassExpression,
    assertClassImplements: () => assertClassImplements,
    assertClassMethod: () => assertClassMethod,
    assertClassPrivateMethod: () => assertClassPrivateMethod,
    assertClassPrivateProperty: () => assertClassPrivateProperty,
    assertClassProperty: () => assertClassProperty,
    assertCompletionStatement: () => assertCompletionStatement,
    assertConditional: () => assertConditional,
    assertConditionalExpression: () => assertConditionalExpression,
    assertContinueStatement: () => assertContinueStatement,
    assertDebuggerStatement: () => assertDebuggerStatement,
    assertDeclaration: () => assertDeclaration,
    assertDeclareClass: () => assertDeclareClass,
    assertDeclareExportAllDeclaration: () => assertDeclareExportAllDeclaration,
    assertDeclareExportDeclaration: () => assertDeclareExportDeclaration,
    assertDeclareFunction: () => assertDeclareFunction,
    assertDeclareInterface: () => assertDeclareInterface,
    assertDeclareModule: () => assertDeclareModule,
    assertDeclareModuleExports: () => assertDeclareModuleExports,
    assertDeclareOpaqueType: () => assertDeclareOpaqueType,
    assertDeclareTypeAlias: () => assertDeclareTypeAlias,
    assertDeclareVariable: () => assertDeclareVariable,
    assertDeclaredPredicate: () => assertDeclaredPredicate,
    assertDecorator: () => assertDecorator,
    assertDirective: () => assertDirective,
    assertDirectiveLiteral: () => assertDirectiveLiteral,
    assertDoExpression: () => assertDoExpression,
    assertDoWhileStatement: () => assertDoWhileStatement,
    assertEmptyStatement: () => assertEmptyStatement,
    assertEmptyTypeAnnotation: () => assertEmptyTypeAnnotation,
    assertEnumBody: () => assertEnumBody,
    assertEnumBooleanBody: () => assertEnumBooleanBody,
    assertEnumBooleanMember: () => assertEnumBooleanMember,
    assertEnumDeclaration: () => assertEnumDeclaration,
    assertEnumDefaultedMember: () => assertEnumDefaultedMember,
    assertEnumMember: () => assertEnumMember,
    assertEnumNumberBody: () => assertEnumNumberBody,
    assertEnumNumberMember: () => assertEnumNumberMember,
    assertEnumStringBody: () => assertEnumStringBody,
    assertEnumStringMember: () => assertEnumStringMember,
    assertEnumSymbolBody: () => assertEnumSymbolBody,
    assertExistsTypeAnnotation: () => assertExistsTypeAnnotation,
    assertExportAllDeclaration: () => assertExportAllDeclaration,
    assertExportDeclaration: () => assertExportDeclaration,
    assertExportDefaultDeclaration: () => assertExportDefaultDeclaration,
    assertExportDefaultSpecifier: () => assertExportDefaultSpecifier,
    assertExportNamedDeclaration: () => assertExportNamedDeclaration,
    assertExportNamespaceSpecifier: () => assertExportNamespaceSpecifier,
    assertExportSpecifier: () => assertExportSpecifier,
    assertExpression: () => assertExpression,
    assertExpressionStatement: () => assertExpressionStatement,
    assertExpressionWrapper: () => assertExpressionWrapper,
    assertFile: () => assertFile,
    assertFlow: () => assertFlow,
    assertFlowBaseAnnotation: () => assertFlowBaseAnnotation,
    assertFlowDeclaration: () => assertFlowDeclaration,
    assertFlowPredicate: () => assertFlowPredicate,
    assertFlowType: () => assertFlowType,
    assertFor: () => assertFor,
    assertForInStatement: () => assertForInStatement,
    assertForOfStatement: () => assertForOfStatement,
    assertForStatement: () => assertForStatement,
    assertForXStatement: () => assertForXStatement,
    assertFunction: () => assertFunction,
    assertFunctionDeclaration: () => assertFunctionDeclaration,
    assertFunctionExpression: () => assertFunctionExpression,
    assertFunctionParameter: () => assertFunctionParameter,
    assertFunctionParent: () => assertFunctionParent,
    assertFunctionTypeAnnotation: () => assertFunctionTypeAnnotation,
    assertFunctionTypeParam: () => assertFunctionTypeParam,
    assertGenericTypeAnnotation: () => assertGenericTypeAnnotation,
    assertIdentifier: () => assertIdentifier,
    assertIfStatement: () => assertIfStatement,
    assertImmutable: () => assertImmutable,
    assertImport: () => assertImport,
    assertImportAttribute: () => assertImportAttribute,
    assertImportDeclaration: () => assertImportDeclaration,
    assertImportDefaultSpecifier: () => assertImportDefaultSpecifier,
    assertImportExpression: () => assertImportExpression,
    assertImportNamespaceSpecifier: () => assertImportNamespaceSpecifier,
    assertImportOrExportDeclaration: () => assertImportOrExportDeclaration,
    assertImportSpecifier: () => assertImportSpecifier,
    assertIndexedAccessType: () => assertIndexedAccessType,
    assertInferredPredicate: () => assertInferredPredicate,
    assertInterfaceDeclaration: () => assertInterfaceDeclaration,
    assertInterfaceExtends: () => assertInterfaceExtends,
    assertInterfaceTypeAnnotation: () => assertInterfaceTypeAnnotation,
    assertInterpreterDirective: () => assertInterpreterDirective,
    assertIntersectionTypeAnnotation: () => assertIntersectionTypeAnnotation,
    assertJSX: () => assertJSX,
    assertJSXAttribute: () => assertJSXAttribute,
    assertJSXClosingElement: () => assertJSXClosingElement,
    assertJSXClosingFragment: () => assertJSXClosingFragment,
    assertJSXElement: () => assertJSXElement,
    assertJSXEmptyExpression: () => assertJSXEmptyExpression,
    assertJSXExpressionContainer: () => assertJSXExpressionContainer,
    assertJSXFragment: () => assertJSXFragment,
    assertJSXIdentifier: () => assertJSXIdentifier,
    assertJSXMemberExpression: () => assertJSXMemberExpression,
    assertJSXNamespacedName: () => assertJSXNamespacedName,
    assertJSXOpeningElement: () => assertJSXOpeningElement,
    assertJSXOpeningFragment: () => assertJSXOpeningFragment,
    assertJSXSpreadAttribute: () => assertJSXSpreadAttribute,
    assertJSXSpreadChild: () => assertJSXSpreadChild,
    assertJSXText: () => assertJSXText,
    assertLVal: () => assertLVal,
    assertLabeledStatement: () => assertLabeledStatement,
    assertLiteral: () => assertLiteral,
    assertLogicalExpression: () => assertLogicalExpression,
    assertLoop: () => assertLoop,
    assertMemberExpression: () => assertMemberExpression,
    assertMetaProperty: () => assertMetaProperty,
    assertMethod: () => assertMethod,
    assertMiscellaneous: () => assertMiscellaneous,
    assertMixedTypeAnnotation: () => assertMixedTypeAnnotation,
    assertModuleDeclaration: () => assertModuleDeclaration,
    assertModuleExpression: () => assertModuleExpression,
    assertModuleSpecifier: () => assertModuleSpecifier,
    assertNewExpression: () => assertNewExpression,
    assertNode: () => assertNode,
    assertNullLiteral: () => assertNullLiteral,
    assertNullLiteralTypeAnnotation: () => assertNullLiteralTypeAnnotation,
    assertNullableTypeAnnotation: () => assertNullableTypeAnnotation,
    assertNumberLiteral: () => assertNumberLiteral,
    assertNumberLiteralTypeAnnotation: () => assertNumberLiteralTypeAnnotation,
    assertNumberTypeAnnotation: () => assertNumberTypeAnnotation,
    assertNumericLiteral: () => assertNumericLiteral,
    assertObjectExpression: () => assertObjectExpression,
    assertObjectMember: () => assertObjectMember,
    assertObjectMethod: () => assertObjectMethod,
    assertObjectPattern: () => assertObjectPattern,
    assertObjectProperty: () => assertObjectProperty,
    assertObjectTypeAnnotation: () => assertObjectTypeAnnotation,
    assertObjectTypeCallProperty: () => assertObjectTypeCallProperty,
    assertObjectTypeIndexer: () => assertObjectTypeIndexer,
    assertObjectTypeInternalSlot: () => assertObjectTypeInternalSlot,
    assertObjectTypeProperty: () => assertObjectTypeProperty,
    assertObjectTypeSpreadProperty: () => assertObjectTypeSpreadProperty,
    assertOpaqueType: () => assertOpaqueType,
    assertOptionalCallExpression: () => assertOptionalCallExpression,
    assertOptionalIndexedAccessType: () => assertOptionalIndexedAccessType,
    assertOptionalMemberExpression: () => assertOptionalMemberExpression,
    assertParenthesizedExpression: () => assertParenthesizedExpression,
    assertPattern: () => assertPattern,
    assertPatternLike: () => assertPatternLike,
    assertPipelineBareFunction: () => assertPipelineBareFunction,
    assertPipelinePrimaryTopicReference: () => assertPipelinePrimaryTopicReference,
    assertPipelineTopicExpression: () => assertPipelineTopicExpression,
    assertPlaceholder: () => assertPlaceholder,
    assertPrivate: () => assertPrivate,
    assertPrivateName: () => assertPrivateName,
    assertProgram: () => assertProgram,
    assertProperty: () => assertProperty,
    assertPureish: () => assertPureish,
    assertQualifiedTypeIdentifier: () => assertQualifiedTypeIdentifier,
    assertRecordExpression: () => assertRecordExpression,
    assertRegExpLiteral: () => assertRegExpLiteral,
    assertRegexLiteral: () => assertRegexLiteral,
    assertRestElement: () => assertRestElement,
    assertRestProperty: () => assertRestProperty,
    assertReturnStatement: () => assertReturnStatement,
    assertScopable: () => assertScopable,
    assertSequenceExpression: () => assertSequenceExpression,
    assertSpreadElement: () => assertSpreadElement,
    assertSpreadProperty: () => assertSpreadProperty,
    assertStandardized: () => assertStandardized,
    assertStatement: () => assertStatement,
    assertStaticBlock: () => assertStaticBlock,
    assertStringLiteral: () => assertStringLiteral,
    assertStringLiteralTypeAnnotation: () => assertStringLiteralTypeAnnotation,
    assertStringTypeAnnotation: () => assertStringTypeAnnotation,
    assertSuper: () => assertSuper,
    assertSwitchCase: () => assertSwitchCase,
    assertSwitchStatement: () => assertSwitchStatement,
    assertSymbolTypeAnnotation: () => assertSymbolTypeAnnotation,
    assertTSAnyKeyword: () => assertTSAnyKeyword,
    assertTSArrayType: () => assertTSArrayType,
    assertTSAsExpression: () => assertTSAsExpression,
    assertTSBaseType: () => assertTSBaseType,
    assertTSBigIntKeyword: () => assertTSBigIntKeyword,
    assertTSBooleanKeyword: () => assertTSBooleanKeyword,
    assertTSCallSignatureDeclaration: () => assertTSCallSignatureDeclaration,
    assertTSClassImplements: () => assertTSClassImplements,
    assertTSConditionalType: () => assertTSConditionalType,
    assertTSConstructSignatureDeclaration: () => assertTSConstructSignatureDeclaration,
    assertTSConstructorType: () => assertTSConstructorType,
    assertTSDeclareFunction: () => assertTSDeclareFunction,
    assertTSDeclareMethod: () => assertTSDeclareMethod,
    assertTSEntityName: () => assertTSEntityName,
    assertTSEnumBody: () => assertTSEnumBody,
    assertTSEnumDeclaration: () => assertTSEnumDeclaration,
    assertTSEnumMember: () => assertTSEnumMember,
    assertTSExportAssignment: () => assertTSExportAssignment,
    assertTSExternalModuleReference: () => assertTSExternalModuleReference,
    assertTSFunctionType: () => assertTSFunctionType,
    assertTSImportEqualsDeclaration: () => assertTSImportEqualsDeclaration,
    assertTSImportType: () => assertTSImportType,
    assertTSIndexSignature: () => assertTSIndexSignature,
    assertTSIndexedAccessType: () => assertTSIndexedAccessType,
    assertTSInferType: () => assertTSInferType,
    assertTSInstantiationExpression: () => assertTSInstantiationExpression,
    assertTSInterfaceBody: () => assertTSInterfaceBody,
    assertTSInterfaceDeclaration: () => assertTSInterfaceDeclaration,
    assertTSInterfaceHeritage: () => assertTSInterfaceHeritage,
    assertTSIntersectionType: () => assertTSIntersectionType,
    assertTSIntrinsicKeyword: () => assertTSIntrinsicKeyword,
    assertTSLiteralType: () => assertTSLiteralType,
    assertTSMappedType: () => assertTSMappedType,
    assertTSMethodSignature: () => assertTSMethodSignature,
    assertTSModuleBlock: () => assertTSModuleBlock,
    assertTSModuleDeclaration: () => assertTSModuleDeclaration,
    assertTSNamedTupleMember: () => assertTSNamedTupleMember,
    assertTSNamespaceExportDeclaration: () => assertTSNamespaceExportDeclaration,
    assertTSNeverKeyword: () => assertTSNeverKeyword,
    assertTSNonNullExpression: () => assertTSNonNullExpression,
    assertTSNullKeyword: () => assertTSNullKeyword,
    assertTSNumberKeyword: () => assertTSNumberKeyword,
    assertTSObjectKeyword: () => assertTSObjectKeyword,
    assertTSOptionalType: () => assertTSOptionalType,
    assertTSParameterProperty: () => assertTSParameterProperty,
    assertTSParenthesizedType: () => assertTSParenthesizedType,
    assertTSPropertySignature: () => assertTSPropertySignature,
    assertTSQualifiedName: () => assertTSQualifiedName,
    assertTSRestType: () => assertTSRestType,
    assertTSSatisfiesExpression: () => assertTSSatisfiesExpression,
    assertTSStringKeyword: () => assertTSStringKeyword,
    assertTSSymbolKeyword: () => assertTSSymbolKeyword,
    assertTSTemplateLiteralType: () => assertTSTemplateLiteralType,
    assertTSThisType: () => assertTSThisType,
    assertTSTupleType: () => assertTSTupleType,
    assertTSType: () => assertTSType,
    assertTSTypeAliasDeclaration: () => assertTSTypeAliasDeclaration,
    assertTSTypeAnnotation: () => assertTSTypeAnnotation,
    assertTSTypeAssertion: () => assertTSTypeAssertion,
    assertTSTypeElement: () => assertTSTypeElement,
    assertTSTypeLiteral: () => assertTSTypeLiteral,
    assertTSTypeOperator: () => assertTSTypeOperator,
    assertTSTypeParameter: () => assertTSTypeParameter,
    assertTSTypeParameterDeclaration: () => assertTSTypeParameterDeclaration,
    assertTSTypeParameterInstantiation: () => assertTSTypeParameterInstantiation,
    assertTSTypePredicate: () => assertTSTypePredicate,
    assertTSTypeQuery: () => assertTSTypeQuery,
    assertTSTypeReference: () => assertTSTypeReference,
    assertTSUndefinedKeyword: () => assertTSUndefinedKeyword,
    assertTSUnionType: () => assertTSUnionType,
    assertTSUnknownKeyword: () => assertTSUnknownKeyword,
    assertTSVoidKeyword: () => assertTSVoidKeyword,
    assertTaggedTemplateExpression: () => assertTaggedTemplateExpression,
    assertTemplateElement: () => assertTemplateElement,
    assertTemplateLiteral: () => assertTemplateLiteral,
    assertTerminatorless: () => assertTerminatorless,
    assertThisExpression: () => assertThisExpression,
    assertThisTypeAnnotation: () => assertThisTypeAnnotation,
    assertThrowStatement: () => assertThrowStatement,
    assertTopicReference: () => assertTopicReference,
    assertTryStatement: () => assertTryStatement,
    assertTupleExpression: () => assertTupleExpression,
    assertTupleTypeAnnotation: () => assertTupleTypeAnnotation,
    assertTypeAlias: () => assertTypeAlias,
    assertTypeAnnotation: () => assertTypeAnnotation,
    assertTypeCastExpression: () => assertTypeCastExpression,
    assertTypeParameter: () => assertTypeParameter,
    assertTypeParameterDeclaration: () => assertTypeParameterDeclaration,
    assertTypeParameterInstantiation: () => assertTypeParameterInstantiation,
    assertTypeScript: () => assertTypeScript,
    assertTypeofTypeAnnotation: () => assertTypeofTypeAnnotation,
    assertUnaryExpression: () => assertUnaryExpression,
    assertUnaryLike: () => assertUnaryLike,
    assertUnionTypeAnnotation: () => assertUnionTypeAnnotation,
    assertUpdateExpression: () => assertUpdateExpression,
    assertUserWhitespacable: () => assertUserWhitespacable,
    assertV8IntrinsicIdentifier: () => assertV8IntrinsicIdentifier,
    assertVariableDeclaration: () => assertVariableDeclaration,
    assertVariableDeclarator: () => assertVariableDeclarator,
    assertVariance: () => assertVariance,
    assertVoidPattern: () => assertVoidPattern,
    assertVoidTypeAnnotation: () => assertVoidTypeAnnotation,
    assertWhile: () => assertWhile,
    assertWhileStatement: () => assertWhileStatement,
    assertWithStatement: () => assertWithStatement,
    assertYieldExpression: () => assertYieldExpression,
    assignmentExpression: () => assignmentExpression$1,
    assignmentPattern: () => assignmentPattern$1,
    awaitExpression: () => awaitExpression,
    bigIntLiteral: () => bigIntLiteral,
    binaryExpression: () => binaryExpression$1,
    bindExpression: () => bindExpression,
    blockStatement: () => blockStatement$2,
    booleanLiteral: () => booleanLiteral,
    booleanLiteralTypeAnnotation: () => booleanLiteralTypeAnnotation,
    booleanTypeAnnotation: () => booleanTypeAnnotation,
    breakStatement: () => breakStatement$1,
    buildMatchMemberExpression: () => buildMatchMemberExpression,
    buildUndefinedNode: () => buildUndefinedNode,
    callExpression: () => callExpression$1,
    catchClause: () => catchClause,
    classAccessorProperty: () => classAccessorProperty,
    classBody: () => classBody,
    classDeclaration: () => classDeclaration,
    classExpression: () => classExpression,
    classImplements: () => classImplements,
    classMethod: () => classMethod$2,
    classPrivateMethod: () => classPrivateMethod$1,
    classPrivateProperty: () => classPrivateProperty,
    classProperty: () => classProperty$1,
    clone: () => clone$2,
    cloneDeep: () => cloneDeep,
    cloneDeepWithoutLoc: () => cloneDeepWithoutLoc,
    cloneNode: () => cloneNode,
    cloneWithoutLoc: () => cloneWithoutLoc,
    conditionalExpression: () => conditionalExpression$1,
    continueStatement: () => continueStatement$1,
    createFlowUnionType: () => createFlowUnionType,
    createTSUnionType: () => createTSUnionType,
    createTypeAnnotationBasedOnTypeof: () => createTypeAnnotationBasedOnTypeof,
    createUnionTypeAnnotation: () => createFlowUnionType,
    debuggerStatement: () => debuggerStatement$1,
    declareClass: () => declareClass,
    declareExportAllDeclaration: () => declareExportAllDeclaration,
    declareExportDeclaration: () => declareExportDeclaration,
    declareFunction: () => declareFunction,
    declareInterface: () => declareInterface,
    declareModule: () => declareModule,
    declareModuleExports: () => declareModuleExports,
    declareOpaqueType: () => declareOpaqueType,
    declareTypeAlias: () => declareTypeAlias,
    declareVariable: () => declareVariable,
    declaredPredicate: () => declaredPredicate,
    decorator: () => decorator$1,
    directive: () => directive$1,
    directiveLiteral: () => directiveLiteral$2,
    doExpression: () => doExpression,
    doWhileStatement: () => doWhileStatement$1,
    emptyStatement: () => emptyStatement$1,
    emptyTypeAnnotation: () => emptyTypeAnnotation,
    ensureBlock: () => ensureBlock,
    enumBooleanBody: () => enumBooleanBody,
    enumBooleanMember: () => enumBooleanMember,
    enumDeclaration: () => enumDeclaration,
    enumDefaultedMember: () => enumDefaultedMember,
    enumNumberBody: () => enumNumberBody,
    enumNumberMember: () => enumNumberMember,
    enumStringBody: () => enumStringBody,
    enumStringMember: () => enumStringMember,
    enumSymbolBody: () => enumSymbolBody,
    existsTypeAnnotation: () => existsTypeAnnotation,
    exportAllDeclaration: () => exportAllDeclaration$1,
    exportDefaultDeclaration: () => exportDefaultDeclaration$1,
    exportDefaultSpecifier: () => exportDefaultSpecifier,
    exportNamedDeclaration: () => exportNamedDeclaration,
    exportNamespaceSpecifier: () => exportNamespaceSpecifier,
    exportSpecifier: () => exportSpecifier,
    expressionStatement: () => expressionStatement$5,
    file: () => file$1,
    forInStatement: () => forInStatement$1,
    forOfStatement: () => forOfStatement$1,
    forStatement: () => forStatement$1,
    functionDeclaration: () => functionDeclaration$1,
    functionExpression: () => functionExpression$1,
    functionTypeAnnotation: () => functionTypeAnnotation,
    functionTypeParam: () => functionTypeParam,
    genericTypeAnnotation: () => genericTypeAnnotation,
    getAssignmentIdentifiers: () => getAssignmentIdentifiers,
    getBindingIdentifiers: () => getBindingIdentifiers,
    getFunctionName: () => getFunctionName,
    getOuterBindingIdentifiers: () => getOuterBindingIdentifiers,
    identifier: () => identifier$3,
    ifStatement: () => ifStatement$1,
    import: () => _import,
    importAttribute: () => importAttribute$1,
    importDeclaration: () => importDeclaration$1,
    importDefaultSpecifier: () => importDefaultSpecifier,
    importExpression: () => importExpression$1,
    importNamespaceSpecifier: () => importNamespaceSpecifier,
    importSpecifier: () => importSpecifier,
    indexedAccessType: () => indexedAccessType,
    inferredPredicate: () => inferredPredicate,
    inheritInnerComments: () => inheritInnerComments,
    inheritLeadingComments: () => inheritLeadingComments,
    inheritTrailingComments: () => inheritTrailingComments,
    inherits: () => inherits,
    inheritsComments: () => inheritsComments,
    interfaceDeclaration: () => interfaceDeclaration,
    interfaceExtends: () => interfaceExtends,
    interfaceTypeAnnotation: () => interfaceTypeAnnotation,
    interpreterDirective: () => interpreterDirective,
    intersectionTypeAnnotation: () => intersectionTypeAnnotation,
    is: () => is$4,
    isAccessor: () => isAccessor,
    isAnyTypeAnnotation: () => isAnyTypeAnnotation,
    isArgumentPlaceholder: () => isArgumentPlaceholder,
    isArrayExpression: () => isArrayExpression$a,
    isArrayPattern: () => isArrayPattern,
    isArrayTypeAnnotation: () => isArrayTypeAnnotation,
    isArrowFunctionExpression: () => isArrowFunctionExpression$2,
    isAssignmentExpression: () => isAssignmentExpression$3,
    isAssignmentPattern: () => isAssignmentPattern$3,
    isAwaitExpression: () => isAwaitExpression$1,
    isBigIntLiteral: () => isBigIntLiteral,
    isBinary: () => isBinary,
    isBinaryExpression: () => isBinaryExpression$2,
    isBindExpression: () => isBindExpression,
    isBinding: () => isBinding$1,
    isBlock: () => isBlock$1,
    isBlockParent: () => isBlockParent,
    isBlockScoped: () => isBlockScoped,
    isBlockStatement: () => isBlockStatement$7,
    isBooleanLiteral: () => isBooleanLiteral$2,
    isBooleanLiteralTypeAnnotation: () => isBooleanLiteralTypeAnnotation,
    isBooleanTypeAnnotation: () => isBooleanTypeAnnotation,
    isBreakStatement: () => isBreakStatement,
    isCallExpression: () => isCallExpression$9,
    isCatchClause: () => isCatchClause,
    isClass: () => isClass,
    isClassAccessorProperty: () => isClassAccessorProperty,
    isClassBody: () => isClassBody$2,
    isClassDeclaration: () => isClassDeclaration,
    isClassExpression: () => isClassExpression,
    isClassImplements: () => isClassImplements,
    isClassMethod: () => isClassMethod$2,
    isClassPrivateMethod: () => isClassPrivateMethod,
    isClassPrivateProperty: () => isClassPrivateProperty,
    isClassProperty: () => isClassProperty$1,
    isCompletionStatement: () => isCompletionStatement,
    isConditional: () => isConditional,
    isConditionalExpression: () => isConditionalExpression,
    isContinueStatement: () => isContinueStatement,
    isDebuggerStatement: () => isDebuggerStatement,
    isDeclaration: () => isDeclaration,
    isDeclareClass: () => isDeclareClass,
    isDeclareExportAllDeclaration: () => isDeclareExportAllDeclaration,
    isDeclareExportDeclaration: () => isDeclareExportDeclaration,
    isDeclareFunction: () => isDeclareFunction,
    isDeclareInterface: () => isDeclareInterface,
    isDeclareModule: () => isDeclareModule,
    isDeclareModuleExports: () => isDeclareModuleExports,
    isDeclareOpaqueType: () => isDeclareOpaqueType,
    isDeclareTypeAlias: () => isDeclareTypeAlias,
    isDeclareVariable: () => isDeclareVariable,
    isDeclaredPredicate: () => isDeclaredPredicate,
    isDecorator: () => isDecorator$2,
    isDirective: () => isDirective,
    isDirectiveLiteral: () => isDirectiveLiteral,
    isDoExpression: () => isDoExpression,
    isDoWhileStatement: () => isDoWhileStatement$1,
    isEmptyStatement: () => isEmptyStatement,
    isEmptyTypeAnnotation: () => isEmptyTypeAnnotation,
    isEnumBody: () => isEnumBody,
    isEnumBooleanBody: () => isEnumBooleanBody,
    isEnumBooleanMember: () => isEnumBooleanMember,
    isEnumDeclaration: () => isEnumDeclaration,
    isEnumDefaultedMember: () => isEnumDefaultedMember,
    isEnumMember: () => isEnumMember,
    isEnumNumberBody: () => isEnumNumberBody,
    isEnumNumberMember: () => isEnumNumberMember,
    isEnumStringBody: () => isEnumStringBody,
    isEnumStringMember: () => isEnumStringMember,
    isEnumSymbolBody: () => isEnumSymbolBody,
    isExistsTypeAnnotation: () => isExistsTypeAnnotation,
    isExportAllDeclaration: () => isExportAllDeclaration,
    isExportDeclaration: () => isExportDeclaration$5,
    isExportDefaultDeclaration: () => isExportDefaultDeclaration$1,
    isExportDefaultSpecifier: () => isExportDefaultSpecifier,
    isExportNamedDeclaration: () => isExportNamedDeclaration$3,
    isExportNamespaceSpecifier: () => isExportNamespaceSpecifier$1,
    isExportSpecifier: () => isExportSpecifier$1,
    isExpression: () => isExpression$2,
    isExpressionStatement: () => isExpressionStatement$7,
    isExpressionWrapper: () => isExpressionWrapper,
    isFile: () => isFile$2,
    isFlow: () => isFlow,
    isFlowBaseAnnotation: () => isFlowBaseAnnotation,
    isFlowDeclaration: () => isFlowDeclaration,
    isFlowPredicate: () => isFlowPredicate,
    isFlowType: () => isFlowType,
    isFor: () => isFor,
    isForInStatement: () => isForInStatement,
    isForOfStatement: () => isForOfStatement$2,
    isForStatement: () => isForStatement,
    isForXStatement: () => isForXStatement,
    isFunction: () => isFunction$7,
    isFunctionDeclaration: () => isFunctionDeclaration$3,
    isFunctionExpression: () => isFunctionExpression$1,
    isFunctionParameter: () => isFunctionParameter,
    isFunctionParent: () => isFunctionParent,
    isFunctionTypeAnnotation: () => isFunctionTypeAnnotation,
    isFunctionTypeParam: () => isFunctionTypeParam,
    isGenericTypeAnnotation: () => isGenericTypeAnnotation,
    isIdentifier: () => isIdentifier$g,
    isIfStatement: () => isIfStatement$3,
    isImmutable: () => isImmutable,
    isImport: () => isImport,
    isImportAttribute: () => isImportAttribute,
    isImportDeclaration: () => isImportDeclaration$2,
    isImportDefaultSpecifier: () => isImportDefaultSpecifier$1,
    isImportExpression: () => isImportExpression,
    isImportNamespaceSpecifier: () => isImportNamespaceSpecifier,
    isImportOrExportDeclaration: () => isImportOrExportDeclaration,
    isImportSpecifier: () => isImportSpecifier,
    isIndexedAccessType: () => isIndexedAccessType,
    isInferredPredicate: () => isInferredPredicate,
    isInterfaceDeclaration: () => isInterfaceDeclaration,
    isInterfaceExtends: () => isInterfaceExtends,
    isInterfaceTypeAnnotation: () => isInterfaceTypeAnnotation,
    isInterpreterDirective: () => isInterpreterDirective,
    isIntersectionTypeAnnotation: () => isIntersectionTypeAnnotation,
    isJSX: () => isJSX,
    isJSXAttribute: () => isJSXAttribute$3,
    isJSXClosingElement: () => isJSXClosingElement,
    isJSXClosingFragment: () => isJSXClosingFragment,
    isJSXElement: () => isJSXElement$5,
    isJSXEmptyExpression: () => isJSXEmptyExpression,
    isJSXExpressionContainer: () => isJSXExpressionContainer,
    isJSXFragment: () => isJSXFragment,
    isJSXIdentifier: () => isJSXIdentifier$3,
    isJSXMemberExpression: () => isJSXMemberExpression,
    isJSXNamespacedName: () => isJSXNamespacedName,
    isJSXOpeningElement: () => isJSXOpeningElement,
    isJSXOpeningFragment: () => isJSXOpeningFragment,
    isJSXSpreadAttribute: () => isJSXSpreadAttribute,
    isJSXSpreadChild: () => isJSXSpreadChild,
    isJSXText: () => isJSXText$4,
    isLVal: () => isLVal,
    isLabeledStatement: () => isLabeledStatement$2,
    isLet: () => isLet,
    isLiteral: () => isLiteral$4,
    isLogicalExpression: () => isLogicalExpression$1,
    isLoop: () => isLoop,
    isMemberExpression: () => isMemberExpression$8,
    isMetaProperty: () => isMetaProperty,
    isMethod: () => isMethod,
    isMiscellaneous: () => isMiscellaneous,
    isMixedTypeAnnotation: () => isMixedTypeAnnotation,
    isModuleDeclaration: () => isModuleDeclaration,
    isModuleExpression: () => isModuleExpression,
    isModuleSpecifier: () => isModuleSpecifier,
    isNewExpression: () => isNewExpression,
    isNode: () => isNode,
    isNodesEquivalent: () => isNodesEquivalent,
    isNullLiteral: () => isNullLiteral$1,
    isNullLiteralTypeAnnotation: () => isNullLiteralTypeAnnotation,
    isNullableTypeAnnotation: () => isNullableTypeAnnotation,
    isNumberLiteral: () => isNumberLiteral,
    isNumberLiteralTypeAnnotation: () => isNumberLiteralTypeAnnotation,
    isNumberTypeAnnotation: () => isNumberTypeAnnotation,
    isNumericLiteral: () => isNumericLiteral,
    isObjectExpression: () => isObjectExpression$9,
    isObjectMember: () => isObjectMember,
    isObjectMethod: () => isObjectMethod$1,
    isObjectPattern: () => isObjectPattern$3,
    isObjectProperty: () => isObjectProperty$3,
    isObjectTypeAnnotation: () => isObjectTypeAnnotation,
    isObjectTypeCallProperty: () => isObjectTypeCallProperty,
    isObjectTypeIndexer: () => isObjectTypeIndexer,
    isObjectTypeInternalSlot: () => isObjectTypeInternalSlot,
    isObjectTypeProperty: () => isObjectTypeProperty,
    isObjectTypeSpreadProperty: () => isObjectTypeSpreadProperty,
    isOpaqueType: () => isOpaqueType,
    isOptionalCallExpression: () => isOptionalCallExpression,
    isOptionalIndexedAccessType: () => isOptionalIndexedAccessType,
    isOptionalMemberExpression: () => isOptionalMemberExpression$1,
    isParenthesizedExpression: () => isParenthesizedExpression,
    isPattern: () => isPattern,
    isPatternLike: () => isPatternLike,
    isPipelineBareFunction: () => isPipelineBareFunction,
    isPipelinePrimaryTopicReference: () => isPipelinePrimaryTopicReference,
    isPipelineTopicExpression: () => isPipelineTopicExpression,
    isPlaceholder: () => isPlaceholder,
    isPlaceholderType: () => isPlaceholderType,
    isPrivate: () => isPrivate,
    isPrivateName: () => isPrivateName,
    isProgram: () => isProgram$5,
    isProperty: () => isProperty$1,
    isPureish: () => isPureish,
    isQualifiedTypeIdentifier: () => isQualifiedTypeIdentifier,
    isRecordExpression: () => isRecordExpression,
    isReferenced: () => isReferenced,
    isRegExpLiteral: () => isRegExpLiteral$2,
    isRegexLiteral: () => isRegexLiteral,
    isRestElement: () => isRestElement,
    isRestProperty: () => isRestProperty,
    isReturnStatement: () => isReturnStatement$3,
    isScopable: () => isScopable,
    isScope: () => isScope,
    isSequenceExpression: () => isSequenceExpression$2,
    isSpecifierDefault: () => isSpecifierDefault,
    isSpreadElement: () => isSpreadElement$3,
    isSpreadProperty: () => isSpreadProperty,
    isStandardized: () => isStandardized,
    isStatement: () => isStatement$7,
    isStaticBlock: () => isStaticBlock,
    isStringLiteral: () => isStringLiteral$a,
    isStringLiteralTypeAnnotation: () => isStringLiteralTypeAnnotation,
    isStringTypeAnnotation: () => isStringTypeAnnotation,
    isSuper: () => isSuper,
    isSwitchCase: () => isSwitchCase,
    isSwitchStatement: () => isSwitchStatement,
    isSymbolTypeAnnotation: () => isSymbolTypeAnnotation,
    isTSAnyKeyword: () => isTSAnyKeyword,
    isTSArrayType: () => isTSArrayType,
    isTSAsExpression: () => isTSAsExpression,
    isTSBaseType: () => isTSBaseType,
    isTSBigIntKeyword: () => isTSBigIntKeyword,
    isTSBooleanKeyword: () => isTSBooleanKeyword,
    isTSCallSignatureDeclaration: () => isTSCallSignatureDeclaration,
    isTSClassImplements: () => isTSClassImplements,
    isTSConditionalType: () => isTSConditionalType$1,
    isTSConstructSignatureDeclaration: () => isTSConstructSignatureDeclaration,
    isTSConstructorType: () => isTSConstructorType,
    isTSDeclareFunction: () => isTSDeclareFunction,
    isTSDeclareMethod: () => isTSDeclareMethod,
    isTSEntityName: () => isTSEntityName,
    isTSEnumBody: () => isTSEnumBody,
    isTSEnumDeclaration: () => isTSEnumDeclaration,
    isTSEnumMember: () => isTSEnumMember,
    isTSExportAssignment: () => isTSExportAssignment,
    isTSExternalModuleReference: () => isTSExternalModuleReference,
    isTSFunctionType: () => isTSFunctionType,
    isTSImportEqualsDeclaration: () => isTSImportEqualsDeclaration,
    isTSImportType: () => isTSImportType$1,
    isTSIndexSignature: () => isTSIndexSignature,
    isTSIndexedAccessType: () => isTSIndexedAccessType,
    isTSInferType: () => isTSInferType,
    isTSInstantiationExpression: () => isTSInstantiationExpression,
    isTSInterfaceBody: () => isTSInterfaceBody,
    isTSInterfaceDeclaration: () => isTSInterfaceDeclaration,
    isTSInterfaceHeritage: () => isTSInterfaceHeritage,
    isTSIntersectionType: () => isTSIntersectionType,
    isTSIntrinsicKeyword: () => isTSIntrinsicKeyword,
    isTSLiteralType: () => isTSLiteralType,
    isTSMappedType: () => isTSMappedType,
    isTSMethodSignature: () => isTSMethodSignature,
    isTSModuleBlock: () => isTSModuleBlock$4,
    isTSModuleDeclaration: () => isTSModuleDeclaration,
    isTSNamedTupleMember: () => isTSNamedTupleMember,
    isTSNamespaceExportDeclaration: () => isTSNamespaceExportDeclaration,
    isTSNeverKeyword: () => isTSNeverKeyword,
    isTSNonNullExpression: () => isTSNonNullExpression,
    isTSNullKeyword: () => isTSNullKeyword,
    isTSNumberKeyword: () => isTSNumberKeyword,
    isTSObjectKeyword: () => isTSObjectKeyword,
    isTSOptionalType: () => isTSOptionalType,
    isTSParameterProperty: () => isTSParameterProperty,
    isTSParenthesizedType: () => isTSParenthesizedType,
    isTSPropertySignature: () => isTSPropertySignature$1,
    isTSQualifiedName: () => isTSQualifiedName,
    isTSRestType: () => isTSRestType,
    isTSSatisfiesExpression: () => isTSSatisfiesExpression,
    isTSStringKeyword: () => isTSStringKeyword,
    isTSSymbolKeyword: () => isTSSymbolKeyword,
    isTSTemplateLiteralType: () => isTSTemplateLiteralType,
    isTSThisType: () => isTSThisType,
    isTSTupleType: () => isTSTupleType,
    isTSType: () => isTSType,
    isTSTypeAliasDeclaration: () => isTSTypeAliasDeclaration$1,
    isTSTypeAnnotation: () => isTSTypeAnnotation,
    isTSTypeAssertion: () => isTSTypeAssertion,
    isTSTypeElement: () => isTSTypeElement,
    isTSTypeLiteral: () => isTSTypeLiteral,
    isTSTypeOperator: () => isTSTypeOperator,
    isTSTypeParameter: () => isTSTypeParameter$1,
    isTSTypeParameterDeclaration: () => isTSTypeParameterDeclaration$1,
    isTSTypeParameterInstantiation: () => isTSTypeParameterInstantiation,
    isTSTypePredicate: () => isTSTypePredicate,
    isTSTypeQuery: () => isTSTypeQuery,
    isTSTypeReference: () => isTSTypeReference$3,
    isTSUndefinedKeyword: () => isTSUndefinedKeyword,
    isTSUnionType: () => isTSUnionType,
    isTSUnknownKeyword: () => isTSUnknownKeyword,
    isTSVoidKeyword: () => isTSVoidKeyword,
    isTaggedTemplateExpression: () => isTaggedTemplateExpression,
    isTemplateElement: () => isTemplateElement$4,
    isTemplateLiteral: () => isTemplateLiteral$4,
    isTerminatorless: () => isTerminatorless,
    isThisExpression: () => isThisExpression,
    isThisTypeAnnotation: () => isThisTypeAnnotation,
    isThrowStatement: () => isThrowStatement,
    isTopicReference: () => isTopicReference,
    isTryStatement: () => isTryStatement,
    isTupleExpression: () => isTupleExpression,
    isTupleTypeAnnotation: () => isTupleTypeAnnotation,
    isType: () => isType,
    isTypeAlias: () => isTypeAlias,
    isTypeAnnotation: () => isTypeAnnotation,
    isTypeCastExpression: () => isTypeCastExpression,
    isTypeParameter: () => isTypeParameter,
    isTypeParameterDeclaration: () => isTypeParameterDeclaration,
    isTypeParameterInstantiation: () => isTypeParameterInstantiation,
    isTypeScript: () => isTypeScript,
    isTypeofTypeAnnotation: () => isTypeofTypeAnnotation,
    isUnaryExpression: () => isUnaryExpression$1,
    isUnaryLike: () => isUnaryLike,
    isUnionTypeAnnotation: () => isUnionTypeAnnotation,
    isUpdateExpression: () => isUpdateExpression,
    isUserWhitespacable: () => isUserWhitespacable,
    isV8IntrinsicIdentifier: () => isV8IntrinsicIdentifier,
    isValidES3Identifier: () => isValidES3Identifier,
    isValidIdentifier: () => isValidIdentifier,
    isVar: () => isVar,
    isVariableDeclaration: () => isVariableDeclaration$5,
    isVariableDeclarator: () => isVariableDeclarator$4,
    isVariance: () => isVariance,
    isVoidPattern: () => isVoidPattern,
    isVoidTypeAnnotation: () => isVoidTypeAnnotation,
    isWhile: () => isWhile,
    isWhileStatement: () => isWhileStatement,
    isWithStatement: () => isWithStatement,
    isYieldExpression: () => isYieldExpression,
    jsxAttribute: () => jsxAttribute$1,
    jsxClosingElement: () => jsxClosingElement,
    jsxClosingFragment: () => jsxClosingFragment,
    jsxElement: () => jsxElement$1,
    jsxEmptyExpression: () => jsxEmptyExpression,
    jsxExpressionContainer: () => jsxExpressionContainer,
    jsxFragment: () => jsxFragment$1,
    jsxIdentifier: () => jsxIdentifier,
    jsxMemberExpression: () => jsxMemberExpression,
    jsxNamespacedName: () => jsxNamespacedName,
    jsxOpeningElement: () => jsxOpeningElement$1,
    jsxOpeningFragment: () => jsxOpeningFragment,
    jsxSpreadAttribute: () => jsxSpreadAttribute,
    jsxSpreadChild: () => jsxSpreadChild,
    jsxText: () => jsxText$1,
    labeledStatement: () => labeledStatement$1,
    logicalExpression: () => logicalExpression$1,
    matchesPattern: () => matchesPattern$1,
    memberExpression: () => memberExpression,
    metaProperty: () => metaProperty,
    mixedTypeAnnotation: () => mixedTypeAnnotation,
    moduleExpression: () => moduleExpression,
    newExpression: () => newExpression$1,
    nullLiteral: () => nullLiteral,
    nullLiteralTypeAnnotation: () => nullLiteralTypeAnnotation,
    nullableTypeAnnotation: () => nullableTypeAnnotation,
    numberLiteral: () => NumberLiteral,
    numberLiteralTypeAnnotation: () => numberLiteralTypeAnnotation,
    numberTypeAnnotation: () => numberTypeAnnotation,
    numericLiteral: () => numericLiteral,
    objectExpression: () => objectExpression$3,
    objectMethod: () => objectMethod$2,
    objectPattern: () => objectPattern$2,
    objectProperty: () => objectProperty$4,
    objectTypeAnnotation: () => objectTypeAnnotation,
    objectTypeCallProperty: () => objectTypeCallProperty,
    objectTypeIndexer: () => objectTypeIndexer,
    objectTypeInternalSlot: () => objectTypeInternalSlot,
    objectTypeProperty: () => objectTypeProperty,
    objectTypeSpreadProperty: () => objectTypeSpreadProperty,
    opaqueType: () => opaqueType,
    optionalCallExpression: () => optionalCallExpression,
    optionalIndexedAccessType: () => optionalIndexedAccessType,
    optionalMemberExpression: () => optionalMemberExpression,
    parenthesizedExpression: () => parenthesizedExpression$3,
    pipelineBareFunction: () => pipelineBareFunction,
    pipelinePrimaryTopicReference: () => pipelinePrimaryTopicReference,
    pipelineTopicExpression: () => pipelineTopicExpression,
    placeholder: () => placeholder,
    prependToMemberExpression: () => prependToMemberExpression,
    privateName: () => privateName$1,
    program: () => program$2,
    qualifiedTypeIdentifier: () => qualifiedTypeIdentifier,
    react: () => react,
    recordExpression: () => recordExpression,
    regExpLiteral: () => regExpLiteral,
    regexLiteral: () => RegexLiteral,
    removeComments: () => removeComments,
    removeProperties: () => removeProperties,
    removePropertiesDeep: () => removePropertiesDeep,
    removeTypeDuplicates: () => removeTypeDuplicates$1,
    restElement: () => restElement$1,
    restProperty: () => RestProperty,
    returnStatement: () => returnStatement$1,
    sequenceExpression: () => sequenceExpression$1,
    shallowEqual: () => shallowEqual,
    spreadElement: () => spreadElement$1,
    spreadProperty: () => SpreadProperty,
    staticBlock: () => staticBlock$1,
    stringLiteral: () => stringLiteral$5,
    stringLiteralTypeAnnotation: () => stringLiteralTypeAnnotation,
    stringTypeAnnotation: () => stringTypeAnnotation,
    super: () => _super,
    switchCase: () => switchCase,
    switchStatement: () => switchStatement$1,
    symbolTypeAnnotation: () => symbolTypeAnnotation,
    taggedTemplateExpression: () => taggedTemplateExpression$1,
    templateElement: () => templateElement$1,
    templateLiteral: () => templateLiteral$1,
    thisExpression: () => thisExpression,
    thisTypeAnnotation: () => thisTypeAnnotation,
    throwStatement: () => throwStatement,
    toBindingIdentifierName: () => toBindingIdentifierName,
    toBlock: () => toBlock,
    toComputedKey: () => toComputedKey,
    toExpression: () => toExpression$4,
    toIdentifier: () => toIdentifier,
    toKeyAlias: () => toKeyAlias,
    toStatement: () => toStatement$1,
    topicReference: () => topicReference,
    traverse: () => traverse$a,
    traverseFast: () => traverseFast,
    tryStatement: () => tryStatement,
    tsAnyKeyword: () => tsAnyKeyword,
    tsArrayType: () => tsArrayType,
    tsAsExpression: () => tsAsExpression$1,
    tsBigIntKeyword: () => tsBigIntKeyword,
    tsBooleanKeyword: () => tsBooleanKeyword,
    tsCallSignatureDeclaration: () => tsCallSignatureDeclaration$1,
    tsClassImplements: () => tsClassImplements,
    tsConditionalType: () => tsConditionalType$1,
    tsConstructSignatureDeclaration: () => tsConstructSignatureDeclaration$1,
    tsConstructorType: () => tsConstructorType$1,
    tsDeclareFunction: () => tsDeclareFunction$1,
    tsDeclareMethod: () => tsDeclareMethod$1,
    tsEnumBody: () => tsEnumBody,
    tsEnumDeclaration: () => tsEnumDeclaration$1,
    tsEnumMember: () => tsEnumMember$1,
    tsExportAssignment: () => tsExportAssignment$1,
    tsExternalModuleReference: () => tsExternalModuleReference,
    tsFunctionType: () => tsFunctionType$1,
    tsImportEqualsDeclaration: () => tsImportEqualsDeclaration,
    tsImportType: () => tsImportType$1,
    tsIndexSignature: () => tsIndexSignature,
    tsIndexedAccessType: () => tsIndexedAccessType,
    tsInferType: () => tsInferType$1,
    tsInstantiationExpression: () => tsInstantiationExpression,
    tsInterfaceBody: () => tsInterfaceBody$1,
    tsInterfaceDeclaration: () => tsInterfaceDeclaration$1,
    tsInterfaceHeritage: () => tsInterfaceHeritage,
    tsIntersectionType: () => tsIntersectionType$1,
    tsIntrinsicKeyword: () => tsIntrinsicKeyword,
    tsLiteralType: () => tsLiteralType,
    tsMappedType: () => tsMappedType$1,
    tsMethodSignature: () => tsMethodSignature$1,
    tsModuleBlock: () => tsModuleBlock,
    tsModuleDeclaration: () => tsModuleDeclaration$1,
    tsNamedTupleMember: () => tsNamedTupleMember$1,
    tsNamespaceExportDeclaration: () => tsNamespaceExportDeclaration,
    tsNeverKeyword: () => tsNeverKeyword,
    tsNonNullExpression: () => tsNonNullExpression,
    tsNullKeyword: () => tsNullKeyword,
    tsNumberKeyword: () => tsNumberKeyword,
    tsObjectKeyword: () => tsObjectKeyword,
    tsOptionalType: () => tsOptionalType,
    tsParameterProperty: () => tsParameterProperty$1,
    tsParenthesizedType: () => tsParenthesizedType$3,
    tsPropertySignature: () => tsPropertySignature$1,
    tsQualifiedName: () => tsQualifiedName,
    tsRestType: () => tsRestType,
    tsSatisfiesExpression: () => tsSatisfiesExpression,
    tsStringKeyword: () => tsStringKeyword,
    tsSymbolKeyword: () => tsSymbolKeyword,
    tsTemplateLiteralType: () => tsTemplateLiteralType,
    tsThisType: () => tsThisType,
    tsTupleType: () => tsTupleType$1,
    tsTypeAliasDeclaration: () => tsTypeAliasDeclaration$1,
    tsTypeAnnotation: () => tsTypeAnnotation,
    tsTypeAssertion: () => tsTypeAssertion,
    tsTypeLiteral: () => tsTypeLiteral$1,
    tsTypeOperator: () => tsTypeOperator,
    tsTypeParameter: () => tsTypeParameter$1,
    tsTypeParameterDeclaration: () => tsTypeParameterDeclaration,
    tsTypeParameterInstantiation: () => tsTypeParameterInstantiation,
    tsTypePredicate: () => tsTypePredicate,
    tsTypeQuery: () => tsTypeQuery$1,
    tsTypeReference: () => tsTypeReference$1,
    tsUndefinedKeyword: () => tsUndefinedKeyword,
    tsUnionType: () => tsUnionType$1,
    tsUnknownKeyword: () => tsUnknownKeyword,
    tsVoidKeyword: () => tsVoidKeyword,
    tupleExpression: () => tupleExpression,
    tupleTypeAnnotation: () => tupleTypeAnnotation,
    typeAlias: () => typeAlias,
    typeAnnotation: () => typeAnnotation,
    typeCastExpression: () => typeCastExpression,
    typeParameter: () => typeParameter,
    typeParameterDeclaration: () => typeParameterDeclaration,
    typeParameterInstantiation: () => typeParameterInstantiation,
    typeofTypeAnnotation: () => typeofTypeAnnotation,
    unaryExpression: () => unaryExpression$1,
    unionTypeAnnotation: () => unionTypeAnnotation,
    updateExpression: () => updateExpression,
    v8IntrinsicIdentifier: () => v8IntrinsicIdentifier,
    validate: () => validate$1$1,
    valueToNode: () => valueToNode,
    variableDeclaration: () => variableDeclaration$1,
    variableDeclarator: () => variableDeclarator,
    variance: () => variance,
    voidPattern: () => voidPattern$1,
    voidTypeAnnotation: () => voidTypeAnnotation,
    whileStatement: () => whileStatement$1,
    withStatement: () => withStatement,
    yieldExpression: () => yieldExpression,
});

// node_modules/@babel/helper-validator-identifier/lib/index.js
var nonASCIIidentifierStartChars = '\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC';
var nonASCIIidentifierChars = '\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65';
var nonASCIIidentifierStart = new RegExp('[' + nonASCIIidentifierStartChars + ']');
var nonASCIIidentifier = new RegExp('[' + nonASCIIidentifierStartChars + nonASCIIidentifierChars + ']');

nonASCIIidentifierStartChars =
nonASCIIidentifierChars = null;
var astralIdentifierStartCodes = [
    0,
    11,
    2,
    25,
    2,
    18,
    2,
    1,
    2,
    14,
    3,
    13,
    35,
    122,
    70,
    52,
    268,
    28,
    4,
    48,
    48,
    31,
    14,
    29,
    6,
    37,
    11,
    29,
    3,
    35,
    5,
    7,
    2,
    4,
    43,
    157,
    19,
    35,
    5,
    35,
    5,
    39,
    9,
    51,
    13,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    2,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    4,
    51,
    13,
    310,
    10,
    21,
    11,
    7,
    25,
    5,
    2,
    41,
    2,
    8,
    70,
    5,
    3,
    0,
    2,
    43,
    2,
    1,
    4,
    0,
    3,
    22,
    11,
    22,
    10,
    30,
    66,
    18,
    2,
    1,
    11,
    21,
    11,
    25,
    71,
    55,
    7,
    1,
    65,
    0,
    16,
    3,
    2,
    2,
    2,
    28,
    43,
    28,
    4,
    28,
    36,
    7,
    2,
    27,
    28,
    53,
    11,
    21,
    11,
    18,
    14,
    17,
    111,
    72,
    56,
    50,
    14,
    50,
    14,
    35,
    39,
    27,
    10,
    22,
    251,
    41,
    7,
    1,
    17,
    2,
    60,
    28,
    11,
    0,
    9,
    21,
    43,
    17,
    47,
    20,
    28,
    22,
    13,
    52,
    58,
    1,
    3,
    0,
    14,
    44,
    33,
    24,
    27,
    35,
    30,
    0,
    3,
    0,
    9,
    34,
    4,
    0,
    13,
    47,
    15,
    3,
    22,
    0,
    2,
    0,
    36,
    17,
    2,
    24,
    20,
    1,
    64,
    6,
    2,
    0,
    2,
    3,
    2,
    14,
    2,
    9,
    8,
    46,
    39,
    7,
    3,
    1,
    3,
    21,
    2,
    6,
    2,
    1,
    2,
    4,
    4,
    0,
    19,
    0,
    13,
    4,
    31,
    9,
    2,
    0,
    3,
    0,
    2,
    37,
    2,
    0,
    26,
    0,
    2,
    0,
    45,
    52,
    19,
    3,
    21,
    2,
    31,
    47,
    21,
    1,
    2,
    0,
    185,
    46,
    42,
    3,
    37,
    47,
    21,
    0,
    60,
    42,
    14,
    0,
    72,
    26,
    38,
    6,
    186,
    43,
    117,
    63,
    32,
    7,
    3,
    0,
    3,
    7,
    2,
    1,
    2,
    23,
    16,
    0,
    2,
    0,
    95,
    7,
    3,
    38,
    17,
    0,
    2,
    0,
    29,
    0,
    11,
    39,
    8,
    0,
    22,
    0,
    12,
    45,
    20,
    0,
    19,
    72,
    200,
    32,
    32,
    8,
    2,
    36,
    18,
    0,
    50,
    29,
    113,
    6,
    2,
    1,
    2,
    37,
    22,
    0,
    26,
    5,
    2,
    1,
    2,
    31,
    15,
    0,
    328,
    18,
    16,
    0,
    2,
    12,
    2,
    33,
    125,
    0,
    80,
    921,
    103,
    110,
    18,
    195,
    2637,
    96,
    16,
    1071,
    18,
    5,
    26,
    3994,
    6,
    582,
    6842,
    29,
    1763,
    568,
    8,
    30,
    18,
    78,
    18,
    29,
    19,
    47,
    17,
    3,
    32,
    20,
    6,
    18,
    433,
    44,
    212,
    63,
    129,
    74,
    6,
    0,
    67,
    12,
    65,
    1,
    2,
    0,
    29,
    6135,
    9,
    1237,
    42,
    9,
    8936,
    3,
    2,
    6,
    2,
    1,
    2,
    290,
    16,
    0,
    30,
    2,
    3,
    0,
    15,
    3,
    9,
    395,
    2309,
    106,
    6,
    12,
    4,
    8,
    8,
    9,
    5991,
    84,
    2,
    70,
    2,
    1,
    3,
    0,
    3,
    1,
    3,
    3,
    2,
    11,
    2,
    0,
    2,
    6,
    2,
    64,
    2,
    3,
    3,
    7,
    2,
    6,
    2,
    27,
    2,
    3,
    2,
    4,
    2,
    0,
    4,
    6,
    2,
    339,
    3,
    24,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    7,
    1845,
    30,
    7,
    5,
    262,
    61,
    147,
    44,
    11,
    6,
    17,
    0,
    322,
    29,
    19,
    43,
    485,
    27,
    229,
    29,
    3,
    0,
    496,
    6,
    2,
    3,
    2,
    1,
    2,
    14,
    2,
    196,
    60,
    67,
    8,
    0,
    1205,
    3,
    2,
    26,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    9,
    2,
    3,
    2,
    0,
    2,
    0,
    7,
    0,
    5,
    0,
    2,
    0,
    2,
    0,
    2,
    2,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    1,
    2,
    0,
    3,
    3,
    2,
    6,
    2,
    3,
    2,
    3,
    2,
    0,
    2,
    9,
    2,
    16,
    6,
    2,
    2,
    4,
    2,
    16,
    4421,
    42719,
    33,
    4153,
    7,
    221,
    3,
    5761,
    15,
    7472,
    16,
    621,
    2467,
    541,
    1507,
    4938,
    6,
    4191,
];
var astralIdentifierCodes = [
    509,
    0,
    227,
    0,
    150,
    4,
    294,
    9,
    1368,
    2,
    2,
    1,
    6,
    3,
    41,
    2,
    5,
    0,
    166,
    1,
    574,
    3,
    9,
    9,
    7,
    9,
    32,
    4,
    318,
    1,
    80,
    3,
    71,
    10,
    50,
    3,
    123,
    2,
    54,
    14,
    32,
    10,
    3,
    1,
    11,
    3,
    46,
    10,
    8,
    0,
    46,
    9,
    7,
    2,
    37,
    13,
    2,
    9,
    6,
    1,
    45,
    0,
    13,
    2,
    49,
    13,
    9,
    3,
    2,
    11,
    83,
    11,
    7,
    0,
    3,
    0,
    158,
    11,
    6,
    9,
    7,
    3,
    56,
    1,
    2,
    6,
    3,
    1,
    3,
    2,
    10,
    0,
    11,
    1,
    3,
    6,
    4,
    4,
    68,
    8,
    2,
    0,
    3,
    0,
    2,
    3,
    2,
    4,
    2,
    0,
    15,
    1,
    83,
    17,
    10,
    9,
    5,
    0,
    82,
    19,
    13,
    9,
    214,
    6,
    3,
    8,
    28,
    1,
    83,
    16,
    16,
    9,
    82,
    12,
    9,
    9,
    7,
    19,
    58,
    14,
    5,
    9,
    243,
    14,
    166,
    9,
    71,
    5,
    2,
    1,
    3,
    3,
    2,
    0,
    2,
    1,
    13,
    9,
    120,
    6,
    3,
    6,
    4,
    0,
    29,
    9,
    41,
    6,
    2,
    3,
    9,
    0,
    10,
    10,
    47,
    15,
    343,
    9,
    54,
    7,
    2,
    7,
    17,
    9,
    57,
    21,
    2,
    13,
    123,
    5,
    4,
    0,
    2,
    1,
    2,
    6,
    2,
    0,
    9,
    9,
    49,
    4,
    2,
    1,
    2,
    4,
    9,
    9,
    330,
    3,
    10,
    1,
    2,
    0,
    49,
    6,
    4,
    4,
    14,
    10,
    5350,
    0,
    7,
    14,
    11465,
    27,
    2343,
    9,
    87,
    9,
    39,
    4,
    60,
    6,
    26,
    9,
    535,
    9,
    470,
    0,
    2,
    54,
    8,
    3,
    82,
    0,
    12,
    1,
    19628,
    1,
    4178,
    9,
    519,
    45,
    3,
    22,
    543,
    4,
    4,
    5,
    9,
    7,
    3,
    6,
    31,
    3,
    149,
    2,
    1418,
    49,
    513,
    54,
    5,
    49,
    9,
    0,
    15,
    0,
    23,
    4,
    2,
    14,
    1361,
    6,
    2,
    16,
    3,
    6,
    2,
    1,
    2,
    4,
    101,
    0,
    161,
    6,
    10,
    9,
    357,
    0,
    62,
    13,
    499,
    13,
    245,
    1,
    2,
    9,
    726,
    6,
    110,
    6,
    6,
    9,
    4759,
    9,
    787719,
    239,
];

function isInAstralSet(code2, set) {
    let pos = 65536;
    
    for (let i = 0, length = set.length; i < length; i += 2) {
        pos += set[i];
        
        if (pos > code2)
            return false;
        
        pos += set[i + 1];
        
        if (pos >= code2)
            return true;
    }
    
    return false;
}

function isIdentifierStart(code2) {
    if (code2 < 65)
        return code2 === 36;
    
    if (code2 <= 90)
        return true;
    
    if (code2 < 97)
        return code2 === 95;
    
    if (code2 <= 122)
        return true;
    
    if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
    }
    
    return isInAstralSet(code2, astralIdentifierStartCodes);
}

function isIdentifierChar(code2) {
    if (code2 < 48)
        return code2 === 36;
    
    if (code2 < 58)
        return true;
    
    if (code2 < 65)
        return false;
    
    if (code2 <= 90)
        return true;
    
    if (code2 < 97)
        return code2 === 95;
    
    if (code2 <= 122)
        return true;
    
    if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
    }
    
    return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
}

function isIdentifierName(name) {
    let isFirst = true;
    
    for (let i = 0; i < name.length; i++) {
        let cp = name.charCodeAt(i);
        
        if ((cp & 64512) === 55296 && i + 1 < name.length) {
            const trail = name.charCodeAt(++i);
            
            if ((trail & 64512) === 56320) {
                cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
            }
        }
        
        if (isFirst) {
            isFirst = false;
            
            if (!isIdentifierStart(cp)) {
                return false;
            }
        } else if (!isIdentifierChar(cp)) {
            return false;
        }
    }
    
    return !isFirst;
}

var reservedWords = {
    keyword: [
        'break',
        'case',
        'catch',
        'continue',
        'debugger',
        'default',
        'do',
        'else',
        'finally',
        'for',
        'function',
        'if',
        'return',
        'switch',
        'throw',
        'try',
        'var',
        'const',
        'while',
        'with',
        'new',
        'this',
        'super',
        'class',
        'extends',
        'export',
        'import',
        'null',
        'true',
        'false',
        'in',
        'instanceof',
        'typeof',
        'void',
        'delete',
    ],
    strict: [
        'implements',
        'interface',
        'let',
        'package',
        'private',
        'protected',
        'public',
        'static',
        'yield',
    ],
    strictBind: ['eval', 'arguments'],
};

var keywords$1 = new Set(reservedWords.keyword);
var reservedWordsStrictSet = new Set(reservedWords.strict);
new Set(reservedWords.strictBind);

function isReservedWord(word, inModule) {
    return inModule && word === 'await' || word === 'enum';
}

function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
}

function isKeyword(word) {
    return keywords$1.has(word);
}

// node_modules/@babel/helper-string-parser/lib/index.js
var _isDigit = function isDigit(code2) {
    return code2 >= 48 && code2 <= 57;
};

function readStringContents(type, input, pos, lineStart, curLine, errors) {
    const initialPos = pos;
    const initialLineStart = lineStart;
    const initialCurLine = curLine;
    let out = '';
    let firstInvalidLoc = null;
    let chunkStart = pos;
    
    const {length} = input;
    
    for (;;) {
        if (pos >= length) {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
            out += input.slice(chunkStart, pos);
            break;
        }
        
        const ch = input.charCodeAt(pos);
        
        if (isStringEnd(type, ch, input, pos)) {
            out += input.slice(chunkStart, pos);
            break;
        }
        
        if (ch === 92) {
            out += input.slice(chunkStart, pos);
            const res = readEscapedChar(input, pos, lineStart, curLine, type === 'template', errors);
            
            if (res.ch === null && !firstInvalidLoc) {
                firstInvalidLoc = {
                    pos,
                    lineStart,
                    curLine,
                };
            } else {
                out += res.ch;
            }
            
            ({
                pos,
                lineStart,
                curLine,
            } = res);
            chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
            ++pos;
            ++curLine;
            lineStart = pos;
        } else if (ch === 10 || ch === 13) {
            {
                out += input.slice(chunkStart, pos) + '\n';
                ++pos;
                
                if (ch === 13 && input.charCodeAt(pos) === 10) {
                    ++pos;
                }
                
                ++curLine;
                chunkStart =
                lineStart = pos;
            }
        } else {
            ++pos;
        }

    }
    
    return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
    };
}

function isStringEnd(type, ch, input, pos) {
    {
        return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
    }
}

function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
    const throwOnInvalid = false;
    pos++;
    const res = (ch2) => ({
        pos,
        ch: ch2,
        lineStart,
        curLine,
    });
    
    const ch = input.charCodeAt(pos++);
    
    switch(ch) {
    case 110:
        return res('\n');
    
    case 114:
        return res('\r');
    
    case 120: {
        let code2;
        
        ({
            code: code2,
            pos,
        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
        return res(code2 === null ? null : String.fromCharCode(code2));
    }
    
    case 117: {
        let code2;
        
        ({
            code: code2,
            pos,
        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
        return res(code2 === null ? null : String.fromCodePoint(code2));
    }
    
    case 116:
        return res('	');
    
    case 98:
        return res('\b');
    
    case 118:
        return res('\v');
    
    case 102:
        return res('\f');
    
    case 13:
        if (input.charCodeAt(pos) === 10) {
            ++pos;
        }
    
    case 10:
        lineStart = pos;
        ++curLine;
    
    case 8232:    
    case 8233:
        return res('');
    
    case 56:    
    case 57:
        {
            return res(null);
        }
    
    default:
        if (ch >= 48 && ch <= 55) {
            const startPos = pos - 1;
            const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
            let octalStr = match[0];
            let octal = parseInt(octalStr, 8);
            
            if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
            }
            
            pos += octalStr.length - 1;
            const next = input.charCodeAt(pos);
            
            if (octalStr !== '0' || next === 56 || next === 57) {
                {
                    return res(null);
                }
            }
            
            return res(String.fromCharCode(octal));
        }
        
        return res(String.fromCharCode(ch));
    }
}

function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
    const initialPos = pos;
    let n2;
    
    ({n: n2, pos} = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, true));
    
    if (n2 === null) {
        {
            pos = initialPos - 1;
        }
    }
    
    return {
        code: n2,
        pos,
    };
}

function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
    const start = pos;
    let invalid = false;
    let total = 0;
    
    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        const code2 = input.charCodeAt(pos);
        let val;
        
        if (code2 === 95 && allowNumSeparator !== 'bail') {
            input.charCodeAt(pos - 1);
            input.charCodeAt(pos + 1);
            
            {
                return {
                        n: null,
                        pos,
                    };
            }
        }
        
        if (code2 >= 97) {
            val = code2 - 97 + 10;
        } else if (code2 >= 65) {
            val = code2 - 65 + 10;
        } else if (_isDigit(code2)) {
            val = code2 - 48;
        } else {
            val = Infinity;
        }
        
        if (val >= radix) {
            if (val <= 9 && bailOnError) {
                return {
                    n: null,
                    pos,
                };
            } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
                val = 0;
            } else if (forceLen) {
                val = 0;
                invalid = true;
            } else {
                break;
            }

        }
        
        ++pos;
        total = total * radix + val;
    }
    
    if (pos === start || len != null && pos - start !== len || invalid) {
        return {
            n: null,
            pos,
        };
    }
    
    return {
        n: total,
        pos,
    };
}

function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
    const ch = input.charCodeAt(pos);
    let code2;
    
    if (ch === 123) {
        ++pos;
        ({
            code: code2,
            pos,
        } = readHexChar(input, pos, lineStart, curLine, input.indexOf('}', pos) - pos, true, throwOnInvalid, errors));
        ++pos;
        
        if (code2 !== null && code2 > 1114111) {
            {
                return {
                    code: null,
                    pos,
                };
            }
        }
    } else {
        ({
            code: code2,
            pos,
        } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
    }
    
    return {
        code: code2,
        pos,
    };
}

// node_modules/@babel/types/lib/index.js
function shallowEqual(actual, expected) {
    const keys2 = Object.keys(expected);
    
    for (const key of keys2) {
        if (actual[key] !== expected[key]) {
            return false;
        }
    }
    
    return true;
}

var warnings = /* @__PURE__ */new Set();

function deprecationWarning(oldName, newName, prefix2 = '', cacheKey = oldName) {
    if (warnings.has(cacheKey))
        return;
    
    warnings.add(cacheKey);
    const {internal, trace} = captureShortStackTrace(1, 2);
    
    if (internal) {
        return;
    }
    
    console.warn(`${prefix2}\`${oldName}\` has been deprecated, please migrate to \`${newName}\`
${trace}`);
}

function captureShortStackTrace(skip2, length) {
    const {
        stackTraceLimit,
        prepareStackTrace,
    } = Error;
    
    let stackTrace;
    
    Error.stackTraceLimit = 1 + skip2 + length;
    Error.prepareStackTrace = function(err, stack) {
        stackTrace = stack;
    };
    new Error().stack;
    Error.stackTraceLimit = stackTraceLimit;
    Error.prepareStackTrace = prepareStackTrace;
    
    if (!stackTrace)
        return {
            internal: false,
            trace: '',
        };
    
    const shortStackTrace = stackTrace.slice(1 + skip2, 1 + skip2 + length);
    
    return {
        internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
        trace: shortStackTrace
            .map((frame) => `    at ${frame}`)
            .join('\n'),
    };
}

function isArrayExpression$a(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ArrayExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isAssignmentExpression$3(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'AssignmentExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isBinaryExpression$2(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'BinaryExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isInterpreterDirective(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'InterpreterDirective')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDirective(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'Directive')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDirectiveLiteral(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DirectiveLiteral')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isBlockStatement$7(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'BlockStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isBreakStatement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'BreakStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isCallExpression$9(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'CallExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isCatchClause(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'CatchClause')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isConditionalExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ConditionalExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isContinueStatement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ContinueStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDebuggerStatement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DebuggerStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDoWhileStatement$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DoWhileStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isEmptyStatement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'EmptyStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isExpressionStatement$7(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ExpressionStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isFile$2(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'File')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isForInStatement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ForInStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isForStatement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ForStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isFunctionDeclaration$3(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'FunctionDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isFunctionExpression$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'FunctionExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isIdentifier$g(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'Identifier')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isIfStatement$3(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'IfStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isLabeledStatement$2(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'LabeledStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isStringLiteral$a(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'StringLiteral')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isNumericLiteral(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'NumericLiteral')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isNullLiteral$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'NullLiteral')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isBooleanLiteral$2(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'BooleanLiteral')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isRegExpLiteral$2(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'RegExpLiteral')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isLogicalExpression$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'LogicalExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isMemberExpression$8(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'MemberExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isNewExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'NewExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isProgram$5(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'Program')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isObjectExpression$9(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ObjectExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isObjectMethod$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ObjectMethod')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isObjectProperty$3(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ObjectProperty')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isRestElement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'RestElement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isReturnStatement$3(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ReturnStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isSequenceExpression$2(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'SequenceExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isParenthesizedExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ParenthesizedExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isSwitchCase(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'SwitchCase')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isSwitchStatement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'SwitchStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isThisExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ThisExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isThrowStatement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ThrowStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTryStatement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TryStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isUnaryExpression$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'UnaryExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isUpdateExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'UpdateExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isVariableDeclaration$5(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'VariableDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isVariableDeclarator$4(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'VariableDeclarator')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isWhileStatement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'WhileStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isWithStatement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'WithStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isAssignmentPattern$3(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'AssignmentPattern')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isArrayPattern(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ArrayPattern')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isArrowFunctionExpression$2(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ArrowFunctionExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isClassBody$2(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ClassBody')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isClassExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ClassExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isClassDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ClassDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isExportAllDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ExportAllDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isExportDefaultDeclaration$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ExportDefaultDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isExportNamedDeclaration$3(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ExportNamedDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isExportSpecifier$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ExportSpecifier')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isForOfStatement$2(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ForOfStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isImportDeclaration$2(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ImportDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isImportDefaultSpecifier$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ImportDefaultSpecifier')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isImportNamespaceSpecifier(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ImportNamespaceSpecifier')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isImportSpecifier(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ImportSpecifier')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isImportExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ImportExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isMetaProperty(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'MetaProperty')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isClassMethod$2(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ClassMethod')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isObjectPattern$3(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ObjectPattern')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isSpreadElement$3(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'SpreadElement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isSuper(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'Super')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTaggedTemplateExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TaggedTemplateExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTemplateElement$4(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TemplateElement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTemplateLiteral$4(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TemplateLiteral')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isYieldExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'YieldExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isAwaitExpression$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'AwaitExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isImport(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'Import')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isBigIntLiteral(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'BigIntLiteral')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isExportNamespaceSpecifier$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ExportNamespaceSpecifier')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isOptionalMemberExpression$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'OptionalMemberExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isOptionalCallExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'OptionalCallExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isClassProperty$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ClassProperty')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isClassAccessorProperty(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ClassAccessorProperty')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isClassPrivateProperty(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ClassPrivateProperty')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isClassPrivateMethod(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ClassPrivateMethod')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isPrivateName(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'PrivateName')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isStaticBlock(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'StaticBlock')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isImportAttribute(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ImportAttribute')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isAnyTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'AnyTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isArrayTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ArrayTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isBooleanTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'BooleanTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isBooleanLiteralTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'BooleanLiteralTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isNullLiteralTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'NullLiteralTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isClassImplements(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ClassImplements')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclareClass(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DeclareClass')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclareFunction(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DeclareFunction')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclareInterface(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DeclareInterface')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclareModule(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DeclareModule')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclareModuleExports(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DeclareModuleExports')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclareTypeAlias(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DeclareTypeAlias')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclareOpaqueType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DeclareOpaqueType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclareVariable(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DeclareVariable')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclareExportDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DeclareExportDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclareExportAllDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DeclareExportAllDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclaredPredicate(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DeclaredPredicate')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isExistsTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ExistsTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isFunctionTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'FunctionTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isFunctionTypeParam(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'FunctionTypeParam')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isGenericTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'GenericTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isInferredPredicate(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'InferredPredicate')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isInterfaceExtends(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'InterfaceExtends')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isInterfaceDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'InterfaceDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isInterfaceTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'InterfaceTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isIntersectionTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'IntersectionTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isMixedTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'MixedTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isEmptyTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'EmptyTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isNullableTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'NullableTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isNumberLiteralTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'NumberLiteralTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isNumberTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'NumberTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isObjectTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ObjectTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isObjectTypeInternalSlot(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ObjectTypeInternalSlot')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isObjectTypeCallProperty(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ObjectTypeCallProperty')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isObjectTypeIndexer(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ObjectTypeIndexer')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isObjectTypeProperty(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ObjectTypeProperty')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isObjectTypeSpreadProperty(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ObjectTypeSpreadProperty')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isOpaqueType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'OpaqueType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isQualifiedTypeIdentifier(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'QualifiedTypeIdentifier')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isStringLiteralTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'StringLiteralTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isStringTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'StringTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isSymbolTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'SymbolTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isThisTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ThisTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTupleTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TupleTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTypeofTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TypeofTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTypeAlias(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TypeAlias')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTypeCastExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TypeCastExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTypeParameter(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TypeParameter')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTypeParameterDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TypeParameterDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTypeParameterInstantiation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TypeParameterInstantiation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isUnionTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'UnionTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isVariance(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'Variance')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isVoidTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'VoidTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isEnumDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'EnumDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isEnumBooleanBody(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'EnumBooleanBody')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isEnumNumberBody(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'EnumNumberBody')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isEnumStringBody(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'EnumStringBody')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isEnumSymbolBody(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'EnumSymbolBody')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isEnumBooleanMember(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'EnumBooleanMember')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isEnumNumberMember(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'EnumNumberMember')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isEnumStringMember(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'EnumStringMember')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isEnumDefaultedMember(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'EnumDefaultedMember')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isIndexedAccessType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'IndexedAccessType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isOptionalIndexedAccessType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'OptionalIndexedAccessType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXAttribute$3(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXAttribute')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXClosingElement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXClosingElement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXElement$5(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXElement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXEmptyExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXEmptyExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXExpressionContainer(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXExpressionContainer')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXSpreadChild(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXSpreadChild')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXIdentifier$3(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXIdentifier')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXMemberExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXMemberExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXNamespacedName(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXNamespacedName')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXOpeningElement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXOpeningElement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXSpreadAttribute(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXSpreadAttribute')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXText$4(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXText')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXFragment(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXFragment')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXOpeningFragment(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXOpeningFragment')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXClosingFragment(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXClosingFragment')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isPlaceholder(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'Placeholder')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isV8IntrinsicIdentifier(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'V8IntrinsicIdentifier')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isArgumentPlaceholder(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ArgumentPlaceholder')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isBindExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'BindExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDecorator$2(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'Decorator')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDoExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DoExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isExportDefaultSpecifier(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ExportDefaultSpecifier')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isRecordExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'RecordExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTupleExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TupleExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isModuleExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ModuleExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTopicReference(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TopicReference')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isPipelineTopicExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'PipelineTopicExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isPipelineBareFunction(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'PipelineBareFunction')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isPipelinePrimaryTopicReference(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'PipelinePrimaryTopicReference')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isVoidPattern(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'VoidPattern')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSParameterProperty(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSParameterProperty')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSDeclareFunction(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSDeclareFunction')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSDeclareMethod(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSDeclareMethod')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSQualifiedName(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSQualifiedName')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSCallSignatureDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSCallSignatureDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSConstructSignatureDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSConstructSignatureDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSPropertySignature$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSPropertySignature')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSMethodSignature(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSMethodSignature')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSIndexSignature(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSIndexSignature')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSAnyKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSAnyKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSBooleanKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSBooleanKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSBigIntKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSBigIntKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSIntrinsicKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSIntrinsicKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSNeverKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSNeverKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSNullKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSNullKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSNumberKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSNumberKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSObjectKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSObjectKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSStringKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSStringKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSSymbolKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSSymbolKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSUndefinedKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSUndefinedKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSUnknownKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSUnknownKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSVoidKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSVoidKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSThisType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSThisType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSFunctionType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSFunctionType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSConstructorType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSConstructorType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypeReference$3(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTypeReference')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypePredicate(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTypePredicate')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypeQuery(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTypeQuery')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypeLiteral(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTypeLiteral')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSArrayType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSArrayType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTupleType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTupleType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSOptionalType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSOptionalType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSRestType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSRestType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSNamedTupleMember(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSNamedTupleMember')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSUnionType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSUnionType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSIntersectionType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSIntersectionType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSConditionalType$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSConditionalType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSInferType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSInferType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSParenthesizedType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSParenthesizedType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypeOperator(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTypeOperator')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSIndexedAccessType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSIndexedAccessType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSMappedType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSMappedType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTemplateLiteralType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTemplateLiteralType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSLiteralType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSLiteralType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSClassImplements(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSClassImplements')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSInterfaceHeritage(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSInterfaceHeritage')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSInterfaceDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSInterfaceDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSInterfaceBody(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSInterfaceBody')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypeAliasDeclaration$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTypeAliasDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSInstantiationExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSInstantiationExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSAsExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSAsExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSSatisfiesExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSSatisfiesExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypeAssertion(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTypeAssertion')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSEnumBody(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSEnumBody')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSEnumDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSEnumDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSEnumMember(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSEnumMember')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSModuleDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSModuleDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSModuleBlock$4(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSModuleBlock')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSImportType$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSImportType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSImportEqualsDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSImportEqualsDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSExternalModuleReference(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSExternalModuleReference')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSNonNullExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSNonNullExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSExportAssignment(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSExportAssignment')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSNamespaceExportDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSNamespaceExportDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypeParameterInstantiation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTypeParameterInstantiation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypeParameterDeclaration$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTypeParameterDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypeParameter$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTypeParameter')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isStandardized(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ArrayExpression':    
    case 'AssignmentExpression':    
    case 'BinaryExpression':    
    case 'InterpreterDirective':    
    case 'Directive':    
    case 'DirectiveLiteral':    
    case 'BlockStatement':    
    case 'BreakStatement':    
    case 'CallExpression':    
    case 'CatchClause':    
    case 'ConditionalExpression':    
    case 'ContinueStatement':    
    case 'DebuggerStatement':    
    case 'DoWhileStatement':    
    case 'EmptyStatement':    
    case 'ExpressionStatement':    
    case 'File':    
    case 'ForInStatement':    
    case 'ForStatement':    
    case 'FunctionDeclaration':    
    case 'FunctionExpression':    
    case 'Identifier':    
    case 'IfStatement':    
    case 'LabeledStatement':    
    case 'StringLiteral':    
    case 'NumericLiteral':    
    case 'NullLiteral':    
    case 'BooleanLiteral':    
    case 'RegExpLiteral':    
    case 'LogicalExpression':    
    case 'MemberExpression':    
    case 'NewExpression':    
    case 'Program':    
    case 'ObjectExpression':    
    case 'ObjectMethod':    
    case 'ObjectProperty':    
    case 'RestElement':    
    case 'ReturnStatement':    
    case 'SequenceExpression':    
    case 'ParenthesizedExpression':    
    case 'SwitchCase':    
    case 'SwitchStatement':    
    case 'ThisExpression':    
    case 'ThrowStatement':    
    case 'TryStatement':    
    case 'UnaryExpression':    
    case 'UpdateExpression':    
    case 'VariableDeclaration':    
    case 'VariableDeclarator':    
    case 'WhileStatement':    
    case 'WithStatement':    
    case 'AssignmentPattern':    
    case 'ArrayPattern':    
    case 'ArrowFunctionExpression':    
    case 'ClassBody':    
    case 'ClassExpression':    
    case 'ClassDeclaration':    
    case 'ExportAllDeclaration':    
    case 'ExportDefaultDeclaration':    
    case 'ExportNamedDeclaration':    
    case 'ExportSpecifier':    
    case 'ForOfStatement':    
    case 'ImportDeclaration':    
    case 'ImportDefaultSpecifier':    
    case 'ImportNamespaceSpecifier':    
    case 'ImportSpecifier':    
    case 'ImportExpression':    
    case 'MetaProperty':    
    case 'ClassMethod':    
    case 'ObjectPattern':    
    case 'SpreadElement':    
    case 'Super':    
    case 'TaggedTemplateExpression':    
    case 'TemplateElement':    
    case 'TemplateLiteral':    
    case 'YieldExpression':    
    case 'AwaitExpression':    
    case 'Import':    
    case 'BigIntLiteral':    
    case 'ExportNamespaceSpecifier':    
    case 'OptionalMemberExpression':    
    case 'OptionalCallExpression':    
    case 'ClassProperty':    
    case 'ClassAccessorProperty':    
    case 'ClassPrivateProperty':    
    case 'ClassPrivateMethod':    
    case 'PrivateName':    
    case 'StaticBlock':    
    case 'ImportAttribute':
        break;
    
    case 'Placeholder':
        switch(node.expectedNode) {
        case 'Identifier':        
        case 'StringLiteral':        
        case 'BlockStatement':        
        case 'ClassBody':
            break;
        
        default:
            return false;
        }
        
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isExpression$2(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ArrayExpression':    
    case 'AssignmentExpression':    
    case 'BinaryExpression':    
    case 'CallExpression':    
    case 'ConditionalExpression':    
    case 'FunctionExpression':    
    case 'Identifier':    
    case 'StringLiteral':    
    case 'NumericLiteral':    
    case 'NullLiteral':    
    case 'BooleanLiteral':    
    case 'RegExpLiteral':    
    case 'LogicalExpression':    
    case 'MemberExpression':    
    case 'NewExpression':    
    case 'ObjectExpression':    
    case 'SequenceExpression':    
    case 'ParenthesizedExpression':    
    case 'ThisExpression':    
    case 'UnaryExpression':    
    case 'UpdateExpression':    
    case 'ArrowFunctionExpression':    
    case 'ClassExpression':    
    case 'ImportExpression':    
    case 'MetaProperty':    
    case 'TaggedTemplateExpression':    
    case 'TemplateLiteral':    
    case 'YieldExpression':    
    case 'AwaitExpression':    
    case 'Import':    
    case 'BigIntLiteral':    
    case 'OptionalMemberExpression':    
    case 'OptionalCallExpression':    
    case 'TypeCastExpression':    
    case 'JSXElement':    
    case 'JSXFragment':    
    case 'BindExpression':    
    case 'DoExpression':    
    case 'RecordExpression':    
    case 'TupleExpression':    
    case 'ModuleExpression':    
    case 'TopicReference':    
    case 'PipelineTopicExpression':    
    case 'PipelineBareFunction':    
    case 'PipelinePrimaryTopicReference':    
    case 'TSInstantiationExpression':    
    case 'TSAsExpression':    
    case 'TSSatisfiesExpression':    
    case 'TSTypeAssertion':    
    case 'TSNonNullExpression':
        break;
    
    case 'Placeholder':
        switch(node.expectedNode) {
        case 'Expression':        
        case 'Identifier':        
        case 'StringLiteral':
            break;
        
        default:
            return false;
        }
        
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isBinary(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'BinaryExpression':    
    case 'LogicalExpression':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isScopable(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'BlockStatement':    
    case 'CatchClause':    
    case 'DoWhileStatement':    
    case 'ForInStatement':    
    case 'ForStatement':    
    case 'FunctionDeclaration':    
    case 'FunctionExpression':    
    case 'Program':    
    case 'ObjectMethod':    
    case 'SwitchStatement':    
    case 'WhileStatement':    
    case 'ArrowFunctionExpression':    
    case 'ClassExpression':    
    case 'ClassDeclaration':    
    case 'ForOfStatement':    
    case 'ClassMethod':    
    case 'ClassPrivateMethod':    
    case 'StaticBlock':    
    case 'TSModuleBlock':
        break;
    
    case 'Placeholder':
        if (node.expectedNode === 'BlockStatement')
            break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isBlockParent(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'BlockStatement':    
    case 'CatchClause':    
    case 'DoWhileStatement':    
    case 'ForInStatement':    
    case 'ForStatement':    
    case 'FunctionDeclaration':    
    case 'FunctionExpression':    
    case 'Program':    
    case 'ObjectMethod':    
    case 'SwitchStatement':    
    case 'WhileStatement':    
    case 'ArrowFunctionExpression':    
    case 'ForOfStatement':    
    case 'ClassMethod':    
    case 'ClassPrivateMethod':    
    case 'StaticBlock':    
    case 'TSModuleBlock':
        break;
    
    case 'Placeholder':
        if (node.expectedNode === 'BlockStatement')
            break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isBlock$1(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'BlockStatement':    
    case 'Program':    
    case 'TSModuleBlock':
        break;
    
    case 'Placeholder':
        if (node.expectedNode === 'BlockStatement')
            break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isStatement$7(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'BlockStatement':    
    case 'BreakStatement':    
    case 'ContinueStatement':    
    case 'DebuggerStatement':    
    case 'DoWhileStatement':    
    case 'EmptyStatement':    
    case 'ExpressionStatement':    
    case 'ForInStatement':    
    case 'ForStatement':    
    case 'FunctionDeclaration':    
    case 'IfStatement':    
    case 'LabeledStatement':    
    case 'ReturnStatement':    
    case 'SwitchStatement':    
    case 'ThrowStatement':    
    case 'TryStatement':    
    case 'VariableDeclaration':    
    case 'WhileStatement':    
    case 'WithStatement':    
    case 'ClassDeclaration':    
    case 'ExportAllDeclaration':    
    case 'ExportDefaultDeclaration':    
    case 'ExportNamedDeclaration':    
    case 'ForOfStatement':    
    case 'ImportDeclaration':    
    case 'DeclareClass':    
    case 'DeclareFunction':    
    case 'DeclareInterface':    
    case 'DeclareModule':    
    case 'DeclareModuleExports':    
    case 'DeclareTypeAlias':    
    case 'DeclareOpaqueType':    
    case 'DeclareVariable':    
    case 'DeclareExportDeclaration':    
    case 'DeclareExportAllDeclaration':    
    case 'InterfaceDeclaration':    
    case 'OpaqueType':    
    case 'TypeAlias':    
    case 'EnumDeclaration':    
    case 'TSDeclareFunction':    
    case 'TSInterfaceDeclaration':    
    case 'TSTypeAliasDeclaration':    
    case 'TSEnumDeclaration':    
    case 'TSModuleDeclaration':    
    case 'TSImportEqualsDeclaration':    
    case 'TSExportAssignment':    
    case 'TSNamespaceExportDeclaration':
        break;
    
    case 'Placeholder':
        switch(node.expectedNode) {
        case 'Statement':        
        case 'Declaration':        
        case 'BlockStatement':
            break;
        
        default:
            return false;
        }
        
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isTerminatorless(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'BreakStatement':    
    case 'ContinueStatement':    
    case 'ReturnStatement':    
    case 'ThrowStatement':    
    case 'YieldExpression':    
    case 'AwaitExpression':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isCompletionStatement(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'BreakStatement':    
    case 'ContinueStatement':    
    case 'ReturnStatement':    
    case 'ThrowStatement':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isConditional(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ConditionalExpression':    
    case 'IfStatement':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isLoop(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'DoWhileStatement':    
    case 'ForInStatement':    
    case 'ForStatement':    
    case 'WhileStatement':    
    case 'ForOfStatement':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isWhile(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'DoWhileStatement':    
    case 'WhileStatement':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isExpressionWrapper(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ExpressionStatement':    
    case 'ParenthesizedExpression':    
    case 'TypeCastExpression':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isFor(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ForInStatement':    
    case 'ForStatement':    
    case 'ForOfStatement':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isForXStatement(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ForInStatement':    
    case 'ForOfStatement':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isFunction$7(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'FunctionDeclaration':    
    case 'FunctionExpression':    
    case 'ObjectMethod':    
    case 'ArrowFunctionExpression':    
    case 'ClassMethod':    
    case 'ClassPrivateMethod':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isFunctionParent(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'FunctionDeclaration':    
    case 'FunctionExpression':    
    case 'ObjectMethod':    
    case 'ArrowFunctionExpression':    
    case 'ClassMethod':    
    case 'ClassPrivateMethod':    
    case 'StaticBlock':    
    case 'TSModuleBlock':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isPureish(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'FunctionDeclaration':    
    case 'FunctionExpression':    
    case 'StringLiteral':    
    case 'NumericLiteral':    
    case 'NullLiteral':    
    case 'BooleanLiteral':    
    case 'RegExpLiteral':    
    case 'ArrowFunctionExpression':    
    case 'BigIntLiteral':
        break;
    
    case 'Placeholder':
        if (node.expectedNode === 'StringLiteral')
            break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclaration(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'FunctionDeclaration':    
    case 'VariableDeclaration':    
    case 'ClassDeclaration':    
    case 'ExportAllDeclaration':    
    case 'ExportDefaultDeclaration':    
    case 'ExportNamedDeclaration':    
    case 'ImportDeclaration':    
    case 'DeclareClass':    
    case 'DeclareFunction':    
    case 'DeclareInterface':    
    case 'DeclareModule':    
    case 'DeclareModuleExports':    
    case 'DeclareTypeAlias':    
    case 'DeclareOpaqueType':    
    case 'DeclareVariable':    
    case 'DeclareExportDeclaration':    
    case 'DeclareExportAllDeclaration':    
    case 'InterfaceDeclaration':    
    case 'OpaqueType':    
    case 'TypeAlias':    
    case 'EnumDeclaration':    
    case 'TSDeclareFunction':    
    case 'TSInterfaceDeclaration':    
    case 'TSTypeAliasDeclaration':    
    case 'TSEnumDeclaration':    
    case 'TSModuleDeclaration':    
    case 'TSImportEqualsDeclaration':
        break;
    
    case 'Placeholder':
        if (node.expectedNode === 'Declaration')
            break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isFunctionParameter(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'Identifier':    
    case 'RestElement':    
    case 'AssignmentPattern':    
    case 'ArrayPattern':    
    case 'ObjectPattern':    
    case 'VoidPattern':
        break;
    
    case 'Placeholder':
        if (node.expectedNode === 'Identifier')
            break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isPatternLike(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'Identifier':    
    case 'MemberExpression':    
    case 'RestElement':    
    case 'AssignmentPattern':    
    case 'ArrayPattern':    
    case 'ObjectPattern':    
    case 'VoidPattern':    
    case 'TSAsExpression':    
    case 'TSSatisfiesExpression':    
    case 'TSTypeAssertion':    
    case 'TSNonNullExpression':
        break;
    
    case 'Placeholder':
        switch(node.expectedNode) {
        case 'Pattern':        
        case 'Identifier':
            break;
        
        default:
            return false;
        }
        
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isLVal(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'Identifier':    
    case 'MemberExpression':    
    case 'ArrayPattern':    
    case 'ObjectPattern':    
    case 'TSAsExpression':    
    case 'TSSatisfiesExpression':    
    case 'TSTypeAssertion':    
    case 'TSNonNullExpression':
        break;
    
    case 'Placeholder':
        switch(node.expectedNode) {
        case 'Pattern':        
        case 'Identifier':
            break;
        
        default:
            return false;
        }
        
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isTSEntityName(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'Identifier':    
    case 'ThisExpression':    
    case 'TSQualifiedName':
        break;
    
    case 'Placeholder':
        if (node.expectedNode === 'Identifier')
            break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isLiteral$4(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'StringLiteral':    
    case 'NumericLiteral':    
    case 'NullLiteral':    
    case 'BooleanLiteral':    
    case 'RegExpLiteral':    
    case 'TemplateLiteral':    
    case 'BigIntLiteral':
        break;
    
    case 'Placeholder':
        if (node.expectedNode === 'StringLiteral')
            break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isUserWhitespacable(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ObjectMethod':    
    case 'ObjectProperty':    
    case 'ObjectTypeInternalSlot':    
    case 'ObjectTypeCallProperty':    
    case 'ObjectTypeIndexer':    
    case 'ObjectTypeProperty':    
    case 'ObjectTypeSpreadProperty':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isMethod(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ObjectMethod':    
    case 'ClassMethod':    
    case 'ClassPrivateMethod':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isObjectMember(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ObjectMethod':    
    case 'ObjectProperty':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isProperty$1(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ObjectProperty':    
    case 'ClassProperty':    
    case 'ClassAccessorProperty':    
    case 'ClassPrivateProperty':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isUnaryLike(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'UnaryExpression':    
    case 'SpreadElement':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isPattern(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'AssignmentPattern':    
    case 'ArrayPattern':    
    case 'ObjectPattern':    
    case 'VoidPattern':
        break;
    
    case 'Placeholder':
        if (node.expectedNode === 'Pattern')
            break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isClass(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ClassExpression':    
    case 'ClassDeclaration':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isImportOrExportDeclaration(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ExportAllDeclaration':    
    case 'ExportDefaultDeclaration':    
    case 'ExportNamedDeclaration':    
    case 'ImportDeclaration':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isExportDeclaration$5(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ExportAllDeclaration':    
    case 'ExportDefaultDeclaration':    
    case 'ExportNamedDeclaration':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isModuleSpecifier(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ExportSpecifier':    
    case 'ImportDefaultSpecifier':    
    case 'ImportNamespaceSpecifier':    
    case 'ImportSpecifier':    
    case 'ExportNamespaceSpecifier':    
    case 'ExportDefaultSpecifier':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isAccessor(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ClassAccessorProperty':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isPrivate(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ClassPrivateProperty':    
    case 'ClassPrivateMethod':    
    case 'PrivateName':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isFlow() {}

function isFlowType() {}

function isFlowBaseAnnotation() {}

function isFlowDeclaration() {}

function isFlowPredicate() {}

function isEnumBody(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'EnumBooleanBody':    
    case 'EnumNumberBody':    
    case 'EnumStringBody':    
    case 'EnumSymbolBody':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isEnumMember(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'EnumBooleanMember':    
    case 'EnumNumberMember':    
    case 'EnumStringMember':    
    case 'EnumDefaultedMember':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isJSX(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'JSXAttribute':    
    case 'JSXClosingElement':    
    case 'JSXElement':    
    case 'JSXEmptyExpression':    
    case 'JSXExpressionContainer':    
    case 'JSXSpreadChild':    
    case 'JSXIdentifier':    
    case 'JSXMemberExpression':    
    case 'JSXNamespacedName':    
    case 'JSXOpeningElement':    
    case 'JSXSpreadAttribute':    
    case 'JSXText':    
    case 'JSXFragment':    
    case 'JSXOpeningFragment':    
    case 'JSXClosingFragment':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isMiscellaneous(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'Placeholder':    
    case 'V8IntrinsicIdentifier':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isTypeScript(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'TSParameterProperty':    
    case 'TSDeclareFunction':    
    case 'TSDeclareMethod':    
    case 'TSQualifiedName':    
    case 'TSCallSignatureDeclaration':    
    case 'TSConstructSignatureDeclaration':    
    case 'TSPropertySignature':    
    case 'TSMethodSignature':    
    case 'TSIndexSignature':    
    case 'TSAnyKeyword':    
    case 'TSBooleanKeyword':    
    case 'TSBigIntKeyword':    
    case 'TSIntrinsicKeyword':    
    case 'TSNeverKeyword':    
    case 'TSNullKeyword':    
    case 'TSNumberKeyword':    
    case 'TSObjectKeyword':    
    case 'TSStringKeyword':    
    case 'TSSymbolKeyword':    
    case 'TSUndefinedKeyword':    
    case 'TSUnknownKeyword':    
    case 'TSVoidKeyword':    
    case 'TSThisType':    
    case 'TSFunctionType':    
    case 'TSConstructorType':    
    case 'TSTypeReference':    
    case 'TSTypePredicate':    
    case 'TSTypeQuery':    
    case 'TSTypeLiteral':    
    case 'TSArrayType':    
    case 'TSTupleType':    
    case 'TSOptionalType':    
    case 'TSRestType':    
    case 'TSNamedTupleMember':    
    case 'TSUnionType':    
    case 'TSIntersectionType':    
    case 'TSConditionalType':    
    case 'TSInferType':    
    case 'TSParenthesizedType':    
    case 'TSTypeOperator':    
    case 'TSIndexedAccessType':    
    case 'TSMappedType':    
    case 'TSTemplateLiteralType':    
    case 'TSLiteralType':    
    case 'TSClassImplements':    
    case 'TSInterfaceHeritage':    
    case 'TSInterfaceDeclaration':    
    case 'TSInterfaceBody':    
    case 'TSTypeAliasDeclaration':    
    case 'TSInstantiationExpression':    
    case 'TSAsExpression':    
    case 'TSSatisfiesExpression':    
    case 'TSTypeAssertion':    
    case 'TSEnumBody':    
    case 'TSEnumDeclaration':    
    case 'TSEnumMember':    
    case 'TSModuleDeclaration':    
    case 'TSModuleBlock':    
    case 'TSImportType':    
    case 'TSImportEqualsDeclaration':    
    case 'TSExternalModuleReference':    
    case 'TSNonNullExpression':    
    case 'TSExportAssignment':    
    case 'TSNamespaceExportDeclaration':    
    case 'TSTypeAnnotation':    
    case 'TSTypeParameterInstantiation':    
    case 'TSTypeParameterDeclaration':    
    case 'TSTypeParameter':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypeElement(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'TSCallSignatureDeclaration':    
    case 'TSConstructSignatureDeclaration':    
    case 'TSPropertySignature':    
    case 'TSMethodSignature':    
    case 'TSIndexSignature':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isTSType(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'TSAnyKeyword':    
    case 'TSBooleanKeyword':    
    case 'TSBigIntKeyword':    
    case 'TSIntrinsicKeyword':    
    case 'TSNeverKeyword':    
    case 'TSNullKeyword':    
    case 'TSNumberKeyword':    
    case 'TSObjectKeyword':    
    case 'TSStringKeyword':    
    case 'TSSymbolKeyword':    
    case 'TSUndefinedKeyword':    
    case 'TSUnknownKeyword':    
    case 'TSVoidKeyword':    
    case 'TSThisType':    
    case 'TSFunctionType':    
    case 'TSConstructorType':    
    case 'TSTypeReference':    
    case 'TSTypePredicate':    
    case 'TSTypeQuery':    
    case 'TSTypeLiteral':    
    case 'TSArrayType':    
    case 'TSTupleType':    
    case 'TSOptionalType':    
    case 'TSRestType':    
    case 'TSUnionType':    
    case 'TSIntersectionType':    
    case 'TSConditionalType':    
    case 'TSInferType':    
    case 'TSParenthesizedType':    
    case 'TSTypeOperator':    
    case 'TSIndexedAccessType':    
    case 'TSMappedType':    
    case 'TSTemplateLiteralType':    
    case 'TSLiteralType':    
    case 'TSClassImplements':    
    case 'TSInterfaceHeritage':    
    case 'TSImportType':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isTSBaseType(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'TSAnyKeyword':    
    case 'TSBooleanKeyword':    
    case 'TSBigIntKeyword':    
    case 'TSIntrinsicKeyword':    
    case 'TSNeverKeyword':    
    case 'TSNullKeyword':    
    case 'TSNumberKeyword':    
    case 'TSObjectKeyword':    
    case 'TSStringKeyword':    
    case 'TSSymbolKeyword':    
    case 'TSUndefinedKeyword':    
    case 'TSUnknownKeyword':    
    case 'TSVoidKeyword':    
    case 'TSThisType':    
    case 'TSTemplateLiteralType':    
    case 'TSLiteralType':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isNumberLiteral(node, opts) {
    deprecationWarning('isNumberLiteral', 'isNumericLiteral');
    
    if (!node)
        return false;
    
    if (node.type !== 'NumberLiteral')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isRegexLiteral(node, opts) {
    deprecationWarning('isRegexLiteral', 'isRegExpLiteral');
    
    if (!node)
        return false;
    
    if (node.type !== 'RegexLiteral')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isRestProperty(node, opts) {
    deprecationWarning('isRestProperty', 'isRestElement');
    
    if (!node)
        return false;
    
    if (node.type !== 'RestProperty')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isSpreadProperty(node, opts) {
    deprecationWarning('isSpreadProperty', 'isSpreadElement');
    
    if (!node)
        return false;
    
    if (node.type !== 'SpreadProperty')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isModuleDeclaration(node, opts) {
    deprecationWarning('isModuleDeclaration', 'isImportOrExportDeclaration');
    return isImportOrExportDeclaration(node, opts);
}

function isMemberExpressionLike(node) {
    return isMemberExpression$8(node) || isMetaProperty(node);
}

function matchesPattern$1(member, match, allowPartial) {
    if (!isMemberExpressionLike(member))
        return false;
    
    const parts = Array.isArray(match) ? match : match.split('.');
    const nodes2 = [];
    let node;
    
    for (node = member; isMemberExpressionLike(node); node = node.object ?? node.meta) {
        nodes2.push(node.property);
    }
    
    nodes2.push(node);
    
    if (nodes2.length < parts.length)
        return false;
    
    if (!allowPartial && nodes2.length > parts.length)
        return false;
    
    for (let i = 0, j = nodes2.length - 1; i < parts.length; (i++, j--)) {
        const node2 = nodes2[j];
        let value;
        
        if (isIdentifier$g(node2)) {
            value = node2.name;
        } else if (isStringLiteral$a(node2)) {
            value = node2.value;
        } else if (isThisExpression(node2)) {
            value = 'this';
        } else if (isSuper(node2)) {
            value = 'super';
        } else if (isPrivateName(node2)) {
            value = '#' + node2.id.name;
        } else {
            return false;
        }


        
        if (parts[i] !== value)
            return false;
    }
    
    return true;
}

function buildMatchMemberExpression(match, allowPartial) {
    const parts = match.split('.');
    return (member) => matchesPattern$1(member, parts, allowPartial);
}

var isReactComponent = buildMatchMemberExpression('React.Component');

function isCompatTag(tagName) {
    return !!tagName && /^[a-z]/.test(tagName);
}

function isType(nodeType, targetType) {
    if (nodeType === targetType)
        return true;
    
    if (nodeType == null)
        return false;
    
    if (ALIAS_KEYS[targetType])
        return false;
    
    const aliases = FLIPPED_ALIAS_KEYS[targetType];
    
    if (aliases?.includes(nodeType))
        return true;
    
    return false;
}

function isPlaceholderType(placeholderType, targetType) {
    if (placeholderType === targetType)
        return true;
    
    const aliases = PLACEHOLDERS_ALIAS[placeholderType];
    
    if (aliases?.includes(targetType))
        return true;
    
    return false;
}

function is$4(type, node, opts) {
    if (!node)
        return false;
    
    const matches = isType(node.type, type);
    
    if (!matches) {
        if (!opts && node.type === 'Placeholder' && type in FLIPPED_ALIAS_KEYS) {
            return isPlaceholderType(node.expectedNode, type);
        }
        
        return false;
    }
    
    if (opts === void 0) {
        return true;
    } else {
        return shallowEqual(node, opts);
    }
}

function isValidIdentifier(name, reserved = true) {
    if (typeof name !== 'string')
        return false;
    
    if (reserved) {
        if (isKeyword(name) || isStrictReservedWord(name, true)) {
            return false;
        }
    }
    
    return isIdentifierName(name);
}

var STATEMENT_OR_BLOCK_KEYS = [
    'consequent',
    'body',
    'alternate',
];
var FLATTENABLE_KEYS = ['body', 'expressions'];
var FOR_INIT_KEYS = [
    'left',
    'init',
];
var COMMENT_KEYS = [
    'leadingComments',
    'trailingComments',
    'innerComments',
];
var LOGICAL_OPERATORS = [
    '||',
    '&&',
    '??',
];
var UPDATE_OPERATORS = [
    '++',
    '--',
];
var BOOLEAN_NUMBER_BINARY_OPERATORS = [
    '>',
    '<',
    '>=',
    '<=',
];
var EQUALITY_BINARY_OPERATORS = [
    '==',
    '===',
    '!=',
    '!==',
];
var COMPARISON_BINARY_OPERATORS = [
    ...EQUALITY_BINARY_OPERATORS,
    'in',
    'instanceof',
];
var BOOLEAN_BINARY_OPERATORS = [
    ...COMPARISON_BINARY_OPERATORS,
    ...BOOLEAN_NUMBER_BINARY_OPERATORS,
];
var NUMBER_BINARY_OPERATORS = [
    '-',
    '/',
    '%',
    '*',
    '**',
    '&',
    '|',
    '>>',
    '>>>',
    '<<',
    '^',
];
var BINARY_OPERATORS = [
    '+',
    ...NUMBER_BINARY_OPERATORS,
    ...BOOLEAN_BINARY_OPERATORS,
    '|>',
];
var ASSIGNMENT_OPERATORS = [
    '=',
    '+=',
    ...NUMBER_BINARY_OPERATORS.map((op) => op + '='),
    ...LOGICAL_OPERATORS.map((op) => op + '='),
];
var BOOLEAN_UNARY_OPERATORS = [
    'delete',
    '!',
];
var NUMBER_UNARY_OPERATORS = [
    '+',
    '-',
    '~',
];
var STRING_UNARY_OPERATORS = ['typeof'];
var UNARY_OPERATORS = [
    'void',
    'throw',
    ...BOOLEAN_UNARY_OPERATORS,
    ...NUMBER_UNARY_OPERATORS,
    ...STRING_UNARY_OPERATORS,
];

var INHERIT_KEYS = {
    optional: [
        'typeAnnotation',
        'typeParameters',
        'returnType',
    ],
    force: [
        'start',
        'loc',
        'end',
    ],
};

var VISITOR_KEYS = {};
var ALIAS_KEYS = {};
var FLIPPED_ALIAS_KEYS = {};
var NODE_FIELDS$1 = {};
var BUILDER_KEYS = {};
var DEPRECATED_KEYS = {};
var NODE_PARENT_VALIDATIONS = {};

function getType$1(val) {
    if (Array.isArray(val)) {
        return 'array';
    } else if (val === null) {
        return 'null';
    } else {
        return typeof val;
    }
}

function validate$2$1(validate4) {
    return {
        validate: validate4,
    };
}

function validateType(...typeNames) {
    return validate$2$1(assertNodeType(...typeNames));
}

function validateOptional(validate4) {
    return {
        validate: validate4,
        optional: true,
    };
}

function validateOptionalType(...typeNames) {
    return {
        validate: assertNodeType(...typeNames),
        optional: true,
    };
}

function arrayOf(elementType) {
    return chain$4(assertValueType('array'), assertEach(elementType));
}

function arrayOfType(...typeNames) {
    return arrayOf(assertNodeType(...typeNames));
}

function validateArrayOfType(...typeNames) {
    return validate$2$1(arrayOfType(...typeNames));
}

function assertEach(callback) {
    const childValidator = validateChild;
    
    function validator(node, key, val) {
        if (!Array.isArray(val))
            return;
        
        let i = 0;
        const subKey = {
            toString() {
                return `${key}[${i}]`;
            },
        };
        
        for (; i < val.length; i++) {
            const v = val[i];
            callback(node, subKey, v);
            childValidator(node, subKey, v);
        }
    }
    
    validator.each = callback;
    return validator;
}

function assertOneOf(...values) {
    function validate4(node, key, val) {
        if (!values.includes(val)) {
            throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
        }
    }
    
    validate4.oneOf = values;
    return validate4;
}

var allExpandedTypes = [];

function assertNodeType(...types2) {
    const expandedTypes =     /* @__PURE__ */new Set();
    
    allExpandedTypes.push({
        types: types2,
        set: expandedTypes,
    });
    function validate4(node, key, val) {
        const valType = val?.type;
        
        if (valType != null) {
            if (expandedTypes.has(valType)) {
                validateChild(node, key, val);
                return;
            }
            
            if (valType === 'Placeholder') {
                for (const type of types2) {
                    if (is$4(type, val)) {
                        validateChild(node, key, val);
                        return;
                    }
                }
            }
        }
        
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types2)} but instead got ${JSON.stringify(valType)}`);
    }
    
    validate4.oneOfNodeTypes = types2;
    
    return validate4;
}

function assertNodeOrValueType(...types2) {
    function validate4(node, key, val) {
        const primitiveType = getType$1(val);
        
        for (const type of types2) {
            if (primitiveType === type || is$4(type, val)) {
                validateChild(node, key, val);
                return;
            }
        }
        
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types2)} but instead got ${JSON.stringify(val?.type)}`);
    }
    
    validate4.oneOfNodeOrValueTypes = types2;
    
    return validate4;
}

function assertValueType(type) {
    function validate4(node, key, val) {
        if (getType$1(val) === type) {
            return;
        }
        
        throw new TypeError(`Property ${key} expected type of ${type} but got ${getType$1(val)}`);
    }
    
    validate4.type = type;
    
    return validate4;
}

function assertShape(shape) {
    const keys2 = Object.keys(shape);
    
    function validate4(node, key, val) {
        const errors = [];
        
        for (const property of keys2) {
            try {
                validateField(node, property, val[property], shape[property]);
            } catch(error) {
                if (error instanceof TypeError) {
                    errors.push(error.message);
                    continue;
                }
                
                throw error;
            }
        }
        
        if (errors.length) {
            throw new TypeError(`Property ${key} of ${node.type} expected to have the following:
${errors.join('\n')}`);
        }
    }
    
    validate4.shapeOf = shape;
    
    return validate4;
}

function assertOptionalChainStart() {
    function validate4(node) {
        let current = node;
        
        while (node) {
            const {type} = current;
            
            if (type === 'OptionalCallExpression') {
                if (current.optional)
                    return;
                
                current = current.callee;
                continue;
            }
            
            if (type === 'OptionalMemberExpression') {
                if (current.optional)
                    return;
                
                current = current.object;
                continue;
            }
            
            break;
        }
        
        throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${current?.type}`);
    }
    
    return validate4;
}

function chain$4(...fns) {
    function validate4(...args) {
        for (const fn of fns) {
            fn(...args);
        }
    }
    
    validate4.chainOf = fns;
    
    if (fns.length >= 2 && 'type' in fns[0] && fns[0].type === 'array' && !('each' in fns[1])) {
        throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
    }
    
    return validate4;
}

var validTypeOpts = /* @__PURE__ */new Set([
    'aliases',
    'builder',
    'deprecatedAlias',
    'fields',
    'inherits',
    'visitor',
    'validate',
]);
var validFieldKeys = /* @__PURE__ */new Set([
    'default',
    'optional',
    'deprecated',
    'validate',
]);
var store$1 = {};

function defineAliasedType(...aliases) {
    return (type, opts = {}) => {
        let defined = opts.aliases;
        
        if (!defined) {
            if (opts.inherits)
                defined = store$1[opts.inherits].aliases?.slice();
            
            defined ?? (defined = []);
            opts.aliases = defined;
        }
        
        const additional = aliases.filter((a) => !defined.includes(a));
        defined.unshift(...additional);
        defineType$5(type, opts);
    };
}

function defineType$5(type, opts = {}) {
    const inherits3 = opts.inherits && store$1[opts.inherits] || {};
    let fields = opts.fields;
    
    if (!fields) {
        fields = {};
        
        if (inherits3.fields) {
            const keys2 = Object.getOwnPropertyNames(inherits3.fields);
            
            for (const key of keys2) {
                const field = inherits3.fields[key];
                const def = field.default;
                
                if (Array.isArray(def) ? def.length > 0 : def && typeof def === 'object') {
                    throw new Error('field defaults can only be primitives or empty arrays currently');
                }
                
                fields[key] = {
                    default: Array.isArray(def) ? [] : def,
                    optional: field.optional,
                    deprecated: field.deprecated,
                    validate: field.validate,
                };
            }
        }
    }
    
    const visitor = opts.visitor || inherits3.visitor || [];
    const aliases = opts.aliases || inherits3.aliases || [];
    const builder = opts.builder
        || inherits3.builder
        || opts.visitor
        || [];
    
    for (const k of Object.keys(opts)) {
        if (!validTypeOpts.has(k)) {
            throw new Error(`Unknown type option "${k}" on ${type}`);
        }
    }
    
    if (opts.deprecatedAlias) {
        DEPRECATED_KEYS[opts.deprecatedAlias] = type;
    }
    
    for (const key of visitor.concat(builder)) {
        fields[key] = fields[key] || {};
    }
    
    for (const key of Object.keys(fields)) {
        const field = fields[key];
        
        if (field.default !== void 0 && !builder.includes(key)) {
            field.optional = true;
        }
        
        if (field.default === void 0) {
            field.default = null;
        } else if (!field.validate && field.default != null) {
            field.validate = assertValueType(getType$1(field.default));
        }
        
        for (const k of Object.keys(field)) {
            if (!validFieldKeys.has(k)) {
                throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
            }
        }
    }
    
    VISITOR_KEYS[type] =
    opts.visitor = visitor;
    BUILDER_KEYS[type] =
    opts.builder = builder;
    NODE_FIELDS$1[type] =
    opts.fields = fields;
    ALIAS_KEYS[type] =
    opts.aliases = aliases;
    aliases.forEach((alias2) => {
        FLIPPED_ALIAS_KEYS[alias2] = FLIPPED_ALIAS_KEYS[alias2] || [];
        FLIPPED_ALIAS_KEYS[alias2].push(type);
    });
    
    if (opts.validate) {
        NODE_PARENT_VALIDATIONS[type] = opts.validate;
    }
    
    store$1[type] = opts;
}

var utils$1 = /* @__PURE__ */Object.freeze({
    __proto__: null,
    ALIAS_KEYS,
    BUILDER_KEYS,
    DEPRECATED_KEYS,
    FLIPPED_ALIAS_KEYS,
    NODE_FIELDS: NODE_FIELDS$1,
    NODE_PARENT_VALIDATIONS,
    VISITOR_KEYS,
    allExpandedTypes,
    arrayOf,
    arrayOfType,
    assertEach,
    assertNodeOrValueType,
    assertNodeType,
    assertOneOf,
    assertOptionalChainStart,
    assertShape,
    assertValueType,
    chain: chain$4,
    default: defineType$5,
    defineAliasedType,
    validate: validate$2$1,
    validateArrayOfType,
    validateOptional,
    validateOptionalType,
    validateType,
});

var defineType$4 = defineAliasedType('Standardized');

defineType$4('ArrayExpression', {
    fields: {
        elements: {
            validate: arrayOf(assertNodeOrValueType('null', 'Expression', 'SpreadElement')),
            default: void 0,
        },
    },
    visitor: ['elements'],
    aliases: ['Expression'],
});
defineType$4('AssignmentExpression', {
    fields: {
        operator: {
            validate: Object.assign((function() {
                const identifier4 = assertOneOf(...ASSIGNMENT_OPERATORS);
                const pattern = assertOneOf('=');
                
                return function(node, key, val) {
                    const validator = is$4('Pattern', node.left) ? pattern : identifier4;
                    validator(node, key, val);
                };
            })(), {
                oneOf: ASSIGNMENT_OPERATORS,
            }),
        },
        left: {
            validate: assertNodeType('Identifier', 'MemberExpression', 'OptionalMemberExpression', 'ArrayPattern', 'ObjectPattern', 'TSAsExpression', 'TSSatisfiesExpression', 'TSTypeAssertion', 'TSNonNullExpression'),
        },
        right: {
            validate: assertNodeType('Expression'),
        },
    },
    builder: [
        'operator',
        'left',
        'right',
    ],
    visitor: ['left', 'right'],
    aliases: ['Expression'],
});
defineType$4('BinaryExpression', {
    builder: [
        'operator',
        'left',
        'right',
    ],
    fields: {
        operator: {
            validate: assertOneOf(...BINARY_OPERATORS),
        },
        left: {
            validate: (function() {
                const expression2 = assertNodeType('Expression');
                const inOp = assertNodeType('Expression', 'PrivateName');
                const validator = Object.assign(function(node, key, val) {
                    const validator2 = node.operator === 'in' ? inOp : expression2;
                    validator2(node, key, val);
                }, {
                    oneOfNodeTypes: ['Expression', 'PrivateName'],
                });
                
                return validator;
            })(),
        },
        right: {
            validate: assertNodeType('Expression'),
        },
    },
    visitor: ['left', 'right'],
    aliases: ['Binary', 'Expression'],
});
defineType$4('InterpreterDirective', {
    builder: ['value'],
    fields: {
        value: {
            validate: assertValueType('string'),
        },
    },
});
defineType$4('Directive', {
    visitor: ['value'],
    fields: {
        value: {
            validate: assertNodeType('DirectiveLiteral'),
        },
    },
});
defineType$4('DirectiveLiteral', {
    builder: ['value'],
    fields: {
        value: {
            validate: assertValueType('string'),
        },
    },
});
defineType$4('BlockStatement', {
    builder: ['body', 'directives'],
    visitor: ['directives', 'body'],
    fields: {
        directives: {
            validate: arrayOfType('Directive'),
            default: [],
        },
        body: validateArrayOfType('Statement'),
    },
    aliases: [
        'Scopable',
        'BlockParent',
        'Block',
        'Statement',
    ],
});
defineType$4('BreakStatement', {
    visitor: ['label'],
    fields: {
        label: {
            validate: assertNodeType('Identifier'),
            optional: true,
        },
    },
    aliases: [
        'Statement',
        'Terminatorless',
        'CompletionStatement',
    ],
});
defineType$4('CallExpression', {
    visitor: [
        'callee',
        'typeArguments',
        'arguments',
    ],
    builder: ['callee', 'arguments'],
    aliases: ['Expression'],
    fields: Object.assign({
        callee: {
            validate: assertNodeType('Expression', 'Super', 'V8IntrinsicIdentifier'),
        },
        arguments: validateArrayOfType('Expression', 'SpreadElement', 'ArgumentPlaceholder'),
        typeArguments: {
            validate: assertNodeType('TypeParameterInstantiation', 'TSTypeParameterInstantiation'),
            optional: true,
        },
    }, {}),
});
defineType$4('CatchClause', {
    visitor: ['param', 'body'],
    fields: {
        param: {
            validate: assertNodeType('Identifier', 'ArrayPattern', 'ObjectPattern'),
            optional: true,
        },
        body: {
            validate: assertNodeType('BlockStatement'),
        },
    },
    aliases: ['Scopable', 'BlockParent'],
});
defineType$4('ConditionalExpression', {
    visitor: [
        'test',
        'consequent',
        'alternate',
    ],
    fields: {
        test: {
            validate: assertNodeType('Expression'),
        },
        consequent: {
            validate: assertNodeType('Expression'),
        },
        alternate: {
            validate: assertNodeType('Expression'),
        },
    },
    aliases: ['Expression', 'Conditional'],
});
defineType$4('ContinueStatement', {
    visitor: ['label'],
    fields: {
        label: {
            validate: assertNodeType('Identifier'),
            optional: true,
        },
    },
    aliases: [
        'Statement',
        'Terminatorless',
        'CompletionStatement',
    ],
});
defineType$4('DebuggerStatement', {
    aliases: ['Statement'],
});
defineType$4('DoWhileStatement', {
    builder: ['test', 'body'],
    visitor: ['body', 'test'],
    fields: {
        test: {
            validate: assertNodeType('Expression'),
        },
        body: {
            validate: assertNodeType('Statement'),
        },
    },
    aliases: [
        'Statement',
        'BlockParent',
        'Loop',
        'While',
        'Scopable',
    ],
});
defineType$4('EmptyStatement', {
    aliases: ['Statement'],
});
defineType$4('ExpressionStatement', {
    visitor: ['expression'],
    fields: {
        expression: {
            validate: assertNodeType('Expression'),
        },
    },
    aliases: ['Statement', 'ExpressionWrapper'],
});
defineType$4('File', {
    builder: [
        'program',
        'comments',
        'tokens',
    ],
    visitor: ['program'],
    fields: {
        program: {
            validate: assertNodeType('Program'),
        },
        comments: {
            validate: assertEach(assertNodeType('CommentBlock', 'CommentLine')),
            optional: true,
        },
        tokens: {
            validate: assertEach(Object.assign(() => {}, {
                type: 'any',
            })),
            optional: true,
        },
    },
});
defineType$4('ForInStatement', {
    visitor: [
        'left',
        'right',
        'body',
    ],
    aliases: [
        'Scopable',
        'Statement',
        'For',
        'BlockParent',
        'Loop',
        'ForXStatement',
    ],
    fields: {
        left: {
            validate: assertNodeType('VariableDeclaration', 'Identifier', 'MemberExpression', 'ArrayPattern', 'ObjectPattern', 'TSAsExpression', 'TSSatisfiesExpression', 'TSTypeAssertion', 'TSNonNullExpression'),
        },
        right: {
            validate: assertNodeType('Expression'),
        },
        body: {
            validate: assertNodeType('Statement'),
        },
    },
});
defineType$4('ForStatement', {
    visitor: [
        'init',
        'test',
        'update',
        'body',
    ],
    aliases: [
        'Scopable',
        'Statement',
        'For',
        'BlockParent',
        'Loop',
    ],
    fields: {
        init: {
            validate: assertNodeType('VariableDeclaration', 'Expression'),
            optional: true,
        },
        test: {
            validate: assertNodeType('Expression'),
            optional: true,
        },
        update: {
            validate: assertNodeType('Expression'),
            optional: true,
        },
        body: {
            validate: assertNodeType('Statement'),
        },
    },
});
var functionCommon = () => ({
    params: validateArrayOfType('FunctionParameter'),
    generator: {
        default: false,
    },
    async: {
        default: false,
    },
});

var functionTypeAnnotationCommon = () => ({
    returnType: {
        validate: assertNodeType('TypeAnnotation', 'TSTypeAnnotation'),
        optional: true,
    },
    typeParameters: {
        validate: assertNodeType('TypeParameterDeclaration', 'TSTypeParameterDeclaration'),
        optional: true,
    },
});

var functionDeclarationCommon = () => Object.assign({}, functionCommon(), {
    declare: {
        validate: assertValueType('boolean'),
        optional: true,
    },
    id: {
        validate: assertNodeType('Identifier'),
        optional: true,
    },
});

defineType$4('FunctionDeclaration', {
    builder: [
        'id',
        'params',
        'body',
        'generator',
        'async',
    ],
    visitor: [
        'id',
        'typeParameters',
        'params',
        'predicate',
        'returnType',
        'body',
    ],
    fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
        body: {
            validate: assertNodeType('BlockStatement'),
        },
        predicate: {
            validate: assertNodeType('DeclaredPredicate', 'InferredPredicate'),
            optional: true,
        },
    }),
    aliases: [
        'Scopable',
        'Function',
        'BlockParent',
        'FunctionParent',
        'Statement',
        'Pureish',
        'Declaration',
    ],
    validate: (function() {
        const identifier4 = assertNodeType('Identifier');
        
        return function(parent, key, node) {
            if (!is$4('ExportDefaultDeclaration', parent)) {
                identifier4(node, 'id', node.id);
            }
        };
    })(),
});
defineType$4('FunctionExpression', {
    inherits: 'FunctionDeclaration',
    aliases: [
        'Scopable',
        'Function',
        'BlockParent',
        'FunctionParent',
        'Expression',
        'Pureish',
    ],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        id: {
            validate: assertNodeType('Identifier'),
            optional: true,
        },
        body: {
            validate: assertNodeType('BlockStatement'),
        },
        predicate: {
            validate: assertNodeType('DeclaredPredicate', 'InferredPredicate'),
            optional: true,
        },
    }),
});
var patternLikeCommon = () => ({
    typeAnnotation: {
        validate: assertNodeType('TypeAnnotation', 'TSTypeAnnotation'),
        optional: true,
    },
    optional: {
        validate: assertValueType('boolean'),
        optional: true,
    },
    decorators: {
        validate: arrayOfType('Decorator'),
        optional: true,
    },
});

defineType$4('Identifier', {
    builder: ['name'],
    visitor: ['typeAnnotation', 'decorators'],
    aliases: [
        'Expression',
        'FunctionParameter',
        'PatternLike',
        'LVal',
        'TSEntityName',
    ],
    fields: Object.assign({}, patternLikeCommon(), {
        name: {
            validate: chain$4(assertValueType('string'), Object.assign(function(node, key, val) {
                if (!isValidIdentifier(val, false)) {
                    throw new TypeError(`"${val}" is not a valid identifier name`);
                }
            }, {
                type: 'string',
            })),
        },
    }),
    validate: function(parent, key, node) {
        const match = /\.(\w+)$/.exec(key.toString());
        
        if (!match)
            return;
        
        const [, parentKey] = match;
        
        const nonComp = {
            computed: false,
        };
        
        if (parentKey === 'property') {
            if (is$4('MemberExpression', parent, nonComp))
                return;
            
            if (is$4('OptionalMemberExpression', parent, nonComp))
                return;
        } else if (parentKey === 'key') {
            if (is$4('Property', parent, nonComp))
                return;
            
            if (is$4('Method', parent, nonComp))
                return;
        } else if (parentKey === 'exported') {
            if (is$4('ExportSpecifier', parent))
                return;
        } else if (parentKey === 'imported') {
            if (is$4('ImportSpecifier', parent, {imported: node}))
                return;
        } else if (parentKey === 'meta') {
            if (is$4('MetaProperty', parent, {meta: node}))
                return;
        }


        
        if ((isKeyword(node.name) || isReservedWord(node.name, false)) && node.name !== 'this') {
            throw new TypeError(`"${node.name}" is not a valid identifier`);
        }
    },
});
defineType$4('IfStatement', {
    visitor: [
        'test',
        'consequent',
        'alternate',
    ],
    aliases: ['Statement', 'Conditional'],
    fields: {
        test: {
            validate: assertNodeType('Expression'),
        },
        consequent: {
            validate: assertNodeType('Statement'),
        },
        alternate: {
            optional: true,
            validate: assertNodeType('Statement'),
        },
    },
});
defineType$4('LabeledStatement', {
    visitor: ['label', 'body'],
    aliases: ['Statement'],
    fields: {
        label: {
            validate: assertNodeType('Identifier'),
        },
        body: {
            validate: assertNodeType('Statement'),
        },
    },
});
defineType$4('StringLiteral', {
    builder: ['value'],
    fields: {
        value: {
            validate: assertValueType('string'),
        },
    },
    aliases: [
        'Expression',
        'Pureish',
        'Literal',
        'Immutable',
    ],
});
defineType$4('NumericLiteral', {
    builder: ['value'],
    deprecatedAlias: 'NumberLiteral',
    fields: {
        value: {
            validate: chain$4(assertValueType('number'), Object.assign(function(node, key, val) {
                if (1 / val < 0 || !Number.isFinite(val)) {
                    const error = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${val}) instead.`);
                    
                    {
                        {
                            if (!new Error().stack.includes('regenerator')) {
                                throw error;
                            }
                        }
                    }
                }
            }, {
                type: 'number',
            })),
        },
    },
    aliases: [
        'Expression',
        'Pureish',
        'Literal',
        'Immutable',
    ],
});
defineType$4('NullLiteral', {
    aliases: [
        'Expression',
        'Pureish',
        'Literal',
        'Immutable',
    ],
});
defineType$4('BooleanLiteral', {
    builder: ['value'],
    fields: {
        value: {
            validate: assertValueType('boolean'),
        },
    },
    aliases: [
        'Expression',
        'Pureish',
        'Literal',
        'Immutable',
    ],
});
defineType$4('RegExpLiteral', {
    builder: ['pattern', 'flags'],
    deprecatedAlias: 'RegexLiteral',
    aliases: [
        'Expression',
        'Pureish',
        'Literal',
    ],
    fields: {
        pattern: {
            validate: assertValueType('string'),
        },
        flags: {
            validate: chain$4(assertValueType('string'), Object.assign(function(node, key, val) {
                const invalid = /[^dgimsuvy]/.exec(val);
                
                if (invalid) {
                    throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
                }
            }, {
                type: 'string',
            })),
            default: '',
        },
    },
});
defineType$4('LogicalExpression', {
    builder: [
        'operator',
        'left',
        'right',
    ],
    visitor: ['left', 'right'],
    aliases: ['Binary', 'Expression'],
    fields: {
        operator: {
            validate: assertOneOf(...LOGICAL_OPERATORS),
        },
        left: {
            validate: assertNodeType('Expression'),
        },
        right: {
            validate: assertNodeType('Expression'),
        },
    },
});
defineType$4('MemberExpression', {
    builder: [
        'object',
        'property',
        'computed',
        ...[],
    ],
    visitor: ['object', 'property'],
    aliases: [
        'Expression',
        'LVal',
        'PatternLike',
    ],
    fields: Object.assign({
        object: {
            validate: assertNodeType('Expression', 'Super'),
        },
        property: {
            validate: (function() {
                const normal = assertNodeType('Identifier', 'PrivateName');
                const computed = assertNodeType('Expression');
                const validator = function(node, key, val) {
                    const validator2 = node.computed ? computed : normal;
                    validator2(node, key, val);
                };
                
                validator.oneOfNodeTypes = [
                    'Expression',
                    'Identifier',
                    'PrivateName',
                ];
                return validator;
            })(),
        },
        computed: {
            default: false,
        },
    }, {}),
});
defineType$4('NewExpression', {
    inherits: 'CallExpression',
});
defineType$4('Program', {
    visitor: ['directives', 'body'],
    builder: [
        'body',
        'directives',
        'sourceType',
        'interpreter',
    ],
    fields: {
        sourceType: {
            validate: assertOneOf('script', 'module'),
            default: 'script',
        },
        interpreter: {
            validate: assertNodeType('InterpreterDirective'),
            default: null,
            optional: true,
        },
        directives: {
            validate: arrayOfType('Directive'),
            default: [],
        },
        body: validateArrayOfType('Statement'),
    },
    aliases: [
        'Scopable',
        'BlockParent',
        'Block',
    ],
});
defineType$4('ObjectExpression', {
    visitor: ['properties'],
    aliases: ['Expression'],
    fields: {
        properties: validateArrayOfType('ObjectMethod', 'ObjectProperty', 'SpreadElement'),
    },
});
defineType$4('ObjectMethod', {
    builder: [
        'kind',
        'key',
        'params',
        'body',
        'computed',
        'generator',
        'async',
    ],
    visitor: [
        'decorators',
        'key',
        'typeParameters',
        'params',
        'returnType',
        'body',
    ],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        kind: Object.assign({
            validate: assertOneOf('method', 'get', 'set'),
        }, {}),
        computed: {
            default: false,
        },
        key: {
            validate: (function() {
                const normal = assertNodeType('Identifier', 'StringLiteral', 'NumericLiteral', 'BigIntLiteral');
                const computed = assertNodeType('Expression');
                const validator = function(node, key, val) {
                    const validator2 = node.computed ? computed : normal;
                    validator2(node, key, val);
                };
                
                validator.oneOfNodeTypes = [
                    'Expression',
                    'Identifier',
                    'StringLiteral',
                    'NumericLiteral',
                    'BigIntLiteral',
                ];
                return validator;
            })(),
        },
        decorators: {
            validate: arrayOfType('Decorator'),
            optional: true,
        },
        body: {
            validate: assertNodeType('BlockStatement'),
        },
    }),
    aliases: [
        'UserWhitespacable',
        'Function',
        'Scopable',
        'BlockParent',
        'FunctionParent',
        'Method',
        'ObjectMember',
    ],
});
defineType$4('ObjectProperty', {
    builder: [
        'key',
        'value',
        'computed',
        'shorthand',
        ...[],
    ],
    fields: {
        computed: {
            default: false,
        },
        key: {
            validate: (function() {
                const normal = assertNodeType('Identifier', 'StringLiteral', 'NumericLiteral', 'BigIntLiteral', 'PrivateName');
                const computed = assertNodeType('Expression');
                const validator = Object.assign(function(node, key, val) {
                    const validator2 = node.computed ? computed : normal;
                    validator2(node, key, val);
                }, {
                    oneOfNodeTypes: [
                        'Expression',
                        'Identifier',
                        'StringLiteral',
                        'NumericLiteral',
                        'BigIntLiteral',
                        'PrivateName',
                    ],
                });
                
                return validator;
            })(),
        },
        value: {
            validate: assertNodeType('Expression', 'PatternLike'),
        },
        shorthand: {
            validate: chain$4(assertValueType('boolean'), Object.assign(function(node, key, shorthand) {
                if (!shorthand)
                    return;
                
                if (node.computed) {
                    throw new TypeError('Property shorthand of ObjectProperty cannot be true if computed is true');
                }
                
                if (!is$4('Identifier', node.key)) {
                    throw new TypeError('Property shorthand of ObjectProperty cannot be true if key is not an Identifier');
                }
            }, {
                type: 'boolean',
            })),
            default: false,
        },
        decorators: {
            validate: arrayOfType('Decorator'),
            optional: true,
        },
    },
    visitor: [
        'decorators',
        'key',
        'value',
    ],
    aliases: [
        'UserWhitespacable',
        'Property',
        'ObjectMember',
    ],
    validate: (function() {
        const pattern = assertNodeType('Identifier', 'Pattern', 'TSAsExpression', 'TSSatisfiesExpression', 'TSNonNullExpression', 'TSTypeAssertion');
        const expression2 = assertNodeType('Expression');
        
        return function(parent, key, node) {
            const validator = is$4('ObjectPattern', parent) ? pattern : expression2;
            validator(node, 'value', node.value);
        };
    })(),
});
defineType$4('RestElement', {
    visitor: ['argument', 'typeAnnotation'],
    builder: ['argument'],
    aliases: ['FunctionParameter', 'PatternLike'],
    deprecatedAlias: 'RestProperty',
    fields: Object.assign({}, patternLikeCommon(), {
        argument: {
            validate: assertNodeType('Identifier', 'ArrayPattern', 'ObjectPattern', 'MemberExpression', 'TSAsExpression', 'TSSatisfiesExpression', 'TSTypeAssertion', 'TSNonNullExpression'),
        },
    }),
    validate: function(parent, key) {
        const match = /(\w+)\[(\d+)\]/.exec(key.toString());
        
        if (!match)
            throw new Error('Internal Babel error: malformed key.');
        
        const [, listKey, index2] = match;
        
        if (parent[listKey].length > +index2 + 1) {
            throw new TypeError(`RestElement must be last element of ${listKey}`);
        }
    },
});
defineType$4('ReturnStatement', {
    visitor: ['argument'],
    aliases: [
        'Statement',
        'Terminatorless',
        'CompletionStatement',
    ],
    fields: {
        argument: {
            validate: assertNodeType('Expression'),
            optional: true,
        },
    },
});
defineType$4('SequenceExpression', {
    visitor: ['expressions'],
    fields: {
        expressions: validateArrayOfType('Expression'),
    },
    aliases: ['Expression'],
});
defineType$4('ParenthesizedExpression', {
    visitor: ['expression'],
    aliases: ['Expression', 'ExpressionWrapper'],
    fields: {
        expression: {
            validate: assertNodeType('Expression'),
        },
    },
});
defineType$4('SwitchCase', {
    visitor: ['test', 'consequent'],
    fields: {
        test: {
            validate: assertNodeType('Expression'),
            optional: true,
        },
        consequent: validateArrayOfType('Statement'),
    },
});
defineType$4('SwitchStatement', {
    visitor: ['discriminant', 'cases'],
    aliases: [
        'Statement',
        'BlockParent',
        'Scopable',
    ],
    fields: {
        discriminant: {
            validate: assertNodeType('Expression'),
        },
        cases: validateArrayOfType('SwitchCase'),
    },
});
defineType$4('ThisExpression', {
    aliases: ['Expression', 'TSEntityName'],
});
defineType$4('ThrowStatement', {
    visitor: ['argument'],
    aliases: [
        'Statement',
        'Terminatorless',
        'CompletionStatement',
    ],
    fields: {
        argument: {
            validate: assertNodeType('Expression'),
        },
    },
});
defineType$4('TryStatement', {
    visitor: [
        'block',
        'handler',
        'finalizer',
    ],
    aliases: ['Statement'],
    fields: {
        block: {
            validate: chain$4(assertNodeType('BlockStatement'), Object.assign(function(node) {
                if (!node.handler && !node.finalizer) {
                    throw new TypeError('TryStatement expects either a handler or finalizer, or both');
                }
            }, {
                oneOfNodeTypes: ['BlockStatement'],
            })),
        },
        handler: {
            optional: true,
            validate: assertNodeType('CatchClause'),
        },
        finalizer: {
            optional: true,
            validate: assertNodeType('BlockStatement'),
        },
    },
});
defineType$4('UnaryExpression', {
    builder: [
        'operator',
        'argument',
        'prefix',
    ],
    fields: {
        prefix: {
            default: true,
        },
        argument: {
            validate: assertNodeType('Expression'),
        },
        operator: {
            validate: assertOneOf(...UNARY_OPERATORS),
        },
    },
    visitor: ['argument'],
    aliases: ['UnaryLike', 'Expression'],
});
defineType$4('UpdateExpression', {
    builder: [
        'operator',
        'argument',
        'prefix',
    ],
    fields: {
        prefix: {
            default: false,
        },
        argument: {
            validate: assertNodeType('Identifier', 'MemberExpression'),
        },
        operator: {
            validate: assertOneOf(...UPDATE_OPERATORS),
        },
    },
    visitor: ['argument'],
    aliases: ['Expression'],
});
defineType$4('VariableDeclaration', {
    builder: ['kind', 'declarations'],
    visitor: ['declarations'],
    aliases: ['Statement', 'Declaration'],
    fields: {
        declare: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        kind: {
            validate: assertOneOf('var', 'let', 'const', 'using', 'await using'),
        },
        declarations: validateArrayOfType('VariableDeclarator'),
    },
    validate: (() => {
        const withoutInit = assertNodeType('Identifier', 'Placeholder');
        const constOrLetOrVar = assertNodeType('Identifier', 'ArrayPattern', 'ObjectPattern', 'Placeholder');
        const usingOrAwaitUsing = assertNodeType('Identifier', 'VoidPattern', 'Placeholder');
        
        return function(parent, key, node) {
            const {kind, declarations} = node;
            
            const parentIsForX = is$4('ForXStatement', parent, {
                left: node,
            });
            
            if (parentIsForX) {
                if (declarations.length !== 1) {
                    throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
                }
            }
            
            for (const decl of declarations) {
                if (kind === 'const' || kind === 'let' || kind === 'var') {
                    if (!parentIsForX && !decl.init) {
                        withoutInit(decl, 'id', decl.id);
                    } else {
                        constOrLetOrVar(decl, 'id', decl.id);
                    }
                } else {
                    usingOrAwaitUsing(decl, 'id', decl.id);
                }
            }
        };
    })(),
});
defineType$4('VariableDeclarator', {
    visitor: ['id', 'init'],
    fields: {
        id: {
            validate: assertNodeType('Identifier', 'ArrayPattern', 'ObjectPattern', 'VoidPattern'),
        },
        definite: {
            optional: true,
            validate: assertValueType('boolean'),
        },
        init: {
            optional: true,
            validate: assertNodeType('Expression'),
        },
    },
});
defineType$4('WhileStatement', {
    visitor: ['test', 'body'],
    aliases: [
        'Statement',
        'BlockParent',
        'Loop',
        'While',
        'Scopable',
    ],
    fields: {
        test: {
            validate: assertNodeType('Expression'),
        },
        body: {
            validate: assertNodeType('Statement'),
        },
    },
});
defineType$4('WithStatement', {
    visitor: ['object', 'body'],
    aliases: ['Statement'],
    fields: {
        object: {
            validate: assertNodeType('Expression'),
        },
        body: {
            validate: assertNodeType('Statement'),
        },
    },
});
defineType$4('AssignmentPattern', {
    visitor: [
        'left',
        'right',
        'decorators',
    ],
    builder: ['left', 'right'],
    aliases: [
        'FunctionParameter',
        'Pattern',
        'PatternLike',
    ],
    fields: Object.assign({}, patternLikeCommon(), {
        left: {
            validate: assertNodeType('Identifier', 'ObjectPattern', 'ArrayPattern', 'MemberExpression', 'TSAsExpression', 'TSSatisfiesExpression', 'TSTypeAssertion', 'TSNonNullExpression'),
        },
        right: {
            validate: assertNodeType('Expression'),
        },
        decorators: {
            validate: arrayOfType('Decorator'),
            optional: true,
        },
    }),
});
defineType$4('ArrayPattern', {
    visitor: ['elements', 'typeAnnotation'],
    builder: ['elements'],
    aliases: [
        'FunctionParameter',
        'Pattern',
        'PatternLike',
        'LVal',
    ],
    fields: Object.assign({}, patternLikeCommon(), {
        elements: {
            validate: chain$4(assertValueType('array'), assertEach(assertNodeOrValueType('null', 'PatternLike'))),
        },
    }),
});
defineType$4('ArrowFunctionExpression', {
    builder: [
        'params',
        'body',
        'async',
    ],
    visitor: [
        'typeParameters',
        'params',
        'predicate',
        'returnType',
        'body',
    ],
    aliases: [
        'Scopable',
        'Function',
        'BlockParent',
        'FunctionParent',
        'Expression',
        'Pureish',
    ],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        expression: {
            validate: assertValueType('boolean'),
        },
        body: {
            validate: assertNodeType('BlockStatement', 'Expression'),
        },
        predicate: {
            validate: assertNodeType('DeclaredPredicate', 'InferredPredicate'),
            optional: true,
        },
    }),
});
defineType$4('ClassBody', {
    visitor: ['body'],
    fields: {
        body: validateArrayOfType('ClassMethod', 'ClassPrivateMethod', 'ClassProperty', 'ClassPrivateProperty', 'ClassAccessorProperty', 'TSDeclareMethod', 'TSIndexSignature', 'StaticBlock'),
    },
});
defineType$4('ClassExpression', {
    builder: [
        'id',
        'superClass',
        'body',
        'decorators',
    ],
    visitor: [
        'decorators',
        'id',
        'typeParameters',
        'superClass',
        'superTypeArguments',
        'mixins',
        'implements',
        'body',
    ],
    aliases: [
        'Scopable',
        'Class',
        'Expression',
    ],
    fields: {
        id: {
            validate: assertNodeType('Identifier'),
            optional: true,
        },
        typeParameters: {
            validate: assertNodeType('TypeParameterDeclaration', 'TSTypeParameterDeclaration'),
            optional: true,
        },
        body: {
            validate: assertNodeType('ClassBody'),
        },
        superClass: {
            optional: true,
            validate: assertNodeType('Expression'),
        },
        ['superTypeArguments']: {
            validate: assertNodeType('TypeParameterInstantiation', 'TSTypeParameterInstantiation'),
            optional: true,
        },
        implements: {
            validate: arrayOfType('TSClassImplements', 'ClassImplements'),
            optional: true,
        },
        decorators: {
            validate: arrayOfType('Decorator'),
            optional: true,
        },
        mixins: {
            validate: assertNodeType('InterfaceExtends'),
            optional: true,
        },
    },
});
defineType$4('ClassDeclaration', {
    inherits: 'ClassExpression',
    aliases: [
        'Scopable',
        'Class',
        'Statement',
        'Declaration',
    ],
    fields: {
        id: {
            validate: assertNodeType('Identifier'),
            optional: true,
        },
        typeParameters: {
            validate: assertNodeType('TypeParameterDeclaration', 'TSTypeParameterDeclaration'),
            optional: true,
        },
        body: {
            validate: assertNodeType('ClassBody'),
        },
        superClass: {
            optional: true,
            validate: assertNodeType('Expression'),
        },
        ['superTypeArguments']: {
            validate: assertNodeType('TypeParameterInstantiation', 'TSTypeParameterInstantiation'),
            optional: true,
        },
        implements: {
            validate: arrayOfType('TSClassImplements', 'ClassImplements'),
            optional: true,
        },
        decorators: {
            validate: arrayOfType('Decorator'),
            optional: true,
        },
        mixins: {
            validate: assertNodeType('InterfaceExtends'),
            optional: true,
        },
        declare: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        abstract: {
            validate: assertValueType('boolean'),
            optional: true,
        },
    },
    validate: (function() {
        const identifier4 = assertNodeType('Identifier');
        
        return function(parent, key, node) {
            if (!is$4('ExportDefaultDeclaration', parent)) {
                identifier4(node, 'id', node.id);
            }
        };
    })(),
});
var importAttributes = {
    attributes: {
        optional: true,
        validate: arrayOfType('ImportAttribute'),
    },
    assertions: {
        deprecated: true,
        optional: true,
        validate: arrayOfType('ImportAttribute'),
    },
};

defineType$4('ExportAllDeclaration', {
    builder: ['source'],
    visitor: [
        'source',
        'attributes',
        'assertions',
    ],
    aliases: [
        'Statement',
        'Declaration',
        'ImportOrExportDeclaration',
        'ExportDeclaration',
    ],
    fields: Object.assign({
        source: {
            validate: assertNodeType('StringLiteral'),
        },
        exportKind: validateOptional(assertOneOf('type', 'value')),
    }, importAttributes),
});
defineType$4('ExportDefaultDeclaration', {
    visitor: ['declaration'],
    aliases: [
        'Statement',
        'Declaration',
        'ImportOrExportDeclaration',
        'ExportDeclaration',
    ],
    fields: {
        declaration: validateType('TSDeclareFunction', 'FunctionDeclaration', 'ClassDeclaration', 'Expression'),
        exportKind: validateOptional(assertOneOf('value')),
    },
});
defineType$4('ExportNamedDeclaration', {
    builder: [
        'declaration',
        'specifiers',
        'source',
    ],
    visitor: [
        'declaration',
        'specifiers',
        'source',
        'attributes',
    ],
    aliases: [
        'Statement',
        'Declaration',
        'ImportOrExportDeclaration',
        'ExportDeclaration',
    ],
    fields: Object.assign({
        declaration: {
            optional: true,
            validate: chain$4(assertNodeType('Declaration'), Object.assign(function(node, key, val) {
                if (val && node.specifiers.length) {
                    throw new TypeError('Only declaration or specifiers is allowed on ExportNamedDeclaration');
                }
                
                if (val && node.source) {
                    throw new TypeError('Cannot export a declaration from a source');
                }
            }, {
                oneOfNodeTypes: ['Declaration'],
            })),
        },
    }, importAttributes, {
        specifiers: {
            default: [],
            validate: arrayOf((function() {
                const sourced = assertNodeType('ExportSpecifier', 'ExportDefaultSpecifier', 'ExportNamespaceSpecifier');
                const sourceless = assertNodeType('ExportSpecifier');
                
                return Object.assign(function(node, key, val) {
                    const validator = node.source ? sourced : sourceless;
                    validator(node, key, val);
                }, {
                    oneOfNodeTypes: [
                        'ExportSpecifier',
                        'ExportDefaultSpecifier',
                        'ExportNamespaceSpecifier',
                    ],
                });
            })()),
        },
        source: {
            validate: assertNodeType('StringLiteral'),
            optional: true,
        },
        exportKind: validateOptional(assertOneOf('type', 'value')),
    }),
});
defineType$4('ExportSpecifier', {
    visitor: ['local', 'exported'],
    aliases: ['ModuleSpecifier'],
    fields: {
        local: {
            validate: assertNodeType('Identifier'),
        },
        exported: {
            validate: assertNodeType('Identifier', 'StringLiteral'),
        },
        exportKind: {
            validate: assertOneOf('type', 'value'),
            optional: true,
        },
    },
});
defineType$4('ForOfStatement', {
    visitor: [
        'left',
        'right',
        'body',
    ],
    builder: [
        'left',
        'right',
        'body',
        'await',
    ],
    aliases: [
        'Scopable',
        'Statement',
        'For',
        'BlockParent',
        'Loop',
        'ForXStatement',
    ],
    fields: {
        left: {
            validate: (function() {
                const declaration = assertNodeType('VariableDeclaration');
                const lval = assertNodeType('Identifier', 'MemberExpression', 'ArrayPattern', 'ObjectPattern', 'TSAsExpression', 'TSSatisfiesExpression', 'TSTypeAssertion', 'TSNonNullExpression');
                
                return Object.assign(function(node, key, val) {
                    if (is$4('VariableDeclaration', val)) {
                        declaration(node, key, val);
                    } else {
                        lval(node, key, val);
                    }
                }, {
                    oneOfNodeTypes: [
                        'VariableDeclaration',
                        'Identifier',
                        'MemberExpression',
                        'ArrayPattern',
                        'ObjectPattern',
                        'TSAsExpression',
                        'TSSatisfiesExpression',
                        'TSTypeAssertion',
                        'TSNonNullExpression',
                    ],
                });
            })(),
        },
        right: {
            validate: assertNodeType('Expression'),
        },
        body: {
            validate: assertNodeType('Statement'),
        },
        await: {
            default: false,
        },
    },
});
defineType$4('ImportDeclaration', {
    builder: ['specifiers', 'source'],
    visitor: [
        'specifiers',
        'source',
        'attributes',
    ],
    aliases: [
        'Statement',
        'Declaration',
        'ImportOrExportDeclaration',
    ],
    fields: Object.assign({}, importAttributes, {
        module: {
            optional: true,
            validate: assertValueType('boolean'),
        },
        phase: {
            default: null,
            validate: assertOneOf('source', 'defer'),
        },
        specifiers: validateArrayOfType('ImportSpecifier', 'ImportDefaultSpecifier', 'ImportNamespaceSpecifier'),
        source: {
            validate: assertNodeType('StringLiteral'),
        },
        importKind: {
            validate: assertOneOf('type', 'typeof', 'value'),
            optional: true,
        },
    }),
});
defineType$4('ImportDefaultSpecifier', {
    visitor: ['local'],
    aliases: ['ModuleSpecifier'],
    fields: {
        local: {
            validate: assertNodeType('Identifier'),
        },
    },
});
defineType$4('ImportNamespaceSpecifier', {
    visitor: ['local'],
    aliases: ['ModuleSpecifier'],
    fields: {
        local: {
            validate: assertNodeType('Identifier'),
        },
    },
});
defineType$4('ImportSpecifier', {
    visitor: ['imported', 'local'],
    builder: ['local', 'imported'],
    aliases: ['ModuleSpecifier'],
    fields: {
        local: {
            validate: assertNodeType('Identifier'),
        },
        imported: {
            validate: assertNodeType('Identifier', 'StringLiteral'),
        },
        importKind: {
            validate: assertOneOf('type', 'typeof', 'value'),
            optional: true,
        },
    },
});
defineType$4('ImportExpression', {
    visitor: ['source', 'options'],
    aliases: ['Expression'],
    fields: {
        phase: {
            default: null,
            validate: assertOneOf('source', 'defer'),
        },
        source: {
            validate: assertNodeType('Expression'),
        },
        options: {
            validate: assertNodeType('Expression'),
            optional: true,
        },
    },
});
defineType$4('MetaProperty', {
    visitor: ['meta', 'property'],
    aliases: ['Expression'],
    fields: {
        meta: {
            validate: chain$4(assertNodeType('Identifier'), Object.assign(function(node, key, val) {
                let property;
                
                switch(val.name) {
                case 'function':
                    property = 'sent';
                    break;
                
                case 'new':
                    property = 'target';
                    break;
                
                case 'import':
                    property = 'meta';
                    break;
                }
                
                if (!is$4('Identifier', node.property, {name: property})) {
                    throw new TypeError('Unrecognised MetaProperty');
                }
            }, {
                oneOfNodeTypes: ['Identifier'],
            })),
        },
        property: {
            validate: assertNodeType('Identifier'),
        },
    },
});
var classMethodOrPropertyCommon = () => ({
    abstract: {
        validate: assertValueType('boolean'),
        optional: true,
    },
    accessibility: {
        validate: assertOneOf('public', 'private', 'protected'),
        optional: true,
    },
    static: {
        default: false,
    },
    override: {
        default: false,
    },
    computed: {
        default: false,
    },
    optional: {
        validate: assertValueType('boolean'),
        optional: true,
    },
    key: {
        validate: chain$4((function() {
            const normal = assertNodeType('Identifier', 'StringLiteral', 'NumericLiteral', 'BigIntLiteral');
            const computed = assertNodeType('Expression');
            
            return function(node, key, val) {
                const validator = node.computed ? computed : normal;
                validator(node, key, val);
            };
        })(), assertNodeType('Identifier', 'StringLiteral', 'NumericLiteral', 'BigIntLiteral', 'Expression')),
    },
});

var classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
    params: validateArrayOfType('FunctionParameter', 'TSParameterProperty'),
    kind: {
        validate: assertOneOf('get', 'set', 'method', 'constructor'),
        default: 'method',
    },
    access: {
        validate: chain$4(assertValueType('string'), assertOneOf('public', 'private', 'protected')),
        optional: true,
    },
    decorators: {
        validate: arrayOfType('Decorator'),
        optional: true,
    },
});

defineType$4('ClassMethod', {
    aliases: [
        'Function',
        'Scopable',
        'BlockParent',
        'FunctionParent',
        'Method',
    ],
    builder: [
        'kind',
        'key',
        'params',
        'body',
        'computed',
        'static',
        'generator',
        'async',
    ],
    visitor: [
        'decorators',
        'key',
        'typeParameters',
        'params',
        'returnType',
        'body',
    ],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
        body: {
            validate: assertNodeType('BlockStatement'),
        },
    }),
});
defineType$4('ObjectPattern', {
    visitor: [
        'decorators',
        'properties',
        'typeAnnotation',
    ],
    builder: ['properties'],
    aliases: [
        'FunctionParameter',
        'Pattern',
        'PatternLike',
        'LVal',
    ],
    fields: Object.assign({}, patternLikeCommon(), {
        properties: validateArrayOfType('RestElement', 'ObjectProperty'),
    }),
});
defineType$4('SpreadElement', {
    visitor: ['argument'],
    aliases: ['UnaryLike'],
    deprecatedAlias: 'SpreadProperty',
    fields: {
        argument: {
            validate: assertNodeType('Expression'),
        },
    },
});
defineType$4('Super', void 0);
defineType$4('TaggedTemplateExpression', {
    visitor: [
        'tag',
        'typeArguments',
        'quasi',
    ],
    builder: ['tag', 'quasi'],
    aliases: ['Expression'],
    fields: {
        tag: {
            validate: assertNodeType('Expression'),
        },
        quasi: {
            validate: assertNodeType('TemplateLiteral'),
        },
        ['typeArguments']: {
            validate: assertNodeType('TypeParameterInstantiation', 'TSTypeParameterInstantiation'),
            optional: true,
        },
    },
});
defineType$4('TemplateElement', {
    builder: ['value', 'tail'],
    fields: {
        value: {
            validate: chain$4(assertShape({
                raw: {
                    validate: assertValueType('string'),
                },
                cooked: {
                    validate: assertValueType('string'),
                    optional: true,
                },
            }), function templateElementCookedValidator(node) {
                const raw = node.value.raw;
                let unterminatedCalled = false;
                const error = () => {
                    throw new Error('Internal @babel/types error.');
                };
                
                const {
                    str,
                    firstInvalidLoc,
                } = readStringContents('template', raw, 0, 0, 0, {
                    unterminated() {
                        unterminatedCalled = true;
                    },
                    strictNumericEscape: error,
                    invalidEscapeSequence: error,
                    numericSeparatorInEscapeSequence: error,
                    unexpectedNumericSeparator: error,
                    invalidDigit: error,
                    invalidCodePoint: error,
                });
                
                if (!unterminatedCalled)
                    throw new Error('Invalid raw');
                
                node.value.cooked = firstInvalidLoc ? null : str;
            }),
        },
        tail: {
            default: false,
        },
    },
});
defineType$4('TemplateLiteral', {
    visitor: ['quasis', 'expressions'],
    aliases: ['Expression', 'Literal'],
    fields: {
        quasis: validateArrayOfType('TemplateElement'),
        expressions: {
            validate: chain$4(assertValueType('array'), assertEach(assertNodeType('Expression', 'TSType')), function(node, key, val) {
                if (node.quasis.length !== val.length + 1) {
                    throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.
Expected ${val.length + 1} quasis but got ${node.quasis.length}`);
                }
            }),
        },
    },
});
defineType$4('YieldExpression', {
    builder: ['argument', 'delegate'],
    visitor: ['argument'],
    aliases: ['Expression', 'Terminatorless'],
    fields: {
        delegate: {
            validate: chain$4(assertValueType('boolean'), Object.assign(function(node, key, val) {
                if (val && !node.argument) {
                    throw new TypeError('Property delegate of YieldExpression cannot be true if there is no argument');
                }
            }, {
                type: 'boolean',
            })),
            default: false,
        },
        argument: {
            optional: true,
            validate: assertNodeType('Expression'),
        },
    },
});
defineType$4('AwaitExpression', {
    builder: ['argument'],
    visitor: ['argument'],
    aliases: ['Expression', 'Terminatorless'],
    fields: {
        argument: {
            validate: assertNodeType('Expression'),
        },
    },
});
defineType$4('Import', {
    aliases: ['Expression'],
});
defineType$4('BigIntLiteral', {
    builder: ['value'],
    fields: {
        value: {
            validate: assertValueType('bigint'),
        },
    },
    aliases: [
        'Expression',
        'Pureish',
        'Literal',
        'Immutable',
    ],
});
defineType$4('ExportNamespaceSpecifier', {
    visitor: ['exported'],
    aliases: ['ModuleSpecifier'],
    fields: {
        exported: {
            validate: assertNodeType('Identifier'),
        },
    },
});
defineType$4('OptionalMemberExpression', {
    builder: [
        'object',
        'property',
        'computed',
        'optional',
    ],
    visitor: ['object', 'property'],
    aliases: ['Expression'],
    fields: {
        object: {
            validate: assertNodeType('Expression'),
        },
        property: {
            validate: (function() {
                const normal = assertNodeType('Identifier');
                const computed = assertNodeType('Expression');
                const validator = Object.assign(function(node, key, val) {
                    const validator2 = node.computed ? computed : normal;
                    validator2(node, key, val);
                }, {
                    oneOfNodeTypes: ['Expression', 'Identifier'],
                });
                
                return validator;
            })(),
        },
        computed: {
            default: false,
        },
        optional: {
            validate: chain$4(assertValueType('boolean'), assertOptionalChainStart()),
        },
    },
});
defineType$4('OptionalCallExpression', {
    visitor: [
        'callee',
        'typeArguments',
        'arguments',
    ],
    builder: [
        'callee',
        'arguments',
        'optional',
    ],
    aliases: ['Expression'],
    fields: Object.assign({
        callee: {
            validate: assertNodeType('Expression'),
        },
        arguments: validateArrayOfType('Expression', 'SpreadElement', 'ArgumentPlaceholder'),
        optional: {
            validate: chain$4(assertValueType('boolean'), assertOptionalChainStart()),
        },
        typeArguments: {
            validate: assertNodeType('TypeParameterInstantiation', 'TSTypeParameterInstantiation'),
            optional: true,
        },
    }, {}),
});
defineType$4('ClassProperty', {
    visitor: [
        'decorators',
        'variance',
        'key',
        'typeAnnotation',
        'value',
    ],
    builder: [
        'key',
        'value',
        'typeAnnotation',
        'decorators',
        'computed',
        'static',
    ],
    aliases: ['Property'],
    fields: Object.assign({}, classMethodOrPropertyCommon(), {
        value: {
            validate: assertNodeType('Expression'),
            optional: true,
        },
        definite: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        typeAnnotation: {
            validate: assertNodeType('TypeAnnotation', 'TSTypeAnnotation'),
            optional: true,
        },
        decorators: {
            validate: arrayOfType('Decorator'),
            optional: true,
        },
        readonly: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        declare: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        variance: {
            validate: assertNodeType('Variance'),
            optional: true,
        },
    }),
});
defineType$4('ClassAccessorProperty', {
    visitor: [
        'decorators',
        'key',
        'typeAnnotation',
        'value',
    ],
    builder: [
        'key',
        'value',
        'typeAnnotation',
        'decorators',
        'computed',
        'static',
    ],
    aliases: ['Property', 'Accessor'],
    fields: Object.assign({}, classMethodOrPropertyCommon(), {
        key: {
            validate: chain$4((function() {
                const normal = assertNodeType('Identifier', 'StringLiteral', 'NumericLiteral', 'BigIntLiteral', 'PrivateName');
                const computed = assertNodeType('Expression');
                
                return function(node, key, val) {
                    const validator = node.computed ? computed : normal;
                    validator(node, key, val);
                };
            })(), assertNodeType('Identifier', 'StringLiteral', 'NumericLiteral', 'BigIntLiteral', 'Expression', 'PrivateName')),
        },
        value: {
            validate: assertNodeType('Expression'),
            optional: true,
        },
        definite: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        typeAnnotation: {
            validate: assertNodeType('TypeAnnotation', 'TSTypeAnnotation'),
            optional: true,
        },
        decorators: {
            validate: arrayOfType('Decorator'),
            optional: true,
        },
        readonly: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        declare: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        variance: {
            validate: assertNodeType('Variance'),
            optional: true,
        },
    }),
});
defineType$4('ClassPrivateProperty', {
    visitor: [
        'decorators',
        'variance',
        'key',
        'typeAnnotation',
        'value',
    ],
    builder: [
        'key',
        'value',
        'decorators',
        'static',
    ],
    aliases: ['Property', 'Private'],
    fields: {
        key: {
            validate: assertNodeType('PrivateName'),
        },
        value: {
            validate: assertNodeType('Expression'),
            optional: true,
        },
        typeAnnotation: {
            validate: assertNodeType('TypeAnnotation', 'TSTypeAnnotation'),
            optional: true,
        },
        decorators: {
            validate: arrayOfType('Decorator'),
            optional: true,
        },
        static: {
            validate: assertValueType('boolean'),
            default: false,
        },
        readonly: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        optional: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        definite: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        variance: {
            validate: assertNodeType('Variance'),
            optional: true,
        },
    },
});
defineType$4('ClassPrivateMethod', {
    builder: [
        'kind',
        'key',
        'params',
        'body',
        'static',
    ],
    visitor: [
        'decorators',
        'key',
        'typeParameters',
        'params',
        'returnType',
        'body',
    ],
    aliases: [
        'Function',
        'Scopable',
        'BlockParent',
        'FunctionParent',
        'Method',
        'Private',
    ],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
        kind: {
            validate: assertOneOf('get', 'set', 'method'),
            default: 'method',
        },
        key: {
            validate: assertNodeType('PrivateName'),
        },
        body: {
            validate: assertNodeType('BlockStatement'),
        },
    }),
});
defineType$4('PrivateName', {
    visitor: ['id'],
    aliases: ['Private'],
    fields: {
        id: {
            validate: assertNodeType('Identifier'),
        },
    },
});
defineType$4('StaticBlock', {
    visitor: ['body'],
    fields: {
        body: validateArrayOfType('Statement'),
    },
    aliases: [
        'Scopable',
        'BlockParent',
        'FunctionParent',
    ],
});
defineType$4('ImportAttribute', {
    visitor: ['key', 'value'],
    fields: {
        key: {
            validate: assertNodeType('Identifier', 'StringLiteral'),
        },
        value: {
            validate: assertNodeType('StringLiteral'),
        },
    },
});
var defineType$3 = defineAliasedType('Flow');

var defineInterfaceishType = (name) => {
    const isDeclareClass2 = name === 'DeclareClass';
    
    defineType$3(name, {
        builder: [
            'id',
            'typeParameters',
            'extends',
            'body',
        ],
        visitor: [
            'id',
            'typeParameters',
            'extends',
            ...isDeclareClass2 ? [
                'mixins',
                'implements',
            ] : [],
            'body',
        ],
        aliases: [
            'FlowDeclaration',
            'Statement',
            'Declaration',
        ],
        fields: Object.assign({
            id: validateType('Identifier'),
            typeParameters: validateOptionalType('TypeParameterDeclaration'),
            extends: validateOptional(arrayOfType('InterfaceExtends')),
        }, isDeclareClass2 ? {
            mixins: validateOptional(arrayOfType('InterfaceExtends')),
            implements: validateOptional(arrayOfType('ClassImplements')),
        } : {}, {
            body: validateType('ObjectTypeAnnotation'),
        }),
    });
};

defineType$3('AnyTypeAnnotation', {
    aliases: ['FlowType', 'FlowBaseAnnotation'],
});
defineType$3('ArrayTypeAnnotation', {
    visitor: ['elementType'],
    aliases: ['FlowType'],
    fields: {
        elementType: validateType('FlowType'),
    },
});
defineType$3('BooleanTypeAnnotation', {
    aliases: ['FlowType', 'FlowBaseAnnotation'],
});
defineType$3('BooleanLiteralTypeAnnotation', {
    builder: ['value'],
    aliases: ['FlowType'],
    fields: {
        value: validate$2$1(assertValueType('boolean')),
    },
});
defineType$3('NullLiteralTypeAnnotation', {
    aliases: ['FlowType', 'FlowBaseAnnotation'],
});
defineType$3('ClassImplements', {
    visitor: ['id', 'typeParameters'],
    fields: {
        id: validateType('Identifier'),
        typeParameters: validateOptionalType('TypeParameterInstantiation'),
    },
});
defineInterfaceishType('DeclareClass');
defineType$3('DeclareFunction', {
    builder: ['id'],
    visitor: ['id', 'predicate'],
    aliases: [
        'FlowDeclaration',
        'Statement',
        'Declaration',
    ],
    fields: {
        id: validateType('Identifier'),
        predicate: validateOptionalType('DeclaredPredicate'),
    },
});
defineInterfaceishType('DeclareInterface');
defineType$3('DeclareModule', {
    builder: ['id', 'body', 'kind'],
    visitor: ['id', 'body'],
    aliases: [
        'FlowDeclaration',
        'Statement',
        'Declaration',
    ],
    fields: {
        id: validateType('Identifier', 'StringLiteral'),
        body: validateType('BlockStatement'),
        kind: validateOptional(assertOneOf('CommonJS', 'ES')),
    },
});
defineType$3('DeclareModuleExports', {
    visitor: ['typeAnnotation'],
    aliases: [
        'FlowDeclaration',
        'Statement',
        'Declaration',
    ],
    fields: {
        typeAnnotation: validateType('TypeAnnotation'),
    },
});
defineType$3('DeclareTypeAlias', {
    visitor: [
        'id',
        'typeParameters',
        'right',
    ],
    aliases: [
        'FlowDeclaration',
        'Statement',
        'Declaration',
    ],
    fields: {
        id: validateType('Identifier'),
        typeParameters: validateOptionalType('TypeParameterDeclaration'),
        right: validateType('FlowType'),
    },
});
defineType$3('DeclareOpaqueType', {
    visitor: [
        'id',
        'typeParameters',
        'supertype',
    ],
    aliases: [
        'FlowDeclaration',
        'Statement',
        'Declaration',
    ],
    fields: {
        id: validateType('Identifier'),
        typeParameters: validateOptionalType('TypeParameterDeclaration'),
        supertype: validateOptionalType('FlowType'),
        impltype: validateOptionalType('FlowType'),
    },
});
defineType$3('DeclareVariable', {
    visitor: ['id'],
    aliases: [
        'FlowDeclaration',
        'Statement',
        'Declaration',
    ],
    fields: {
        id: validateType('Identifier'),
    },
});
defineType$3('DeclareExportDeclaration', {
    visitor: [
        'declaration',
        'specifiers',
        'source',
        'attributes',
    ],
    aliases: [
        'FlowDeclaration',
        'Statement',
        'Declaration',
    ],
    fields: Object.assign({
        declaration: validateOptionalType('Flow'),
        specifiers: validateOptional(arrayOfType('ExportSpecifier', 'ExportNamespaceSpecifier')),
        source: validateOptionalType('StringLiteral'),
        default: validateOptional(assertValueType('boolean')),
    }, importAttributes),
});
defineType$3('DeclareExportAllDeclaration', {
    visitor: ['source', 'attributes'],
    aliases: [
        'FlowDeclaration',
        'Statement',
        'Declaration',
    ],
    fields: Object.assign({
        source: validateType('StringLiteral'),
        exportKind: validateOptional(assertOneOf('type', 'value')),
    }, importAttributes),
});
defineType$3('DeclaredPredicate', {
    visitor: ['value'],
    aliases: ['FlowPredicate'],
    fields: {
        value: validateType('Flow'),
    },
});
defineType$3('ExistsTypeAnnotation', {
    aliases: ['FlowType'],
});
defineType$3('FunctionTypeAnnotation', {
    builder: [
        'typeParameters',
        'params',
        'rest',
        'returnType',
    ],
    visitor: [
        'typeParameters',
        'this',
        'params',
        'rest',
        'returnType',
    ],
    aliases: ['FlowType'],
    fields: {
        typeParameters: validateOptionalType('TypeParameterDeclaration'),
        params: validateArrayOfType('FunctionTypeParam'),
        rest: validateOptionalType('FunctionTypeParam'),
        this: validateOptionalType('FunctionTypeParam'),
        returnType: validateType('FlowType'),
    },
});
defineType$3('FunctionTypeParam', {
    visitor: ['name', 'typeAnnotation'],
    fields: {
        name: validateOptionalType('Identifier'),
        typeAnnotation: validateType('FlowType'),
        optional: validateOptional(assertValueType('boolean')),
    },
});
defineType$3('GenericTypeAnnotation', {
    visitor: ['id', 'typeParameters'],
    aliases: ['FlowType'],
    fields: {
        id: validateType('Identifier', 'QualifiedTypeIdentifier'),
        typeParameters: validateOptionalType('TypeParameterInstantiation'),
    },
});
defineType$3('InferredPredicate', {
    aliases: ['FlowPredicate'],
});
defineType$3('InterfaceExtends', {
    visitor: ['id', 'typeParameters'],
    fields: {
        id: validateType('Identifier', 'QualifiedTypeIdentifier'),
        typeParameters: validateOptionalType('TypeParameterInstantiation'),
    },
});
defineInterfaceishType('InterfaceDeclaration');
defineType$3('InterfaceTypeAnnotation', {
    visitor: ['extends', 'body'],
    aliases: ['FlowType'],
    fields: {
        extends: validateOptional(arrayOfType('InterfaceExtends')),
        body: validateType('ObjectTypeAnnotation'),
    },
});
defineType$3('IntersectionTypeAnnotation', {
    visitor: ['types'],
    aliases: ['FlowType'],
    fields: {
        types: validate$2$1(arrayOfType('FlowType')),
    },
});
defineType$3('MixedTypeAnnotation', {
    aliases: ['FlowType', 'FlowBaseAnnotation'],
});
defineType$3('EmptyTypeAnnotation', {
    aliases: ['FlowType', 'FlowBaseAnnotation'],
});
defineType$3('NullableTypeAnnotation', {
    visitor: ['typeAnnotation'],
    aliases: ['FlowType'],
    fields: {
        typeAnnotation: validateType('FlowType'),
    },
});
defineType$3('NumberLiteralTypeAnnotation', {
    builder: ['value'],
    aliases: ['FlowType'],
    fields: {
        value: validate$2$1(assertValueType('number')),
    },
});
defineType$3('NumberTypeAnnotation', {
    aliases: ['FlowType', 'FlowBaseAnnotation'],
});
defineType$3('ObjectTypeAnnotation', {
    visitor: [
        'properties',
        'indexers',
        'callProperties',
        'internalSlots',
    ],
    aliases: ['FlowType'],
    builder: [
        'properties',
        'indexers',
        'callProperties',
        'internalSlots',
        'exact',
    ],
    fields: {
        properties: validate$2$1(arrayOfType('ObjectTypeProperty', 'ObjectTypeSpreadProperty')),
        indexers: {
            validate: arrayOfType('ObjectTypeIndexer'),
            optional: false,
            default: [],
        },
        callProperties: {
            validate: arrayOfType('ObjectTypeCallProperty'),
            optional: false,
            default: [],
        },
        internalSlots: {
            validate: arrayOfType('ObjectTypeInternalSlot'),
            optional: false,
            default: [],
        },
        exact: {
            validate: assertValueType('boolean'),
            default: false,
        },
        inexact: validateOptional(assertValueType('boolean')),
    },
});
defineType$3('ObjectTypeInternalSlot', {
    visitor: ['id', 'value'],
    builder: [
        'id',
        'value',
        'optional',
        'static',
        'method',
    ],
    aliases: ['UserWhitespacable'],
    fields: {
        id: validateType('Identifier'),
        value: validateType('FlowType'),
        optional: validate$2$1(assertValueType('boolean')),
        static: validate$2$1(assertValueType('boolean')),
        method: validate$2$1(assertValueType('boolean')),
    },
});
defineType$3('ObjectTypeCallProperty', {
    visitor: ['value'],
    aliases: ['UserWhitespacable'],
    fields: {
        value: validateType('FlowType'),
        static: validate$2$1(assertValueType('boolean')),
    },
});
defineType$3('ObjectTypeIndexer', {
    visitor: [
        'variance',
        'id',
        'key',
        'value',
    ],
    builder: [
        'id',
        'key',
        'value',
        'variance',
    ],
    aliases: ['UserWhitespacable'],
    fields: {
        id: validateOptionalType('Identifier'),
        key: validateType('FlowType'),
        value: validateType('FlowType'),
        static: validate$2$1(assertValueType('boolean')),
        variance: validateOptionalType('Variance'),
    },
});
defineType$3('ObjectTypeProperty', {
    visitor: [
        'key',
        'value',
        'variance',
    ],
    aliases: ['UserWhitespacable'],
    fields: {
        key: validateType('Identifier', 'StringLiteral'),
        value: validateType('FlowType'),
        kind: validate$2$1(assertOneOf('init', 'get', 'set')),
        static: validate$2$1(assertValueType('boolean')),
        proto: validate$2$1(assertValueType('boolean')),
        optional: validate$2$1(assertValueType('boolean')),
        variance: validateOptionalType('Variance'),
        method: validate$2$1(assertValueType('boolean')),
    },
});
defineType$3('ObjectTypeSpreadProperty', {
    visitor: ['argument'],
    aliases: ['UserWhitespacable'],
    fields: {
        argument: validateType('FlowType'),
    },
});
defineType$3('OpaqueType', {
    visitor: [
        'id',
        'typeParameters',
        'supertype',
        'impltype',
    ],
    aliases: [
        'FlowDeclaration',
        'Statement',
        'Declaration',
    ],
    fields: {
        id: validateType('Identifier'),
        typeParameters: validateOptionalType('TypeParameterDeclaration'),
        supertype: validateOptionalType('FlowType'),
        impltype: validateType('FlowType'),
    },
});
defineType$3('QualifiedTypeIdentifier', {
    visitor: ['qualification', 'id'],
    builder: ['id', 'qualification'],
    fields: {
        id: validateType('Identifier'),
        qualification: validateType('Identifier', 'QualifiedTypeIdentifier'),
    },
});
defineType$3('StringLiteralTypeAnnotation', {
    builder: ['value'],
    aliases: ['FlowType'],
    fields: {
        value: validate$2$1(assertValueType('string')),
    },
});
defineType$3('StringTypeAnnotation', {
    aliases: ['FlowType', 'FlowBaseAnnotation'],
});
defineType$3('SymbolTypeAnnotation', {
    aliases: ['FlowType', 'FlowBaseAnnotation'],
});
defineType$3('ThisTypeAnnotation', {
    aliases: ['FlowType', 'FlowBaseAnnotation'],
});
defineType$3('TupleTypeAnnotation', {
    visitor: ['types'],
    aliases: ['FlowType'],
    fields: {
        types: validate$2$1(arrayOfType('FlowType')),
    },
});
defineType$3('TypeofTypeAnnotation', {
    visitor: ['argument'],
    aliases: ['FlowType'],
    fields: {
        argument: validateType('FlowType'),
    },
});
defineType$3('TypeAlias', {
    visitor: [
        'id',
        'typeParameters',
        'right',
    ],
    aliases: [
        'FlowDeclaration',
        'Statement',
        'Declaration',
    ],
    fields: {
        id: validateType('Identifier'),
        typeParameters: validateOptionalType('TypeParameterDeclaration'),
        right: validateType('FlowType'),
    },
});
defineType$3('TypeAnnotation', {
    visitor: ['typeAnnotation'],
    fields: {
        typeAnnotation: validateType('FlowType'),
    },
});
defineType$3('TypeCastExpression', {
    visitor: ['expression', 'typeAnnotation'],
    aliases: ['ExpressionWrapper', 'Expression'],
    fields: {
        expression: validateType('Expression'),
        typeAnnotation: validateType('TypeAnnotation'),
    },
});
defineType$3('TypeParameter', {
    visitor: [
        'bound',
        'default',
        'variance',
    ],
    fields: {
        name: validate$2$1(assertValueType('string')),
        bound: validateOptionalType('TypeAnnotation'),
        default: validateOptionalType('FlowType'),
        variance: validateOptionalType('Variance'),
    },
});
defineType$3('TypeParameterDeclaration', {
    visitor: ['params'],
    fields: {
        params: validate$2$1(arrayOfType('TypeParameter')),
    },
});
defineType$3('TypeParameterInstantiation', {
    visitor: ['params'],
    fields: {
        params: validate$2$1(arrayOfType('FlowType')),
    },
});
defineType$3('UnionTypeAnnotation', {
    visitor: ['types'],
    aliases: ['FlowType'],
    fields: {
        types: validate$2$1(arrayOfType('FlowType')),
    },
});
defineType$3('Variance', {
    builder: ['kind'],
    fields: {
        kind: validate$2$1(assertOneOf('minus', 'plus')),
    },
});
defineType$3('VoidTypeAnnotation', {
    aliases: ['FlowType', 'FlowBaseAnnotation'],
});
defineType$3('EnumDeclaration', {
    aliases: ['Statement', 'Declaration'],
    visitor: ['id', 'body'],
    fields: {
        id: validateType('Identifier'),
        body: validateType('EnumBooleanBody', 'EnumNumberBody', 'EnumStringBody', 'EnumSymbolBody'),
    },
});
defineType$3('EnumBooleanBody', {
    aliases: ['EnumBody'],
    visitor: ['members'],
    fields: {
        explicitType: validate$2$1(assertValueType('boolean')),
        members: validateArrayOfType('EnumBooleanMember'),
        hasUnknownMembers: validate$2$1(assertValueType('boolean')),
    },
});
defineType$3('EnumNumberBody', {
    aliases: ['EnumBody'],
    visitor: ['members'],
    fields: {
        explicitType: validate$2$1(assertValueType('boolean')),
        members: validateArrayOfType('EnumNumberMember'),
        hasUnknownMembers: validate$2$1(assertValueType('boolean')),
    },
});
defineType$3('EnumStringBody', {
    aliases: ['EnumBody'],
    visitor: ['members'],
    fields: {
        explicitType: validate$2$1(assertValueType('boolean')),
        members: validateArrayOfType('EnumStringMember', 'EnumDefaultedMember'),
        hasUnknownMembers: validate$2$1(assertValueType('boolean')),
    },
});
defineType$3('EnumSymbolBody', {
    aliases: ['EnumBody'],
    visitor: ['members'],
    fields: {
        members: validateArrayOfType('EnumDefaultedMember'),
        hasUnknownMembers: validate$2$1(assertValueType('boolean')),
    },
});
defineType$3('EnumBooleanMember', {
    aliases: ['EnumMember'],
    builder: ['id'],
    visitor: ['id', 'init'],
    fields: {
        id: validateType('Identifier'),
        init: validateType('BooleanLiteral'),
    },
});
defineType$3('EnumNumberMember', {
    aliases: ['EnumMember'],
    visitor: ['id', 'init'],
    fields: {
        id: validateType('Identifier'),
        init: validateType('NumericLiteral'),
    },
});
defineType$3('EnumStringMember', {
    aliases: ['EnumMember'],
    visitor: ['id', 'init'],
    fields: {
        id: validateType('Identifier'),
        init: validateType('StringLiteral'),
    },
});
defineType$3('EnumDefaultedMember', {
    aliases: ['EnumMember'],
    visitor: ['id'],
    fields: {
        id: validateType('Identifier'),
    },
});
defineType$3('IndexedAccessType', {
    visitor: ['objectType', 'indexType'],
    aliases: ['FlowType'],
    fields: {
        objectType: validateType('FlowType'),
        indexType: validateType('FlowType'),
    },
});
defineType$3('OptionalIndexedAccessType', {
    visitor: ['objectType', 'indexType'],
    aliases: ['FlowType'],
    fields: {
        objectType: validateType('FlowType'),
        indexType: validateType('FlowType'),
        optional: validate$2$1(assertValueType('boolean')),
    },
});
var defineType$2 = defineAliasedType('JSX');

defineType$2('JSXAttribute', {
    visitor: ['name', 'value'],
    aliases: ['Immutable'],
    fields: {
        name: {
            validate: assertNodeType('JSXIdentifier', 'JSXNamespacedName'),
        },
        value: {
            optional: true,
            validate: assertNodeType('JSXElement', 'JSXFragment', 'StringLiteral', 'JSXExpressionContainer'),
        },
    },
});
defineType$2('JSXClosingElement', {
    visitor: ['name'],
    aliases: ['Immutable'],
    fields: {
        name: {
            validate: assertNodeType('JSXIdentifier', 'JSXMemberExpression', 'JSXNamespacedName'),
        },
    },
});
defineType$2('JSXElement', {
    builder: [
        'openingElement',
        'closingElement',
        'children',
    ],
    visitor: [
        'openingElement',
        'children',
        'closingElement',
    ],
    aliases: ['Immutable', 'Expression'],
    fields: Object.assign({
        openingElement: {
            validate: assertNodeType('JSXOpeningElement'),
        },
        closingElement: {
            optional: true,
            validate: assertNodeType('JSXClosingElement'),
        },
        children: validateArrayOfType('JSXText', 'JSXExpressionContainer', 'JSXSpreadChild', 'JSXElement', 'JSXFragment'),
    }, {}),
});
defineType$2('JSXEmptyExpression', {});
defineType$2('JSXExpressionContainer', {
    visitor: ['expression'],
    aliases: ['Immutable'],
    fields: {
        expression: {
            validate: assertNodeType('Expression', 'JSXEmptyExpression'),
        },
    },
});
defineType$2('JSXSpreadChild', {
    visitor: ['expression'],
    aliases: ['Immutable'],
    fields: {
        expression: {
            validate: assertNodeType('Expression'),
        },
    },
});
defineType$2('JSXIdentifier', {
    builder: ['name'],
    fields: {
        name: {
            validate: assertValueType('string'),
        },
    },
});
defineType$2('JSXMemberExpression', {
    visitor: ['object', 'property'],
    fields: {
        object: {
            validate: assertNodeType('JSXMemberExpression', 'JSXIdentifier'),
        },
        property: {
            validate: assertNodeType('JSXIdentifier'),
        },
    },
});
defineType$2('JSXNamespacedName', {
    visitor: ['namespace', 'name'],
    fields: {
        namespace: {
            validate: assertNodeType('JSXIdentifier'),
        },
        name: {
            validate: assertNodeType('JSXIdentifier'),
        },
    },
});
defineType$2('JSXOpeningElement', {
    builder: [
        'name',
        'attributes',
        'selfClosing',
    ],
    visitor: [
        'name',
        'typeArguments',
        'attributes',
    ],
    aliases: ['Immutable'],
    fields: Object.assign({
        name: {
            validate: assertNodeType('JSXIdentifier', 'JSXMemberExpression', 'JSXNamespacedName'),
        },
        selfClosing: {
            default: false,
        },
        attributes: validateArrayOfType('JSXAttribute', 'JSXSpreadAttribute'),
        typeArguments: {
            validate: assertNodeType('TypeParameterInstantiation', 'TSTypeParameterInstantiation'),
            optional: true,
        },
    }, {}),
});
defineType$2('JSXSpreadAttribute', {
    visitor: ['argument'],
    fields: {
        argument: {
            validate: assertNodeType('Expression'),
        },
    },
});
defineType$2('JSXText', {
    aliases: ['Immutable'],
    builder: ['value'],
    fields: {
        value: {
            validate: assertValueType('string'),
        },
    },
});
defineType$2('JSXFragment', {
    builder: [
        'openingFragment',
        'closingFragment',
        'children',
    ],
    visitor: [
        'openingFragment',
        'children',
        'closingFragment',
    ],
    aliases: ['Immutable', 'Expression'],
    fields: {
        openingFragment: {
            validate: assertNodeType('JSXOpeningFragment'),
        },
        closingFragment: {
            validate: assertNodeType('JSXClosingFragment'),
        },
        children: validateArrayOfType('JSXText', 'JSXExpressionContainer', 'JSXSpreadChild', 'JSXElement', 'JSXFragment'),
    },
});
defineType$2('JSXOpeningFragment', {
    aliases: ['Immutable'],
});
defineType$2('JSXClosingFragment', {
    aliases: ['Immutable'],
});
var PLACEHOLDERS = [
    'Identifier',
    'StringLiteral',
    'Expression',
    'Statement',
    'Declaration',
    'BlockStatement',
    'ClassBody',
    'Pattern',
];

var PLACEHOLDERS_ALIAS = {
    Declaration: ['Statement'],
    Pattern: ['PatternLike', 'LVal'],
};

for (const type of PLACEHOLDERS) {
    const alias2 = ALIAS_KEYS[type];
    
    if (alias2?.length)
        PLACEHOLDERS_ALIAS[type] = alias2;
}

var PLACEHOLDERS_FLIPPED_ALIAS = {};

Object
    .keys(PLACEHOLDERS_ALIAS)
    .forEach((type) => {
        PLACEHOLDERS_ALIAS[type].forEach((alias2) => {
            if (!Object.hasOwn(PLACEHOLDERS_FLIPPED_ALIAS, alias2)) {
                PLACEHOLDERS_FLIPPED_ALIAS[alias2] = [];
            }
            
            PLACEHOLDERS_FLIPPED_ALIAS[alias2].push(type);
        });
    });
var defineType$1 = defineAliasedType('Miscellaneous');

defineType$1('Placeholder', {
    visitor: [],
    builder: ['expectedNode', 'name'],
    fields: Object.assign({
        name: {
            validate: assertNodeType('Identifier'),
        },
        expectedNode: {
            validate: assertOneOf(...PLACEHOLDERS),
        },
    }, patternLikeCommon()),
});
defineType$1('V8IntrinsicIdentifier', {
    builder: ['name'],
    fields: {
        name: {
            validate: assertValueType('string'),
        },
    },
});
defineType$5('ArgumentPlaceholder', {});
defineType$5('BindExpression', {
    visitor: ['object', 'callee'],
    aliases: ['Expression'],
    fields: {
        object: {
            validate: assertNodeType('Expression'),
        },
        callee: {
            validate: assertNodeType('Expression'),
        },
    },
});
defineType$5('Decorator', {
    visitor: ['expression'],
    fields: {
        expression: {
            validate: assertNodeType('Expression'),
        },
    },
});
defineType$5('DoExpression', {
    visitor: ['body'],
    builder: ['body', 'async'],
    aliases: ['Expression'],
    fields: {
        body: {
            validate: assertNodeType('BlockStatement'),
        },
        async: {
            validate: assertValueType('boolean'),
            default: false,
        },
    },
});
defineType$5('ExportDefaultSpecifier', {
    visitor: ['exported'],
    aliases: ['ModuleSpecifier'],
    fields: {
        exported: {
            validate: assertNodeType('Identifier'),
        },
    },
});
defineType$5('RecordExpression', {
    visitor: ['properties'],
    aliases: ['Expression'],
    fields: {
        properties: validateArrayOfType('ObjectProperty', 'SpreadElement'),
    },
});
defineType$5('TupleExpression', {
    fields: {
        elements: {
            validate: arrayOfType('Expression', 'SpreadElement'),
            default: [],
        },
    },
    visitor: ['elements'],
    aliases: ['Expression'],
});
defineType$5('ModuleExpression', {
    visitor: ['body'],
    fields: {
        body: {
            validate: assertNodeType('Program'),
        },
    },
    aliases: ['Expression'],
});
defineType$5('TopicReference', {
    aliases: ['Expression'],
});
defineType$5('PipelineTopicExpression', {
    builder: ['expression'],
    visitor: ['expression'],
    fields: {
        expression: {
            validate: assertNodeType('Expression'),
        },
    },
    aliases: ['Expression'],
});
defineType$5('PipelineBareFunction', {
    builder: ['callee'],
    visitor: ['callee'],
    fields: {
        callee: {
            validate: assertNodeType('Expression'),
        },
    },
    aliases: ['Expression'],
});
defineType$5('PipelinePrimaryTopicReference', {
    aliases: ['Expression'],
});
defineType$5('VoidPattern', {
    aliases: [
        'Pattern',
        'PatternLike',
        'FunctionParameter',
    ],
});
var defineType = defineAliasedType('TypeScript');
var bool = assertValueType('boolean');

var tSFunctionTypeAnnotationCommon = () => ({
    returnType: {
        validate: assertNodeType('TSTypeAnnotation'),
        optional: true,
    },
    typeParameters: {
        validate: assertNodeType('TSTypeParameterDeclaration'),
        optional: true,
    },
});

defineType('TSParameterProperty', {
    aliases: [],
    visitor: ['parameter'],
    fields: {
        accessibility: {
            validate: assertOneOf('public', 'private', 'protected'),
            optional: true,
        },
        readonly: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        parameter: {
            validate: assertNodeType('Identifier', 'AssignmentPattern'),
        },
        override: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        decorators: {
            validate: arrayOfType('Decorator'),
            optional: true,
        },
    },
});
defineType('TSDeclareFunction', {
    aliases: ['Statement', 'Declaration'],
    visitor: [
        'id',
        'typeParameters',
        'params',
        'returnType',
    ],
    fields: Object.assign({}, functionDeclarationCommon(), tSFunctionTypeAnnotationCommon()),
});
defineType('TSDeclareMethod', {
    visitor: [
        'decorators',
        'key',
        'typeParameters',
        'params',
        'returnType',
    ],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon(), tSFunctionTypeAnnotationCommon()),
});
defineType('TSQualifiedName', {
    aliases: ['TSEntityName'],
    visitor: ['left', 'right'],
    fields: {
        left: validateType('TSEntityName'),
        right: validateType('Identifier'),
    },
});
var signatureDeclarationCommon = () => ({
    typeParameters: validateOptionalType('TSTypeParameterDeclaration'),
    ['params']: validateArrayOfType('ArrayPattern', 'Identifier', 'ObjectPattern', 'RestElement'),
    ['returnType']: validateOptionalType('TSTypeAnnotation'),
});

var callConstructSignatureDeclaration = {
    aliases: ['TSTypeElement'],
    visitor: [
        'typeParameters',
        'params',
        'returnType',
    ],
    fields: signatureDeclarationCommon(),
};

defineType('TSCallSignatureDeclaration', callConstructSignatureDeclaration);
defineType('TSConstructSignatureDeclaration', callConstructSignatureDeclaration);
var namedTypeElementCommon = () => ({
    key: validateType('Expression'),
    computed: {
        default: false,
    },
    optional: validateOptional(bool),
});

defineType('TSPropertySignature', {
    aliases: ['TSTypeElement'],
    visitor: ['key', 'typeAnnotation'],
    fields: Object.assign({}, namedTypeElementCommon(), {
        readonly: validateOptional(bool),
        typeAnnotation: validateOptionalType('TSTypeAnnotation'),
        kind: {
            optional: true,
            validate: assertOneOf('get', 'set'),
        },
    }),
});
defineType('TSMethodSignature', {
    aliases: ['TSTypeElement'],
    visitor: [
        'key',
        'typeParameters',
        'params',
        'returnType',
    ],
    fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
        kind: {
            validate: assertOneOf('method', 'get', 'set'),
        },
    }),
});
defineType('TSIndexSignature', {
    aliases: ['TSTypeElement'],
    visitor: ['parameters', 'typeAnnotation'],
    fields: {
        readonly: validateOptional(bool),
        static: validateOptional(bool),
        parameters: validateArrayOfType('Identifier'),
        typeAnnotation: validateOptionalType('TSTypeAnnotation'),
    },
});
var tsKeywordTypes = [
    'TSAnyKeyword',
    'TSBooleanKeyword',
    'TSBigIntKeyword',
    'TSIntrinsicKeyword',
    'TSNeverKeyword',
    'TSNullKeyword',
    'TSNumberKeyword',
    'TSObjectKeyword',
    'TSStringKeyword',
    'TSSymbolKeyword',
    'TSUndefinedKeyword',
    'TSUnknownKeyword',
    'TSVoidKeyword',
];

for (const type of tsKeywordTypes) {
    defineType(type, {
        aliases: ['TSType', 'TSBaseType'],
        visitor: [],
        fields: {},
    });
}

defineType('TSThisType', {
    aliases: ['TSType', 'TSBaseType'],
    visitor: [],
    fields: {},
});

var fnOrCtrBase = {
    aliases: ['TSType'],
    visitor: [
        'typeParameters',
        'params',
        'returnType',
    ],
};

defineType('TSFunctionType', Object.assign({},
    fnOrCtrBase,{
        fields: signatureDeclarationCommon(),
    },
));
defineType('TSConstructorType', Object.assign({},
    fnOrCtrBase,{
        fields: Object.assign({}, signatureDeclarationCommon(), {
            abstract: validateOptional(bool),
        }),
    },
));
defineType('TSTypeReference', {
    aliases: ['TSType'],
    visitor: ['typeName', 'typeArguments'],
    fields: {
        typeName: validateType('TSEntityName'),
        ['typeArguments']: validateOptionalType('TSTypeParameterInstantiation'),
    },
});
defineType('TSTypePredicate', {
    aliases: ['TSType'],
    visitor: ['parameterName', 'typeAnnotation'],
    builder: [
        'parameterName',
        'typeAnnotation',
        'asserts',
    ],
    fields: {
        parameterName: validateType('Identifier', 'TSThisType'),
        typeAnnotation: validateOptionalType('TSTypeAnnotation'),
        asserts: validateOptional(bool),
    },
});
defineType('TSTypeQuery', {
    aliases: ['TSType'],
    visitor: ['exprName', 'typeArguments'],
    fields: {
        exprName: validateType('TSEntityName', 'TSImportType'),
        ['typeArguments']: validateOptionalType('TSTypeParameterInstantiation'),
    },
});
defineType('TSTypeLiteral', {
    aliases: ['TSType'],
    visitor: ['members'],
    fields: {
        members: validateArrayOfType('TSTypeElement'),
    },
});
defineType('TSArrayType', {
    aliases: ['TSType'],
    visitor: ['elementType'],
    fields: {
        elementType: validateType('TSType'),
    },
});
defineType('TSTupleType', {
    aliases: ['TSType'],
    visitor: ['elementTypes'],
    fields: {
        elementTypes: validateArrayOfType('TSType', 'TSNamedTupleMember'),
    },
});
defineType('TSOptionalType', {
    aliases: ['TSType'],
    visitor: ['typeAnnotation'],
    fields: {
        typeAnnotation: validateType('TSType'),
    },
});
defineType('TSRestType', {
    aliases: ['TSType'],
    visitor: ['typeAnnotation'],
    fields: {
        typeAnnotation: validateType('TSType'),
    },
});
defineType('TSNamedTupleMember', {
    visitor: ['label', 'elementType'],
    builder: [
        'label',
        'elementType',
        'optional',
    ],
    fields: {
        label: validateType('Identifier'),
        optional: {
            validate: bool,
            default: false,
        },
        elementType: validateType('TSType'),
    },
});
var unionOrIntersection = {
    aliases: ['TSType'],
    visitor: ['types'],
    fields: {
        types: validateArrayOfType('TSType'),
    },
};

defineType('TSUnionType', unionOrIntersection);
defineType('TSIntersectionType', unionOrIntersection);
defineType('TSConditionalType', {
    aliases: ['TSType'],
    visitor: [
        'checkType',
        'extendsType',
        'trueType',
        'falseType',
    ],
    fields: {
        checkType: validateType('TSType'),
        extendsType: validateType('TSType'),
        trueType: validateType('TSType'),
        falseType: validateType('TSType'),
    },
});
defineType('TSInferType', {
    aliases: ['TSType'],
    visitor: ['typeParameter'],
    fields: {
        typeParameter: validateType('TSTypeParameter'),
    },
});
defineType('TSParenthesizedType', {
    aliases: ['TSType'],
    visitor: ['typeAnnotation'],
    fields: {
        typeAnnotation: validateType('TSType'),
    },
});
defineType('TSTypeOperator', {
    aliases: ['TSType'],
    visitor: ['typeAnnotation'],
    builder: ['typeAnnotation', 'operator'],
    fields: {
        operator: {
            validate: assertOneOf('keyof', 'readonly', 'unique'),
            default: void 0,
        },
        typeAnnotation: validateType('TSType'),
    },
});
defineType('TSIndexedAccessType', {
    aliases: ['TSType'],
    visitor: ['objectType', 'indexType'],
    fields: {
        objectType: validateType('TSType'),
        indexType: validateType('TSType'),
    },
});
defineType('TSMappedType', {
    aliases: ['TSType'],
    visitor: [
        'key',
        'constraint',
        'nameType',
        'typeAnnotation',
    ],
    builder: [
        'key',
        'constraint',
        'nameType',
        'typeAnnotation',
    ],
    fields: Object.assign({}, {
        key: validateType('Identifier'),
        constraint: validateType('TSType'),
    }, {
        readonly: validateOptional(assertOneOf(true, false, '+', '-')),
        optional: validateOptional(assertOneOf(true, false, '+', '-')),
        typeAnnotation: validateOptionalType('TSType'),
        nameType: validateOptionalType('TSType'),
    }),
});
defineType('TSTemplateLiteralType', {
    aliases: ['TSType', 'TSBaseType'],
    visitor: ['quasis', 'types'],
    fields: {
        quasis: validateArrayOfType('TemplateElement'),
        types: {
            validate: chain$4(assertValueType('array'), assertEach(assertNodeType('TSType')), function(node, key, val) {
                if (node.quasis.length !== val.length + 1) {
                    throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of types.
Expected ${val.length + 1} quasis but got ${node.quasis.length}`);
                }
            }),
        },
    },
});
defineType('TSLiteralType', {
    aliases: ['TSType', 'TSBaseType'],
    visitor: ['literal'],
    fields: {
        literal: {
            validate: (function() {
                const unaryExpression3 = assertNodeType('NumericLiteral', 'BigIntLiteral');
                const unaryOperator = assertOneOf('-');
                const literal = assertNodeType('NumericLiteral', 'StringLiteral', 'BooleanLiteral', 'BigIntLiteral', 'TemplateLiteral');
                
                function validator(parent, key, node) {
                    if (is$4('UnaryExpression', node)) {
                        unaryOperator(node, 'operator', node.operator);
                        unaryExpression3(node, 'argument', node.argument);
                    } else {
                        literal(parent, key, node);
                    }
                }
                
                validator.oneOfNodeTypes = [
                    'NumericLiteral',
                    'StringLiteral',
                    'BooleanLiteral',
                    'BigIntLiteral',
                    'TemplateLiteral',
                    'UnaryExpression',
                ];
                return validator;
            })(),
        },
    },
});
{
    defineType('TSClassImplements', {
        aliases: ['TSType'],
        visitor: ['expression', 'typeArguments'],
        fields: {
            expression: validateType('Expression'),
            typeArguments: validateOptionalType('TSTypeParameterInstantiation'),
        },
    });
    defineType('TSInterfaceHeritage', {
        aliases: ['TSType'],
        visitor: ['expression', 'typeArguments'],
        fields: {
            expression: validateType('Expression'),
            typeArguments: validateOptionalType('TSTypeParameterInstantiation'),
        },
    });
}
defineType('TSInterfaceDeclaration', {
    aliases: ['Statement', 'Declaration'],
    visitor: [
        'id',
        'typeParameters',
        'extends',
        'body',
    ],
    fields: {
        declare: validateOptional(bool),
        id: validateType('Identifier'),
        typeParameters: validateOptionalType('TSTypeParameterDeclaration'),
        extends: validateOptional(arrayOfType('TSClassImplements')),
        body: validateType('TSInterfaceBody'),
    },
});
defineType('TSInterfaceBody', {
    visitor: ['body'],
    fields: {
        body: validateArrayOfType('TSTypeElement'),
    },
});
defineType('TSTypeAliasDeclaration', {
    aliases: ['Statement', 'Declaration'],
    visitor: [
        'id',
        'typeParameters',
        'typeAnnotation',
    ],
    fields: {
        declare: validateOptional(bool),
        id: validateType('Identifier'),
        typeParameters: validateOptionalType('TSTypeParameterDeclaration'),
        typeAnnotation: validateType('TSType'),
    },
});
defineType('TSInstantiationExpression', {
    aliases: ['Expression'],
    visitor: ['expression', 'typeArguments'],
    fields: {
        expression: validateType('Expression'),
        ['typeArguments']: validateOptionalType('TSTypeParameterInstantiation'),
    },
});
var TSTypeExpression = {
    aliases: [
        'Expression',
        'LVal',
        'PatternLike',
    ],
    visitor: ['expression', 'typeAnnotation'],
    fields: {
        expression: validateType('Expression'),
        typeAnnotation: validateType('TSType'),
    },
};

defineType('TSAsExpression', TSTypeExpression);
defineType('TSSatisfiesExpression', TSTypeExpression);
defineType('TSTypeAssertion', {
    aliases: [
        'Expression',
        'LVal',
        'PatternLike',
    ],
    visitor: ['typeAnnotation', 'expression'],
    fields: {
        typeAnnotation: validateType('TSType'),
        expression: validateType('Expression'),
    },
});
defineType('TSEnumBody', {
    visitor: ['members'],
    fields: {
        members: validateArrayOfType('TSEnumMember'),
    },
});
{
    defineType('TSEnumDeclaration', {
        aliases: ['Statement', 'Declaration'],
        visitor: ['id', 'body'],
        fields: {
            declare: validateOptional(bool),
            const: validateOptional(bool),
            id: validateType('Identifier'),
            body: validateType('TSEnumBody'),
        },
    });
}
defineType('TSEnumMember', {
    visitor: ['id', 'initializer'],
    fields: {
        id: validateType('Identifier', 'StringLiteral'),
        initializer: validateOptionalType('Expression'),
    },
});
defineType('TSModuleDeclaration', {
    aliases: ['Statement', 'Declaration'],
    visitor: ['id', 'body'],
    fields: Object.assign({
        kind: {
            validate: assertOneOf('global', 'module', 'namespace'),
        },
        declare: validateOptional(bool),
    }, false, {
        id: validateType('TSEntityName', 'StringLiteral'),
        body: validateType('TSModuleBlock'),
    }),
});
defineType('TSModuleBlock', {
    aliases: [
        'Scopable',
        'Block',
        'BlockParent',
        'FunctionParent',
    ],
    visitor: ['body'],
    fields: {
        body: validateArrayOfType('Statement'),
    },
});
defineType('TSImportType', {
    aliases: ['TSType'],
    builder: [
        'argument',
        'qualifier',
        'typeArguments',
    ],
    visitor: [
        'argument',
        'options',
        'qualifier',
        'typeArguments',
    ],
    fields: {
        argument: validateType('TSLiteralType'),
        qualifier: validateOptionalType('TSEntityName'),
        ['typeArguments']: validateOptionalType('TSTypeParameterInstantiation'),
        options: {
            validate: assertNodeType('ObjectExpression'),
            optional: true,
        },
    },
});
defineType('TSImportEqualsDeclaration', {
    aliases: ['Statement', 'Declaration'],
    visitor: ['id', 'moduleReference'],
    fields: Object.assign({}, {}, {
        id: validateType('Identifier'),
        moduleReference: validateType('TSEntityName', 'TSExternalModuleReference'),
        importKind: {
            validate: assertOneOf('type', 'value'),
            optional: true,
        },
    }),
});
defineType('TSExternalModuleReference', {
    visitor: ['expression'],
    fields: {
        expression: validateType('StringLiteral'),
    },
});
defineType('TSNonNullExpression', {
    aliases: [
        'Expression',
        'LVal',
        'PatternLike',
    ],
    visitor: ['expression'],
    fields: {
        expression: validateType('Expression'),
    },
});
defineType('TSExportAssignment', {
    aliases: ['Statement'],
    visitor: ['expression'],
    fields: {
        expression: validateType('Expression'),
    },
});
defineType('TSNamespaceExportDeclaration', {
    aliases: ['Statement'],
    visitor: ['id'],
    fields: {
        id: validateType('Identifier'),
    },
});
defineType('TSTypeAnnotation', {
    visitor: ['typeAnnotation'],
    fields: {
        typeAnnotation: {
            validate: assertNodeType('TSType'),
        },
    },
});
defineType('TSTypeParameterInstantiation', {
    visitor: ['params'],
    fields: {
        params: validateArrayOfType('TSType'),
    },
});
defineType('TSTypeParameterDeclaration', {
    visitor: ['params'],
    fields: {
        params: validateArrayOfType('TSTypeParameter'),
    },
});
defineType('TSTypeParameter', {
    builder: [
        'constraint',
        'default',
        'name',
    ],
    visitor: [
        'name',
        'constraint',
        'default',
    ],
    fields: {
        name: {
            validate: assertNodeType('Identifier'),
        },
        in: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        out: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        const: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        constraint: {
            validate: assertNodeType('TSType'),
            optional: true,
        },
        default: {
            validate: assertNodeType('TSType'),
            optional: true,
        },
    },
});
var DEPRECATED_ALIASES = {
    ModuleDeclaration: 'ImportOrExportDeclaration',
};

Object
    .keys(DEPRECATED_ALIASES)
    .forEach((deprecatedAlias) => {
        FLIPPED_ALIAS_KEYS[deprecatedAlias] = FLIPPED_ALIAS_KEYS[DEPRECATED_ALIASES[deprecatedAlias]];
    });
for (const {types: types2, set} of allExpandedTypes) {
    for (const type of types2) {
        const aliases = FLIPPED_ALIAS_KEYS[type];
        
        if (aliases) {
            aliases.forEach(set.add, set);
        } else {
            set.add(type);
        }
    }
}

var TYPES$4 = [].concat(Object.keys(VISITOR_KEYS), Object.keys(FLIPPED_ALIAS_KEYS), Object.keys(DEPRECATED_KEYS));

function validate$1$1(node, key, val) {
    if (!node)
        return;
    
    const fields = NODE_FIELDS$1[node.type];
    
    if (!fields)
        return;
    
    const field = fields[key];
    validateField(node, key, val, field);
    validateChild(node, key, val);
}

function validateInternal(field, node, key, val, maybeNode) {
    if (!field?.validate)
        return;
    
    if (field.optional && val == null)
        return;
    
    field.validate(node, key, val);
    
    if (maybeNode) {
        const type = val.type;
        
        if (type == null)
            return;
        
        NODE_PARENT_VALIDATIONS[type]?.(node, key, val);
    }
}

function validateField(node, key, val, field) {
    if (!field?.validate)
        return;
    
    if (field.optional && val == null)
        return;
    
    field.validate(node, key, val);
}

function validateChild(node, key, val) {
    const type = val?.type;
    
    if (type == null)
        return;
    
    NODE_PARENT_VALIDATIONS[type]?.(node, key, val);
}

var _validate = /* @__PURE__ */Object.freeze({
    __proto__: null,
    default: validate$1$1,
    validateChild,
    validateField,
    validateInternal,
});

var {validateInternal: validate$4} = _validate;

var {NODE_FIELDS} = utils$1;

function arrayExpression$4(elements) {
    const node = {
        type: 'ArrayExpression',
        elements,
    };
    
    const defs = NODE_FIELDS.ArrayExpression;
    validate$4(defs.elements, node, 'elements', elements, 1);
    return node;
}

function assignmentExpression$1(operator, left, right) {
    const node = {
        type: 'AssignmentExpression',
        operator,
        left,
        right,
    };
    
    const defs = NODE_FIELDS.AssignmentExpression;
    validate$4(defs.operator, node, 'operator', operator);
    validate$4(defs.left, node, 'left', left, 1);
    validate$4(defs.right, node, 'right', right, 1);
    return node;
}

function binaryExpression$1(operator, left, right) {
    const node = {
        type: 'BinaryExpression',
        operator,
        left,
        right,
    };
    
    const defs = NODE_FIELDS.BinaryExpression;
    validate$4(defs.operator, node, 'operator', operator);
    validate$4(defs.left, node, 'left', left, 1);
    validate$4(defs.right, node, 'right', right, 1);
    return node;
}

function interpreterDirective(value) {
    const node = {
        type: 'InterpreterDirective',
        value,
    };
    
    const defs = NODE_FIELDS.InterpreterDirective;
    validate$4(defs.value, node, 'value', value);
    return node;
}

function directive$1(value) {
    const node = {
        type: 'Directive',
        value,
    };
    
    const defs = NODE_FIELDS.Directive;
    validate$4(defs.value, node, 'value', value, 1);
    return node;
}

function directiveLiteral$2(value) {
    const node = {
        type: 'DirectiveLiteral',
        value,
    };
    
    const defs = NODE_FIELDS.DirectiveLiteral;
    validate$4(defs.value, node, 'value', value);
    return node;
}

function blockStatement$2(body, directives = []) {
    const node = {
        type: 'BlockStatement',
        body,
        directives,
    };
    
    const defs = NODE_FIELDS.BlockStatement;
    validate$4(defs.body, node, 'body', body, 1);
    validate$4(defs.directives, node, 'directives', directives, 1);
    return node;
}

function breakStatement$1(label = null) {
    const node = {
        type: 'BreakStatement',
        label,
    };
    
    const defs = NODE_FIELDS.BreakStatement;
    validate$4(defs.label, node, 'label', label, 1);
    return node;
}

function callExpression$1(callee, _arguments) {
    const node = {
        type: 'CallExpression',
        callee,
        arguments: _arguments,
    };
    
    const defs = NODE_FIELDS.CallExpression;
    validate$4(defs.callee, node, 'callee', callee, 1);
    validate$4(defs.arguments, node, 'arguments', _arguments, 1);
    return node;
}

function catchClause(param = null, body) {
    const node = {
        type: 'CatchClause',
        param,
        body,
    };
    
    const defs = NODE_FIELDS.CatchClause;
    validate$4(defs.param, node, 'param', param, 1);
    validate$4(defs.body, node, 'body', body, 1);
    return node;
}

function conditionalExpression$1(test, consequent, alternate) {
    const node = {
        type: 'ConditionalExpression',
        test,
        consequent,
        alternate,
    };
    
    const defs = NODE_FIELDS.ConditionalExpression;
    validate$4(defs.test, node, 'test', test, 1);
    validate$4(defs.consequent, node, 'consequent', consequent, 1);
    validate$4(defs.alternate, node, 'alternate', alternate, 1);
    return node;
}

function continueStatement$1(label = null) {
    const node = {
        type: 'ContinueStatement',
        label,
    };
    
    const defs = NODE_FIELDS.ContinueStatement;
    validate$4(defs.label, node, 'label', label, 1);
    return node;
}

function debuggerStatement$1() {
    return {
        type: 'DebuggerStatement',
    };
}

function doWhileStatement$1(test, body) {
    const node = {
        type: 'DoWhileStatement',
        test,
        body,
    };
    
    const defs = NODE_FIELDS.DoWhileStatement;
    validate$4(defs.test, node, 'test', test, 1);
    validate$4(defs.body, node, 'body', body, 1);
    return node;
}

function emptyStatement$1() {
    return {
        type: 'EmptyStatement',
    };
}

function expressionStatement$5(expression2) {
    const node = {
        type: 'ExpressionStatement',
        expression: expression2,
    };
    
    const defs = NODE_FIELDS.ExpressionStatement;
    validate$4(defs.expression, node, 'expression', expression2, 1);
    return node;
}

function file$1(program3, comments = null, tokens = null) {
    const node = {
        type: 'File',
        program: program3,
        comments,
        tokens,
    };
    
    const defs = NODE_FIELDS.File;
    validate$4(defs.program, node, 'program', program3, 1);
    validate$4(defs.comments, node, 'comments', comments, 1);
    validate$4(defs.tokens, node, 'tokens', tokens);
    return node;
}

function forInStatement$1(left, right, body) {
    const node = {
        type: 'ForInStatement',
        left,
        right,
        body,
    };
    
    const defs = NODE_FIELDS.ForInStatement;
    validate$4(defs.left, node, 'left', left, 1);
    validate$4(defs.right, node, 'right', right, 1);
    validate$4(defs.body, node, 'body', body, 1);
    return node;
}

function forStatement$1(init = null, test = null, update = null, body) {
    const node = {
        type: 'ForStatement',
        init,
        test,
        update,
        body,
    };
    
    const defs = NODE_FIELDS.ForStatement;
    validate$4(defs.init, node, 'init', init, 1);
    validate$4(defs.test, node, 'test', test, 1);
    validate$4(defs.update, node, 'update', update, 1);
    validate$4(defs.body, node, 'body', body, 1);
    return node;
}

function functionDeclaration$1(id = null, params, body, generator = false, async = false) {
    const node = {
        type: 'FunctionDeclaration',
        id,
        params,
        body,
        generator,
        async,
    };
    
    const defs = NODE_FIELDS.FunctionDeclaration;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.params, node, 'params', params, 1);
    validate$4(defs.body, node, 'body', body, 1);
    validate$4(defs.generator, node, 'generator', generator);
    validate$4(defs.async, node, 'async', async);
    return node;
}

function functionExpression$1(id = null, params, body, generator = false, async = false) {
    const node = {
        type: 'FunctionExpression',
        id,
        params,
        body,
        generator,
        async,
    };
    
    const defs = NODE_FIELDS.FunctionExpression;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.params, node, 'params', params, 1);
    validate$4(defs.body, node, 'body', body, 1);
    validate$4(defs.generator, node, 'generator', generator);
    validate$4(defs.async, node, 'async', async);
    return node;
}

function identifier$3(name) {
    const node = {
        type: 'Identifier',
        name,
    };
    
    const defs = NODE_FIELDS.Identifier;
    validate$4(defs.name, node, 'name', name);
    return node;
}

function ifStatement$1(test, consequent, alternate = null) {
    const node = {
        type: 'IfStatement',
        test,
        consequent,
        alternate,
    };
    
    const defs = NODE_FIELDS.IfStatement;
    validate$4(defs.test, node, 'test', test, 1);
    validate$4(defs.consequent, node, 'consequent', consequent, 1);
    validate$4(defs.alternate, node, 'alternate', alternate, 1);
    return node;
}

function labeledStatement$1(label, body) {
    const node = {
        type: 'LabeledStatement',
        label,
        body,
    };
    
    const defs = NODE_FIELDS.LabeledStatement;
    validate$4(defs.label, node, 'label', label, 1);
    validate$4(defs.body, node, 'body', body, 1);
    return node;
}

function stringLiteral$5(value) {
    const node = {
        type: 'StringLiteral',
        value,
    };
    
    const defs = NODE_FIELDS.StringLiteral;
    validate$4(defs.value, node, 'value', value);
    return node;
}

function numericLiteral(value) {
    const node = {
        type: 'NumericLiteral',
        value,
    };
    
    const defs = NODE_FIELDS.NumericLiteral;
    validate$4(defs.value, node, 'value', value);
    return node;
}

function nullLiteral() {
    return {
        type: 'NullLiteral',
    };
}

function booleanLiteral(value) {
    const node = {
        type: 'BooleanLiteral',
        value,
    };
    
    const defs = NODE_FIELDS.BooleanLiteral;
    validate$4(defs.value, node, 'value', value);
    return node;
}

function regExpLiteral(pattern, flags = '') {
    const node = {
        type: 'RegExpLiteral',
        pattern,
        flags,
    };
    
    const defs = NODE_FIELDS.RegExpLiteral;
    validate$4(defs.pattern, node, 'pattern', pattern);
    validate$4(defs.flags, node, 'flags', flags);
    return node;
}

function logicalExpression$1(operator, left, right) {
    const node = {
        type: 'LogicalExpression',
        operator,
        left,
        right,
    };
    
    const defs = NODE_FIELDS.LogicalExpression;
    validate$4(defs.operator, node, 'operator', operator);
    validate$4(defs.left, node, 'left', left, 1);
    validate$4(defs.right, node, 'right', right, 1);
    return node;
}

function memberExpression(object, property, computed = false) {
    const node = {
        type: 'MemberExpression',
        object,
        property,
        computed,
    };
    
    const defs = NODE_FIELDS.MemberExpression;
    validate$4(defs.object, node, 'object', object, 1);
    validate$4(defs.property, node, 'property', property, 1);
    validate$4(defs.computed, node, 'computed', computed);
    return node;
}

function newExpression$1(callee, _arguments) {
    const node = {
        type: 'NewExpression',
        callee,
        arguments: _arguments,
    };
    
    const defs = NODE_FIELDS.NewExpression;
    validate$4(defs.callee, node, 'callee', callee, 1);
    validate$4(defs.arguments, node, 'arguments', _arguments, 1);
    return node;
}

function program$2(body, directives = [], sourceType = 'script', interpreter = null) {
    const node = {
        type: 'Program',
        body,
        directives,
        sourceType,
        interpreter,
    };
    
    const defs = NODE_FIELDS.Program;
    validate$4(defs.body, node, 'body', body, 1);
    validate$4(defs.directives, node, 'directives', directives, 1);
    validate$4(defs.sourceType, node, 'sourceType', sourceType);
    validate$4(defs.interpreter, node, 'interpreter', interpreter, 1);
    return node;
}

function objectExpression$3(properties) {
    const node = {
        type: 'ObjectExpression',
        properties,
    };
    
    const defs = NODE_FIELDS.ObjectExpression;
    validate$4(defs.properties, node, 'properties', properties, 1);
    return node;
}

function objectMethod$2(kind, key, params, body, computed = false, generator = false, async = false) {
    const node = {
        type: 'ObjectMethod',
        kind,
        key,
        params,
        body,
        computed,
        generator,
        async,
    };
    
    const defs = NODE_FIELDS.ObjectMethod;
    validate$4(defs.kind, node, 'kind', kind);
    validate$4(defs.key, node, 'key', key, 1);
    validate$4(defs.params, node, 'params', params, 1);
    validate$4(defs.body, node, 'body', body, 1);
    validate$4(defs.computed, node, 'computed', computed);
    validate$4(defs.generator, node, 'generator', generator);
    validate$4(defs.async, node, 'async', async);
    return node;
}

function objectProperty$4(key, value, computed = false, shorthand = false) {
    const node = {
        type: 'ObjectProperty',
        key,
        value,
        computed,
        shorthand,
    };
    
    const defs = NODE_FIELDS.ObjectProperty;
    validate$4(defs.key, node, 'key', key, 1);
    validate$4(defs.value, node, 'value', value, 1);
    validate$4(defs.computed, node, 'computed', computed);
    validate$4(defs.shorthand, node, 'shorthand', shorthand);
    return node;
}

function restElement$1(argument) {
    const node = {
        type: 'RestElement',
        argument,
    };
    
    const defs = NODE_FIELDS.RestElement;
    validate$4(defs.argument, node, 'argument', argument, 1);
    return node;
}

function returnStatement$1(argument = null) {
    const node = {
        type: 'ReturnStatement',
        argument,
    };
    
    const defs = NODE_FIELDS.ReturnStatement;
    validate$4(defs.argument, node, 'argument', argument, 1);
    return node;
}

function sequenceExpression$1(expressions) {
    const node = {
        type: 'SequenceExpression',
        expressions,
    };
    
    const defs = NODE_FIELDS.SequenceExpression;
    validate$4(defs.expressions, node, 'expressions', expressions, 1);
    return node;
}

function parenthesizedExpression$3(expression2) {
    const node = {
        type: 'ParenthesizedExpression',
        expression: expression2,
    };
    
    const defs = NODE_FIELDS.ParenthesizedExpression;
    validate$4(defs.expression, node, 'expression', expression2, 1);
    return node;
}

function switchCase(test = null, consequent) {
    const node = {
        type: 'SwitchCase',
        test,
        consequent,
    };
    
    const defs = NODE_FIELDS.SwitchCase;
    validate$4(defs.test, node, 'test', test, 1);
    validate$4(defs.consequent, node, 'consequent', consequent, 1);
    return node;
}

function switchStatement$1(discriminant, cases) {
    const node = {
        type: 'SwitchStatement',
        discriminant,
        cases,
    };
    
    const defs = NODE_FIELDS.SwitchStatement;
    validate$4(defs.discriminant, node, 'discriminant', discriminant, 1);
    validate$4(defs.cases, node, 'cases', cases, 1);
    return node;
}

function thisExpression() {
    return {
        type: 'ThisExpression',
    };
}

function throwStatement(argument) {
    const node = {
        type: 'ThrowStatement',
        argument,
    };
    
    const defs = NODE_FIELDS.ThrowStatement;
    validate$4(defs.argument, node, 'argument', argument, 1);
    return node;
}

function tryStatement(block, handler = null, finalizer = null) {
    const node = {
        type: 'TryStatement',
        block,
        handler,
        finalizer,
    };
    
    const defs = NODE_FIELDS.TryStatement;
    validate$4(defs.block, node, 'block', block, 1);
    validate$4(defs.handler, node, 'handler', handler, 1);
    validate$4(defs.finalizer, node, 'finalizer', finalizer, 1);
    return node;
}

function unaryExpression$1(operator, argument, prefix2 = true) {
    const node = {
        type: 'UnaryExpression',
        operator,
        argument,
        prefix: prefix2,
    };
    
    const defs = NODE_FIELDS.UnaryExpression;
    validate$4(defs.operator, node, 'operator', operator);
    validate$4(defs.argument, node, 'argument', argument, 1);
    validate$4(defs.prefix, node, 'prefix', prefix2);
    return node;
}

function updateExpression(operator, argument, prefix2 = false) {
    const node = {
        type: 'UpdateExpression',
        operator,
        argument,
        prefix: prefix2,
    };
    
    const defs = NODE_FIELDS.UpdateExpression;
    validate$4(defs.operator, node, 'operator', operator);
    validate$4(defs.argument, node, 'argument', argument, 1);
    validate$4(defs.prefix, node, 'prefix', prefix2);
    return node;
}

function variableDeclaration$1(kind, declarations) {
    const node = {
        type: 'VariableDeclaration',
        kind,
        declarations,
    };
    
    const defs = NODE_FIELDS.VariableDeclaration;
    validate$4(defs.kind, node, 'kind', kind);
    validate$4(defs.declarations, node, 'declarations', declarations, 1);
    return node;
}

function variableDeclarator(id, init = null) {
    const node = {
        type: 'VariableDeclarator',
        id,
        init,
    };
    
    const defs = NODE_FIELDS.VariableDeclarator;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.init, node, 'init', init, 1);
    return node;
}

function whileStatement$1(test, body) {
    const node = {
        type: 'WhileStatement',
        test,
        body,
    };
    
    const defs = NODE_FIELDS.WhileStatement;
    validate$4(defs.test, node, 'test', test, 1);
    validate$4(defs.body, node, 'body', body, 1);
    return node;
}

function withStatement(object, body) {
    const node = {
        type: 'WithStatement',
        object,
        body,
    };
    
    const defs = NODE_FIELDS.WithStatement;
    validate$4(defs.object, node, 'object', object, 1);
    validate$4(defs.body, node, 'body', body, 1);
    return node;
}

function assignmentPattern$1(left, right) {
    const node = {
        type: 'AssignmentPattern',
        left,
        right,
    };
    
    const defs = NODE_FIELDS.AssignmentPattern;
    validate$4(defs.left, node, 'left', left, 1);
    validate$4(defs.right, node, 'right', right, 1);
    return node;
}

function arrayPattern$1(elements) {
    const node = {
        type: 'ArrayPattern',
        elements,
    };
    
    const defs = NODE_FIELDS.ArrayPattern;
    validate$4(defs.elements, node, 'elements', elements, 1);
    return node;
}

function arrowFunctionExpression$1(params, body, async = false) {
    const node = {
        type: 'ArrowFunctionExpression',
        params,
        body,
        async,
        expression: null,
    };
    
    const defs = NODE_FIELDS.ArrowFunctionExpression;
    validate$4(defs.params, node, 'params', params, 1);
    validate$4(defs.body, node, 'body', body, 1);
    validate$4(defs.async, node, 'async', async);
    return node;
}

function classBody(body) {
    const node = {
        type: 'ClassBody',
        body,
    };
    
    const defs = NODE_FIELDS.ClassBody;
    validate$4(defs.body, node, 'body', body, 1);
    return node;
}

function classExpression(id = null, superClass = null, body, decorators = null) {
    const node = {
        type: 'ClassExpression',
        id,
        superClass,
        body,
        decorators,
    };
    
    const defs = NODE_FIELDS.ClassExpression;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.superClass, node, 'superClass', superClass, 1);
    validate$4(defs.body, node, 'body', body, 1);
    validate$4(defs.decorators, node, 'decorators', decorators, 1);
    return node;
}

function classDeclaration(id = null, superClass = null, body, decorators = null) {
    const node = {
        type: 'ClassDeclaration',
        id,
        superClass,
        body,
        decorators,
    };
    
    const defs = NODE_FIELDS.ClassDeclaration;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.superClass, node, 'superClass', superClass, 1);
    validate$4(defs.body, node, 'body', body, 1);
    validate$4(defs.decorators, node, 'decorators', decorators, 1);
    return node;
}

function exportAllDeclaration$1(source) {
    const node = {
        type: 'ExportAllDeclaration',
        source,
    };
    
    const defs = NODE_FIELDS.ExportAllDeclaration;
    validate$4(defs.source, node, 'source', source, 1);
    return node;
}

function exportDefaultDeclaration$1(declaration) {
    const node = {
        type: 'ExportDefaultDeclaration',
        declaration,
    };
    
    const defs = NODE_FIELDS.ExportDefaultDeclaration;
    validate$4(defs.declaration, node, 'declaration', declaration, 1);
    return node;
}

function exportNamedDeclaration(declaration = null, specifiers = [], source = null) {
    const node = {
        type: 'ExportNamedDeclaration',
        declaration,
        specifiers,
        source,
    };
    
    const defs = NODE_FIELDS.ExportNamedDeclaration;
    validate$4(defs.declaration, node, 'declaration', declaration, 1);
    validate$4(defs.specifiers, node, 'specifiers', specifiers, 1);
    validate$4(defs.source, node, 'source', source, 1);
    return node;
}

function exportSpecifier(local, exported) {
    const node = {
        type: 'ExportSpecifier',
        local,
        exported,
    };
    
    const defs = NODE_FIELDS.ExportSpecifier;
    validate$4(defs.local, node, 'local', local, 1);
    validate$4(defs.exported, node, 'exported', exported, 1);
    return node;
}

function forOfStatement$1(left, right, body, _await = false) {
    const node = {
        type: 'ForOfStatement',
        left,
        right,
        body,
        await: _await,
    };
    
    const defs = NODE_FIELDS.ForOfStatement;
    validate$4(defs.left, node, 'left', left, 1);
    validate$4(defs.right, node, 'right', right, 1);
    validate$4(defs.body, node, 'body', body, 1);
    validate$4(defs.await, node, 'await', _await);
    return node;
}

function importDeclaration$1(specifiers, source) {
    const node = {
        type: 'ImportDeclaration',
        specifiers,
        source,
    };
    
    const defs = NODE_FIELDS.ImportDeclaration;
    validate$4(defs.specifiers, node, 'specifiers', specifiers, 1);
    validate$4(defs.source, node, 'source', source, 1);
    return node;
}

function importDefaultSpecifier(local) {
    const node = {
        type: 'ImportDefaultSpecifier',
        local,
    };
    
    const defs = NODE_FIELDS.ImportDefaultSpecifier;
    validate$4(defs.local, node, 'local', local, 1);
    return node;
}

function importNamespaceSpecifier(local) {
    const node = {
        type: 'ImportNamespaceSpecifier',
        local,
    };
    
    const defs = NODE_FIELDS.ImportNamespaceSpecifier;
    validate$4(defs.local, node, 'local', local, 1);
    return node;
}

function importSpecifier(local, imported) {
    const node = {
        type: 'ImportSpecifier',
        local,
        imported,
    };
    
    const defs = NODE_FIELDS.ImportSpecifier;
    validate$4(defs.local, node, 'local', local, 1);
    validate$4(defs.imported, node, 'imported', imported, 1);
    return node;
}

function importExpression$1(source, options = null) {
    const node = {
        type: 'ImportExpression',
        source,
        options,
    };
    
    const defs = NODE_FIELDS.ImportExpression;
    validate$4(defs.source, node, 'source', source, 1);
    validate$4(defs.options, node, 'options', options, 1);
    return node;
}

function metaProperty(meta, property) {
    const node = {
        type: 'MetaProperty',
        meta,
        property,
    };
    
    const defs = NODE_FIELDS.MetaProperty;
    validate$4(defs.meta, node, 'meta', meta, 1);
    validate$4(defs.property, node, 'property', property, 1);
    return node;
}

function classMethod$2(kind = 'method', key, params, body, computed = false, _static = false, generator = false, async = false) {
    const node = {
        type: 'ClassMethod',
        kind,
        key,
        params,
        body,
        computed,
        static: _static,
        generator,
        async,
    };
    
    const defs = NODE_FIELDS.ClassMethod;
    validate$4(defs.kind, node, 'kind', kind);
    validate$4(defs.key, node, 'key', key, 1);
    validate$4(defs.params, node, 'params', params, 1);
    validate$4(defs.body, node, 'body', body, 1);
    validate$4(defs.computed, node, 'computed', computed);
    validate$4(defs.static, node, 'static', _static);
    validate$4(defs.generator, node, 'generator', generator);
    validate$4(defs.async, node, 'async', async);
    return node;
}

function objectPattern$2(properties) {
    const node = {
        type: 'ObjectPattern',
        properties,
    };
    
    const defs = NODE_FIELDS.ObjectPattern;
    validate$4(defs.properties, node, 'properties', properties, 1);
    return node;
}

function spreadElement$1(argument) {
    const node = {
        type: 'SpreadElement',
        argument,
    };
    
    const defs = NODE_FIELDS.SpreadElement;
    validate$4(defs.argument, node, 'argument', argument, 1);
    return node;
}

function _super() {
    return {
        type: 'Super',
    };
}

function taggedTemplateExpression$1(tag, quasi) {
    const node = {
        type: 'TaggedTemplateExpression',
        tag,
        quasi,
    };
    
    const defs = NODE_FIELDS.TaggedTemplateExpression;
    validate$4(defs.tag, node, 'tag', tag, 1);
    validate$4(defs.quasi, node, 'quasi', quasi, 1);
    return node;
}

function templateElement$1(value, tail = false) {
    const node = {
        type: 'TemplateElement',
        value,
        tail,
    };
    
    const defs = NODE_FIELDS.TemplateElement;
    validate$4(defs.value, node, 'value', value);
    validate$4(defs.tail, node, 'tail', tail);
    return node;
}

function templateLiteral$1(quasis, expressions) {
    const node = {
        type: 'TemplateLiteral',
        quasis,
        expressions,
    };
    
    const defs = NODE_FIELDS.TemplateLiteral;
    validate$4(defs.quasis, node, 'quasis', quasis, 1);
    validate$4(defs.expressions, node, 'expressions', expressions, 1);
    return node;
}

function yieldExpression(argument = null, delegate = false) {
    const node = {
        type: 'YieldExpression',
        argument,
        delegate,
    };
    
    const defs = NODE_FIELDS.YieldExpression;
    validate$4(defs.argument, node, 'argument', argument, 1);
    validate$4(defs.delegate, node, 'delegate', delegate);
    return node;
}

function awaitExpression(argument) {
    const node = {
        type: 'AwaitExpression',
        argument,
    };
    
    const defs = NODE_FIELDS.AwaitExpression;
    validate$4(defs.argument, node, 'argument', argument, 1);
    return node;
}

function _import() {
    return {
        type: 'Import',
    };
}

function bigIntLiteral(value) {
    const node = {
        type: 'BigIntLiteral',
        value,
    };
    
    const defs = NODE_FIELDS.BigIntLiteral;
    validate$4(defs.value, node, 'value', value);
    return node;
}

function exportNamespaceSpecifier(exported) {
    const node = {
        type: 'ExportNamespaceSpecifier',
        exported,
    };
    
    const defs = NODE_FIELDS.ExportNamespaceSpecifier;
    validate$4(defs.exported, node, 'exported', exported, 1);
    return node;
}

function optionalMemberExpression(object, property, computed = false, optional) {
    const node = {
        type: 'OptionalMemberExpression',
        object,
        property,
        computed,
        optional,
    };
    
    const defs = NODE_FIELDS.OptionalMemberExpression;
    validate$4(defs.object, node, 'object', object, 1);
    validate$4(defs.property, node, 'property', property, 1);
    validate$4(defs.computed, node, 'computed', computed);
    validate$4(defs.optional, node, 'optional', optional);
    return node;
}

function optionalCallExpression(callee, _arguments, optional) {
    const node = {
        type: 'OptionalCallExpression',
        callee,
        arguments: _arguments,
        optional,
    };
    
    const defs = NODE_FIELDS.OptionalCallExpression;
    validate$4(defs.callee, node, 'callee', callee, 1);
    validate$4(defs.arguments, node, 'arguments', _arguments, 1);
    validate$4(defs.optional, node, 'optional', optional);
    return node;
}

function classProperty$1(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
    const node = {
        type: 'ClassProperty',
        key,
        value,
        typeAnnotation: typeAnnotation2,
        decorators,
        computed,
        static: _static,
    };
    
    const defs = NODE_FIELDS.ClassProperty;
    validate$4(defs.key, node, 'key', key, 1);
    validate$4(defs.value, node, 'value', value, 1);
    validate$4(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    validate$4(defs.decorators, node, 'decorators', decorators, 1);
    validate$4(defs.computed, node, 'computed', computed);
    validate$4(defs.static, node, 'static', _static);
    return node;
}

function classAccessorProperty(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
    const node = {
        type: 'ClassAccessorProperty',
        key,
        value,
        typeAnnotation: typeAnnotation2,
        decorators,
        computed,
        static: _static,
    };
    
    const defs = NODE_FIELDS.ClassAccessorProperty;
    validate$4(defs.key, node, 'key', key, 1);
    validate$4(defs.value, node, 'value', value, 1);
    validate$4(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    validate$4(defs.decorators, node, 'decorators', decorators, 1);
    validate$4(defs.computed, node, 'computed', computed);
    validate$4(defs.static, node, 'static', _static);
    return node;
}

function classPrivateProperty(key, value = null, decorators = null, _static = false) {
    const node = {
        type: 'ClassPrivateProperty',
        key,
        value,
        decorators,
        static: _static,
    };
    
    const defs = NODE_FIELDS.ClassPrivateProperty;
    validate$4(defs.key, node, 'key', key, 1);
    validate$4(defs.value, node, 'value', value, 1);
    validate$4(defs.decorators, node, 'decorators', decorators, 1);
    validate$4(defs.static, node, 'static', _static);
    return node;
}

function classPrivateMethod$1(kind = 'method', key, params, body, _static = false) {
    const node = {
        type: 'ClassPrivateMethod',
        kind,
        key,
        params,
        body,
        static: _static,
    };
    
    const defs = NODE_FIELDS.ClassPrivateMethod;
    validate$4(defs.kind, node, 'kind', kind);
    validate$4(defs.key, node, 'key', key, 1);
    validate$4(defs.params, node, 'params', params, 1);
    validate$4(defs.body, node, 'body', body, 1);
    validate$4(defs.static, node, 'static', _static);
    return node;
}

function privateName$1(id) {
    const node = {
        type: 'PrivateName',
        id,
    };
    
    const defs = NODE_FIELDS.PrivateName;
    validate$4(defs.id, node, 'id', id, 1);
    return node;
}

function staticBlock$1(body) {
    const node = {
        type: 'StaticBlock',
        body,
    };
    
    const defs = NODE_FIELDS.StaticBlock;
    validate$4(defs.body, node, 'body', body, 1);
    return node;
}

function importAttribute$1(key, value) {
    const node = {
        type: 'ImportAttribute',
        key,
        value,
    };
    
    const defs = NODE_FIELDS.ImportAttribute;
    validate$4(defs.key, node, 'key', key, 1);
    validate$4(defs.value, node, 'value', value, 1);
    return node;
}

function anyTypeAnnotation() {
    return {
        type: 'AnyTypeAnnotation',
    };
}

function arrayTypeAnnotation(elementType) {
    const node = {
        type: 'ArrayTypeAnnotation',
        elementType,
    };
    
    const defs = NODE_FIELDS.ArrayTypeAnnotation;
    validate$4(defs.elementType, node, 'elementType', elementType, 1);
    return node;
}

function booleanTypeAnnotation() {
    return {
        type: 'BooleanTypeAnnotation',
    };
}

function booleanLiteralTypeAnnotation(value) {
    const node = {
        type: 'BooleanLiteralTypeAnnotation',
        value,
    };
    
    const defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;
    validate$4(defs.value, node, 'value', value);
    return node;
}

function nullLiteralTypeAnnotation() {
    return {
        type: 'NullLiteralTypeAnnotation',
    };
}

function classImplements(id, typeParameters = null) {
    const node = {
        type: 'ClassImplements',
        id,
        typeParameters,
    };
    
    const defs = NODE_FIELDS.ClassImplements;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    return node;
}

function declareClass(id, typeParameters = null, _extends = null, body) {
    const node = {
        type: 'DeclareClass',
        id,
        typeParameters,
        extends: _extends,
        body,
    };
    
    const defs = NODE_FIELDS.DeclareClass;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$4(defs.extends, node, 'extends', _extends, 1);
    validate$4(defs.body, node, 'body', body, 1);
    return node;
}

function declareFunction(id) {
    const node = {
        type: 'DeclareFunction',
        id,
    };
    
    const defs = NODE_FIELDS.DeclareFunction;
    validate$4(defs.id, node, 'id', id, 1);
    return node;
}

function declareInterface(id, typeParameters = null, _extends = null, body) {
    const node = {
        type: 'DeclareInterface',
        id,
        typeParameters,
        extends: _extends,
        body,
    };
    
    const defs = NODE_FIELDS.DeclareInterface;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$4(defs.extends, node, 'extends', _extends, 1);
    validate$4(defs.body, node, 'body', body, 1);
    return node;
}

function declareModule(id, body, kind = null) {
    const node = {
        type: 'DeclareModule',
        id,
        body,
        kind,
    };
    
    const defs = NODE_FIELDS.DeclareModule;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.body, node, 'body', body, 1);
    validate$4(defs.kind, node, 'kind', kind);
    return node;
}

function declareModuleExports(typeAnnotation2) {
    const node = {
        type: 'DeclareModuleExports',
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.DeclareModuleExports;
    validate$4(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function declareTypeAlias(id, typeParameters = null, right) {
    const node = {
        type: 'DeclareTypeAlias',
        id,
        typeParameters,
        right,
    };
    
    const defs = NODE_FIELDS.DeclareTypeAlias;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$4(defs.right, node, 'right', right, 1);
    return node;
}

function declareOpaqueType(id, typeParameters = null, supertype = null) {
    const node = {
        type: 'DeclareOpaqueType',
        id,
        typeParameters,
        supertype,
    };
    
    const defs = NODE_FIELDS.DeclareOpaqueType;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$4(defs.supertype, node, 'supertype', supertype, 1);
    return node;
}

function declareVariable(id) {
    const node = {
        type: 'DeclareVariable',
        id,
    };
    
    const defs = NODE_FIELDS.DeclareVariable;
    validate$4(defs.id, node, 'id', id, 1);
    return node;
}

function declareExportDeclaration(declaration = null, specifiers = null, source = null, attributes = null) {
    const node = {
        type: 'DeclareExportDeclaration',
        declaration,
        specifiers,
        source,
        attributes,
    };
    
    const defs = NODE_FIELDS.DeclareExportDeclaration;
    validate$4(defs.declaration, node, 'declaration', declaration, 1);
    validate$4(defs.specifiers, node, 'specifiers', specifiers, 1);
    validate$4(defs.source, node, 'source', source, 1);
    validate$4(defs.attributes, node, 'attributes', attributes, 1);
    return node;
}

function declareExportAllDeclaration(source, attributes = null) {
    const node = {
        type: 'DeclareExportAllDeclaration',
        source,
        attributes,
    };
    
    const defs = NODE_FIELDS.DeclareExportAllDeclaration;
    validate$4(defs.source, node, 'source', source, 1);
    validate$4(defs.attributes, node, 'attributes', attributes, 1);
    return node;
}

function declaredPredicate(value) {
    const node = {
        type: 'DeclaredPredicate',
        value,
    };
    
    const defs = NODE_FIELDS.DeclaredPredicate;
    validate$4(defs.value, node, 'value', value, 1);
    return node;
}

function existsTypeAnnotation() {
    return {
        type: 'ExistsTypeAnnotation',
    };
}

function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
    const node = {
        type: 'FunctionTypeAnnotation',
        typeParameters,
        params,
        rest,
        returnType,
    };
    
    const defs = NODE_FIELDS.FunctionTypeAnnotation;
    validate$4(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$4(defs.params, node, 'params', params, 1);
    validate$4(defs.rest, node, 'rest', rest, 1);
    validate$4(defs.returnType, node, 'returnType', returnType, 1);
    return node;
}

function functionTypeParam(name = null, typeAnnotation2) {
    const node = {
        type: 'FunctionTypeParam',
        name,
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.FunctionTypeParam;
    validate$4(defs.name, node, 'name', name, 1);
    validate$4(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function genericTypeAnnotation(id, typeParameters = null) {
    const node = {
        type: 'GenericTypeAnnotation',
        id,
        typeParameters,
    };
    
    const defs = NODE_FIELDS.GenericTypeAnnotation;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    return node;
}

function inferredPredicate() {
    return {
        type: 'InferredPredicate',
    };
}

function interfaceExtends(id, typeParameters = null) {
    const node = {
        type: 'InterfaceExtends',
        id,
        typeParameters,
    };
    
    const defs = NODE_FIELDS.InterfaceExtends;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    return node;
}

function interfaceDeclaration(id, typeParameters = null, _extends = null, body) {
    const node = {
        type: 'InterfaceDeclaration',
        id,
        typeParameters,
        extends: _extends,
        body,
    };
    
    const defs = NODE_FIELDS.InterfaceDeclaration;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$4(defs.extends, node, 'extends', _extends, 1);
    validate$4(defs.body, node, 'body', body, 1);
    return node;
}

function interfaceTypeAnnotation(_extends = null, body) {
    const node = {
        type: 'InterfaceTypeAnnotation',
        extends: _extends,
        body,
    };
    
    const defs = NODE_FIELDS.InterfaceTypeAnnotation;
    validate$4(defs.extends, node, 'extends', _extends, 1);
    validate$4(defs.body, node, 'body', body, 1);
    return node;
}

function intersectionTypeAnnotation(types2) {
    const node = {
        type: 'IntersectionTypeAnnotation',
        types: types2,
    };
    
    const defs = NODE_FIELDS.IntersectionTypeAnnotation;
    validate$4(defs.types, node, 'types', types2, 1);
    return node;
}

function mixedTypeAnnotation() {
    return {
        type: 'MixedTypeAnnotation',
    };
}

function emptyTypeAnnotation() {
    return {
        type: 'EmptyTypeAnnotation',
    };
}

function nullableTypeAnnotation(typeAnnotation2) {
    const node = {
        type: 'NullableTypeAnnotation',
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.NullableTypeAnnotation;
    validate$4(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function numberLiteralTypeAnnotation(value) {
    const node = {
        type: 'NumberLiteralTypeAnnotation',
        value,
    };
    
    const defs = NODE_FIELDS.NumberLiteralTypeAnnotation;
    validate$4(defs.value, node, 'value', value);
    return node;
}

function numberTypeAnnotation() {
    return {
        type: 'NumberTypeAnnotation',
    };
}

function objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {
    const node = {
        type: 'ObjectTypeAnnotation',
        properties,
        indexers,
        callProperties,
        internalSlots,
        exact,
    };
    
    const defs = NODE_FIELDS.ObjectTypeAnnotation;
    validate$4(defs.properties, node, 'properties', properties, 1);
    validate$4(defs.indexers, node, 'indexers', indexers, 1);
    validate$4(defs.callProperties, node, 'callProperties', callProperties, 1);
    validate$4(defs.internalSlots, node, 'internalSlots', internalSlots, 1);
    validate$4(defs.exact, node, 'exact', exact);
    return node;
}

function objectTypeInternalSlot(id, value, optional, _static, method) {
    const node = {
        type: 'ObjectTypeInternalSlot',
        id,
        value,
        optional,
        static: _static,
        method,
    };
    
    const defs = NODE_FIELDS.ObjectTypeInternalSlot;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.value, node, 'value', value, 1);
    validate$4(defs.optional, node, 'optional', optional);
    validate$4(defs.static, node, 'static', _static);
    validate$4(defs.method, node, 'method', method);
    return node;
}

function objectTypeCallProperty(value) {
    const node = {
        type: 'ObjectTypeCallProperty',
        value,
        static: null,
    };
    
    const defs = NODE_FIELDS.ObjectTypeCallProperty;
    validate$4(defs.value, node, 'value', value, 1);
    return node;
}

function objectTypeIndexer(id = null, key, value, variance2 = null) {
    const node = {
        type: 'ObjectTypeIndexer',
        id,
        key,
        value,
        variance: variance2,
        static: null,
    };
    
    const defs = NODE_FIELDS.ObjectTypeIndexer;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.key, node, 'key', key, 1);
    validate$4(defs.value, node, 'value', value, 1);
    validate$4(defs.variance, node, 'variance', variance2, 1);
    return node;
}

function objectTypeProperty(key, value, variance2 = null) {
    const node = {
        type: 'ObjectTypeProperty',
        key,
        value,
        variance: variance2,
        kind: null,
        method: null,
        optional: null,
        proto: null,
        static: null,
    };
    
    const defs = NODE_FIELDS.ObjectTypeProperty;
    validate$4(defs.key, node, 'key', key, 1);
    validate$4(defs.value, node, 'value', value, 1);
    validate$4(defs.variance, node, 'variance', variance2, 1);
    return node;
}

function objectTypeSpreadProperty(argument) {
    const node = {
        type: 'ObjectTypeSpreadProperty',
        argument,
    };
    
    const defs = NODE_FIELDS.ObjectTypeSpreadProperty;
    validate$4(defs.argument, node, 'argument', argument, 1);
    return node;
}

function opaqueType(id, typeParameters = null, supertype = null, impltype) {
    const node = {
        type: 'OpaqueType',
        id,
        typeParameters,
        supertype,
        impltype,
    };
    
    const defs = NODE_FIELDS.OpaqueType;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$4(defs.supertype, node, 'supertype', supertype, 1);
    validate$4(defs.impltype, node, 'impltype', impltype, 1);
    return node;
}

function qualifiedTypeIdentifier(id, qualification) {
    const node = {
        type: 'QualifiedTypeIdentifier',
        id,
        qualification,
    };
    
    const defs = NODE_FIELDS.QualifiedTypeIdentifier;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.qualification, node, 'qualification', qualification, 1);
    return node;
}

function stringLiteralTypeAnnotation(value) {
    const node = {
        type: 'StringLiteralTypeAnnotation',
        value,
    };
    
    const defs = NODE_FIELDS.StringLiteralTypeAnnotation;
    validate$4(defs.value, node, 'value', value);
    return node;
}

function stringTypeAnnotation() {
    return {
        type: 'StringTypeAnnotation',
    };
}

function symbolTypeAnnotation() {
    return {
        type: 'SymbolTypeAnnotation',
    };
}

function thisTypeAnnotation() {
    return {
        type: 'ThisTypeAnnotation',
    };
}

function tupleTypeAnnotation(types2) {
    const node = {
        type: 'TupleTypeAnnotation',
        types: types2,
    };
    
    const defs = NODE_FIELDS.TupleTypeAnnotation;
    validate$4(defs.types, node, 'types', types2, 1);
    return node;
}

function typeofTypeAnnotation(argument) {
    const node = {
        type: 'TypeofTypeAnnotation',
        argument,
    };
    
    const defs = NODE_FIELDS.TypeofTypeAnnotation;
    validate$4(defs.argument, node, 'argument', argument, 1);
    return node;
}

function typeAlias(id, typeParameters = null, right) {
    const node = {
        type: 'TypeAlias',
        id,
        typeParameters,
        right,
    };
    
    const defs = NODE_FIELDS.TypeAlias;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$4(defs.right, node, 'right', right, 1);
    return node;
}

function typeAnnotation(typeAnnotation2) {
    const node = {
        type: 'TypeAnnotation',
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TypeAnnotation;
    validate$4(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function typeCastExpression(expression2, typeAnnotation2) {
    const node = {
        type: 'TypeCastExpression',
        expression: expression2,
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TypeCastExpression;
    validate$4(defs.expression, node, 'expression', expression2, 1);
    validate$4(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function typeParameter(bound = null, _default = null, variance2 = null) {
    const node = {
        type: 'TypeParameter',
        bound,
        default: _default,
        variance: variance2,
        name: null,
    };
    
    const defs = NODE_FIELDS.TypeParameter;
    validate$4(defs.bound, node, 'bound', bound, 1);
    validate$4(defs.default, node, 'default', _default, 1);
    validate$4(defs.variance, node, 'variance', variance2, 1);
    return node;
}

function typeParameterDeclaration(params) {
    const node = {
        type: 'TypeParameterDeclaration',
        params,
    };
    
    const defs = NODE_FIELDS.TypeParameterDeclaration;
    validate$4(defs.params, node, 'params', params, 1);
    return node;
}

function typeParameterInstantiation(params) {
    const node = {
        type: 'TypeParameterInstantiation',
        params,
    };
    
    const defs = NODE_FIELDS.TypeParameterInstantiation;
    validate$4(defs.params, node, 'params', params, 1);
    return node;
}

function unionTypeAnnotation(types2) {
    const node = {
        type: 'UnionTypeAnnotation',
        types: types2,
    };
    
    const defs = NODE_FIELDS.UnionTypeAnnotation;
    validate$4(defs.types, node, 'types', types2, 1);
    return node;
}

function variance(kind) {
    const node = {
        type: 'Variance',
        kind,
    };
    
    const defs = NODE_FIELDS.Variance;
    validate$4(defs.kind, node, 'kind', kind);
    return node;
}

function voidTypeAnnotation() {
    return {
        type: 'VoidTypeAnnotation',
    };
}

function enumDeclaration(id, body) {
    const node = {
        type: 'EnumDeclaration',
        id,
        body,
    };
    
    const defs = NODE_FIELDS.EnumDeclaration;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.body, node, 'body', body, 1);
    return node;
}

function enumBooleanBody(members) {
    const node = {
        type: 'EnumBooleanBody',
        members,
        explicitType: null,
        hasUnknownMembers: null,
    };
    
    const defs = NODE_FIELDS.EnumBooleanBody;
    validate$4(defs.members, node, 'members', members, 1);
    return node;
}

function enumNumberBody(members) {
    const node = {
        type: 'EnumNumberBody',
        members,
        explicitType: null,
        hasUnknownMembers: null,
    };
    
    const defs = NODE_FIELDS.EnumNumberBody;
    validate$4(defs.members, node, 'members', members, 1);
    return node;
}

function enumStringBody(members) {
    const node = {
        type: 'EnumStringBody',
        members,
        explicitType: null,
        hasUnknownMembers: null,
    };
    
    const defs = NODE_FIELDS.EnumStringBody;
    validate$4(defs.members, node, 'members', members, 1);
    return node;
}

function enumSymbolBody(members) {
    const node = {
        type: 'EnumSymbolBody',
        members,
        hasUnknownMembers: null,
    };
    
    const defs = NODE_FIELDS.EnumSymbolBody;
    validate$4(defs.members, node, 'members', members, 1);
    return node;
}

function enumBooleanMember(id) {
    const node = {
        type: 'EnumBooleanMember',
        id,
        init: null,
    };
    
    const defs = NODE_FIELDS.EnumBooleanMember;
    validate$4(defs.id, node, 'id', id, 1);
    return node;
}

function enumNumberMember(id, init) {
    const node = {
        type: 'EnumNumberMember',
        id,
        init,
    };
    
    const defs = NODE_FIELDS.EnumNumberMember;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.init, node, 'init', init, 1);
    return node;
}

function enumStringMember(id, init) {
    const node = {
        type: 'EnumStringMember',
        id,
        init,
    };
    
    const defs = NODE_FIELDS.EnumStringMember;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.init, node, 'init', init, 1);
    return node;
}

function enumDefaultedMember(id) {
    const node = {
        type: 'EnumDefaultedMember',
        id,
    };
    
    const defs = NODE_FIELDS.EnumDefaultedMember;
    validate$4(defs.id, node, 'id', id, 1);
    return node;
}

function indexedAccessType(objectType, indexType) {
    const node = {
        type: 'IndexedAccessType',
        objectType,
        indexType,
    };
    
    const defs = NODE_FIELDS.IndexedAccessType;
    validate$4(defs.objectType, node, 'objectType', objectType, 1);
    validate$4(defs.indexType, node, 'indexType', indexType, 1);
    return node;
}

function optionalIndexedAccessType(objectType, indexType) {
    const node = {
        type: 'OptionalIndexedAccessType',
        objectType,
        indexType,
        optional: null,
    };
    
    const defs = NODE_FIELDS.OptionalIndexedAccessType;
    validate$4(defs.objectType, node, 'objectType', objectType, 1);
    validate$4(defs.indexType, node, 'indexType', indexType, 1);
    return node;
}

function jsxAttribute$1(name, value = null) {
    const node = {
        type: 'JSXAttribute',
        name,
        value,
    };
    
    const defs = NODE_FIELDS.JSXAttribute;
    validate$4(defs.name, node, 'name', name, 1);
    validate$4(defs.value, node, 'value', value, 1);
    return node;
}

function jsxClosingElement(name) {
    const node = {
        type: 'JSXClosingElement',
        name,
    };
    
    const defs = NODE_FIELDS.JSXClosingElement;
    validate$4(defs.name, node, 'name', name, 1);
    return node;
}

function jsxElement$1(openingElement, closingElement = null, children) {
    const node = {
        type: 'JSXElement',
        openingElement,
        closingElement,
        children,
    };
    
    const defs = NODE_FIELDS.JSXElement;
    validate$4(defs.openingElement, node, 'openingElement', openingElement, 1);
    validate$4(defs.closingElement, node, 'closingElement', closingElement, 1);
    validate$4(defs.children, node, 'children', children, 1);
    return node;
}

function jsxEmptyExpression() {
    return {
        type: 'JSXEmptyExpression',
    };
}

function jsxExpressionContainer(expression2) {
    const node = {
        type: 'JSXExpressionContainer',
        expression: expression2,
    };
    
    const defs = NODE_FIELDS.JSXExpressionContainer;
    validate$4(defs.expression, node, 'expression', expression2, 1);
    return node;
}

function jsxSpreadChild(expression2) {
    const node = {
        type: 'JSXSpreadChild',
        expression: expression2,
    };
    
    const defs = NODE_FIELDS.JSXSpreadChild;
    validate$4(defs.expression, node, 'expression', expression2, 1);
    return node;
}

function jsxIdentifier(name) {
    const node = {
        type: 'JSXIdentifier',
        name,
    };
    
    const defs = NODE_FIELDS.JSXIdentifier;
    validate$4(defs.name, node, 'name', name);
    return node;
}

function jsxMemberExpression(object, property) {
    const node = {
        type: 'JSXMemberExpression',
        object,
        property,
    };
    
    const defs = NODE_FIELDS.JSXMemberExpression;
    validate$4(defs.object, node, 'object', object, 1);
    validate$4(defs.property, node, 'property', property, 1);
    return node;
}

function jsxNamespacedName(namespace, name) {
    const node = {
        type: 'JSXNamespacedName',
        namespace,
        name,
    };
    
    const defs = NODE_FIELDS.JSXNamespacedName;
    validate$4(defs.namespace, node, 'namespace', namespace, 1);
    validate$4(defs.name, node, 'name', name, 1);
    return node;
}

function jsxOpeningElement$1(name, attributes, selfClosing = false) {
    const node = {
        type: 'JSXOpeningElement',
        name,
        attributes,
        selfClosing,
    };
    
    const defs = NODE_FIELDS.JSXOpeningElement;
    validate$4(defs.name, node, 'name', name, 1);
    validate$4(defs.attributes, node, 'attributes', attributes, 1);
    validate$4(defs.selfClosing, node, 'selfClosing', selfClosing);
    return node;
}

function jsxSpreadAttribute(argument) {
    const node = {
        type: 'JSXSpreadAttribute',
        argument,
    };
    
    const defs = NODE_FIELDS.JSXSpreadAttribute;
    validate$4(defs.argument, node, 'argument', argument, 1);
    return node;
}

function jsxText$1(value) {
    const node = {
        type: 'JSXText',
        value,
    };
    
    const defs = NODE_FIELDS.JSXText;
    validate$4(defs.value, node, 'value', value);
    return node;
}

function jsxFragment$1(openingFragment, closingFragment, children) {
    const node = {
        type: 'JSXFragment',
        openingFragment,
        closingFragment,
        children,
    };
    
    const defs = NODE_FIELDS.JSXFragment;
    validate$4(defs.openingFragment, node, 'openingFragment', openingFragment, 1);
    validate$4(defs.closingFragment, node, 'closingFragment', closingFragment, 1);
    validate$4(defs.children, node, 'children', children, 1);
    return node;
}

function jsxOpeningFragment() {
    return {
        type: 'JSXOpeningFragment',
    };
}

function jsxClosingFragment() {
    return {
        type: 'JSXClosingFragment',
    };
}

function placeholder(expectedNode, name) {
    const node = {
        type: 'Placeholder',
        expectedNode,
        name,
    };
    
    const defs = NODE_FIELDS.Placeholder;
    validate$4(defs.expectedNode, node, 'expectedNode', expectedNode);
    validate$4(defs.name, node, 'name', name, 1);
    return node;
}

function v8IntrinsicIdentifier(name) {
    const node = {
        type: 'V8IntrinsicIdentifier',
        name,
    };
    
    const defs = NODE_FIELDS.V8IntrinsicIdentifier;
    validate$4(defs.name, node, 'name', name);
    return node;
}

function argumentPlaceholder() {
    return {
        type: 'ArgumentPlaceholder',
    };
}

function bindExpression(object, callee) {
    const node = {
        type: 'BindExpression',
        object,
        callee,
    };
    
    const defs = NODE_FIELDS.BindExpression;
    validate$4(defs.object, node, 'object', object, 1);
    validate$4(defs.callee, node, 'callee', callee, 1);
    return node;
}

function decorator$1(expression2) {
    const node = {
        type: 'Decorator',
        expression: expression2,
    };
    
    const defs = NODE_FIELDS.Decorator;
    validate$4(defs.expression, node, 'expression', expression2, 1);
    return node;
}

function doExpression(body, async = false) {
    const node = {
        type: 'DoExpression',
        body,
        async,
    };
    
    const defs = NODE_FIELDS.DoExpression;
    validate$4(defs.body, node, 'body', body, 1);
    validate$4(defs.async, node, 'async', async);
    return node;
}

function exportDefaultSpecifier(exported) {
    const node = {
        type: 'ExportDefaultSpecifier',
        exported,
    };
    
    const defs = NODE_FIELDS.ExportDefaultSpecifier;
    validate$4(defs.exported, node, 'exported', exported, 1);
    return node;
}

function recordExpression(properties) {
    const node = {
        type: 'RecordExpression',
        properties,
    };
    
    const defs = NODE_FIELDS.RecordExpression;
    validate$4(defs.properties, node, 'properties', properties, 1);
    return node;
}

function tupleExpression(elements = []) {
    const node = {
        type: 'TupleExpression',
        elements,
    };
    
    const defs = NODE_FIELDS.TupleExpression;
    validate$4(defs.elements, node, 'elements', elements, 1);
    return node;
}

function moduleExpression(body) {
    const node = {
        type: 'ModuleExpression',
        body,
    };
    
    const defs = NODE_FIELDS.ModuleExpression;
    validate$4(defs.body, node, 'body', body, 1);
    return node;
}

function topicReference() {
    return {
        type: 'TopicReference',
    };
}

function pipelineTopicExpression(expression2) {
    const node = {
        type: 'PipelineTopicExpression',
        expression: expression2,
    };
    
    const defs = NODE_FIELDS.PipelineTopicExpression;
    validate$4(defs.expression, node, 'expression', expression2, 1);
    return node;
}

function pipelineBareFunction(callee) {
    const node = {
        type: 'PipelineBareFunction',
        callee,
    };
    
    const defs = NODE_FIELDS.PipelineBareFunction;
    validate$4(defs.callee, node, 'callee', callee, 1);
    return node;
}

function pipelinePrimaryTopicReference() {
    return {
        type: 'PipelinePrimaryTopicReference',
    };
}

function voidPattern$1() {
    return {
        type: 'VoidPattern',
    };
}

function tsParameterProperty$1(parameter) {
    const node = {
        type: 'TSParameterProperty',
        parameter,
    };
    
    const defs = NODE_FIELDS.TSParameterProperty;
    validate$4(defs.parameter, node, 'parameter', parameter, 1);
    return node;
}

function tsDeclareFunction$1(id = null, typeParameters = null, params, returnType = null) {
    const node = {
        type: 'TSDeclareFunction',
        id,
        typeParameters,
        params,
        returnType,
    };
    
    const defs = NODE_FIELDS.TSDeclareFunction;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$4(defs.params, node, 'params', params, 1);
    validate$4(defs.returnType, node, 'returnType', returnType, 1);
    return node;
}

function tsDeclareMethod$1(decorators = null, key, typeParameters = null, params, returnType = null) {
    const node = {
        type: 'TSDeclareMethod',
        decorators,
        key,
        typeParameters,
        params,
        returnType,
    };
    
    const defs = NODE_FIELDS.TSDeclareMethod;
    validate$4(defs.decorators, node, 'decorators', decorators, 1);
    validate$4(defs.key, node, 'key', key, 1);
    validate$4(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$4(defs.params, node, 'params', params, 1);
    validate$4(defs.returnType, node, 'returnType', returnType, 1);
    return node;
}

function tsQualifiedName(left, right) {
    const node = {
        type: 'TSQualifiedName',
        left,
        right,
    };
    
    const defs = NODE_FIELDS.TSQualifiedName;
    validate$4(defs.left, node, 'left', left, 1);
    validate$4(defs.right, node, 'right', right, 1);
    return node;
}

function tsCallSignatureDeclaration$1(typeParameters = null, params, returnType = null) {
    const node = {
        type: 'TSCallSignatureDeclaration',
        typeParameters,
        params,
        returnType,
    };
    
    const defs = NODE_FIELDS.TSCallSignatureDeclaration;
    validate$4(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$4(defs.params, node, 'params', params, 1);
    validate$4(defs.returnType, node, 'returnType', returnType, 1);
    return node;
}

function tsConstructSignatureDeclaration$1(typeParameters = null, params, returnType = null) {
    const node = {
        type: 'TSConstructSignatureDeclaration',
        typeParameters,
        params,
        returnType,
    };
    
    const defs = NODE_FIELDS.TSConstructSignatureDeclaration;
    validate$4(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$4(defs.params, node, 'params', params, 1);
    validate$4(defs.returnType, node, 'returnType', returnType, 1);
    return node;
}

function tsPropertySignature$1(key, typeAnnotation2 = null) {
    const node = {
        type: 'TSPropertySignature',
        key,
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TSPropertySignature;
    validate$4(defs.key, node, 'key', key, 1);
    validate$4(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function tsMethodSignature$1(key, typeParameters = null, params, returnType = null) {
    const node = {
        type: 'TSMethodSignature',
        key,
        typeParameters,
        params,
        returnType,
        kind: null,
    };
    
    const defs = NODE_FIELDS.TSMethodSignature;
    validate$4(defs.key, node, 'key', key, 1);
    validate$4(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$4(defs.params, node, 'params', params, 1);
    validate$4(defs.returnType, node, 'returnType', returnType, 1);
    return node;
}

function tsIndexSignature(parameters, typeAnnotation2 = null) {
    const node = {
        type: 'TSIndexSignature',
        parameters,
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TSIndexSignature;
    validate$4(defs.parameters, node, 'parameters', parameters, 1);
    validate$4(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function tsAnyKeyword() {
    return {
        type: 'TSAnyKeyword',
    };
}

function tsBooleanKeyword() {
    return {
        type: 'TSBooleanKeyword',
    };
}

function tsBigIntKeyword() {
    return {
        type: 'TSBigIntKeyword',
    };
}

function tsIntrinsicKeyword() {
    return {
        type: 'TSIntrinsicKeyword',
    };
}

function tsNeverKeyword() {
    return {
        type: 'TSNeverKeyword',
    };
}

function tsNullKeyword() {
    return {
        type: 'TSNullKeyword',
    };
}

function tsNumberKeyword() {
    return {
        type: 'TSNumberKeyword',
    };
}

function tsObjectKeyword() {
    return {
        type: 'TSObjectKeyword',
    };
}

function tsStringKeyword() {
    return {
        type: 'TSStringKeyword',
    };
}

function tsSymbolKeyword() {
    return {
        type: 'TSSymbolKeyword',
    };
}

function tsUndefinedKeyword() {
    return {
        type: 'TSUndefinedKeyword',
    };
}

function tsUnknownKeyword() {
    return {
        type: 'TSUnknownKeyword',
    };
}

function tsVoidKeyword() {
    return {
        type: 'TSVoidKeyword',
    };
}

function tsThisType() {
    return {
        type: 'TSThisType',
    };
}

function tsFunctionType$1(typeParameters = null, params, returnType = null) {
    const node = {
        type: 'TSFunctionType',
        typeParameters,
        params,
        returnType,
    };
    
    const defs = NODE_FIELDS.TSFunctionType;
    validate$4(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$4(defs.params, node, 'params', params, 1);
    validate$4(defs.returnType, node, 'returnType', returnType, 1);
    return node;
}

function tsConstructorType$1(typeParameters = null, params, returnType = null) {
    const node = {
        type: 'TSConstructorType',
        typeParameters,
        params,
        returnType,
    };
    
    const defs = NODE_FIELDS.TSConstructorType;
    validate$4(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$4(defs.params, node, 'params', params, 1);
    validate$4(defs.returnType, node, 'returnType', returnType, 1);
    return node;
}

function tsTypeReference$1(typeName, typeArguments = null) {
    const node = {
        type: 'TSTypeReference',
        typeName,
        typeArguments,
    };
    
    const defs = NODE_FIELDS.TSTypeReference;
    validate$4(defs.typeName, node, 'typeName', typeName, 1);
    validate$4(defs.typeArguments, node, 'typeArguments', typeArguments, 1);
    return node;
}

function tsTypePredicate(parameterName, typeAnnotation2 = null, asserts = null) {
    const node = {
        type: 'TSTypePredicate',
        parameterName,
        typeAnnotation: typeAnnotation2,
        asserts,
    };
    
    const defs = NODE_FIELDS.TSTypePredicate;
    validate$4(defs.parameterName, node, 'parameterName', parameterName, 1);
    validate$4(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    validate$4(defs.asserts, node, 'asserts', asserts);
    return node;
}

function tsTypeQuery$1(exprName, typeArguments = null) {
    const node = {
        type: 'TSTypeQuery',
        exprName,
        typeArguments,
    };
    
    const defs = NODE_FIELDS.TSTypeQuery;
    validate$4(defs.exprName, node, 'exprName', exprName, 1);
    validate$4(defs.typeArguments, node, 'typeArguments', typeArguments, 1);
    return node;
}

function tsTypeLiteral$1(members) {
    const node = {
        type: 'TSTypeLiteral',
        members,
    };
    
    const defs = NODE_FIELDS.TSTypeLiteral;
    validate$4(defs.members, node, 'members', members, 1);
    return node;
}

function tsArrayType(elementType) {
    const node = {
        type: 'TSArrayType',
        elementType,
    };
    
    const defs = NODE_FIELDS.TSArrayType;
    validate$4(defs.elementType, node, 'elementType', elementType, 1);
    return node;
}

function tsTupleType$1(elementTypes) {
    const node = {
        type: 'TSTupleType',
        elementTypes,
    };
    
    const defs = NODE_FIELDS.TSTupleType;
    validate$4(defs.elementTypes, node, 'elementTypes', elementTypes, 1);
    return node;
}

function tsOptionalType(typeAnnotation2) {
    const node = {
        type: 'TSOptionalType',
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TSOptionalType;
    validate$4(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function tsRestType(typeAnnotation2) {
    const node = {
        type: 'TSRestType',
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TSRestType;
    validate$4(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function tsNamedTupleMember$1(label, elementType, optional = false) {
    const node = {
        type: 'TSNamedTupleMember',
        label,
        elementType,
        optional,
    };
    
    const defs = NODE_FIELDS.TSNamedTupleMember;
    validate$4(defs.label, node, 'label', label, 1);
    validate$4(defs.elementType, node, 'elementType', elementType, 1);
    validate$4(defs.optional, node, 'optional', optional);
    return node;
}

function tsUnionType$1(types2) {
    const node = {
        type: 'TSUnionType',
        types: types2,
    };
    
    const defs = NODE_FIELDS.TSUnionType;
    validate$4(defs.types, node, 'types', types2, 1);
    return node;
}

function tsIntersectionType$1(types2) {
    const node = {
        type: 'TSIntersectionType',
        types: types2,
    };
    
    const defs = NODE_FIELDS.TSIntersectionType;
    validate$4(defs.types, node, 'types', types2, 1);
    return node;
}

function tsConditionalType$1(checkType, extendsType, trueType, falseType) {
    const node = {
        type: 'TSConditionalType',
        checkType,
        extendsType,
        trueType,
        falseType,
    };
    
    const defs = NODE_FIELDS.TSConditionalType;
    validate$4(defs.checkType, node, 'checkType', checkType, 1);
    validate$4(defs.extendsType, node, 'extendsType', extendsType, 1);
    validate$4(defs.trueType, node, 'trueType', trueType, 1);
    validate$4(defs.falseType, node, 'falseType', falseType, 1);
    return node;
}

function tsInferType$1(typeParameter2) {
    const node = {
        type: 'TSInferType',
        typeParameter: typeParameter2,
    };
    
    const defs = NODE_FIELDS.TSInferType;
    validate$4(defs.typeParameter, node, 'typeParameter', typeParameter2, 1);
    return node;
}

function tsParenthesizedType$3(typeAnnotation2) {
    const node = {
        type: 'TSParenthesizedType',
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TSParenthesizedType;
    validate$4(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function tsTypeOperator(typeAnnotation2, operator) {
    const node = {
        type: 'TSTypeOperator',
        typeAnnotation: typeAnnotation2,
        operator,
    };
    
    const defs = NODE_FIELDS.TSTypeOperator;
    validate$4(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    validate$4(defs.operator, node, 'operator', operator);
    return node;
}

function tsIndexedAccessType(objectType, indexType) {
    const node = {
        type: 'TSIndexedAccessType',
        objectType,
        indexType,
    };
    
    const defs = NODE_FIELDS.TSIndexedAccessType;
    validate$4(defs.objectType, node, 'objectType', objectType, 1);
    validate$4(defs.indexType, node, 'indexType', indexType, 1);
    return node;
}

function tsMappedType$1(key, constraint, nameType = null, typeAnnotation2 = null) {
    const node = {
        type: 'TSMappedType',
        key,
        constraint,
        nameType,
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TSMappedType;
    validate$4(defs.key, node, 'key', key, 1);
    validate$4(defs.constraint, node, 'constraint', constraint, 1);
    validate$4(defs.nameType, node, 'nameType', nameType, 1);
    validate$4(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function tsTemplateLiteralType(quasis, types2) {
    const node = {
        type: 'TSTemplateLiteralType',
        quasis,
        types: types2,
    };
    
    const defs = NODE_FIELDS.TSTemplateLiteralType;
    validate$4(defs.quasis, node, 'quasis', quasis, 1);
    validate$4(defs.types, node, 'types', types2, 1);
    return node;
}

function tsLiteralType(literal) {
    const node = {
        type: 'TSLiteralType',
        literal,
    };
    
    const defs = NODE_FIELDS.TSLiteralType;
    validate$4(defs.literal, node, 'literal', literal, 1);
    return node;
}

function tsClassImplements(expression2, typeArguments = null) {
    const node = {
        type: 'TSClassImplements',
        expression: expression2,
        typeArguments,
    };
    
    const defs = NODE_FIELDS.TSClassImplements;
    validate$4(defs.expression, node, 'expression', expression2, 1);
    validate$4(defs.typeArguments, node, 'typeArguments', typeArguments, 1);
    return node;
}

function tsInterfaceHeritage(expression2, typeArguments = null) {
    const node = {
        type: 'TSInterfaceHeritage',
        expression: expression2,
        typeArguments,
    };
    
    const defs = NODE_FIELDS.TSInterfaceHeritage;
    validate$4(defs.expression, node, 'expression', expression2, 1);
    validate$4(defs.typeArguments, node, 'typeArguments', typeArguments, 1);
    return node;
}

function tsInterfaceDeclaration$1(id, typeParameters = null, _extends = null, body) {
    const node = {
        type: 'TSInterfaceDeclaration',
        id,
        typeParameters,
        extends: _extends,
        body,
    };
    
    const defs = NODE_FIELDS.TSInterfaceDeclaration;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$4(defs.extends, node, 'extends', _extends, 1);
    validate$4(defs.body, node, 'body', body, 1);
    return node;
}

function tsInterfaceBody$1(body) {
    const node = {
        type: 'TSInterfaceBody',
        body,
    };
    
    const defs = NODE_FIELDS.TSInterfaceBody;
    validate$4(defs.body, node, 'body', body, 1);
    return node;
}

function tsTypeAliasDeclaration$1(id, typeParameters = null, typeAnnotation2) {
    const node = {
        type: 'TSTypeAliasDeclaration',
        id,
        typeParameters,
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TSTypeAliasDeclaration;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$4(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function tsInstantiationExpression(expression2, typeArguments = null) {
    const node = {
        type: 'TSInstantiationExpression',
        expression: expression2,
        typeArguments,
    };
    
    const defs = NODE_FIELDS.TSInstantiationExpression;
    validate$4(defs.expression, node, 'expression', expression2, 1);
    validate$4(defs.typeArguments, node, 'typeArguments', typeArguments, 1);
    return node;
}

function tsAsExpression$1(expression2, typeAnnotation2) {
    const node = {
        type: 'TSAsExpression',
        expression: expression2,
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TSAsExpression;
    validate$4(defs.expression, node, 'expression', expression2, 1);
    validate$4(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function tsSatisfiesExpression(expression2, typeAnnotation2) {
    const node = {
        type: 'TSSatisfiesExpression',
        expression: expression2,
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TSSatisfiesExpression;
    validate$4(defs.expression, node, 'expression', expression2, 1);
    validate$4(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function tsTypeAssertion(typeAnnotation2, expression2) {
    const node = {
        type: 'TSTypeAssertion',
        typeAnnotation: typeAnnotation2,
        expression: expression2,
    };
    
    const defs = NODE_FIELDS.TSTypeAssertion;
    validate$4(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    validate$4(defs.expression, node, 'expression', expression2, 1);
    return node;
}

function tsEnumBody(members) {
    const node = {
        type: 'TSEnumBody',
        members,
    };
    
    const defs = NODE_FIELDS.TSEnumBody;
    validate$4(defs.members, node, 'members', members, 1);
    return node;
}

function tsEnumDeclaration$1(id, body) {
    const node = {
        type: 'TSEnumDeclaration',
        id,
        body,
    };
    
    const defs = NODE_FIELDS.TSEnumDeclaration;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.body, node, 'body', body, 1);
    return node;
}

function tsEnumMember$1(id, initializer = null) {
    const node = {
        type: 'TSEnumMember',
        id,
        initializer,
    };
    
    const defs = NODE_FIELDS.TSEnumMember;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.initializer, node, 'initializer', initializer, 1);
    return node;
}

function tsModuleDeclaration$1(id, body) {
    const node = {
        type: 'TSModuleDeclaration',
        id,
        body,
        kind: null,
    };
    
    const defs = NODE_FIELDS.TSModuleDeclaration;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.body, node, 'body', body, 1);
    return node;
}

function tsModuleBlock(body) {
    const node = {
        type: 'TSModuleBlock',
        body,
    };
    
    const defs = NODE_FIELDS.TSModuleBlock;
    validate$4(defs.body, node, 'body', body, 1);
    return node;
}

function tsImportType$1(argument, qualifier = null, typeArguments = null) {
    const node = {
        type: 'TSImportType',
        argument,
        qualifier,
        typeArguments,
    };
    
    const defs = NODE_FIELDS.TSImportType;
    validate$4(defs.argument, node, 'argument', argument, 1);
    validate$4(defs.qualifier, node, 'qualifier', qualifier, 1);
    validate$4(defs.typeArguments, node, 'typeArguments', typeArguments, 1);
    return node;
}

function tsImportEqualsDeclaration(id, moduleReference) {
    const node = {
        type: 'TSImportEqualsDeclaration',
        id,
        moduleReference,
    };
    
    const defs = NODE_FIELDS.TSImportEqualsDeclaration;
    validate$4(defs.id, node, 'id', id, 1);
    validate$4(defs.moduleReference, node, 'moduleReference', moduleReference, 1);
    return node;
}

function tsExternalModuleReference(expression2) {
    const node = {
        type: 'TSExternalModuleReference',
        expression: expression2,
    };
    
    const defs = NODE_FIELDS.TSExternalModuleReference;
    validate$4(defs.expression, node, 'expression', expression2, 1);
    return node;
}

function tsNonNullExpression(expression2) {
    const node = {
        type: 'TSNonNullExpression',
        expression: expression2,
    };
    
    const defs = NODE_FIELDS.TSNonNullExpression;
    validate$4(defs.expression, node, 'expression', expression2, 1);
    return node;
}

function tsExportAssignment$1(expression2) {
    const node = {
        type: 'TSExportAssignment',
        expression: expression2,
    };
    
    const defs = NODE_FIELDS.TSExportAssignment;
    validate$4(defs.expression, node, 'expression', expression2, 1);
    return node;
}

function tsNamespaceExportDeclaration(id) {
    const node = {
        type: 'TSNamespaceExportDeclaration',
        id,
    };
    
    const defs = NODE_FIELDS.TSNamespaceExportDeclaration;
    validate$4(defs.id, node, 'id', id, 1);
    return node;
}

function tsTypeAnnotation(typeAnnotation2) {
    const node = {
        type: 'TSTypeAnnotation',
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TSTypeAnnotation;
    validate$4(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function tsTypeParameterInstantiation(params) {
    const node = {
        type: 'TSTypeParameterInstantiation',
        params,
    };
    
    const defs = NODE_FIELDS.TSTypeParameterInstantiation;
    validate$4(defs.params, node, 'params', params, 1);
    return node;
}

function tsTypeParameterDeclaration(params) {
    const node = {
        type: 'TSTypeParameterDeclaration',
        params,
    };
    
    const defs = NODE_FIELDS.TSTypeParameterDeclaration;
    validate$4(defs.params, node, 'params', params, 1);
    return node;
}

function tsTypeParameter$1(constraint = null, _default = null, name) {
    const node = {
        type: 'TSTypeParameter',
        constraint,
        default: _default,
        name,
    };
    
    const defs = NODE_FIELDS.TSTypeParameter;
    validate$4(defs.constraint, node, 'constraint', constraint, 1);
    validate$4(defs.default, node, 'default', _default, 1);
    validate$4(defs.name, node, 'name', name, 1);
    return node;
}

function NumberLiteral(value) {
    deprecationWarning('NumberLiteral', 'NumericLiteral', 'The node type ');
    return numericLiteral(value);
}

function RegexLiteral(pattern, flags = '') {
    deprecationWarning('RegexLiteral', 'RegExpLiteral', 'The node type ');
    return regExpLiteral(pattern, flags);
}

function RestProperty(argument) {
    deprecationWarning('RestProperty', 'RestElement', 'The node type ');
    return restElement$1(argument);
}

function SpreadProperty(argument) {
    deprecationWarning('SpreadProperty', 'SpreadElement', 'The node type ');
    return spreadElement$1(argument);
}

var b = /* @__PURE__ */Object.freeze({
    __proto__: null,
    anyTypeAnnotation,
    argumentPlaceholder,
    arrayExpression: arrayExpression$4,
    arrayPattern: arrayPattern$1,
    arrayTypeAnnotation,
    arrowFunctionExpression: arrowFunctionExpression$1,
    assignmentExpression: assignmentExpression$1,
    assignmentPattern: assignmentPattern$1,
    awaitExpression,
    bigIntLiteral,
    binaryExpression: binaryExpression$1,
    bindExpression,
    blockStatement: blockStatement$2,
    booleanLiteral,
    booleanLiteralTypeAnnotation,
    booleanTypeAnnotation,
    breakStatement: breakStatement$1,
    callExpression: callExpression$1,
    catchClause,
    classAccessorProperty,
    classBody,
    classDeclaration,
    classExpression,
    classImplements,
    classMethod: classMethod$2,
    classPrivateMethod: classPrivateMethod$1,
    classPrivateProperty,
    classProperty: classProperty$1,
    conditionalExpression: conditionalExpression$1,
    continueStatement: continueStatement$1,
    debuggerStatement: debuggerStatement$1,
    declareClass,
    declareExportAllDeclaration,
    declareExportDeclaration,
    declareFunction,
    declareInterface,
    declareModule,
    declareModuleExports,
    declareOpaqueType,
    declareTypeAlias,
    declareVariable,
    declaredPredicate,
    decorator: decorator$1,
    directive: directive$1,
    directiveLiteral: directiveLiteral$2,
    doExpression,
    doWhileStatement: doWhileStatement$1,
    emptyStatement: emptyStatement$1,
    emptyTypeAnnotation,
    enumBooleanBody,
    enumBooleanMember,
    enumDeclaration,
    enumDefaultedMember,
    enumNumberBody,
    enumNumberMember,
    enumStringBody,
    enumStringMember,
    enumSymbolBody,
    existsTypeAnnotation,
    exportAllDeclaration: exportAllDeclaration$1,
    exportDefaultDeclaration: exportDefaultDeclaration$1,
    exportDefaultSpecifier,
    exportNamedDeclaration,
    exportNamespaceSpecifier,
    exportSpecifier,
    expressionStatement: expressionStatement$5,
    file: file$1,
    forInStatement: forInStatement$1,
    forOfStatement: forOfStatement$1,
    forStatement: forStatement$1,
    functionDeclaration: functionDeclaration$1,
    functionExpression: functionExpression$1,
    functionTypeAnnotation,
    functionTypeParam,
    genericTypeAnnotation,
    identifier: identifier$3,
    ifStatement: ifStatement$1,
    import: _import,
    importAttribute: importAttribute$1,
    importDeclaration: importDeclaration$1,
    importDefaultSpecifier,
    importExpression: importExpression$1,
    importNamespaceSpecifier,
    importSpecifier,
    indexedAccessType,
    inferredPredicate,
    interfaceDeclaration,
    interfaceExtends,
    interfaceTypeAnnotation,
    interpreterDirective,
    intersectionTypeAnnotation,
    jsxAttribute: jsxAttribute$1,
    jsxClosingElement,
    jsxClosingFragment,
    jsxElement: jsxElement$1,
    jsxEmptyExpression,
    jsxExpressionContainer,
    jsxFragment: jsxFragment$1,
    jsxIdentifier,
    jsxMemberExpression,
    jsxNamespacedName,
    jsxOpeningElement: jsxOpeningElement$1,
    jsxOpeningFragment,
    jsxSpreadAttribute,
    jsxSpreadChild,
    jsxText: jsxText$1,
    labeledStatement: labeledStatement$1,
    logicalExpression: logicalExpression$1,
    memberExpression,
    metaProperty,
    mixedTypeAnnotation,
    moduleExpression,
    newExpression: newExpression$1,
    nullLiteral,
    nullLiteralTypeAnnotation,
    nullableTypeAnnotation,
    numberLiteral: NumberLiteral,
    numberLiteralTypeAnnotation,
    numberTypeAnnotation,
    numericLiteral,
    objectExpression: objectExpression$3,
    objectMethod: objectMethod$2,
    objectPattern: objectPattern$2,
    objectProperty: objectProperty$4,
    objectTypeAnnotation,
    objectTypeCallProperty,
    objectTypeIndexer,
    objectTypeInternalSlot,
    objectTypeProperty,
    objectTypeSpreadProperty,
    opaqueType,
    optionalCallExpression,
    optionalIndexedAccessType,
    optionalMemberExpression,
    parenthesizedExpression: parenthesizedExpression$3,
    pipelineBareFunction,
    pipelinePrimaryTopicReference,
    pipelineTopicExpression,
    placeholder,
    privateName: privateName$1,
    program: program$2,
    qualifiedTypeIdentifier,
    recordExpression,
    regExpLiteral,
    regexLiteral: RegexLiteral,
    restElement: restElement$1,
    restProperty: RestProperty,
    returnStatement: returnStatement$1,
    sequenceExpression: sequenceExpression$1,
    spreadElement: spreadElement$1,
    spreadProperty: SpreadProperty,
    staticBlock: staticBlock$1,
    stringLiteral: stringLiteral$5,
    stringLiteralTypeAnnotation,
    stringTypeAnnotation,
    super: _super,
    switchCase,
    switchStatement: switchStatement$1,
    symbolTypeAnnotation,
    taggedTemplateExpression: taggedTemplateExpression$1,
    templateElement: templateElement$1,
    templateLiteral: templateLiteral$1,
    thisExpression,
    thisTypeAnnotation,
    throwStatement,
    topicReference,
    tryStatement,
    tsAnyKeyword,
    tsArrayType,
    tsAsExpression: tsAsExpression$1,
    tsBigIntKeyword,
    tsBooleanKeyword,
    tsCallSignatureDeclaration: tsCallSignatureDeclaration$1,
    tsClassImplements,
    tsConditionalType: tsConditionalType$1,
    tsConstructSignatureDeclaration: tsConstructSignatureDeclaration$1,
    tsConstructorType: tsConstructorType$1,
    tsDeclareFunction: tsDeclareFunction$1,
    tsDeclareMethod: tsDeclareMethod$1,
    tsEnumBody,
    tsEnumDeclaration: tsEnumDeclaration$1,
    tsEnumMember: tsEnumMember$1,
    tsExportAssignment: tsExportAssignment$1,
    tsExternalModuleReference,
    tsFunctionType: tsFunctionType$1,
    tsImportEqualsDeclaration,
    tsImportType: tsImportType$1,
    tsIndexSignature,
    tsIndexedAccessType,
    tsInferType: tsInferType$1,
    tsInstantiationExpression,
    tsInterfaceBody: tsInterfaceBody$1,
    tsInterfaceDeclaration: tsInterfaceDeclaration$1,
    tsInterfaceHeritage,
    tsIntersectionType: tsIntersectionType$1,
    tsIntrinsicKeyword,
    tsLiteralType,
    tsMappedType: tsMappedType$1,
    tsMethodSignature: tsMethodSignature$1,
    tsModuleBlock,
    tsModuleDeclaration: tsModuleDeclaration$1,
    tsNamedTupleMember: tsNamedTupleMember$1,
    tsNamespaceExportDeclaration,
    tsNeverKeyword,
    tsNonNullExpression,
    tsNullKeyword,
    tsNumberKeyword,
    tsObjectKeyword,
    tsOptionalType,
    tsParameterProperty: tsParameterProperty$1,
    tsParenthesizedType: tsParenthesizedType$3,
    tsPropertySignature: tsPropertySignature$1,
    tsQualifiedName,
    tsRestType,
    tsSatisfiesExpression,
    tsStringKeyword,
    tsSymbolKeyword,
    tsTemplateLiteralType,
    tsThisType,
    tsTupleType: tsTupleType$1,
    tsTypeAliasDeclaration: tsTypeAliasDeclaration$1,
    tsTypeAnnotation,
    tsTypeAssertion,
    tsTypeLiteral: tsTypeLiteral$1,
    tsTypeOperator,
    tsTypeParameter: tsTypeParameter$1,
    tsTypeParameterDeclaration,
    tsTypeParameterInstantiation,
    tsTypePredicate,
    tsTypeQuery: tsTypeQuery$1,
    tsTypeReference: tsTypeReference$1,
    tsUndefinedKeyword,
    tsUnionType: tsUnionType$1,
    tsUnknownKeyword,
    tsVoidKeyword,
    tupleExpression,
    tupleTypeAnnotation,
    typeAlias,
    typeAnnotation,
    typeCastExpression,
    typeParameter,
    typeParameterDeclaration,
    typeParameterInstantiation,
    typeofTypeAnnotation,
    unaryExpression: unaryExpression$1,
    unionTypeAnnotation,
    updateExpression,
    v8IntrinsicIdentifier,
    variableDeclaration: variableDeclaration$1,
    variableDeclarator,
    variance,
    voidPattern: voidPattern$1,
    voidTypeAnnotation,
    whileStatement: whileStatement$1,
    withStatement,
    yieldExpression,
});

function alias(lowercase) {
    {
        return function() {
            deprecationWarning(lowercase.replace(/^(?:ts|jsx|[a-z])/, (x) => x.toUpperCase()), lowercase, 'Usage of builders starting with an uppercase letter such as ', 'uppercase builders');
            return b[lowercase](...arguments);
        };
    }
}

var ArrayExpression$1 = alias('arrayExpression');
var AssignmentExpression$1 = alias('assignmentExpression');
var BinaryExpression$1 = alias('binaryExpression');
var InterpreterDirective = alias('interpreterDirective');
var Directive = alias('directive');
var DirectiveLiteral$1 = alias('directiveLiteral');
var BlockStatement$1 = alias('blockStatement');
var BreakStatement$1 = alias('breakStatement');
var CallExpression$2 = alias('callExpression');
var CatchClause = alias('catchClause');
var ConditionalExpression$1 = alias('conditionalExpression');
var ContinueStatement$1 = alias('continueStatement');
var DebuggerStatement$1 = alias('debuggerStatement');
var DoWhileStatement$1 = alias('doWhileStatement');
var EmptyStatement$1 = alias('emptyStatement');
var ExpressionStatement$1 = alias('expressionStatement');
var File = alias('file');
var ForInStatement$1 = alias('forInStatement');
var ForStatement$1 = alias('forStatement');
var FunctionDeclaration$1 = alias('functionDeclaration');
var FunctionExpression$1 = alias('functionExpression');
var Identifier$1 = alias('identifier');
var IfStatement$1 = alias('ifStatement');
var LabeledStatement$1 = alias('labeledStatement');
var StringLiteral$1 = alias('stringLiteral');
var NumericLiteral = alias('numericLiteral');
var NullLiteral = alias('nullLiteral');
var BooleanLiteral = alias('booleanLiteral');
var RegExpLiteral = alias('regExpLiteral');
var LogicalExpression$1 = alias('logicalExpression');
var MemberExpression = alias('memberExpression');
var NewExpression$1 = alias('newExpression');
var Program$1 = alias('program');
var ObjectExpression$1 = alias('objectExpression');
var ObjectMethod$1 = alias('objectMethod');
var ObjectProperty$1 = alias('objectProperty');
var RestElement$1 = alias('restElement');
var ReturnStatement$1 = alias('returnStatement');
var SequenceExpression$1 = alias('sequenceExpression');
var ParenthesizedExpression$1 = alias('parenthesizedExpression');
var SwitchCase = alias('switchCase');
var SwitchStatement$1 = alias('switchStatement');
var ThisExpression = alias('thisExpression');
var ThrowStatement = alias('throwStatement');
var TryStatement = alias('tryStatement');
var UnaryExpression = alias('unaryExpression');
var UpdateExpression = alias('updateExpression');
var VariableDeclaration$1 = alias('variableDeclaration');
var VariableDeclarator = alias('variableDeclarator');
var WhileStatement$1 = alias('whileStatement');
var WithStatement = alias('withStatement');
var AssignmentPattern$1 = alias('assignmentPattern');
var ArrayPattern$1 = alias('arrayPattern');
var ArrowFunctionExpression$1 = alias('arrowFunctionExpression');
var ClassBody = alias('classBody');
var ClassExpression$1 = alias('classExpression');
var ClassDeclaration$1 = alias('classDeclaration');
var ExportAllDeclaration$1 = alias('exportAllDeclaration');
var ExportDefaultDeclaration$1 = alias('exportDefaultDeclaration');
var ExportNamedDeclaration = alias('exportNamedDeclaration');
var ExportSpecifier$1 = alias('exportSpecifier');
var ForOfStatement$1 = alias('forOfStatement');
var ImportDeclaration = alias('importDeclaration');
var ImportDefaultSpecifier = alias('importDefaultSpecifier');
var ImportNamespaceSpecifier = alias('importNamespaceSpecifier');
var ImportSpecifier = alias('importSpecifier');
var ImportExpression$1 = alias('importExpression');
var MetaProperty = alias('metaProperty');
var ClassMethod$2 = alias('classMethod');
var ObjectPattern$1 = alias('objectPattern');
var SpreadElement$1 = alias('spreadElement');
var Super = alias('super');
var TaggedTemplateExpression$1 = alias('taggedTemplateExpression');
var TemplateElement = alias('templateElement');
var TemplateLiteral$1 = alias('templateLiteral');
var YieldExpression = alias('yieldExpression');
var AwaitExpression = alias('awaitExpression');
var Import = alias('import');
var BigIntLiteral = alias('bigIntLiteral');
var ExportNamespaceSpecifier$1 = alias('exportNamespaceSpecifier');
var OptionalMemberExpression = alias('optionalMemberExpression');
var OptionalCallExpression$1 = alias('optionalCallExpression');
var ClassProperty$1 = alias('classProperty');
var ClassAccessorProperty$1 = alias('classAccessorProperty');
var ClassPrivateProperty$1 = alias('classPrivateProperty');
var ClassPrivateMethod$1 = alias('classPrivateMethod');
var PrivateName$1 = alias('privateName');
var StaticBlock$1 = alias('staticBlock');
var ImportAttribute = alias('importAttribute');
var AnyTypeAnnotation = alias('anyTypeAnnotation');
var ArrayTypeAnnotation = alias('arrayTypeAnnotation');
var BooleanTypeAnnotation = alias('booleanTypeAnnotation');
var BooleanLiteralTypeAnnotation = alias('booleanLiteralTypeAnnotation');
var NullLiteralTypeAnnotation = alias('nullLiteralTypeAnnotation');
var ClassImplements = alias('classImplements');
var DeclareClass = alias('declareClass');
var DeclareFunction = alias('declareFunction');
var DeclareInterface = alias('declareInterface');
var DeclareModule = alias('declareModule');
var DeclareModuleExports = alias('declareModuleExports');
var DeclareTypeAlias = alias('declareTypeAlias');
var DeclareOpaqueType = alias('declareOpaqueType');
var DeclareVariable = alias('declareVariable');
var DeclareExportDeclaration = alias('declareExportDeclaration');
var DeclareExportAllDeclaration = alias('declareExportAllDeclaration');
var DeclaredPredicate = alias('declaredPredicate');
var ExistsTypeAnnotation = alias('existsTypeAnnotation');
var FunctionTypeAnnotation = alias('functionTypeAnnotation');
var FunctionTypeParam = alias('functionTypeParam');
var GenericTypeAnnotation = alias('genericTypeAnnotation');
var InferredPredicate = alias('inferredPredicate');
var InterfaceExtends = alias('interfaceExtends');
var InterfaceDeclaration = alias('interfaceDeclaration');
var InterfaceTypeAnnotation = alias('interfaceTypeAnnotation');
var IntersectionTypeAnnotation = alias('intersectionTypeAnnotation');
var MixedTypeAnnotation = alias('mixedTypeAnnotation');
var EmptyTypeAnnotation = alias('emptyTypeAnnotation');
var NullableTypeAnnotation = alias('nullableTypeAnnotation');
var NumberLiteralTypeAnnotation = alias('numberLiteralTypeAnnotation');
var NumberTypeAnnotation = alias('numberTypeAnnotation');
var ObjectTypeAnnotation = alias('objectTypeAnnotation');
var ObjectTypeInternalSlot = alias('objectTypeInternalSlot');
var ObjectTypeCallProperty = alias('objectTypeCallProperty');
var ObjectTypeIndexer = alias('objectTypeIndexer');
var ObjectTypeProperty = alias('objectTypeProperty');
var ObjectTypeSpreadProperty = alias('objectTypeSpreadProperty');
var OpaqueType = alias('opaqueType');
var QualifiedTypeIdentifier = alias('qualifiedTypeIdentifier');
var StringLiteralTypeAnnotation = alias('stringLiteralTypeAnnotation');
var StringTypeAnnotation = alias('stringTypeAnnotation');
var SymbolTypeAnnotation = alias('symbolTypeAnnotation');
var ThisTypeAnnotation = alias('thisTypeAnnotation');
var TupleTypeAnnotation = alias('tupleTypeAnnotation');
var TypeofTypeAnnotation = alias('typeofTypeAnnotation');
var TypeAlias = alias('typeAlias');
var TypeAnnotation = alias('typeAnnotation');
var TypeCastExpression = alias('typeCastExpression');
var TypeParameter = alias('typeParameter');
var TypeParameterDeclaration = alias('typeParameterDeclaration');
var TypeParameterInstantiation = alias('typeParameterInstantiation');
var UnionTypeAnnotation = alias('unionTypeAnnotation');
var Variance = alias('variance');
var VoidTypeAnnotation = alias('voidTypeAnnotation');
var EnumDeclaration = alias('enumDeclaration');
var EnumBooleanBody = alias('enumBooleanBody');
var EnumNumberBody = alias('enumNumberBody');
var EnumStringBody = alias('enumStringBody');
var EnumSymbolBody = alias('enumSymbolBody');
var EnumBooleanMember = alias('enumBooleanMember');
var EnumNumberMember = alias('enumNumberMember');
var EnumStringMember = alias('enumStringMember');
var EnumDefaultedMember = alias('enumDefaultedMember');
var IndexedAccessType = alias('indexedAccessType');
var OptionalIndexedAccessType = alias('optionalIndexedAccessType');
var JSXAttribute$1 = alias('jsxAttribute');
var JSXClosingElement = alias('jsxClosingElement');
var JSXElement$1 = alias('jsxElement');
var JSXEmptyExpression = alias('jsxEmptyExpression');
var JSXExpressionContainer = alias('jsxExpressionContainer');
var JSXSpreadChild = alias('jsxSpreadChild');
var JSXIdentifier = alias('jsxIdentifier');
var JSXMemberExpression = alias('jsxMemberExpression');
var JSXNamespacedName = alias('jsxNamespacedName');
var JSXOpeningElement$1 = alias('jsxOpeningElement');
var JSXSpreadAttribute = alias('jsxSpreadAttribute');
var JSXText$1 = alias('jsxText');
var JSXFragment = alias('jsxFragment');
var JSXOpeningFragment = alias('jsxOpeningFragment');
var JSXClosingFragment = alias('jsxClosingFragment');
var Placeholder = alias('placeholder');
var V8IntrinsicIdentifier = alias('v8IntrinsicIdentifier');
var ArgumentPlaceholder = alias('argumentPlaceholder');
var BindExpression = alias('bindExpression');
var Decorator$1 = alias('decorator');
var DoExpression = alias('doExpression');
var ExportDefaultSpecifier = alias('exportDefaultSpecifier');
var RecordExpression = alias('recordExpression');
var TupleExpression = alias('tupleExpression');
var ModuleExpression = alias('moduleExpression');
var TopicReference = alias('topicReference');
var PipelineTopicExpression = alias('pipelineTopicExpression');
var PipelineBareFunction = alias('pipelineBareFunction');
var PipelinePrimaryTopicReference = alias('pipelinePrimaryTopicReference');
var VoidPattern$1 = alias('voidPattern');
var TSParameterProperty$1 = alias('tsParameterProperty');
var TSDeclareFunction$1 = alias('tsDeclareFunction');
var TSDeclareMethod$1 = alias('tsDeclareMethod');
var TSQualifiedName = alias('tsQualifiedName');
var TSCallSignatureDeclaration$1 = alias('tsCallSignatureDeclaration');
var TSConstructSignatureDeclaration$1 = alias('tsConstructSignatureDeclaration');
var TSPropertySignature$1 = alias('tsPropertySignature');
var TSMethodSignature$1 = alias('tsMethodSignature');
var TSIndexSignature = alias('tsIndexSignature');
var TSAnyKeyword = alias('tsAnyKeyword');
var TSBooleanKeyword = alias('tsBooleanKeyword');
var TSBigIntKeyword = alias('tsBigIntKeyword');
var TSIntrinsicKeyword = alias('tsIntrinsicKeyword');
var TSNeverKeyword = alias('tsNeverKeyword');
var TSNullKeyword = alias('tsNullKeyword');
var TSNumberKeyword = alias('tsNumberKeyword');
var TSObjectKeyword = alias('tsObjectKeyword');
var TSStringKeyword = alias('tsStringKeyword');
var TSSymbolKeyword = alias('tsSymbolKeyword');
var TSUndefinedKeyword = alias('tsUndefinedKeyword');
var TSUnknownKeyword = alias('tsUnknownKeyword');
var TSVoidKeyword = alias('tsVoidKeyword');
var TSThisType = alias('tsThisType');
var TSFunctionType$1 = alias('tsFunctionType');
var TSConstructorType$1 = alias('tsConstructorType');
var TSTypeReference$1 = alias('tsTypeReference');
var TSTypePredicate = alias('tsTypePredicate');
var TSTypeQuery$1 = alias('tsTypeQuery');
var TSTypeLiteral$1 = alias('tsTypeLiteral');
var TSArrayType = alias('tsArrayType');
var TSTupleType$1 = alias('tsTupleType');
var TSOptionalType = alias('tsOptionalType');
var TSRestType = alias('tsRestType');
var TSNamedTupleMember$1 = alias('tsNamedTupleMember');
var TSUnionType$1 = alias('tsUnionType');
var TSIntersectionType$1 = alias('tsIntersectionType');
var TSConditionalType$1 = alias('tsConditionalType');
var TSInferType$1 = alias('tsInferType');
var TSParenthesizedType$1 = alias('tsParenthesizedType');
var TSTypeOperator = alias('tsTypeOperator');
var TSIndexedAccessType = alias('tsIndexedAccessType');
var TSMappedType$1 = alias('tsMappedType');
var TSTemplateLiteralType = alias('tsTemplateLiteralType');
var TSLiteralType = alias('tsLiteralType');
var TSClassImplements = alias('tsClassImplements');
var TSInterfaceHeritage = alias('tsInterfaceHeritage');
var TSInterfaceDeclaration$1 = alias('tsInterfaceDeclaration');
var TSInterfaceBody$1 = alias('tsInterfaceBody');
var TSTypeAliasDeclaration$1 = alias('tsTypeAliasDeclaration');
var TSInstantiationExpression = alias('tsInstantiationExpression');
var TSAsExpression$1 = alias('tsAsExpression');
var TSSatisfiesExpression = alias('tsSatisfiesExpression');
var TSTypeAssertion = alias('tsTypeAssertion');
var TSEnumBody = alias('tsEnumBody');
var TSEnumDeclaration$1 = alias('tsEnumDeclaration');
var TSEnumMember$1 = alias('tsEnumMember');
var TSModuleDeclaration$1 = alias('tsModuleDeclaration');
var TSModuleBlock$1 = alias('tsModuleBlock');
var TSImportType$1 = alias('tsImportType');
var TSImportEqualsDeclaration = alias('tsImportEqualsDeclaration');
var TSExternalModuleReference = alias('tsExternalModuleReference');
var TSNonNullExpression = alias('tsNonNullExpression');
var TSExportAssignment$1 = alias('tsExportAssignment');
var TSNamespaceExportDeclaration = alias('tsNamespaceExportDeclaration');
var TSTypeAnnotation = alias('tsTypeAnnotation');
var TSTypeParameterInstantiation = alias('tsTypeParameterInstantiation');
var TSTypeParameterDeclaration = alias('tsTypeParameterDeclaration');
var TSTypeParameter$1 = alias('tsTypeParameter');

function cleanJSXElementLiteralChild(child, args) {
    const lines = child.value.split(/\r\n|\n|\r/);
    let lastNonEmptyLine = 0;
    
    for (let i = 0; i < lines.length; i++) {
        if (/[^ \t]/.exec(lines[i])) {
            lastNonEmptyLine = i;
        }
    }
    
    let str = '';
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const isFirstLine = i === 0;
        const isLastLine = i === lines.length - 1;
        const isLastNonEmptyLine = i === lastNonEmptyLine;
        let trimmedLine = line.replace(/\t/g, ' ');
        
        if (!isFirstLine) {
            trimmedLine = trimmedLine.replace(/^ +/, '');
        }
        
        if (!isLastLine) {
            trimmedLine = trimmedLine.replace(/ +$/, '');
        }
        
        if (trimmedLine) {
            if (!isLastNonEmptyLine) {
                trimmedLine += ' ';
            }
            
            str += trimmedLine;
        }
    }
    
    if (str)
        args.push(inherits(stringLiteral$5(str), child));
}

function buildChildren(node) {
    const elements = [];
    
    for (let i = 0; i < node.children.length; i++) {
        let child = node.children[i];
        
        if (isJSXText$4(child)) {
            cleanJSXElementLiteralChild(child, elements);
            continue;
        }
        
        if (isJSXExpressionContainer(child))
            child = child.expression;
        
        if (isJSXEmptyExpression(child))
            continue;
        
        elements.push(child);
    }
    
    return elements;
}

function isNode(node) {
    return !!(node && VISITOR_KEYS[node.type]);
}

function assertNode(node) {
    if (!isNode(node)) {
        const type = node?.type ?? JSON.stringify(node);
        throw new TypeError(`Not a valid node of type "${type}"`);
    }
}

function assert(type, node, opts) {
    if (!is$4(type, node, opts)) {
        throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, but instead got "${node.type}".`);
    }
}

function assertArrayExpression(node, opts) {
    assert('ArrayExpression', node, opts);
}

function assertAssignmentExpression(node, opts) {
    assert('AssignmentExpression', node, opts);
}

function assertBinaryExpression(node, opts) {
    assert('BinaryExpression', node, opts);
}

function assertInterpreterDirective(node, opts) {
    assert('InterpreterDirective', node, opts);
}

function assertDirective(node, opts) {
    assert('Directive', node, opts);
}

function assertDirectiveLiteral(node, opts) {
    assert('DirectiveLiteral', node, opts);
}

function assertBlockStatement(node, opts) {
    assert('BlockStatement', node, opts);
}

function assertBreakStatement(node, opts) {
    assert('BreakStatement', node, opts);
}

function assertCallExpression(node, opts) {
    assert('CallExpression', node, opts);
}

function assertCatchClause(node, opts) {
    assert('CatchClause', node, opts);
}

function assertConditionalExpression(node, opts) {
    assert('ConditionalExpression', node, opts);
}

function assertContinueStatement(node, opts) {
    assert('ContinueStatement', node, opts);
}

function assertDebuggerStatement(node, opts) {
    assert('DebuggerStatement', node, opts);
}

function assertDoWhileStatement(node, opts) {
    assert('DoWhileStatement', node, opts);
}

function assertEmptyStatement(node, opts) {
    assert('EmptyStatement', node, opts);
}

function assertExpressionStatement(node, opts) {
    assert('ExpressionStatement', node, opts);
}

function assertFile(node, opts) {
    assert('File', node, opts);
}

function assertForInStatement(node, opts) {
    assert('ForInStatement', node, opts);
}

function assertForStatement(node, opts) {
    assert('ForStatement', node, opts);
}

function assertFunctionDeclaration(node, opts) {
    assert('FunctionDeclaration', node, opts);
}

function assertFunctionExpression(node, opts) {
    assert('FunctionExpression', node, opts);
}

function assertIdentifier(node, opts) {
    assert('Identifier', node, opts);
}

function assertIfStatement(node, opts) {
    assert('IfStatement', node, opts);
}

function assertLabeledStatement(node, opts) {
    assert('LabeledStatement', node, opts);
}

function assertStringLiteral(node, opts) {
    assert('StringLiteral', node, opts);
}

function assertNumericLiteral(node, opts) {
    assert('NumericLiteral', node, opts);
}

function assertNullLiteral(node, opts) {
    assert('NullLiteral', node, opts);
}

function assertBooleanLiteral(node, opts) {
    assert('BooleanLiteral', node, opts);
}

function assertRegExpLiteral(node, opts) {
    assert('RegExpLiteral', node, opts);
}

function assertLogicalExpression(node, opts) {
    assert('LogicalExpression', node, opts);
}

function assertMemberExpression(node, opts) {
    assert('MemberExpression', node, opts);
}

function assertNewExpression(node, opts) {
    assert('NewExpression', node, opts);
}

function assertProgram(node, opts) {
    assert('Program', node, opts);
}

function assertObjectExpression(node, opts) {
    assert('ObjectExpression', node, opts);
}

function assertObjectMethod(node, opts) {
    assert('ObjectMethod', node, opts);
}

function assertObjectProperty(node, opts) {
    assert('ObjectProperty', node, opts);
}

function assertRestElement(node, opts) {
    assert('RestElement', node, opts);
}

function assertReturnStatement(node, opts) {
    assert('ReturnStatement', node, opts);
}

function assertSequenceExpression(node, opts) {
    assert('SequenceExpression', node, opts);
}

function assertParenthesizedExpression(node, opts) {
    assert('ParenthesizedExpression', node, opts);
}

function assertSwitchCase(node, opts) {
    assert('SwitchCase', node, opts);
}

function assertSwitchStatement(node, opts) {
    assert('SwitchStatement', node, opts);
}

function assertThisExpression(node, opts) {
    assert('ThisExpression', node, opts);
}

function assertThrowStatement(node, opts) {
    assert('ThrowStatement', node, opts);
}

function assertTryStatement(node, opts) {
    assert('TryStatement', node, opts);
}

function assertUnaryExpression(node, opts) {
    assert('UnaryExpression', node, opts);
}

function assertUpdateExpression(node, opts) {
    assert('UpdateExpression', node, opts);
}

function assertVariableDeclaration(node, opts) {
    assert('VariableDeclaration', node, opts);
}

function assertVariableDeclarator(node, opts) {
    assert('VariableDeclarator', node, opts);
}

function assertWhileStatement(node, opts) {
    assert('WhileStatement', node, opts);
}

function assertWithStatement(node, opts) {
    assert('WithStatement', node, opts);
}

function assertAssignmentPattern(node, opts) {
    assert('AssignmentPattern', node, opts);
}

function assertArrayPattern(node, opts) {
    assert('ArrayPattern', node, opts);
}

function assertArrowFunctionExpression(node, opts) {
    assert('ArrowFunctionExpression', node, opts);
}

function assertClassBody(node, opts) {
    assert('ClassBody', node, opts);
}

function assertClassExpression(node, opts) {
    assert('ClassExpression', node, opts);
}

function assertClassDeclaration(node, opts) {
    assert('ClassDeclaration', node, opts);
}

function assertExportAllDeclaration(node, opts) {
    assert('ExportAllDeclaration', node, opts);
}

function assertExportDefaultDeclaration(node, opts) {
    assert('ExportDefaultDeclaration', node, opts);
}

function assertExportNamedDeclaration(node, opts) {
    assert('ExportNamedDeclaration', node, opts);
}

function assertExportSpecifier(node, opts) {
    assert('ExportSpecifier', node, opts);
}

function assertForOfStatement(node, opts) {
    assert('ForOfStatement', node, opts);
}

function assertImportDeclaration(node, opts) {
    assert('ImportDeclaration', node, opts);
}

function assertImportDefaultSpecifier(node, opts) {
    assert('ImportDefaultSpecifier', node, opts);
}

function assertImportNamespaceSpecifier(node, opts) {
    assert('ImportNamespaceSpecifier', node, opts);
}

function assertImportSpecifier(node, opts) {
    assert('ImportSpecifier', node, opts);
}

function assertImportExpression(node, opts) {
    assert('ImportExpression', node, opts);
}

function assertMetaProperty(node, opts) {
    assert('MetaProperty', node, opts);
}

function assertClassMethod(node, opts) {
    assert('ClassMethod', node, opts);
}

function assertObjectPattern(node, opts) {
    assert('ObjectPattern', node, opts);
}

function assertSpreadElement(node, opts) {
    assert('SpreadElement', node, opts);
}

function assertSuper(node, opts) {
    assert('Super', node, opts);
}

function assertTaggedTemplateExpression(node, opts) {
    assert('TaggedTemplateExpression', node, opts);
}

function assertTemplateElement(node, opts) {
    assert('TemplateElement', node, opts);
}

function assertTemplateLiteral(node, opts) {
    assert('TemplateLiteral', node, opts);
}

function assertYieldExpression(node, opts) {
    assert('YieldExpression', node, opts);
}

function assertAwaitExpression(node, opts) {
    assert('AwaitExpression', node, opts);
}

function assertImport(node, opts) {
    assert('Import', node, opts);
}

function assertBigIntLiteral(node, opts) {
    assert('BigIntLiteral', node, opts);
}

function assertExportNamespaceSpecifier(node, opts) {
    assert('ExportNamespaceSpecifier', node, opts);
}

function assertOptionalMemberExpression(node, opts) {
    assert('OptionalMemberExpression', node, opts);
}

function assertOptionalCallExpression(node, opts) {
    assert('OptionalCallExpression', node, opts);
}

function assertClassProperty(node, opts) {
    assert('ClassProperty', node, opts);
}

function assertClassAccessorProperty(node, opts) {
    assert('ClassAccessorProperty', node, opts);
}

function assertClassPrivateProperty(node, opts) {
    assert('ClassPrivateProperty', node, opts);
}

function assertClassPrivateMethod(node, opts) {
    assert('ClassPrivateMethod', node, opts);
}

function assertPrivateName(node, opts) {
    assert('PrivateName', node, opts);
}

function assertStaticBlock(node, opts) {
    assert('StaticBlock', node, opts);
}

function assertImportAttribute(node, opts) {
    assert('ImportAttribute', node, opts);
}

function assertAnyTypeAnnotation(node, opts) {
    assert('AnyTypeAnnotation', node, opts);
}

function assertArrayTypeAnnotation(node, opts) {
    assert('ArrayTypeAnnotation', node, opts);
}

function assertBooleanTypeAnnotation(node, opts) {
    assert('BooleanTypeAnnotation', node, opts);
}

function assertBooleanLiteralTypeAnnotation(node, opts) {
    assert('BooleanLiteralTypeAnnotation', node, opts);
}

function assertNullLiteralTypeAnnotation(node, opts) {
    assert('NullLiteralTypeAnnotation', node, opts);
}

function assertClassImplements(node, opts) {
    assert('ClassImplements', node, opts);
}

function assertDeclareClass(node, opts) {
    assert('DeclareClass', node, opts);
}

function assertDeclareFunction(node, opts) {
    assert('DeclareFunction', node, opts);
}

function assertDeclareInterface(node, opts) {
    assert('DeclareInterface', node, opts);
}

function assertDeclareModule(node, opts) {
    assert('DeclareModule', node, opts);
}

function assertDeclareModuleExports(node, opts) {
    assert('DeclareModuleExports', node, opts);
}

function assertDeclareTypeAlias(node, opts) {
    assert('DeclareTypeAlias', node, opts);
}

function assertDeclareOpaqueType(node, opts) {
    assert('DeclareOpaqueType', node, opts);
}

function assertDeclareVariable(node, opts) {
    assert('DeclareVariable', node, opts);
}

function assertDeclareExportDeclaration(node, opts) {
    assert('DeclareExportDeclaration', node, opts);
}

function assertDeclareExportAllDeclaration(node, opts) {
    assert('DeclareExportAllDeclaration', node, opts);
}

function assertDeclaredPredicate(node, opts) {
    assert('DeclaredPredicate', node, opts);
}

function assertExistsTypeAnnotation(node, opts) {
    assert('ExistsTypeAnnotation', node, opts);
}

function assertFunctionTypeAnnotation(node, opts) {
    assert('FunctionTypeAnnotation', node, opts);
}

function assertFunctionTypeParam(node, opts) {
    assert('FunctionTypeParam', node, opts);
}

function assertGenericTypeAnnotation(node, opts) {
    assert('GenericTypeAnnotation', node, opts);
}

function assertInferredPredicate(node, opts) {
    assert('InferredPredicate', node, opts);
}

function assertInterfaceExtends(node, opts) {
    assert('InterfaceExtends', node, opts);
}

function assertInterfaceDeclaration(node, opts) {
    assert('InterfaceDeclaration', node, opts);
}

function assertInterfaceTypeAnnotation(node, opts) {
    assert('InterfaceTypeAnnotation', node, opts);
}

function assertIntersectionTypeAnnotation(node, opts) {
    assert('IntersectionTypeAnnotation', node, opts);
}

function assertMixedTypeAnnotation(node, opts) {
    assert('MixedTypeAnnotation', node, opts);
}

function assertEmptyTypeAnnotation(node, opts) {
    assert('EmptyTypeAnnotation', node, opts);
}

function assertNullableTypeAnnotation(node, opts) {
    assert('NullableTypeAnnotation', node, opts);
}

function assertNumberLiteralTypeAnnotation(node, opts) {
    assert('NumberLiteralTypeAnnotation', node, opts);
}

function assertNumberTypeAnnotation(node, opts) {
    assert('NumberTypeAnnotation', node, opts);
}

function assertObjectTypeAnnotation(node, opts) {
    assert('ObjectTypeAnnotation', node, opts);
}

function assertObjectTypeInternalSlot(node, opts) {
    assert('ObjectTypeInternalSlot', node, opts);
}

function assertObjectTypeCallProperty(node, opts) {
    assert('ObjectTypeCallProperty', node, opts);
}

function assertObjectTypeIndexer(node, opts) {
    assert('ObjectTypeIndexer', node, opts);
}

function assertObjectTypeProperty(node, opts) {
    assert('ObjectTypeProperty', node, opts);
}

function assertObjectTypeSpreadProperty(node, opts) {
    assert('ObjectTypeSpreadProperty', node, opts);
}

function assertOpaqueType(node, opts) {
    assert('OpaqueType', node, opts);
}

function assertQualifiedTypeIdentifier(node, opts) {
    assert('QualifiedTypeIdentifier', node, opts);
}

function assertStringLiteralTypeAnnotation(node, opts) {
    assert('StringLiteralTypeAnnotation', node, opts);
}

function assertStringTypeAnnotation(node, opts) {
    assert('StringTypeAnnotation', node, opts);
}

function assertSymbolTypeAnnotation(node, opts) {
    assert('SymbolTypeAnnotation', node, opts);
}

function assertThisTypeAnnotation(node, opts) {
    assert('ThisTypeAnnotation', node, opts);
}

function assertTupleTypeAnnotation(node, opts) {
    assert('TupleTypeAnnotation', node, opts);
}

function assertTypeofTypeAnnotation(node, opts) {
    assert('TypeofTypeAnnotation', node, opts);
}

function assertTypeAlias(node, opts) {
    assert('TypeAlias', node, opts);
}

function assertTypeAnnotation(node, opts) {
    assert('TypeAnnotation', node, opts);
}

function assertTypeCastExpression(node, opts) {
    assert('TypeCastExpression', node, opts);
}

function assertTypeParameter(node, opts) {
    assert('TypeParameter', node, opts);
}

function assertTypeParameterDeclaration(node, opts) {
    assert('TypeParameterDeclaration', node, opts);
}

function assertTypeParameterInstantiation(node, opts) {
    assert('TypeParameterInstantiation', node, opts);
}

function assertUnionTypeAnnotation(node, opts) {
    assert('UnionTypeAnnotation', node, opts);
}

function assertVariance(node, opts) {
    assert('Variance', node, opts);
}

function assertVoidTypeAnnotation(node, opts) {
    assert('VoidTypeAnnotation', node, opts);
}

function assertEnumDeclaration(node, opts) {
    assert('EnumDeclaration', node, opts);
}

function assertEnumBooleanBody(node, opts) {
    assert('EnumBooleanBody', node, opts);
}

function assertEnumNumberBody(node, opts) {
    assert('EnumNumberBody', node, opts);
}

function assertEnumStringBody(node, opts) {
    assert('EnumStringBody', node, opts);
}

function assertEnumSymbolBody(node, opts) {
    assert('EnumSymbolBody', node, opts);
}

function assertEnumBooleanMember(node, opts) {
    assert('EnumBooleanMember', node, opts);
}

function assertEnumNumberMember(node, opts) {
    assert('EnumNumberMember', node, opts);
}

function assertEnumStringMember(node, opts) {
    assert('EnumStringMember', node, opts);
}

function assertEnumDefaultedMember(node, opts) {
    assert('EnumDefaultedMember', node, opts);
}

function assertIndexedAccessType(node, opts) {
    assert('IndexedAccessType', node, opts);
}

function assertOptionalIndexedAccessType(node, opts) {
    assert('OptionalIndexedAccessType', node, opts);
}

function assertJSXAttribute(node, opts) {
    assert('JSXAttribute', node, opts);
}

function assertJSXClosingElement(node, opts) {
    assert('JSXClosingElement', node, opts);
}

function assertJSXElement(node, opts) {
    assert('JSXElement', node, opts);
}

function assertJSXEmptyExpression(node, opts) {
    assert('JSXEmptyExpression', node, opts);
}

function assertJSXExpressionContainer(node, opts) {
    assert('JSXExpressionContainer', node, opts);
}

function assertJSXSpreadChild(node, opts) {
    assert('JSXSpreadChild', node, opts);
}

function assertJSXIdentifier(node, opts) {
    assert('JSXIdentifier', node, opts);
}

function assertJSXMemberExpression(node, opts) {
    assert('JSXMemberExpression', node, opts);
}

function assertJSXNamespacedName(node, opts) {
    assert('JSXNamespacedName', node, opts);
}

function assertJSXOpeningElement(node, opts) {
    assert('JSXOpeningElement', node, opts);
}

function assertJSXSpreadAttribute(node, opts) {
    assert('JSXSpreadAttribute', node, opts);
}

function assertJSXText(node, opts) {
    assert('JSXText', node, opts);
}

function assertJSXFragment(node, opts) {
    assert('JSXFragment', node, opts);
}

function assertJSXOpeningFragment(node, opts) {
    assert('JSXOpeningFragment', node, opts);
}

function assertJSXClosingFragment(node, opts) {
    assert('JSXClosingFragment', node, opts);
}

function assertPlaceholder(node, opts) {
    assert('Placeholder', node, opts);
}

function assertV8IntrinsicIdentifier(node, opts) {
    assert('V8IntrinsicIdentifier', node, opts);
}

function assertArgumentPlaceholder(node, opts) {
    assert('ArgumentPlaceholder', node, opts);
}

function assertBindExpression(node, opts) {
    assert('BindExpression', node, opts);
}

function assertDecorator(node, opts) {
    assert('Decorator', node, opts);
}

function assertDoExpression(node, opts) {
    assert('DoExpression', node, opts);
}

function assertExportDefaultSpecifier(node, opts) {
    assert('ExportDefaultSpecifier', node, opts);
}

function assertRecordExpression(node, opts) {
    assert('RecordExpression', node, opts);
}

function assertTupleExpression(node, opts) {
    assert('TupleExpression', node, opts);
}

function assertModuleExpression(node, opts) {
    assert('ModuleExpression', node, opts);
}

function assertTopicReference(node, opts) {
    assert('TopicReference', node, opts);
}

function assertPipelineTopicExpression(node, opts) {
    assert('PipelineTopicExpression', node, opts);
}

function assertPipelineBareFunction(node, opts) {
    assert('PipelineBareFunction', node, opts);
}

function assertPipelinePrimaryTopicReference(node, opts) {
    assert('PipelinePrimaryTopicReference', node, opts);
}

function assertVoidPattern(node, opts) {
    assert('VoidPattern', node, opts);
}

function assertTSParameterProperty(node, opts) {
    assert('TSParameterProperty', node, opts);
}

function assertTSDeclareFunction(node, opts) {
    assert('TSDeclareFunction', node, opts);
}

function assertTSDeclareMethod(node, opts) {
    assert('TSDeclareMethod', node, opts);
}

function assertTSQualifiedName(node, opts) {
    assert('TSQualifiedName', node, opts);
}

function assertTSCallSignatureDeclaration(node, opts) {
    assert('TSCallSignatureDeclaration', node, opts);
}

function assertTSConstructSignatureDeclaration(node, opts) {
    assert('TSConstructSignatureDeclaration', node, opts);
}

function assertTSPropertySignature(node, opts) {
    assert('TSPropertySignature', node, opts);
}

function assertTSMethodSignature(node, opts) {
    assert('TSMethodSignature', node, opts);
}

function assertTSIndexSignature(node, opts) {
    assert('TSIndexSignature', node, opts);
}

function assertTSAnyKeyword(node, opts) {
    assert('TSAnyKeyword', node, opts);
}

function assertTSBooleanKeyword(node, opts) {
    assert('TSBooleanKeyword', node, opts);
}

function assertTSBigIntKeyword(node, opts) {
    assert('TSBigIntKeyword', node, opts);
}

function assertTSIntrinsicKeyword(node, opts) {
    assert('TSIntrinsicKeyword', node, opts);
}

function assertTSNeverKeyword(node, opts) {
    assert('TSNeverKeyword', node, opts);
}

function assertTSNullKeyword(node, opts) {
    assert('TSNullKeyword', node, opts);
}

function assertTSNumberKeyword(node, opts) {
    assert('TSNumberKeyword', node, opts);
}

function assertTSObjectKeyword(node, opts) {
    assert('TSObjectKeyword', node, opts);
}

function assertTSStringKeyword(node, opts) {
    assert('TSStringKeyword', node, opts);
}

function assertTSSymbolKeyword(node, opts) {
    assert('TSSymbolKeyword', node, opts);
}

function assertTSUndefinedKeyword(node, opts) {
    assert('TSUndefinedKeyword', node, opts);
}

function assertTSUnknownKeyword(node, opts) {
    assert('TSUnknownKeyword', node, opts);
}

function assertTSVoidKeyword(node, opts) {
    assert('TSVoidKeyword', node, opts);
}

function assertTSThisType(node, opts) {
    assert('TSThisType', node, opts);
}

function assertTSFunctionType(node, opts) {
    assert('TSFunctionType', node, opts);
}

function assertTSConstructorType(node, opts) {
    assert('TSConstructorType', node, opts);
}

function assertTSTypeReference(node, opts) {
    assert('TSTypeReference', node, opts);
}

function assertTSTypePredicate(node, opts) {
    assert('TSTypePredicate', node, opts);
}

function assertTSTypeQuery(node, opts) {
    assert('TSTypeQuery', node, opts);
}

function assertTSTypeLiteral(node, opts) {
    assert('TSTypeLiteral', node, opts);
}

function assertTSArrayType(node, opts) {
    assert('TSArrayType', node, opts);
}

function assertTSTupleType(node, opts) {
    assert('TSTupleType', node, opts);
}

function assertTSOptionalType(node, opts) {
    assert('TSOptionalType', node, opts);
}

function assertTSRestType(node, opts) {
    assert('TSRestType', node, opts);
}

function assertTSNamedTupleMember(node, opts) {
    assert('TSNamedTupleMember', node, opts);
}

function assertTSUnionType(node, opts) {
    assert('TSUnionType', node, opts);
}

function assertTSIntersectionType(node, opts) {
    assert('TSIntersectionType', node, opts);
}

function assertTSConditionalType(node, opts) {
    assert('TSConditionalType', node, opts);
}

function assertTSInferType(node, opts) {
    assert('TSInferType', node, opts);
}

function assertTSParenthesizedType(node, opts) {
    assert('TSParenthesizedType', node, opts);
}

function assertTSTypeOperator(node, opts) {
    assert('TSTypeOperator', node, opts);
}

function assertTSIndexedAccessType(node, opts) {
    assert('TSIndexedAccessType', node, opts);
}

function assertTSMappedType(node, opts) {
    assert('TSMappedType', node, opts);
}

function assertTSTemplateLiteralType(node, opts) {
    assert('TSTemplateLiteralType', node, opts);
}

function assertTSLiteralType(node, opts) {
    assert('TSLiteralType', node, opts);
}

function assertTSClassImplements(node, opts) {
    assert('TSClassImplements', node, opts);
}

function assertTSInterfaceHeritage(node, opts) {
    assert('TSInterfaceHeritage', node, opts);
}

function assertTSInterfaceDeclaration(node, opts) {
    assert('TSInterfaceDeclaration', node, opts);
}

function assertTSInterfaceBody(node, opts) {
    assert('TSInterfaceBody', node, opts);
}

function assertTSTypeAliasDeclaration(node, opts) {
    assert('TSTypeAliasDeclaration', node, opts);
}

function assertTSInstantiationExpression(node, opts) {
    assert('TSInstantiationExpression', node, opts);
}

function assertTSAsExpression(node, opts) {
    assert('TSAsExpression', node, opts);
}

function assertTSSatisfiesExpression(node, opts) {
    assert('TSSatisfiesExpression', node, opts);
}

function assertTSTypeAssertion(node, opts) {
    assert('TSTypeAssertion', node, opts);
}

function assertTSEnumBody(node, opts) {
    assert('TSEnumBody', node, opts);
}

function assertTSEnumDeclaration(node, opts) {
    assert('TSEnumDeclaration', node, opts);
}

function assertTSEnumMember(node, opts) {
    assert('TSEnumMember', node, opts);
}

function assertTSModuleDeclaration(node, opts) {
    assert('TSModuleDeclaration', node, opts);
}

function assertTSModuleBlock(node, opts) {
    assert('TSModuleBlock', node, opts);
}

function assertTSImportType(node, opts) {
    assert('TSImportType', node, opts);
}

function assertTSImportEqualsDeclaration(node, opts) {
    assert('TSImportEqualsDeclaration', node, opts);
}

function assertTSExternalModuleReference(node, opts) {
    assert('TSExternalModuleReference', node, opts);
}

function assertTSNonNullExpression(node, opts) {
    assert('TSNonNullExpression', node, opts);
}

function assertTSExportAssignment(node, opts) {
    assert('TSExportAssignment', node, opts);
}

function assertTSNamespaceExportDeclaration(node, opts) {
    assert('TSNamespaceExportDeclaration', node, opts);
}

function assertTSTypeAnnotation(node, opts) {
    assert('TSTypeAnnotation', node, opts);
}

function assertTSTypeParameterInstantiation(node, opts) {
    assert('TSTypeParameterInstantiation', node, opts);
}

function assertTSTypeParameterDeclaration(node, opts) {
    assert('TSTypeParameterDeclaration', node, opts);
}

function assertTSTypeParameter(node, opts) {
    assert('TSTypeParameter', node, opts);
}

function assertStandardized(node, opts) {
    assert('Standardized', node, opts);
}

function assertExpression(node, opts) {
    assert('Expression', node, opts);
}

function assertBinary(node, opts) {
    assert('Binary', node, opts);
}

function assertScopable(node, opts) {
    assert('Scopable', node, opts);
}

function assertBlockParent(node, opts) {
    assert('BlockParent', node, opts);
}

function assertBlock(node, opts) {
    assert('Block', node, opts);
}

function assertStatement(node, opts) {
    assert('Statement', node, opts);
}

function assertTerminatorless(node, opts) {
    assert('Terminatorless', node, opts);
}

function assertCompletionStatement(node, opts) {
    assert('CompletionStatement', node, opts);
}

function assertConditional(node, opts) {
    assert('Conditional', node, opts);
}

function assertLoop(node, opts) {
    assert('Loop', node, opts);
}

function assertWhile(node, opts) {
    assert('While', node, opts);
}

function assertExpressionWrapper(node, opts) {
    assert('ExpressionWrapper', node, opts);
}

function assertFor(node, opts) {
    assert('For', node, opts);
}

function assertForXStatement(node, opts) {
    assert('ForXStatement', node, opts);
}

function assertFunction(node, opts) {
    assert('Function', node, opts);
}

function assertFunctionParent(node, opts) {
    assert('FunctionParent', node, opts);
}

function assertPureish(node, opts) {
    assert('Pureish', node, opts);
}

function assertDeclaration(node, opts) {
    assert('Declaration', node, opts);
}

function assertFunctionParameter(node, opts) {
    assert('FunctionParameter', node, opts);
}

function assertPatternLike(node, opts) {
    assert('PatternLike', node, opts);
}

function assertLVal(node, opts) {
    assert('LVal', node, opts);
}

function assertTSEntityName(node, opts) {
    assert('TSEntityName', node, opts);
}

function assertLiteral(node, opts) {
    assert('Literal', node, opts);
}

function assertImmutable(node, opts) {
    assert('Immutable', node, opts);
}

function assertUserWhitespacable(node, opts) {
    assert('UserWhitespacable', node, opts);
}

function assertMethod(node, opts) {
    assert('Method', node, opts);
}

function assertObjectMember(node, opts) {
    assert('ObjectMember', node, opts);
}

function assertProperty(node, opts) {
    assert('Property', node, opts);
}

function assertUnaryLike(node, opts) {
    assert('UnaryLike', node, opts);
}

function assertPattern(node, opts) {
    assert('Pattern', node, opts);
}

function assertClass(node, opts) {
    assert('Class', node, opts);
}

function assertImportOrExportDeclaration(node, opts) {
    assert('ImportOrExportDeclaration', node, opts);
}

function assertExportDeclaration(node, opts) {
    assert('ExportDeclaration', node, opts);
}

function assertModuleSpecifier(node, opts) {
    assert('ModuleSpecifier', node, opts);
}

function assertAccessor(node, opts) {
    assert('Accessor', node, opts);
}

function assertPrivate(node, opts) {
    assert('Private', node, opts);
}

function assertFlow(node, opts) {
    assert('Flow', node, opts);
}

function assertFlowType(node, opts) {
    assert('FlowType', node, opts);
}

function assertFlowBaseAnnotation(node, opts) {
    assert('FlowBaseAnnotation', node, opts);
}

function assertFlowDeclaration(node, opts) {
    assert('FlowDeclaration', node, opts);
}

function assertFlowPredicate(node, opts) {
    assert('FlowPredicate', node, opts);
}

function assertEnumBody(node, opts) {
    assert('EnumBody', node, opts);
}

function assertEnumMember(node, opts) {
    assert('EnumMember', node, opts);
}

function assertJSX(node, opts) {
    assert('JSX', node, opts);
}

function assertMiscellaneous(node, opts) {
    assert('Miscellaneous', node, opts);
}

function assertTypeScript(node, opts) {
    assert('TypeScript', node, opts);
}

function assertTSTypeElement(node, opts) {
    assert('TSTypeElement', node, opts);
}

function assertTSType(node, opts) {
    assert('TSType', node, opts);
}

function assertTSBaseType(node, opts) {
    assert('TSBaseType', node, opts);
}

function assertNumberLiteral(node, opts) {
    deprecationWarning('assertNumberLiteral', 'assertNumericLiteral');
    assert('NumberLiteral', node, opts);
}

function assertRegexLiteral(node, opts) {
    deprecationWarning('assertRegexLiteral', 'assertRegExpLiteral');
    assert('RegexLiteral', node, opts);
}

function assertRestProperty(node, opts) {
    deprecationWarning('assertRestProperty', 'assertRestElement');
    assert('RestProperty', node, opts);
}

function assertSpreadProperty(node, opts) {
    deprecationWarning('assertSpreadProperty', 'assertSpreadElement');
    assert('SpreadProperty', node, opts);
}

function assertModuleDeclaration(node, opts) {
    deprecationWarning('assertModuleDeclaration', 'assertImportOrExportDeclaration');
    assert('ModuleDeclaration', node, opts);
}

function createTypeAnnotationBasedOnTypeof(type) {
    switch(type) {
    case 'string':
        return stringTypeAnnotation();
    
    case 'number':
        return numberTypeAnnotation();
    
    case 'undefined':
        return voidTypeAnnotation();
    
    case 'boolean':
        return booleanTypeAnnotation();
    
    case 'function':
        return genericTypeAnnotation(identifier$3('Function'));
    
    case 'object':
        return genericTypeAnnotation(identifier$3('Object'));
    
    case 'symbol':
        return genericTypeAnnotation(identifier$3('Symbol'));
    
    case 'bigint':
        return anyTypeAnnotation();
    }
    
    throw new Error('Invalid typeof value: ' + type);
}

function getQualifiedName$1(node) {
    return isIdentifier$g(node) ? node.name : `${node.id.name}.${getQualifiedName$1(node.qualification)}`;
}

function removeTypeDuplicates$1(nodesIn) {
    const nodes2 = Array.from(nodesIn);
    const generics =     /* @__PURE__ */new Map();
    const bases =     /* @__PURE__ */new Map();
    const typeGroups =     /* @__PURE__ */new Set();
    const types2 = [];
    
    for (let i = 0; i < nodes2.length; i++) {
        const node = nodes2[i];
        
        if (!node)
            continue;
        
        if (types2.includes(node)) {
            continue;
        }
        
        if (isAnyTypeAnnotation(node)) {
            return [node];
        }
        
        if (isFlowBaseAnnotation()) {
            bases.set(node.type, node);
            continue;
        }
        
        if (isUnionTypeAnnotation(node)) {
            if (!typeGroups.has(node.types)) {
                nodes2.push(...node.types);
                typeGroups.add(node.types);
            }
            
            continue;
        }
        
        if (isGenericTypeAnnotation(node)) {
            const name = getQualifiedName$1(node.id);
            
            if (generics.has(name)) {
                let existing = generics.get(name);
                
                if (existing.typeParameters) {
                    if (node.typeParameters) {
                        existing.typeParameters.params.push(...node.typeParameters.params);
                        existing.typeParameters.params = removeTypeDuplicates$1(existing.typeParameters.params);
                    }
                } else {
                    existing = node.typeParameters;
                }
            } else {
                generics.set(name, node);
            }
            
            continue;
        }
        
        types2.push(node);
    }
    
    for (const [, baseType] of bases) {
        types2.push(baseType);
    }
    
    for (const [, genericName] of generics) {
        types2.push(genericName);
    }
    
    return types2;
}

function createFlowUnionType(types2) {
    const flattened = removeTypeDuplicates$1(types2);
    
    if (flattened.length === 1) {
        return flattened[0];
    } else {
        return unionTypeAnnotation(flattened);
    }
}

function getQualifiedName(node) {
    return isIdentifier$g(node) ? node.name : isThisExpression(node) ? 'this' : `${node.right.name}.${getQualifiedName(node.left)}`;
}

function removeTypeDuplicates(nodesIn) {
    const nodes2 = Array.from(nodesIn);
    const generics =     /* @__PURE__ */new Map();
    const bases =     /* @__PURE__ */new Map();
    const typeGroups =     /* @__PURE__ */new Set();
    const types2 = [];
    
    for (let i = 0; i < nodes2.length; i++) {
        const node = nodes2[i];
        
        if (!node)
            continue;
        
        if (types2.includes(node)) {
            continue;
        }
        
        if (isTSAnyKeyword(node)) {
            return [node];
        }
        
        if (isTSBaseType(node)) {
            bases.set(node.type, node);
            continue;
        }
        
        if (isTSUnionType(node)) {
            if (!typeGroups.has(node.types)) {
                nodes2.push(...node.types);
                typeGroups.add(node.types);
            }
            
            continue;
        }
        
        const typeArgumentsKey = 'typeArguments';
        
        if (isTSTypeReference$3(node) && node[typeArgumentsKey]) {
            const typeArguments = node[typeArgumentsKey];
            const name = getQualifiedName(node.typeName);
            
            if (generics.has(name)) {
                let existing = generics.get(name);
                const existingTypeArguments = existing[typeArgumentsKey];
                
                if (existingTypeArguments) {
                    existingTypeArguments.params.push(...typeArguments.params);
                    existingTypeArguments.params = removeTypeDuplicates(existingTypeArguments.params);
                } else {
                    existing = typeArguments;
                }
            } else {
                generics.set(name, node);
            }
            
            continue;
        }
        
        types2.push(node);
    }
    
    for (const [, baseType] of bases) {
        types2.push(baseType);
    }
    
    for (const [, genericName] of generics) {
        types2.push(genericName);
    }
    
    return types2;
}

function createTSUnionType(typeAnnotations) {
    const types2 = typeAnnotations.map((type) => {
        return isTSTypeAnnotation(type) ? type.typeAnnotation : type;
    });
    
    const flattened = removeTypeDuplicates(types2);
    
    if (flattened.length === 1) {
        return flattened[0];
    } else {
        return tsUnionType$1(flattened);
    }
}

function buildUndefinedNode() {
    return unaryExpression$1('void', numericLiteral(0), true);
}

var {hasOwn} = Object;

function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
    if (obj && typeof obj.type === 'string') {
        return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
    }
    
    return obj;
}

function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
    if (Array.isArray(obj)) {
        return obj.map((node) => cloneIfNode(node, deep, withoutLoc, commentsCache));
    }
    
    return cloneIfNode(obj, deep, withoutLoc, commentsCache);
}

function cloneNode(node, deep = true, withoutLoc = false) {
    return cloneNodeInternal(node, deep, withoutLoc,     /* @__PURE__ */new Map());
}

function cloneNodeInternal(node, deep = true, withoutLoc = false, commentsCache) {
    if (!node)
        return node;
    
    const {type} = node;
    
    const newNode = {
        type: node.type,
    };
    
    if (isIdentifier$g(node)) {
        newNode.name = node.name;
        
        if (hasOwn(node, 'optional') && typeof node.optional === 'boolean') {
            newNode.optional = node.optional;
        }
        
        if (hasOwn(node, 'typeAnnotation')) {
            newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;
        }
        
        if (hasOwn(node, 'decorators')) {
            newNode.decorators = deep ? cloneIfNodeOrArray(node.decorators, true, withoutLoc, commentsCache) : node.decorators;
        }
    } else if (!hasOwn(NODE_FIELDS$1, type)) {
        throw new Error(`Unknown node type: "${type}"`);
    } else {
        for (const field of Object.keys(NODE_FIELDS$1[type])) {
            if (hasOwn(node, field)) {
                if (deep) {
                    newNode[field] = isFile$2(node) && field === 'comments' ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache);
                } else {
                    newNode[field] = node[field];
                }
            }
        }
    }
    
    if (hasOwn(node, 'loc')) {
        if (withoutLoc) {
            newNode.loc = null;
        } else {
            newNode.loc = node.loc;
        }
    }
    
    if (hasOwn(node, 'leadingComments')) {
        newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);
    }
    
    if (hasOwn(node, 'innerComments')) {
        newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);
    }
    
    if (hasOwn(node, 'trailingComments')) {
        newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);
    }
    
    if (hasOwn(node, 'extra')) {
        newNode.extra = Object.assign({}, node.extra);
    }
    
    return newNode;
}

function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
    if (!comments || !deep) {
        return comments;
    }
    
    return comments.map((comment) => {
        const cache2 = commentsCache.get(comment);
        
        if (cache2)
            return cache2;
        
        const {
            type,
            value,
            loc,
        } = comment;
        
        const ret = {
            type,
            value,
            loc,
        };
        
        if (withoutLoc) {
            ret.loc = null;
        }
        
        commentsCache.set(comment, ret);
        return ret;
    });
}

function clone$2(node) {
    return cloneNode(node, false);
}

function cloneDeep(node) {
    return cloneNode(node);
}

function cloneDeepWithoutLoc(node) {
    return cloneNode(node, true, true);
}

function cloneWithoutLoc(node) {
    return cloneNode(node, false, true);
}

function addComments(node, type, comments) {
    if (!comments || !node)
        return node;
    
    const key = `${type}Comments`;
    
    if (node[key]) {
        if (type === 'leading') {
            node[key] = comments.concat(node[key]);
        } else {
            node[key].push(...comments);
        }
    } else {
        node[key] = comments;
    }
    
    return node;
}

function addComment(node, type, content, line) {
    return addComments(node, type, [{
        type: line ? 'CommentLine' : 'CommentBlock',
        value: content,
    }]);
}

function inherit(key, child, parent) {
    if (child && parent) {
        child[key] = Array.from(new Set([]
            .concat(child[key], parent[key])
            .filter(Boolean)));
    }
}

function inheritInnerComments(child, parent) {
    inherit('innerComments', child, parent);
}

function inheritLeadingComments(child, parent) {
    inherit('leadingComments', child, parent);
}

function inheritTrailingComments(child, parent) {
    inherit('trailingComments', child, parent);
}

function inheritsComments(child, parent) {
    inheritTrailingComments(child, parent);
    inheritLeadingComments(child, parent);
    inheritInnerComments(child, parent);
    return child;
}

function removeComments(node) {
    COMMENT_KEYS.forEach((key) => {
        node[key] = null;
    });
    return node;
}

var STANDARDIZED_TYPES = FLIPPED_ALIAS_KEYS['Standardized'];
var EXPRESSION_TYPES = FLIPPED_ALIAS_KEYS['Expression'];
var BINARY_TYPES = FLIPPED_ALIAS_KEYS['Binary'];
var SCOPABLE_TYPES = FLIPPED_ALIAS_KEYS['Scopable'];
var BLOCKPARENT_TYPES = FLIPPED_ALIAS_KEYS['BlockParent'];
var BLOCK_TYPES = FLIPPED_ALIAS_KEYS['Block'];
var STATEMENT_TYPES = FLIPPED_ALIAS_KEYS['Statement'];
var TERMINATORLESS_TYPES = FLIPPED_ALIAS_KEYS['Terminatorless'];
var COMPLETIONSTATEMENT_TYPES = FLIPPED_ALIAS_KEYS['CompletionStatement'];
var CONDITIONAL_TYPES = FLIPPED_ALIAS_KEYS['Conditional'];
var LOOP_TYPES = FLIPPED_ALIAS_KEYS['Loop'];
var WHILE_TYPES = FLIPPED_ALIAS_KEYS['While'];
var EXPRESSIONWRAPPER_TYPES = FLIPPED_ALIAS_KEYS['ExpressionWrapper'];
var FOR_TYPES = FLIPPED_ALIAS_KEYS['For'];
var FORXSTATEMENT_TYPES = FLIPPED_ALIAS_KEYS['ForXStatement'];
var FUNCTION_TYPES = FLIPPED_ALIAS_KEYS['Function'];
var FUNCTIONPARENT_TYPES = FLIPPED_ALIAS_KEYS['FunctionParent'];
var PUREISH_TYPES = FLIPPED_ALIAS_KEYS['Pureish'];
var DECLARATION_TYPES = FLIPPED_ALIAS_KEYS['Declaration'];
var FUNCTIONPARAMETER_TYPES = FLIPPED_ALIAS_KEYS['FunctionParameter'];
var PATTERNLIKE_TYPES = FLIPPED_ALIAS_KEYS['PatternLike'];
var LVAL_TYPES = FLIPPED_ALIAS_KEYS['LVal'];
var TSENTITYNAME_TYPES = FLIPPED_ALIAS_KEYS['TSEntityName'];
var LITERAL_TYPES = FLIPPED_ALIAS_KEYS['Literal'];
var IMMUTABLE_TYPES = FLIPPED_ALIAS_KEYS['Immutable'];
var USERWHITESPACABLE_TYPES = FLIPPED_ALIAS_KEYS['UserWhitespacable'];
var METHOD_TYPES = FLIPPED_ALIAS_KEYS['Method'];
var OBJECTMEMBER_TYPES = FLIPPED_ALIAS_KEYS['ObjectMember'];
var PROPERTY_TYPES = FLIPPED_ALIAS_KEYS['Property'];
var UNARYLIKE_TYPES = FLIPPED_ALIAS_KEYS['UnaryLike'];
var PATTERN_TYPES = FLIPPED_ALIAS_KEYS['Pattern'];
var CLASS_TYPES = FLIPPED_ALIAS_KEYS['Class'];
var IMPORTOREXPORTDECLARATION_TYPES = FLIPPED_ALIAS_KEYS['ImportOrExportDeclaration'];
var EXPORTDECLARATION_TYPES = FLIPPED_ALIAS_KEYS['ExportDeclaration'];
var MODULESPECIFIER_TYPES = FLIPPED_ALIAS_KEYS['ModuleSpecifier'];
var ACCESSOR_TYPES = FLIPPED_ALIAS_KEYS['Accessor'];
var PRIVATE_TYPES = FLIPPED_ALIAS_KEYS['Private'];
var FLOW_TYPES = FLIPPED_ALIAS_KEYS['Flow'];
var FLOWTYPE_TYPES = FLIPPED_ALIAS_KEYS['FlowType'];
var FLOWBASEANNOTATION_TYPES = FLIPPED_ALIAS_KEYS['FlowBaseAnnotation'];
var FLOWDECLARATION_TYPES = FLIPPED_ALIAS_KEYS['FlowDeclaration'];
var FLOWPREDICATE_TYPES = FLIPPED_ALIAS_KEYS['FlowPredicate'];
var ENUMBODY_TYPES = FLIPPED_ALIAS_KEYS['EnumBody'];
var ENUMMEMBER_TYPES = FLIPPED_ALIAS_KEYS['EnumMember'];
var JSX_TYPES = FLIPPED_ALIAS_KEYS['JSX'];
var MISCELLANEOUS_TYPES = FLIPPED_ALIAS_KEYS['Miscellaneous'];
var TYPESCRIPT_TYPES = FLIPPED_ALIAS_KEYS['TypeScript'];
var TSTYPEELEMENT_TYPES = FLIPPED_ALIAS_KEYS['TSTypeElement'];
var TSTYPE_TYPES = FLIPPED_ALIAS_KEYS['TSType'];
var TSBASETYPE_TYPES = FLIPPED_ALIAS_KEYS['TSBaseType'];
var MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;

function toBlock(node, parent) {
    if (isBlockStatement$7(node)) {
        return node;
    }
    
    let blockNodes = [];
    
    if (isEmptyStatement(node)) {
        blockNodes = [];
    } else {
        if (!isStatement$7(node)) {
            if (isFunction$7(parent)) {
                node = returnStatement$1(node);
            } else {
                node = expressionStatement$5(node);
            }
        }
        
        blockNodes = [node];
    }
    
    return blockStatement$2(blockNodes);
}

function ensureBlock(node, key = 'body') {
    const result = toBlock(node[key], node);
    
    node[key] = result;
    return result;
}

function toIdentifier(input) {
    input = input + '';
    let name = '';
    
    for (const c of input) {
        name += isIdentifierChar(c.codePointAt(0)) ? c : '-';
    }
    
    name = name.replace(/^[-0-9]+/, '');
    name = name.replace(/[-\s]+(.)?/g, function(match, c) {
        return c ? c.toUpperCase() : '';
    });
    
    if (!isValidIdentifier(name)) {
        name = `_${name}`;
    }
    
    return name || '_';
}

function toBindingIdentifierName(name) {
    name = toIdentifier(name);
    
    if (name === 'eval' || name === 'arguments')
        name = '_' + name;
    
    return name;
}

function toComputedKey(node, key = node.key || node.property) {
    if (!node.computed && isIdentifier$g(key))
        key = stringLiteral$5(key.name);
    
    return key;
}

function toExpression$4(node) {
    if (isExpressionStatement$7(node)) {
        node = node.expression;
    }
    
    if (isExpression$2(node)) {
        return node;
    }
    
    if (isClass(node)) {
        node.type = 'ClassExpression';
        node.abstract = false;
    } else if (isFunction$7(node)) {
        node.type = 'FunctionExpression';
    }
    
    if (!isExpression$2(node)) {
        throw new Error(`cannot turn ${node.type} to an expression`);
    }
    
    return node;
}

var _skip = Symbol();
var _stop = Symbol();

function traverseFast(node, enter, opts) {
    if (!node)
        return false;
    
    const keys2 = VISITOR_KEYS[node.type];
    
    if (!keys2)
        return false;
    
    opts = opts || {};
    const ret = enter(node, opts);
    
    if (ret !== void 0) {
        switch(ret) {
        case _skip:
            return false;
        
        case _stop:
            return true;
        }
    }
    
    for (const key of keys2) {
        const subNode = node[key];
        
        if (!subNode)
            continue;
        
        if (Array.isArray(subNode)) {
            for (const node2 of subNode) {
                if (traverseFast(node2, enter, opts))
                    return true;
            }
        } else {
            if (traverseFast(subNode, enter, opts))
                return true;
        }
    }
    
    return false;
}

traverseFast.skip = _skip;
traverseFast.stop = _stop;
var CLEAR_KEYS = [
    'tokens',
    'start',
    'end',
    'loc',
    'raw',
    'rawValue',
];
var CLEAR_KEYS_PLUS_COMMENTS = [
    ...COMMENT_KEYS,
    'comments',
    ...CLEAR_KEYS,
];

function removeProperties(node, opts = {}) {
    const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
    
    for (const key of map) {
        if (node[key] != null)
            node[key] = void 0;
    }
    
    for (const key of Object.keys(node)) {
        if (key[0] === '_' && node[key] != null)
            node[key] = void 0;
    }
    
    const symbols = Object.getOwnPropertySymbols(node);
    
    for (const sym of symbols) {
        node[sym] = null;
    }
}

function removePropertiesDeep(tree, opts) {
    traverseFast(tree, removeProperties, opts);
    return tree;
}

function toKeyAlias(node, key = node.key) {
    let alias2;
    
    if (node.kind === 'method') {
        return toKeyAlias.increment() + '';
    } else if (isIdentifier$g(key)) {
        alias2 = key.name;
    } else if (isStringLiteral$a(key)) {
        alias2 = JSON.stringify(key.value);
    } else {
        alias2 = JSON.stringify(removePropertiesDeep(cloneNode(key)));
    }
    
    if (node.computed) {
        alias2 = `[${alias2}]`;
    }
    
    if (node.static) {
        alias2 = `static:${alias2}`;
    }
    
    return alias2;
}

toKeyAlias.uid = 0;
toKeyAlias.increment = function() {
    if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
        return toKeyAlias.uid = 0;
    } else {
        return toKeyAlias.uid++;
    }
};
function toStatement$1(node, ignore) {
    if (isStatement$7(node)) {
        return node;
    }
    
    let mustHaveId = false;
    let newType;
    
    if (isClass(node)) {
        mustHaveId = true;
        newType = 'ClassDeclaration';
    } else if (isFunction$7(node)) {
        mustHaveId = true;
        newType = 'FunctionDeclaration';
    } else if (isAssignmentExpression$3(node)) {
        return expressionStatement$5(node);
    }
    
    if (mustHaveId && !node.id) {
        newType = false;
    }
    
    if (!newType) {
        if (ignore) {
            return false;
        } else {
            throw new Error(`cannot turn ${node.type} to a statement`);
        }
    }
    
    node.type = newType;
    return node;
}

var objectToString = Function.call.bind(Object.prototype.toString);

function isRegExp(value) {
    return objectToString(value) === '[object RegExp]';
}

function isPlainObject(value) {
    if (typeof value !== 'object' || value === null || Object.prototype.toString.call(value) !== '[object Object]') {
        return false;
    }
    
    const proto = Object.getPrototypeOf(value);
    
    return proto === null || Object.getPrototypeOf(proto) === null;
}

function valueToNode(value) {
    if (value === void 0) {
        return identifier$3('undefined');
    }
    
    if (value === true || value === false) {
        return booleanLiteral(value);
    }
    
    if (value === null) {
        return nullLiteral();
    }
    
    if (typeof value === 'string') {
        return stringLiteral$5(value);
    }
    
    if (typeof value === 'number') {
        let result;
        
        if (Number.isFinite(value)) {
            result = numericLiteral(Math.abs(value));
        } else {
            let numerator;
            
            if (Number.isNaN(value)) {
                numerator = numericLiteral(0);
            } else {
                numerator = numericLiteral(1);
            }
            
            result = binaryExpression$1('/', numerator, numericLiteral(0));
        }
        
        if (value < 0 || Object.is(value, -0)) {
            result = unaryExpression$1('-', result);
        }
        
        return result;
    }
    
    if (typeof value === 'bigint') {
        if (value < 0) {
            return unaryExpression$1('-', bigIntLiteral(-value));
        } else {
            return bigIntLiteral(value);
        }
    }
    
    if (isRegExp(value)) {
        const pattern = value.source;
        const flags = /\/([a-z]*)$/.exec(value.toString())[1];
        
        return regExpLiteral(pattern, flags);
    }
    
    if (Array.isArray(value)) {
        return arrayExpression$4(value.map(valueToNode));
    }
    
    if (isPlainObject(value)) {
        const props = [];
        
        for (const key of Object.keys(value)) {
            let nodeKey, computed = false;
            
            if (isValidIdentifier(key)) {
                if (key === '__proto__') {
                    computed = true;
                    nodeKey = stringLiteral$5(key);
                } else {
                    nodeKey = identifier$3(key);
                }
            } else {
                nodeKey = stringLiteral$5(key);
            }
            
            props.push(objectProperty$4(nodeKey, valueToNode(value[key]), computed));
        }
        
        return objectExpression$3(props);
    }
    
    throw new Error('don\'t know how to turn this value into a node');
}

function appendToMemberExpression(member, append, computed = false) {
    member.object = memberExpression(member.object, member.property, member.computed);
    member.property = append;
    member.computed = !!computed;
    return member;
}

function inherits(child, parent) {
    if (!child || !parent)
        return child;
    
    for (const key of INHERIT_KEYS.optional) {
        if (child[key] == null) {
            child[key] = parent[key];
        }
    }
    
    for (const key of Object.keys(parent)) {
        if (key[0] === '_' && key !== '__clone') {
            child[key] = parent[key];
        }
    }
    
    for (const key of INHERIT_KEYS.force) {
        child[key] = parent[key];
    }
    
    inheritsComments(child, parent);
    
    return child;
}

function prependToMemberExpression(member, prepend) {
    if (isSuper(member.object)) {
        throw new Error('Cannot prepend node to super property access (`super.foo`).');
    }
    
    member.object = memberExpression(prepend, member.object);
    
    return member;
}

function getAssignmentIdentifiers(node) {
    const search = [].concat(node);
    const ids =     /* @__PURE__ */Object.create(null);
    
    while (search.length) {
        const id = search.pop();
        
        if (!id)
            continue;
        
        switch(id.type) {
        case 'ArrayPattern':
            search.push(...id.elements);
            break;
        
        case 'AssignmentExpression':        
        case 'AssignmentPattern':        
        case 'ForInStatement':        
        case 'ForOfStatement':
            search.push(id.left);
            break;
        
        case 'ObjectPattern':
            search.push(...id.properties);
            break;
        
        case 'ObjectProperty':
            search.push(id.value);
            break;
        
        case 'RestElement':        
        case 'UpdateExpression':
            search.push(id.argument);
            break;
        
        case 'UnaryExpression':
            if (id.operator === 'delete') {
                search.push(id.argument);
            }
            
            break;
        
        case 'Identifier':
            ids[id.name] = id;
            break;
        }
    }
    
    return ids;
}

function getBindingIdentifiers(node, duplicates, outerOnly, newBindingsOnly) {
    const search = [].concat(node);
    const ids =     /* @__PURE__ */Object.create(null);
    
    while (search.length) {
        const id = search.shift();
        
        if (!id)
            continue;
        
        if (newBindingsOnly && (isAssignmentExpression$3(id) || isUnaryExpression$1(id) || isUpdateExpression(id))) {
            continue;
        }
        
        if (isIdentifier$g(id)) {
            if (duplicates) {
                const _ids = ids[id.name] = ids[id.name] || [];
                _ids.push(id);
            } else {
                ids[id.name] = id;
            }
            
            continue;
        }
        
        if (isExportDeclaration$5(id) && !isExportAllDeclaration(id)) {
            if (isDeclaration(id.declaration)) {
                search.push(id.declaration);
            }
            
            continue;
        }
        
        if (outerOnly) {
            if (isFunctionDeclaration$3(id)) {
                search.push(id.id);
                continue;
            }
            
            if (isFunctionExpression$1(id) || isClassExpression(id)) {
                continue;
            }
        }
        
        const keys2 = getBindingIdentifiers.keys[id.type];
        
        if (keys2) {
            for (let i = 0; i < keys2.length; i++) {
                const key = keys2[i];
                const nodes2 = id[key];
                
                if (nodes2) {
                    if (Array.isArray(nodes2)) {
                        search.push(...nodes2);
                    } else {
                        search.push(nodes2);
                    }
                }
            }
        }
    }
    
    return ids;
}

var keys$4 = {
    DeclareClass: ['id'],
    DeclareFunction: ['id'],
    DeclareModule: ['id'],
    DeclareVariable: ['id'],
    DeclareInterface: ['id'],
    DeclareTypeAlias: ['id'],
    DeclareOpaqueType: ['id'],
    InterfaceDeclaration: ['id'],
    TypeAlias: ['id'],
    OpaqueType: ['id'],
    CatchClause: ['param'],
    LabeledStatement: ['label'],
    UnaryExpression: ['argument'],
    AssignmentExpression: ['left'],
    ImportSpecifier: ['local'],
    ImportNamespaceSpecifier: ['local'],
    ImportDefaultSpecifier: ['local'],
    ImportDeclaration: ['specifiers'],
    TSImportEqualsDeclaration: ['id'],
    ExportSpecifier: ['exported'],
    ExportNamespaceSpecifier: ['exported'],
    ExportDefaultSpecifier: ['exported'],
    FunctionDeclaration: ['id', 'params'],
    FunctionExpression: ['id', 'params'],
    ArrowFunctionExpression: ['params'],
    ObjectMethod: ['params'],
    ClassMethod: ['params'],
    ClassPrivateMethod: ['params'],
    ForInStatement: ['left'],
    ForOfStatement: ['left'],
    ClassDeclaration: ['id'],
    ClassExpression: ['id'],
    RestElement: ['argument'],
    UpdateExpression: ['argument'],
    ObjectProperty: ['value'],
    AssignmentPattern: ['left'],
    ArrayPattern: ['elements'],
    ObjectPattern: ['properties'],
    VariableDeclaration: ['declarations'],
    VariableDeclarator: ['id'],
};

getBindingIdentifiers.keys = keys$4;
function getOuterBindingIdentifiers(node, duplicates) {
    return getBindingIdentifiers(node, duplicates, true);
}

function getNameFromLiteralId(id) {
    if (isNullLiteral$1(id)) {
        return 'null';
    }
    
    if (isRegExpLiteral$2(id)) {
        return `/${id.pattern}/${id.flags}`;
    }
    
    if (isTemplateLiteral$4(id)) {
        return id.quasis
            .map((quasi) => quasi.value.raw)
            .join('');
    }
    
    if (id.value !== void 0) {
        return String(id.value);
    }
    
    return null;
}

function getObjectMemberKey(node) {
    if (!node.computed || isLiteral$4(node.key)) {
        return node.key;
    }
}

function getFunctionName(node, parent) {
    if ('id' in node && node.id) {
        return {
            name: node.id.name,
            originalNode: node.id,
        };
    }
    
    let prefix2 = '';
    let id;
    
    if (isObjectProperty$3(parent, {value: node})) {
        id = getObjectMemberKey(parent);
    } else if (isObjectMethod$1(node) || isClassMethod$2(node)) {
        id = getObjectMemberKey(node);
        
        if (node.kind === 'get')
            prefix2 = 'get ';
        else if (node.kind === 'set')
            prefix2 = 'set ';
    } else if (isVariableDeclarator$4(parent, {init: node})) {
        id = parent.id;
    } else if (isAssignmentExpression$3(parent, {operator: '=', right: node})) {
        id = parent.left;
    }

    
    if (!id)
        return null;
    
    const name = isLiteral$4(id) ? getNameFromLiteralId(id) : isIdentifier$g(id) ? id.name : isPrivateName(id) ? id.id.name : null;
    
    if (name == null)
        return null;
    
    return {
        name: prefix2 + name,
        originalNode: id,
    };
}

function traverse$a(node, handlers, state) {
    if (typeof handlers === 'function') {
        handlers = {
            enter: handlers,
        };
    }
    
    const {enter, exit} = handlers;
    
    traverseSimpleImpl(node, enter, exit, state, []);
}

function traverseSimpleImpl(node, enter, exit, state, ancestors) {
    const keys2 = VISITOR_KEYS[node.type];
    
    if (!keys2)
        return;
    
    if (enter)
        enter(node, ancestors, state);
    
    for (const key of keys2) {
        const subNode = node[key];
        
        if (Array.isArray(subNode)) {
            for (let i = 0; i < subNode.length; i++) {
                const child = subNode[i];
                
                if (!child)
                    continue;
                
                ancestors.push({
                    node,
                    key,
                    index: i,
                });
                traverseSimpleImpl(child, enter, exit, state, ancestors);
                ancestors.pop();
            }
        } else if (subNode) {
            ancestors.push({
                node,
                key,
            });
            traverseSimpleImpl(subNode, enter, exit, state, ancestors);
            ancestors.pop();
        }
    }
    
    if (exit)
        exit(node, ancestors, state);
}

function isBinding$1(node, parent, grandparent) {
    if (grandparent && node.type === 'Identifier' && parent.type === 'ObjectProperty' && grandparent.type === 'ObjectExpression') {
        return false;
    }
    
    const keys2 = getBindingIdentifiers.keys[parent.type];
    
    if (keys2) {
        for (let i = 0; i < keys2.length; i++) {
            const key = keys2[i];
            const val = parent[key];
            
            if (Array.isArray(val)) {
                if (val.includes(node))
                    return true;
            } else {
                if (val === node)
                    return true;
            }
        }
    }
    
    return false;
}

function isLet(node) {
    {
        return isVariableDeclaration$5(node) && node.kind !== 'var';
    }
}

function isBlockScoped(node) {
    return isFunctionDeclaration$3(node) || isClassDeclaration(node) || isLet(node);
}

function isImmutable(node) {
    if (isType(node.type, 'Immutable'))
        return true;
    
    if (isIdentifier$g(node)) {
        if (node.name === 'undefined') {
            return true;
        } else {
            return false;
        }
    }
    
    return false;
}

function isNodesEquivalent(a, b2) {
    if (typeof a !== 'object' || typeof b2 !== 'object' || a == null || b2 == null) {
        return a === b2;
    }
    
    if (a.type !== b2.type) {
        return false;
    }
    
    const fields = Object.keys(NODE_FIELDS$1[a.type] || a.type);
    const visitorKeys = VISITOR_KEYS[a.type];
    
    for (const field of fields) {
        const val_a = a[field];
        const val_b = b2[field];
        
        if (typeof val_a !== typeof val_b) {
            return false;
        }
        
        if (val_a == null && val_b == null) {
            continue;
        } else if (val_a == null || val_b == null) {
            return false;
        }
        
        if (Array.isArray(val_a)) {
            if (!Array.isArray(val_b)) {
                return false;
            }
            
            if (val_a.length !== val_b.length) {
                return false;
            }
            
            for (let i = 0; i < val_a.length; i++) {
                if (!isNodesEquivalent(val_a[i], val_b[i])) {
                    return false;
                }
            }
            
            continue;
        }
        
        if (typeof val_a === 'object' && !visitorKeys?.includes(field)) {
            for (const key of Object.keys(val_a)) {
                if (val_a[key] !== val_b[key]) {
                    return false;
                }
            }
            
            continue;
        }
        
        if (!isNodesEquivalent(val_a, val_b)) {
            return false;
        }
    }
    
    return true;
}

function isReferenced(node, parent, grandparent) {
    switch(parent.type) {
    case 'MemberExpression':    
    case 'OptionalMemberExpression':
        if (parent.property === node) {
            return !!parent.computed;
        }
        
        return parent.object === node;
    
    case 'JSXMemberExpression':
        return parent.object === node;
    
    case 'VariableDeclarator':
        return parent.init === node;
    
    case 'ArrowFunctionExpression':
        return parent.body === node;
    
    case 'PrivateName':
        return false;
    
    case 'ClassMethod':    
    case 'ClassPrivateMethod':    
    case 'ObjectMethod':
        if (parent.key === node) {
            return !!parent.computed;
        }
        
        return false;
    
    case 'ObjectProperty':
        if (parent.key === node) {
            return !!parent.computed;
        }
        
        return !grandparent || grandparent.type !== 'ObjectPattern';
    
    case 'ClassProperty':    
    case 'ClassAccessorProperty':
        if (parent.key === node) {
            return !!parent.computed;
        }
        
        return true;
    
    case 'ClassPrivateProperty':
        return parent.key !== node;
    
    case 'ClassDeclaration':    
    case 'ClassExpression':
        return parent.superClass === node;
    
    case 'AssignmentExpression':
        return parent.right === node;
    
    case 'AssignmentPattern':
        return parent.right === node;
    
    case 'LabeledStatement':
        return false;
    
    case 'CatchClause':
        return false;
    
    case 'RestElement':
        return false;
    
    case 'BreakStatement':    
    case 'ContinueStatement':
        return false;
    
    case 'FunctionDeclaration':    
    case 'FunctionExpression':
        return false;
    
    case 'ExportNamespaceSpecifier':    
    case 'ExportDefaultSpecifier':
        return false;
    
    case 'ExportSpecifier':
        if (grandparent?.source) {
            return false;
        }
        
        return parent.local === node;
    
    case 'ImportDefaultSpecifier':    
    case 'ImportNamespaceSpecifier':    
    case 'ImportSpecifier':
        return false;
    
    case 'ImportAttribute':
        return false;
    
    case 'JSXAttribute':
        return false;
    
    case 'ObjectPattern':    
    case 'ArrayPattern':
        return false;
    
    case 'MetaProperty':
        return false;
    
    case 'ObjectTypeProperty':
        return parent.key !== node;
    
    case 'TSEnumMember':
        return parent.id !== node;
    
    case 'TSPropertySignature':
        if (parent.key === node) {
            return !!parent.computed;
        }
        
        return true;
    }
    
    return true;
}

function isScope(node, parent) {
    if (isBlockStatement$7(node) && (isFunction$7(parent) || isCatchClause(parent))) {
        return false;
    }
    
    if (isPattern(node) && (isFunction$7(parent) || isCatchClause(parent))) {
        return true;
    }
    
    return isScopable(node);
}

function isSpecifierDefault(specifier) {
    return isImportDefaultSpecifier$1(specifier) || isIdentifier$g(specifier.imported || specifier.exported, {
        name: 'default',
    });
}

var RESERVED_WORDS_ES3_ONLY = /* @__PURE__ */new Set([
    'abstract',
    'boolean',
    'byte',
    'char',
    'double',
    'enum',
    'final',
    'float',
    'goto',
    'implements',
    'int',
    'interface',
    'long',
    'native',
    'package',
    'private',
    'protected',
    'public',
    'short',
    'static',
    'synchronized',
    'throws',
    'transient',
    'volatile',
]);

function isValidES3Identifier(name) {
    return isValidIdentifier(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
}

function isVar(node) {
    {
        return isVariableDeclaration$5(node) && node.kind === 'var';
    }
}

var react = {
    isReactComponent,
    isCompatTag,
    buildChildren,
};

// node_modules/@babel/parser/lib/index.js
function _objectWithoutPropertiesLoose(r, e) {
    if (null == r)
        return {};
    
    var t = {};
    
    for (var n2 in r)    if ({}.hasOwnProperty.call(r, n2)) {
        if (-1 !== e.indexOf(n2))
            continue;
        
        t[n2] = r[n2];
    }
    
    return t;
}

var Position = class {
    constructor(line, col, index2) {
        __publicField(this, 'line');
        __publicField(this, 'column');
        __publicField(this, 'index');
        this.line = line;
        this.column = col;
        this.index = index2;
    }
};

var SourceLocation = class {
    constructor(start, end) {
        __publicField(this, 'start');
        __publicField(this, 'end');
        __publicField(this, 'filename');
        __publicField(this, 'identifierName');
        this.start = start;
        this.end = end;
    }
};

function createPositionWithColumnOffset(position, columnOffset) {
    const {
        line,
        column,
        index: index2,
    } = position;
    
    return new Position(line, column + columnOffset, index2 + columnOffset);
}

var code = 'BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED';

var ModuleErrors = {
    ImportMetaOutsideModule: {
        message: `import.meta may appear only with 'sourceType: "module"'`,
        code,
    },
    ImportOutsideModule: {
        message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
        code,
    },
};

var NodeDescriptions = {
    ArrayPattern: 'array destructuring pattern',
    AssignmentExpression: 'assignment expression',
    AssignmentPattern: 'assignment expression',
    ArrowFunctionExpression: 'arrow function expression',
    ConditionalExpression: 'conditional expression',
    CatchClause: 'catch clause',
    ForOfStatement: 'for-of statement',
    ForInStatement: 'for-in statement',
    ForStatement: 'for-loop',
    FormalParameters: 'function parameter list',
    Identifier: 'identifier',
    ImportSpecifier: 'import specifier',
    ImportDefaultSpecifier: 'import default specifier',
    ImportNamespaceSpecifier: 'import namespace specifier',
    ObjectPattern: 'object destructuring pattern',
    ParenthesizedExpression: 'parenthesized expression',
    RestElement: 'rest element',
    UpdateExpression: {
        true: 'prefix operation',
        false: 'postfix operation',
    },
    VariableDeclarator: 'variable declaration',
    YieldExpression: 'yield expression',
};

var toNodeDescription = (node) => node.type === 'UpdateExpression' ? NodeDescriptions.UpdateExpression[`${node.prefix}`] : NodeDescriptions[node.type];

var StandardErrors = {
    AccessorIsGenerator: ({kind}) => `A ${kind}ter cannot be a generator.`,
    ArgumentsInClass: '\'arguments\' is only allowed in functions and class methods.',
    AsyncFunctionInSingleStatementContext: 'Async functions can only be declared at the top level or inside a block.',
    AwaitBindingIdentifier: 'Can not use \'await\' as identifier inside an async function.',
    AwaitBindingIdentifierInStaticBlock: 'Can not use \'await\' as identifier inside a static block.',
    AwaitExpressionFormalParameter: '\'await\' is not allowed in async function parameters.',
    AwaitUsingNotInAsyncContext: '\'await using\' is only allowed within async functions and at the top levels of modules.',
    AwaitNotInAsyncContext: '\'await\' is only allowed within async functions and at the top levels of modules.',
    BadGetterArity: 'A \'get\' accessor must not have any formal parameters.',
    BadSetterArity: 'A \'set\' accessor must have exactly one formal parameter.',
    BadSetterRestParameter: 'A \'set\' accessor function argument must not be a rest parameter.',
    ConstructorClassField: 'Classes may not have a field named \'constructor\'.',
    ConstructorClassPrivateField: 'Classes may not have a private field named \'#constructor\'.',
    ConstructorIsAccessor: 'Class constructor may not be an accessor.',
    ConstructorIsAsync: 'Constructor can\'t be an async function.',
    ConstructorIsGenerator: 'Constructor can\'t be a generator.',
    DeclarationMissingInitializer: ({kind}) => `Missing initializer in ${kind} declaration.`,
    DecoratorArgumentsOutsideParentheses: 'Decorator arguments must be moved inside parentheses: use \'@(decorator(args))\' instead of \'@(decorator)(args)\'.',
    DecoratorBeforeExport: 'Decorators must be placed *before* the \'export\' keyword. Remove the \'decoratorsBeforeExport: true\' option to use the \'export @decorator class {}\' syntax.',
    DecoratorsBeforeAfterExport: 'Decorators can be placed *either* before or after the \'export\' keyword, but not in both locations at the same time.',
    DecoratorConstructor: 'Decorators can\'t be used with a constructor. Did you mean \'@dec class { ... }\'?',
    DecoratorExportClass: 'Decorators must be placed *after* the \'export\' keyword. Remove the \'decoratorsBeforeExport: false\' option to use the \'@decorator export class {}\' syntax.',
    DecoratorSemicolon: 'Decorators must not be followed by a semicolon.',
    DecoratorStaticBlock: 'Decorators can\'t be used with a static block.',
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: 'Deleting a private field is not allowed.',
    DestructureNamedImport: 'ES2015 named imports do not destructure. Use another statement for destructuring after the import.',
    DuplicateConstructor: 'Duplicate constructor in the same class.',
    DuplicateDefaultExport: 'Only one default export allowed per module.',
    DuplicateExport: ({exportName}) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
    DuplicateProto: 'Redefinition of __proto__ property.',
    DuplicateRegExpFlags: 'Duplicate regular expression flag.',
    ElementAfterRest: 'Rest element must be last element.',
    EscapedCharNotAnIdentifier: 'Invalid Unicode escape.',
    ExportBindingIsString: ({localName, exportName}) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
    ExportDefaultFromAsIdentifier: '\'from\' is not allowed as an identifier after \'export default\'.',
    ForInOfLoopInitializer: ({type}) => `'${type === 'ForInStatement' ? 'for-in' : 'for-of'}' loop variable declaration may not have an initializer.`,
    ForInUsing: 'For-in loop may not start with \'using\' declaration.',
    ForOfAsync: 'The left-hand side of a for-of loop may not be \'async\'.',
    ForOfLet: 'The left-hand side of a for-of loop may not start with \'let\'.',
    GeneratorInSingleStatementContext: 'Generators can only be declared at the top level or inside a block.',
    IllegalBreakContinue: ({type}) => `Unsyntactic ${type === 'BreakStatement' ? 'break' : 'continue'}.`,
    IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list.',
    IllegalReturn: '\'return\' outside of function.',
    ImportAttributesUseAssert: 'The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.',
    ImportBindingIsString: ({importName}) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`,
    ImportCallArity: `\`import()\` requires exactly one or two arguments.`,
    ImportCallNotNewExpression: 'Cannot use new with import(...).',
    ImportCallSpreadArgument: '`...` is not allowed in `import()`.',
    ImportJSONBindingNotDefault: 'A JSON module can only be imported with `default`.',
    ImportReflectionHasAssertion: '`import module x` cannot have assertions.',
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: 'The \'u\' and \'v\' regular expression flags cannot be enabled at the same time.',
    InvalidBigIntLiteral: 'Invalid BigIntLiteral.',
    InvalidCodePoint: 'Code point out of bounds.',
    InvalidCoverDiscardElement: '\'void\' must be followed by an expression when not used in a binding position.',
    InvalidCoverInitializedName: 'Invalid shorthand property initializer.',
    InvalidDecimal: 'Invalid decimal.',
    InvalidDigit: ({radix}) => `Expected number in radix ${radix}.`,
    InvalidEscapeSequence: 'Bad character escape sequence.',
    InvalidEscapeSequenceTemplate: 'Invalid escape sequence in template.',
    InvalidEscapedReservedWord: ({reservedWord}) => `Escape sequence in keyword ${reservedWord}.`,
    InvalidIdentifier: ({identifierName}) => `Invalid identifier ${identifierName}.`,
    InvalidLhs: ({ancestor}) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
    InvalidLhsBinding: ({ancestor}) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
    InvalidLhsOptionalChaining: ({ancestor}) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,
    InvalidNumber: 'Invalid number.',
    InvalidOrMissingExponent: 'Floating-point numbers require a valid exponent after the \'e\'.',
    InvalidOrUnexpectedToken: ({unexpected}) => `Unexpected character '${unexpected}'.`,
    InvalidParenthesizedAssignment: 'Invalid parenthesized assignment pattern.',
    InvalidPrivateFieldResolution: ({identifierName}) => `Private name #${identifierName} is not defined.`,
    InvalidPropertyBindingPattern: 'Binding member expression.',
    InvalidRecordProperty: 'Only properties and spread elements are allowed in record definitions.',
    InvalidRestAssignmentPattern: 'Invalid rest operator\'s argument.',
    LabelRedeclaration: ({labelName}) => `Label '${labelName}' is already declared.`,
    LetInLexicalBinding: '\'let\' is disallowed as a lexically bound name.',
    LineTerminatorBeforeArrow: 'No line break is allowed before \'=>\'.',
    MalformedRegExpFlags: 'Invalid regular expression flag.',
    MissingClassName: 'A class name is required.',
    MissingEqInAssignment: 'Only \'=\' operator can be used for specifying default value.',
    MissingSemicolon: 'Missing semicolon.',
    MissingPlugin: ({missingPlugin}) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin
        .map((name) => JSON.stringify(name))
        .join(', ')}.`,
    MissingOneOfPlugins: ({missingPlugin}) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin
        .map((name) => JSON.stringify(name))
        .join(', ')}.`,
    MissingUnicodeEscape: 'Expecting Unicode escape sequence \\uXXXX.',
    MixingCoalesceWithLogical: 'Nullish coalescing operator(??) requires parens when mixing with logical operators.',
    ModuleAttributeDifferentFromType: 'The only accepted module attribute is `type`.',
    ModuleAttributeInvalidValue: 'Only string literals are allowed as module attribute values.',
    ModuleAttributesWithDuplicateKeys: ({key}) => `Duplicate key "${key}" is not allowed in module attributes.`,
    ModuleExportNameHasLoneSurrogate: ({surrogateCharCode}) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
    ModuleExportUndefined: ({localName}) => `Export '${localName}' is not defined.`,
    MultipleDefaultsInSwitch: 'Multiple default clauses.',
    NewlineAfterThrow: 'Illegal newline after throw.',
    NoCatchOrFinally: 'Missing catch or finally clause.',
    NumberIdentifier: 'Identifier directly after number.',
    NumericSeparatorInEscapeSequence: 'Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.',
    ObsoleteAwaitStar: '\'await*\' has been removed from the async functions proposal. Use Promise.all() instead.',
    OptionalChainingNoNew: 'Constructors in/after an Optional Chain are not allowed.',
    OptionalChainingNoTemplate: 'Tagged Template Literals are not allowed in optionalChain.',
    OverrideOnConstructor: '\'override\' modifier cannot appear on a constructor declaration.',
    ParamDupe: 'Argument name clash.',
    PatternHasAccessor: 'Object pattern can\'t contain getter or setter.',
    PatternHasMethod: 'Object pattern can\'t contain methods.',
    PrivateInExpectedIn: ({identifierName}) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
    PrivateNameRedeclaration: ({identifierName}) => `Duplicate private name #${identifierName}.`,
    RecordExpressionBarIncorrectEndSyntaxType: 'Record expressions ending with \'|}\' are only allowed when the \'syntaxType\' option of the \'recordAndTuple\' plugin is set to \'bar\'.',
    RecordExpressionBarIncorrectStartSyntaxType: 'Record expressions starting with \'{|\' are only allowed when the \'syntaxType\' option of the \'recordAndTuple\' plugin is set to \'bar\'.',
    RecordExpressionHashIncorrectStartSyntaxType: 'Record expressions starting with \'#{\' are only allowed when the \'syntaxType\' option of the \'recordAndTuple\' plugin is set to \'hash\'.',
    RecordNoProto: '\'__proto__\' is not allowed in Record expressions.',
    RestTrailingComma: 'Unexpected trailing comma after rest element.',
    SloppyFunction: 'In non-strict mode code, functions can only be declared at top level or inside a block.',
    SloppyFunctionAnnexB: 'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.',
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: 'Classes may not have static property named prototype.',
    SuperNotAllowed: '`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name (\'constructor\') or not extending another class?',
    SuperPrivateField: 'Private fields can\'t be accessed on super.',
    TrailingDecorator: 'Decorators must be attached to a class element.',
    TupleExpressionBarIncorrectEndSyntaxType: 'Tuple expressions ending with \'|]\' are only allowed when the \'syntaxType\' option of the \'recordAndTuple\' plugin is set to \'bar\'.',
    TupleExpressionBarIncorrectStartSyntaxType: 'Tuple expressions starting with \'[|\' are only allowed when the \'syntaxType\' option of the \'recordAndTuple\' plugin is set to \'bar\'.',
    TupleExpressionHashIncorrectStartSyntaxType: 'Tuple expressions starting with \'#[\' are only allowed when the \'syntaxType\' option of the \'recordAndTuple\' plugin is set to \'hash\'.',
    UnexpectedArgumentPlaceholder: 'Unexpected argument placeholder.',
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: 'Unexpected digit after hash token.',
    UnexpectedImportExport: '\'import\' and \'export\' may only appear at the top level.',
    UnexpectedKeyword: ({keyword}) => `Unexpected keyword '${keyword}'.`,
    UnexpectedLeadingDecorator: 'Leading decorators must be attached to a class declaration.',
    UnexpectedLexicalDeclaration: 'Lexical declaration cannot appear in a single-statement context.',
    UnexpectedNewTarget: '`new.target` can only be used in functions or class properties.',
    UnexpectedNumericSeparator: 'A numeric separator is only allowed between two digits.',
    UnexpectedPrivateField: 'Unexpected private name.',
    UnexpectedReservedWord: ({reservedWord}) => `Unexpected reserved word '${reservedWord}'.`,
    UnexpectedSuper: '\'super\' is only allowed in object methods and classes.',
    UnexpectedToken: ({expected, unexpected}) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ''}${expected ? `, expected "${expected}"` : ''}`,
    UnexpectedTokenUnaryExponentiation: 'Illegal expression. Wrap left hand side or entire exponentiation in parentheses.',
    UnexpectedUsingDeclaration: 'Using declaration cannot appear in the top level when source type is `script` or in the bare case statement.',
    UnexpectedVoidPattern: 'Unexpected void binding.',
    UnsupportedBind: 'Binding should be performed on object property.',
    UnsupportedDecoratorExport: 'A decorated export must export a class declaration.',
    UnsupportedDefaultExport: 'Only expressions, functions or classes are allowed as the `default` export.',
    UnsupportedImport: '`import` can only be used in `import()` or `import.meta`.',
    UnsupportedMetaProperty: ({target, onlyValidPropertyName}) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
    UnsupportedParameterDecorator: 'Decorators cannot be used to decorate parameters.',
    UnsupportedPropertyDecorator: 'Decorators cannot be used to decorate object literal properties.',
    UnsupportedSuper: '\'super\' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).',
    UnterminatedComment: 'Unterminated comment.',
    UnterminatedRegExp: 'Unterminated regular expression.',
    UnterminatedString: 'Unterminated string constant.',
    UnterminatedTemplate: 'Unterminated template.',
    UsingDeclarationExport: 'Using declaration cannot be exported.',
    UsingDeclarationHasBindingPattern: 'Using declaration cannot have destructuring patterns.',
    VarRedeclaration: ({identifierName}) => `Identifier '${identifierName}' has already been declared.`,
    VoidPatternCatchClauseParam: 'A void binding can not be the catch clause parameter. Use `try { ... } catch { ... }` if you want to discard the caught error.',
    VoidPatternInitializer: 'A void binding may not have an initializer.',
    YieldBindingIdentifier: 'Can not use \'yield\' as identifier inside a generator.',
    YieldInParameter: 'Yield expression is not allowed in formal parameters.',
    YieldNotInGeneratorFunction: '\'yield\' is only allowed within generator functions.',
    ZeroDigitNumericSeparator: 'Numeric separator can not be used after leading 0.',
};

var StrictModeErrors = {
    StrictDelete: 'Deleting local variable in strict mode.',
    StrictEvalArguments: ({referenceName}) => `Assigning to '${referenceName}' in strict mode.`,
    StrictEvalArgumentsBinding: ({bindingName}) => `Binding '${bindingName}' in strict mode.`,
    StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block.',
    StrictNumericEscape: 'The only valid numeric escape in strict mode is \'\\0\'.',
    StrictOctalLiteral: 'Legacy octal literals are not allowed in strict mode.',
    StrictWith: '\'with\' in strict mode.',
};

var ParseExpressionErrors = {
    ParseExpressionEmptyInput: 'Unexpected parseExpression() input: The input is empty or contains only comments.',
    ParseExpressionExpectsEOF: ({unexpected}) => `Unexpected parseExpression() input: The input should contain exactly one expression, but the first expression is followed by the unexpected character \`${String.fromCodePoint(unexpected)}\`.`,
};

var UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */new Set([
    'ArrowFunctionExpression',
    'AssignmentExpression',
    'ConditionalExpression',
    'YieldExpression',
]);

var PipelineOperatorErrors = Object.assign({
    PipeBodyIsTighter: 'Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.',
    PipeTopicRequiresHackPipes: 'Topic references are only supported when using the `"proposal": "hack"` version of the pipeline proposal.',
    PipeTopicUnbound: 'Topic reference is unbound; it must be inside a pipe body.',
    PipeTopicUnconfiguredToken: ({token}) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
    PipeTopicUnused: 'Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.',
    PipeUnparenthesizedBody: ({type}) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
        type,
    })}; please wrap it in parentheses.`,
}, {});

var _excluded = ['message'];

function defineHidden(obj, key, value) {
    Object.defineProperty(obj, key, {
        enumerable: false,
        configurable: true,
        value,
    });
}

function toParseErrorConstructor({toMessage, code: code2, reasonCode, syntaxPlugin}) {
    const hasMissingPlugin = reasonCode === 'MissingPlugin' || reasonCode === 'MissingOneOfPlugins';
    
    return function constructor(loc, details) {
        const error = new SyntaxError();
        
        error.code = code2;
        error.reasonCode = reasonCode;
        error.loc = loc;
        error.pos = loc.index;
        error.syntaxPlugin = syntaxPlugin;
        
        if (hasMissingPlugin) {
            error.missingPlugin = details.missingPlugin;
        }
        
        defineHidden(error, 'clone', function clone2(overrides = {}) {
            const {
                line,
                column,
                index: index2,
            } = overrides.loc ?? loc;
            
            return constructor(new Position(line, column, index2), Object.assign({}, details, overrides.details));
        });
        defineHidden(error, 'details', details);
        Object.defineProperty(error, 'message', {
            configurable: true,
            get() {
                const message = `${toMessage(details)} (${loc.line}:${loc.column})`;
                
                this.message = message;
                return message;
            },
            set(value) {
                Object.defineProperty(this, 'message', {
                    value,
                    writable: true,
                });
            },
        });
        return error;
    };
}

function ParseErrorEnum(argument, syntaxPlugin) {
    if (Array.isArray(argument)) {
        return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
    }
    
    const ParseErrorConstructors = {};
    
    for (const reasonCode of Object.keys(argument)) {
        const template = argument[reasonCode];
        const _ref = typeof template === 'string' ? {
                message: () => template,
            } : typeof template === 'function' ? {
                message: template,
            } : template, {message} = _ref, rest = _objectWithoutPropertiesLoose(_ref, _excluded);
        
        const toMessage = typeof message === 'string' ? () => message : message;
        
        ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
            code: 'BABEL_PARSER_SYNTAX_ERROR',
            reasonCode,
            toMessage,
        }, syntaxPlugin ? {
            syntaxPlugin,
        } : {}, rest));
    }
    
    return ParseErrorConstructors;
}

var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum(ParseExpressionErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));

function createDefaultOptions() {
    return {
        sourceType: 'script',
        sourceFilename: void 0,
        startIndex: 0,
        startColumn: 0,
        startLine: 1,
        allowAwaitOutsideFunction: false,
        allowReturnOutsideFunction: false,
        allowNewTargetOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowSuperOutsideMethod: false,
        allowUndeclaredExports: false,
        allowYieldOutsideFunction: false,
        plugins: [],
        strictMode: null,
        ranges: false,
        tokens: false,
        createImportExpressions: true,
        createParenthesizedExpressions: false,
        errorRecovery: false,
        attachComment: true,
        annexB: true,
    };
}

function getOptions(opts) {
    const options = createDefaultOptions();
    
    if (opts == null) {
        return options;
    }
    
    if (opts.annexB != null && opts.annexB !== false) {
        throw new Error('The `annexB` option can only be set to `false`.');
    }
    
    for (const key of Object.keys(options)) {
        if (opts[key] != null)
            options[key] = opts[key];
    }
    
    if (options.startLine === 1) {
        if (opts.startIndex == null && options.startColumn > 0) {
            options.startIndex = options.startColumn;
        } else if (opts.startColumn == null && options.startIndex > 0) {
            options.startColumn = options.startIndex;
        }
    } else if (opts.startColumn == null || opts.startIndex == null) {
        {
            throw new Error('With a `startLine > 1` you must also specify `startIndex` and `startColumn`.');
        }
    }
    
    if (options.sourceType === 'commonjs') {
        if (opts.allowAwaitOutsideFunction != null) {
            throw new Error('The `allowAwaitOutsideFunction` option cannot be used with `sourceType: \'commonjs\'`.');
        }
        
        if (opts.allowReturnOutsideFunction != null) {
            throw new Error('`sourceType: \'commonjs\'` implies `allowReturnOutsideFunction: true`, please remove the `allowReturnOutsideFunction` option or use `sourceType: \'script\'`.');
        }
        
        if (opts.allowNewTargetOutsideFunction != null) {
            throw new Error('`sourceType: \'commonjs\'` implies `allowNewTargetOutsideFunction: true`, please remove the `allowNewTargetOutsideFunction` option or use `sourceType: \'script\'`.');
        }
    }
    
    return options;
}

var {defineProperty} = Object;

var toUnenumerable = (object, key) => {
    if (object) {
        defineProperty(object, key, {
            enumerable: false,
            value: object[key],
        });
    }
};

function toESTreeLocation(node) {
    toUnenumerable(node.loc.start, 'index');
    toUnenumerable(node.loc.end, 'index');
    return node;
}

var estree = (superClass) => class ESTreeParserMixin extends superClass {
    parse() {
        const file2 = toESTreeLocation(super.parse());
        
        if (this.optionFlags & 256) {
            file2.tokens = file2.tokens.map(toESTreeLocation);
        }
        
        return file2;
    }
    
    parseRegExpLiteral({pattern, flags}) {
        let regex = null;
        
        try {
            regex = new RegExp(pattern, flags);
        } catch(_) {}


                const node = this.estreeParseLiteral(regex);
        
        node.regex = {
            pattern,
            flags,
        };
        return node;
    }
    
    parseBigIntLiteral(value) {
        let bigInt;
        
        try {
            bigInt = BigInt(value);
        } catch {
            bigInt = null;
        }


                const node = this.estreeParseLiteral(bigInt);
        
        node.bigint = String(node.value || value);
        return node;
    }
    
    parseDecimalLiteral(value) {
        const decimal = null;
        const node = this.estreeParseLiteral(decimal);
        
        node.decimal = String(node.value || value);
        return node;
    }
    
    estreeParseLiteral(value) {
        return this.parseLiteral(value, 'Literal');
    }
    
    parseStringLiteral(value) {
        return this.estreeParseLiteral(value);
    }
    
    parseNumericLiteral(value) {
        return this.estreeParseLiteral(value);
    }
    
    parseNullLiteral() {
        return this.estreeParseLiteral(null);
    }
    
    parseBooleanLiteral(value) {
        return this.estreeParseLiteral(value);
    }
    
    estreeParseChainExpression(node, endLoc) {
        const chain2 = this.startNodeAtNode(node);
        
        chain2.expression = node;
        return this.finishNodeAt(chain2, 'ChainExpression', endLoc);
    }
    
    directiveToStmt(directive2) {
        const expression2 = directive2.value;
        delete directive2.value;
        this.castNodeTo(expression2, 'Literal');
        expression2.raw = expression2.extra.raw;
        expression2.value = expression2.extra.expressionValue;
        const stmt = this.castNodeTo(directive2, 'ExpressionStatement');
        
        stmt.expression = expression2;
        stmt.directive = expression2.extra.rawValue;
        delete expression2.extra;
        return stmt;
    }
    
    fillOptionalPropertiesForTSESLint(node) {}
    
    cloneEstreeStringLiteral(node) {
        const {
            start,
            end,
            loc,
            range,
            raw,
            value,
        } = node;
        
        const cloned = Object.create(node.constructor.prototype);
        
        cloned.type = 'Literal';
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range;
        cloned.raw = raw;
        cloned.value = value;
        return cloned;
    }
    
    initFunction(node, isAsync) {
        super.initFunction(node, isAsync);
        node.expression = false;
    }
    
    checkDeclaration(node) {
        if (node != null && this.isObjectProperty(node)) {
            this.checkDeclaration(node.value);
        } else {
            super.checkDeclaration(node);
        }
    }
    
    getObjectOrClassMethodParams(method) {
        return method.value.params;
    }
    
    isValidDirective(stmt) {
        return stmt.type === 'ExpressionStatement'
            && stmt.expression.type === 'Literal'
            && typeof stmt.expression.value === 'string'
            && !stmt.expression.extra?.parenthesized;
    }
    
    parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
        const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));
        
        node.body = directiveStatements.concat(node.body);
        delete node.directives;
    }
    
    parsePrivateName() {
        const node = super.parsePrivateName();
        return this.convertPrivateNameToPrivateIdentifier(node);
    }
    
    convertPrivateNameToPrivateIdentifier(node) {
        const name = super.getPrivateNameSV(node);
        
        node = node;
        delete node.id;
        node.name = name;
        return this.castNodeTo(node, 'PrivateIdentifier');
    }
    
    isPrivateName(node) {
        return node.type === 'PrivateIdentifier';
    }
    
    getPrivateNameSV(node) {
        return node.name;
    }
    
    parseLiteral(value, type) {
        const node = super.parseLiteral(value, type);
        
        node.raw = node.extra.raw;
        delete node.extra;
        return node;
    }
    
    parseFunctionBody(node, allowExpression, isMethod3 = false) {
        super.parseFunctionBody(node, allowExpression, isMethod3);
        node.expression = node.body.type !== 'BlockStatement';
    }
    
    parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        let funcNode = this.startNode();
        
        funcNode.kind = node.kind;
        funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        delete funcNode.kind;
        const {typeParameters} = node;
        
        if (typeParameters) {
            delete node.typeParameters;
            funcNode.typeParameters = typeParameters;
            this.resetStartLocationFromNode(funcNode, typeParameters);
        }
        
        const valueNode = this.castNodeTo(funcNode, this.hasPlugin('typescript') && !funcNode.body ? 'TSEmptyBodyFunctionExpression' : 'FunctionExpression');
        
        node.value = valueNode;
        
        if (type === 'ClassPrivateMethod') {
            node.computed = false;
        }
        
        if (this.hasPlugin('typescript')) {
            if (node.abstract) {
                delete node.abstract;
                return this.finishNode(node, 'TSAbstractMethodDefinition');
            }
        }
        
        if (type === 'ObjectMethod') {
            if (node.kind === 'method') {
                node.kind = 'init';
            }
            
            node.shorthand = false;
            return this.finishNode(node, 'Property');
        } else {
            return this.finishNode(node, 'MethodDefinition');
        }
    }
    
    nameIsConstructor(key) {
        if (key.type === 'Literal')
            return key.value === 'constructor';
        
        return super.nameIsConstructor(key);
    }
    
    parseClassProperty(...args) {
        const propertyNode = super.parseClassProperty(...args);
        
        if (propertyNode.abstract && this.hasPlugin('typescript')) {
            delete propertyNode.abstract;
            this.castNodeTo(propertyNode, 'TSAbstractPropertyDefinition');
        } else {
            this.castNodeTo(propertyNode, 'PropertyDefinition');
        }
        
        return propertyNode;
    }
    
    parseClassPrivateProperty(...args) {
        const propertyNode = super.parseClassPrivateProperty(...args);
        
        if (propertyNode.abstract && this.hasPlugin('typescript')) {
            this.castNodeTo(propertyNode, 'TSAbstractPropertyDefinition');
        } else {
            this.castNodeTo(propertyNode, 'PropertyDefinition');
        }
        
        propertyNode.computed = false;
        return propertyNode;
    }
    
    parseClassAccessorProperty(node) {
        const accessorPropertyNode = super.parseClassAccessorProperty(node);
        
        if (accessorPropertyNode.abstract && this.hasPlugin('typescript')) {
            delete accessorPropertyNode.abstract;
            this.castNodeTo(accessorPropertyNode, 'TSAbstractAccessorProperty');
        } else {
            this.castNodeTo(accessorPropertyNode, 'AccessorProperty');
        }
        
        return accessorPropertyNode;
    }
    
    parseObjectProperty(prop, startLoc, isPattern3, refExpressionErrors) {
        const node = super.parseObjectProperty(prop, startLoc, isPattern3, refExpressionErrors);
        
        if (node) {
            node.kind = 'init';
            this.castNodeTo(node, 'Property');
        }
        
        return node;
    }
    
    finishObjectProperty(node) {
        node.kind = 'init';
        return this.finishNode(node, 'Property');
    }
    
    isValidLVal(type, isUnparenthesizedInAssign, binding) {
        return type === 'Property' ? 'value' : super.isValidLVal(type, isUnparenthesizedInAssign, binding);
    }
    
    isAssignable(node, isBinding3) {
        if (node != null && this.isObjectProperty(node)) {
            return this.isAssignable(node.value, isBinding3);
        }
        
        return super.isAssignable(node, isBinding3);
    }
    
    toAssignable(node, isLHS = false) {
        if (node != null && this.isObjectProperty(node)) {
            const {key, value} = node;
            
            if (this.isPrivateName(key)) {
                this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
            }
            
            this.toAssignable(value, isLHS);
        } else {
            super.toAssignable(node, isLHS);
        }
    }
    
    toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === 'Property' && (prop.kind === 'get' || prop.kind === 'set')) {
            this.raise(Errors.PatternHasAccessor, prop.key);
        } else if (prop.type === 'Property' && prop.method) {
            this.raise(Errors.PatternHasMethod, prop.key);
        } else {
            super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
        }
    }
    
    finishCallExpression(unfinished, optional) {
        const node = super.finishCallExpression(unfinished, optional);
        
        if (node.callee.type === 'Import') {
            this.castNodeTo(node, 'ImportExpression');
            node.source = node.arguments[0];
            node.options = node.arguments[1] ?? null;
            delete node.arguments;
            delete node.callee;
        } else if (node.type === 'OptionalCallExpression') {
            this.castNodeTo(node, 'CallExpression');
        } else {
            node.optional = false;
        }
        
        return node;
    }
    
    toReferencedArguments(node) {
        if (node.type === 'ImportExpression') {
            return;
        }
        
        super.toReferencedArguments(node);
    }
    
    parseExport(unfinished, decorators) {
        const exportStartLoc = this.state.lastTokStartLoc;
        const node = super.parseExport(unfinished, decorators);
        
        switch(node.type) {
        case 'ExportAllDeclaration':
            node.exported = null;
            break;
        
        case 'ExportNamedDeclaration':
            if (node.specifiers.length === 1 && node.specifiers[0].type === 'ExportNamespaceSpecifier') {
                this.castNodeTo(node, 'ExportAllDeclaration');
                node.exported = node.specifiers[0].exported;
                delete node.specifiers;
            }
        
        case 'ExportDefaultDeclaration': {
            const {declaration} = node;
            
            if (declaration?.type === 'ClassDeclaration' && declaration.decorators?.length > 0 && declaration.start === node.start) {
                this.resetStartLocation(node, exportStartLoc);
            }
        }
        break;
        }
        
        
        return node;
    }
    
    stopParseSubscript(base, state) {
        const node = super.stopParseSubscript(base, state);
        
        if (state.optionalChainMember) {
            return this.estreeParseChainExpression(node, base.loc.end);
        }
        
        return node;
    }
    
    parseMember(base, startLoc, state, computed, optional) {
        const node = super.parseMember(base, startLoc, state, computed, optional);
        
        if (node.type === 'OptionalMemberExpression') {
            this.castNodeTo(node, 'MemberExpression');
        } else {
            node.optional = false;
        }
        
        return node;
    }
    
    isOptionalMemberExpression(node) {
        if (node.type === 'ChainExpression') {
            return node.expression.type === 'MemberExpression';
        }
        
        return super.isOptionalMemberExpression(node);
    }
    
    hasPropertyAsPrivateName(node) {
        if (node.type === 'ChainExpression') {
            node = node.expression;
        }
        
        return super.hasPropertyAsPrivateName(node);
    }
    
    isObjectProperty(node) {
        return node.type === 'Property' && node.kind === 'init' && !node.method;
    }
    
    isObjectMethod(node) {
        return node.type === 'Property'
            && (node.method
            || node.kind === 'get'
            || node.kind === 'set');
    }
    
    castNodeTo(node, type) {
        const result = super.castNodeTo(node, type);
        this.fillOptionalPropertiesForTSESLint(result);
        return result;
    }
    
    cloneIdentifier(node) {
        const cloned = super.cloneIdentifier(node);
        this.fillOptionalPropertiesForTSESLint(cloned);
        return cloned;
    }
    
    cloneStringLiteral(node) {
        if (node.type === 'Literal') {
            return this.cloneEstreeStringLiteral(node);
        }
        
        return super.cloneStringLiteral(node);
    }
    
    finishNodeAt(node, type, endLoc) {
        return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
    }
    
    finishNode(node, type) {
        const result = super.finishNode(node, type);
        this.fillOptionalPropertiesForTSESLint(result);
        return result;
    }
    
    resetStartLocation(node, startLoc) {
        super.resetStartLocation(node, startLoc);
        toESTreeLocation(node);
    }
    
    resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
        super.resetEndLocation(node, endLoc);
        toESTreeLocation(node);
    }
};

var TokContext = class {
    constructor(token, preserveSpace) {
        __publicField(this, 'token');
        __publicField(this, 'preserveSpace');
        this.token = token;
        this.preserveSpace = !!preserveSpace;
    }
};

var types$18 = {
    brace: new TokContext('{'),
    j_oTag: new TokContext('<tag'),
    j_cTag: new TokContext('</tag'),
    j_expr: new TokContext('<tag>...</tag>', true),
};

var beforeExpr = true;
var startsExpr = true;
var isLoop2 = true;
var isAssign = true;
var prefix$1 = true;
var postfix = true;

var ExportedTokenType = class {
    constructor(label, conf = {}) {
        __publicField(this, 'label');
        __publicField(this, 'keyword');
        __publicField(this, 'beforeExpr');
        __publicField(this, 'startsExpr');
        __publicField(this, 'rightAssociative');
        __publicField(this, 'isLoop');
        __publicField(this, 'isAssign');
        __publicField(this, 'prefix');
        __publicField(this, 'postfix');
        __publicField(this, 'binop');
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.rightAssociative = !!conf.rightAssociative;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop != null ? conf.binop : null;
    }
};

var keywords$1$1 = /* @__PURE__ */new Map();

function createKeyword(name, options = {}) {
    options.keyword = name;
    const token = createToken(name, options);
    keywords$1$1.set(name, token);
    return token;
}

function createBinop(name, binop) {
    return createToken(name, {
        beforeExpr,
        binop,
    });
}

var tokenTypeCounter = -1;
var tokenTypes = [];
var tokenLabels = [];
var tokenBinops = [];
var tokenBeforeExprs = [];
var tokenStartsExprs = [];
var tokenPrefixes = [];

function createToken(name, options = {}) {
    ++tokenTypeCounter;
    tokenLabels.push(name);
    tokenBinops.push(options.binop ?? -1);
    tokenBeforeExprs.push(options.beforeExpr ?? false);
    tokenStartsExprs.push(options.startsExpr ?? false);
    tokenPrefixes.push(options.prefix ?? false);
    tokenTypes.push(new ExportedTokenType(name, options));
    return tokenTypeCounter;
}

function createKeywordLike(name, options = {}) {
    ++tokenTypeCounter;
    keywords$1$1.set(name, tokenTypeCounter);
    tokenLabels.push(name);
    tokenBinops.push(options.binop ?? -1);
    tokenBeforeExprs.push(options.beforeExpr ?? false);
    tokenStartsExprs.push(options.startsExpr ?? false);
    tokenPrefixes.push(options.prefix ?? false);
    tokenTypes.push(new ExportedTokenType('name', options));
    return tokenTypeCounter;
}

var tt = {
    bracketL: createToken('[', {
        beforeExpr,
        startsExpr,
    }),
    bracketHashL: createToken('#[', {
        beforeExpr,
        startsExpr,
    }),
    bracketBarL: createToken('[|', {
        beforeExpr,
        startsExpr,
    }),
    bracketR: createToken(']'),
    bracketBarR: createToken('|]'),
    braceL: createToken('{', {
        beforeExpr,
        startsExpr,
    }),
    braceBarL: createToken('{|', {
        beforeExpr,
        startsExpr,
    }),
    braceHashL: createToken('#{', {
        beforeExpr,
        startsExpr,
    }),
    braceR: createToken('}'),
    braceBarR: createToken('|}'),
    parenL: createToken('(', {
        beforeExpr,
        startsExpr,
    }),
    parenR: createToken(')'),
    comma: createToken(',', {
        beforeExpr,
    }),
    semi: createToken(';', {
        beforeExpr,
    }),
    colon: createToken(':', {
        beforeExpr,
    }),
    doubleColon: createToken('::', {
        beforeExpr,
    }),
    dot: createToken('.'),
    question: createToken('?', {
        beforeExpr,
    }),
    questionDot: createToken('?.'),
    arrow: createToken('=>', {
        beforeExpr,
    }),
    template: createToken('template'),
    ellipsis: createToken('...', {
        beforeExpr,
    }),
    backQuote: createToken('`', {
        startsExpr,
    }),
    dollarBraceL: createToken('${', {
        beforeExpr,
        startsExpr,
    }),
    templateTail: createToken('...`', {
        startsExpr,
    }),
    templateNonTail: createToken('...${', {
        beforeExpr,
        startsExpr,
    }),
    at: createToken('@'),
    hash: createToken('#', {
        startsExpr,
    }),
    interpreterDirective: createToken('#!...'),
    eq: createToken('=', {
        beforeExpr,
        isAssign,
    }),
    assign: createToken('_=', {
        beforeExpr,
        isAssign,
    }),
    slashAssign: createToken('_=', {
        beforeExpr,
        isAssign,
    }),
    xorAssign: createToken('_=', {
        beforeExpr,
        isAssign,
    }),
    moduloAssign: createToken('_=', {
        beforeExpr,
        isAssign,
    }),
    incDec: createToken('++/--', {
        prefix: prefix$1,
        postfix,
        startsExpr,
    }),
    bang: createToken('!', {
        beforeExpr,
        prefix: prefix$1,
        startsExpr,
    }),
    tilde: createToken('~', {
        beforeExpr,
        prefix: prefix$1,
        startsExpr,
    }),
    doubleCaret: createToken('^^', {
        startsExpr,
    }),
    doubleAt: createToken('@@', {
        startsExpr,
    }),
    pipeline: createBinop('|>', 0),
    nullishCoalescing: createBinop('??', 1),
    logicalOR: createBinop('||', 1),
    logicalAND: createBinop('&&', 2),
    bitwiseOR: createBinop('|', 3),
    bitwiseXOR: createBinop('^', 4),
    bitwiseAND: createBinop('&', 5),
    equality: createBinop('==/!=/===/!==', 6),
    lt: createBinop('</>/<=/>=', 7),
    gt: createBinop('</>/<=/>=', 7),
    relational: createBinop('</>/<=/>=', 7),
    bitShift: createBinop('<</>>/>>>', 8),
    bitShiftL: createBinop('<</>>/>>>', 8),
    bitShiftR: createBinop('<</>>/>>>', 8),
    plusMin: createToken('+/-', {
        beforeExpr,
        binop: 9,
        prefix: prefix$1,
        startsExpr,
    }),
    modulo: createToken('%', {
        binop: 10,
        startsExpr,
    }),
    star: createToken('*', {
        binop: 10,
    }),
    slash: createBinop('/', 10),
    exponent: createToken('**', {
        beforeExpr,
        binop: 11,
        rightAssociative: true,
    }),
    _in: createKeyword('in', {
        beforeExpr,
        binop: 7,
    }),
    _instanceof: createKeyword('instanceof', {
        beforeExpr,
        binop: 7,
    }),
    _break: createKeyword('break'),
    _case: createKeyword('case', {
        beforeExpr,
    }),
    _catch: createKeyword('catch'),
    _continue: createKeyword('continue'),
    _debugger: createKeyword('debugger'),
    _default: createKeyword('default', {
        beforeExpr,
    }),
    _else: createKeyword('else', {
        beforeExpr,
    }),
    _finally: createKeyword('finally'),
    _function: createKeyword('function', {
        startsExpr,
    }),
    _if: createKeyword('if'),
    _return: createKeyword('return', {
        beforeExpr,
    }),
    _switch: createKeyword('switch'),
    _throw: createKeyword('throw', {
        beforeExpr,
        prefix: prefix$1,
        startsExpr,
    }),
    _try: createKeyword('try'),
    _var: createKeyword('var'),
    _const: createKeyword('const'),
    _with: createKeyword('with'),
    _new: createKeyword('new', {
        beforeExpr,
        startsExpr,
    }),
    _this: createKeyword('this', {
        startsExpr,
    }),
    _super: createKeyword('super', {
        startsExpr,
    }),
    _class: createKeyword('class', {
        startsExpr,
    }),
    _extends: createKeyword('extends', {
        beforeExpr,
    }),
    _export: createKeyword('export'),
    _import: createKeyword('import', {
        startsExpr,
    }),
    _null: createKeyword('null', {
        startsExpr,
    }),
    _true: createKeyword('true', {
        startsExpr,
    }),
    _false: createKeyword('false', {
        startsExpr,
    }),
    _typeof: createKeyword('typeof', {
        beforeExpr,
        prefix: prefix$1,
        startsExpr,
    }),
    _void: createKeyword('void', {
        beforeExpr,
        prefix: prefix$1,
        startsExpr,
    }),
    _delete: createKeyword('delete', {
        beforeExpr,
        prefix: prefix$1,
        startsExpr,
    }),
    _do: createKeyword('do', {
        isLoop: isLoop2,
        beforeExpr,
    }),
    _for: createKeyword('for', {
        isLoop: isLoop2,
    }),
    _while: createKeyword('while', {
        isLoop: isLoop2,
    }),
    _as: createKeywordLike('as', {
        startsExpr,
    }),
    _assert: createKeywordLike('assert', {
        startsExpr,
    }),
    _async: createKeywordLike('async', {
        startsExpr,
    }),
    _await: createKeywordLike('await', {
        startsExpr,
    }),
    _defer: createKeywordLike('defer', {
        startsExpr,
    }),
    _from: createKeywordLike('from', {
        startsExpr,
    }),
    _get: createKeywordLike('get', {
        startsExpr,
    }),
    _let: createKeywordLike('let', {
        startsExpr,
    }),
    _meta: createKeywordLike('meta', {
        startsExpr,
    }),
    _of: createKeywordLike('of', {
        startsExpr,
    }),
    _sent: createKeywordLike('sent', {
        startsExpr,
    }),
    _set: createKeywordLike('set', {
        startsExpr,
    }),
    _source: createKeywordLike('source', {
        startsExpr,
    }),
    _static: createKeywordLike('static', {
        startsExpr,
    }),
    _using: createKeywordLike('using', {
        startsExpr,
    }),
    _yield: createKeywordLike('yield', {
        startsExpr,
    }),
    _asserts: createKeywordLike('asserts', {
        startsExpr,
    }),
    _checks: createKeywordLike('checks', {
        startsExpr,
    }),
    _exports: createKeywordLike('exports', {
        startsExpr,
    }),
    _global: createKeywordLike('global', {
        startsExpr,
    }),
    _implements: createKeywordLike('implements', {
        startsExpr,
    }),
    _intrinsic: createKeywordLike('intrinsic', {
        startsExpr,
    }),
    _infer: createKeywordLike('infer', {
        startsExpr,
    }),
    _is: createKeywordLike('is', {
        startsExpr,
    }),
    _mixins: createKeywordLike('mixins', {
        startsExpr,
    }),
    _proto: createKeywordLike('proto', {
        startsExpr,
    }),
    _require: createKeywordLike('require', {
        startsExpr,
    }),
    _satisfies: createKeywordLike('satisfies', {
        startsExpr,
    }),
    _keyof: createKeywordLike('keyof', {
        startsExpr,
    }),
    _readonly: createKeywordLike('readonly', {
        startsExpr,
    }),
    _unique: createKeywordLike('unique', {
        startsExpr,
    }),
    _abstract: createKeywordLike('abstract', {
        startsExpr,
    }),
    _declare: createKeywordLike('declare', {
        startsExpr,
    }),
    _enum: createKeywordLike('enum', {
        startsExpr,
    }),
    _module: createKeywordLike('module', {
        startsExpr,
    }),
    _namespace: createKeywordLike('namespace', {
        startsExpr,
    }),
    _interface: createKeywordLike('interface', {
        startsExpr,
    }),
    _type: createKeywordLike('type', {
        startsExpr,
    }),
    _opaque: createKeywordLike('opaque', {
        startsExpr,
    }),
    name: createToken('name', {
        startsExpr,
    }),
    placeholder: createToken('%%', {
        startsExpr,
    }),
    string: createToken('string', {
        startsExpr,
    }),
    num: createToken('num', {
        startsExpr,
    }),
    bigint: createToken('bigint', {
        startsExpr,
    }),
    decimal: createToken('decimal', {
        startsExpr,
    }),
    regexp: createToken('regexp', {
        startsExpr,
    }),
    privateName: createToken('#name', {
        startsExpr,
    }),
    eof: createToken('eof'),
    jsxName: createToken('jsxName'),
    jsxText: createToken('jsxText', {
        beforeExpr,
    }),
    jsxTagStart: createToken('jsxTagStart', {
        startsExpr,
    }),
    jsxTagEnd: createToken('jsxTagEnd'),
};

function tokenIsIdentifier(token) {
    return token >= 93 && token <= 133;
}

function tokenKeywordOrIdentifierIsKeyword(token) {
    return token <= 92;
}

function tokenIsKeywordOrIdentifier(token) {
    return token >= 58 && token <= 133;
}

function tokenIsLiteralPropertyName(token) {
    return token >= 58 && token <= 137;
}

function tokenComesBeforeExpression(token) {
    return tokenBeforeExprs[token];
}

function tokenCanStartExpression(token) {
    return tokenStartsExprs[token];
}

function tokenIsAssignment(token) {
    return token >= 29 && token <= 33;
}

function tokenIsLoop(token) {
    return token >= 90 && token <= 92;
}

function tokenIsKeyword(token) {
    return token >= 58 && token <= 92;
}

function tokenIsOperator(token) {
    return token >= 39 && token <= 59;
}

function tokenIsPostfix(token) {
    return token === 34;
}

function tokenIsPrefix(token) {
    return tokenPrefixes[token];
}

function tokenIsTSTypeOperator(token) {
    return token >= 121 && token <= 123;
}

function tokenIsTSDeclarationStart(token) {
    return token >= 124 && token <= 130;
}

function tokenLabelName(token) {
    return tokenLabels[token];
}

function tokenOperatorPrecedence(token) {
    return tokenBinops[token];
}

function tokenIsRightAssociative(token) {
    return token === 57;
}

function tokenIsTemplate(token) {
    return token >= 24 && token <= 25;
}

function getExportedToken(token) {
    return tokenTypes[token];
}

var nonASCIIidentifierStartChars2 = '\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC';
var nonASCIIidentifierChars2 = '\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65';
var nonASCIIidentifierStart2 = new RegExp('[' + nonASCIIidentifierStartChars2 + ']');
var nonASCIIidentifier2 = new RegExp('[' + nonASCIIidentifierStartChars2 + nonASCIIidentifierChars2 + ']');

nonASCIIidentifierStartChars2 =
nonASCIIidentifierChars2 = null;
var astralIdentifierStartCodes2 = [
    0,
    11,
    2,
    25,
    2,
    18,
    2,
    1,
    2,
    14,
    3,
    13,
    35,
    122,
    70,
    52,
    268,
    28,
    4,
    48,
    48,
    31,
    14,
    29,
    6,
    37,
    11,
    29,
    3,
    35,
    5,
    7,
    2,
    4,
    43,
    157,
    19,
    35,
    5,
    35,
    5,
    39,
    9,
    51,
    13,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    2,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    4,
    51,
    13,
    310,
    10,
    21,
    11,
    7,
    25,
    5,
    2,
    41,
    2,
    8,
    70,
    5,
    3,
    0,
    2,
    43,
    2,
    1,
    4,
    0,
    3,
    22,
    11,
    22,
    10,
    30,
    66,
    18,
    2,
    1,
    11,
    21,
    11,
    25,
    71,
    55,
    7,
    1,
    65,
    0,
    16,
    3,
    2,
    2,
    2,
    28,
    43,
    28,
    4,
    28,
    36,
    7,
    2,
    27,
    28,
    53,
    11,
    21,
    11,
    18,
    14,
    17,
    111,
    72,
    56,
    50,
    14,
    50,
    14,
    35,
    39,
    27,
    10,
    22,
    251,
    41,
    7,
    1,
    17,
    2,
    60,
    28,
    11,
    0,
    9,
    21,
    43,
    17,
    47,
    20,
    28,
    22,
    13,
    52,
    58,
    1,
    3,
    0,
    14,
    44,
    33,
    24,
    27,
    35,
    30,
    0,
    3,
    0,
    9,
    34,
    4,
    0,
    13,
    47,
    15,
    3,
    22,
    0,
    2,
    0,
    36,
    17,
    2,
    24,
    20,
    1,
    64,
    6,
    2,
    0,
    2,
    3,
    2,
    14,
    2,
    9,
    8,
    46,
    39,
    7,
    3,
    1,
    3,
    21,
    2,
    6,
    2,
    1,
    2,
    4,
    4,
    0,
    19,
    0,
    13,
    4,
    31,
    9,
    2,
    0,
    3,
    0,
    2,
    37,
    2,
    0,
    26,
    0,
    2,
    0,
    45,
    52,
    19,
    3,
    21,
    2,
    31,
    47,
    21,
    1,
    2,
    0,
    185,
    46,
    42,
    3,
    37,
    47,
    21,
    0,
    60,
    42,
    14,
    0,
    72,
    26,
    38,
    6,
    186,
    43,
    117,
    63,
    32,
    7,
    3,
    0,
    3,
    7,
    2,
    1,
    2,
    23,
    16,
    0,
    2,
    0,
    95,
    7,
    3,
    38,
    17,
    0,
    2,
    0,
    29,
    0,
    11,
    39,
    8,
    0,
    22,
    0,
    12,
    45,
    20,
    0,
    19,
    72,
    200,
    32,
    32,
    8,
    2,
    36,
    18,
    0,
    50,
    29,
    113,
    6,
    2,
    1,
    2,
    37,
    22,
    0,
    26,
    5,
    2,
    1,
    2,
    31,
    15,
    0,
    328,
    18,
    16,
    0,
    2,
    12,
    2,
    33,
    125,
    0,
    80,
    921,
    103,
    110,
    18,
    195,
    2637,
    96,
    16,
    1071,
    18,
    5,
    26,
    3994,
    6,
    582,
    6842,
    29,
    1763,
    568,
    8,
    30,
    18,
    78,
    18,
    29,
    19,
    47,
    17,
    3,
    32,
    20,
    6,
    18,
    433,
    44,
    212,
    63,
    129,
    74,
    6,
    0,
    67,
    12,
    65,
    1,
    2,
    0,
    29,
    6135,
    9,
    1237,
    42,
    9,
    8936,
    3,
    2,
    6,
    2,
    1,
    2,
    290,
    16,
    0,
    30,
    2,
    3,
    0,
    15,
    3,
    9,
    395,
    2309,
    106,
    6,
    12,
    4,
    8,
    8,
    9,
    5991,
    84,
    2,
    70,
    2,
    1,
    3,
    0,
    3,
    1,
    3,
    3,
    2,
    11,
    2,
    0,
    2,
    6,
    2,
    64,
    2,
    3,
    3,
    7,
    2,
    6,
    2,
    27,
    2,
    3,
    2,
    4,
    2,
    0,
    4,
    6,
    2,
    339,
    3,
    24,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    7,
    1845,
    30,
    7,
    5,
    262,
    61,
    147,
    44,
    11,
    6,
    17,
    0,
    322,
    29,
    19,
    43,
    485,
    27,
    229,
    29,
    3,
    0,
    496,
    6,
    2,
    3,
    2,
    1,
    2,
    14,
    2,
    196,
    60,
    67,
    8,
    0,
    1205,
    3,
    2,
    26,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    9,
    2,
    3,
    2,
    0,
    2,
    0,
    7,
    0,
    5,
    0,
    2,
    0,
    2,
    0,
    2,
    2,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    1,
    2,
    0,
    3,
    3,
    2,
    6,
    2,
    3,
    2,
    3,
    2,
    0,
    2,
    9,
    2,
    16,
    6,
    2,
    2,
    4,
    2,
    16,
    4421,
    42719,
    33,
    4153,
    7,
    221,
    3,
    5761,
    15,
    7472,
    16,
    621,
    2467,
    541,
    1507,
    4938,
    6,
    4191,
];
var astralIdentifierCodes2 = [
    509,
    0,
    227,
    0,
    150,
    4,
    294,
    9,
    1368,
    2,
    2,
    1,
    6,
    3,
    41,
    2,
    5,
    0,
    166,
    1,
    574,
    3,
    9,
    9,
    7,
    9,
    32,
    4,
    318,
    1,
    80,
    3,
    71,
    10,
    50,
    3,
    123,
    2,
    54,
    14,
    32,
    10,
    3,
    1,
    11,
    3,
    46,
    10,
    8,
    0,
    46,
    9,
    7,
    2,
    37,
    13,
    2,
    9,
    6,
    1,
    45,
    0,
    13,
    2,
    49,
    13,
    9,
    3,
    2,
    11,
    83,
    11,
    7,
    0,
    3,
    0,
    158,
    11,
    6,
    9,
    7,
    3,
    56,
    1,
    2,
    6,
    3,
    1,
    3,
    2,
    10,
    0,
    11,
    1,
    3,
    6,
    4,
    4,
    68,
    8,
    2,
    0,
    3,
    0,
    2,
    3,
    2,
    4,
    2,
    0,
    15,
    1,
    83,
    17,
    10,
    9,
    5,
    0,
    82,
    19,
    13,
    9,
    214,
    6,
    3,
    8,
    28,
    1,
    83,
    16,
    16,
    9,
    82,
    12,
    9,
    9,
    7,
    19,
    58,
    14,
    5,
    9,
    243,
    14,
    166,
    9,
    71,
    5,
    2,
    1,
    3,
    3,
    2,
    0,
    2,
    1,
    13,
    9,
    120,
    6,
    3,
    6,
    4,
    0,
    29,
    9,
    41,
    6,
    2,
    3,
    9,
    0,
    10,
    10,
    47,
    15,
    343,
    9,
    54,
    7,
    2,
    7,
    17,
    9,
    57,
    21,
    2,
    13,
    123,
    5,
    4,
    0,
    2,
    1,
    2,
    6,
    2,
    0,
    9,
    9,
    49,
    4,
    2,
    1,
    2,
    4,
    9,
    9,
    330,
    3,
    10,
    1,
    2,
    0,
    49,
    6,
    4,
    4,
    14,
    10,
    5350,
    0,
    7,
    14,
    11465,
    27,
    2343,
    9,
    87,
    9,
    39,
    4,
    60,
    6,
    26,
    9,
    535,
    9,
    470,
    0,
    2,
    54,
    8,
    3,
    82,
    0,
    12,
    1,
    19628,
    1,
    4178,
    9,
    519,
    45,
    3,
    22,
    543,
    4,
    4,
    5,
    9,
    7,
    3,
    6,
    31,
    3,
    149,
    2,
    1418,
    49,
    513,
    54,
    5,
    49,
    9,
    0,
    15,
    0,
    23,
    4,
    2,
    14,
    1361,
    6,
    2,
    16,
    3,
    6,
    2,
    1,
    2,
    4,
    101,
    0,
    161,
    6,
    10,
    9,
    357,
    0,
    62,
    13,
    499,
    13,
    245,
    1,
    2,
    9,
    726,
    6,
    110,
    6,
    6,
    9,
    4759,
    9,
    787719,
    239,
];

function isInAstralSet2(code2, set) {
    let pos = 65536;
    
    for (let i = 0, length = set.length; i < length; i += 2) {
        pos += set[i];
        
        if (pos > code2)
            return false;
        
        pos += set[i + 1];
        
        if (pos >= code2)
            return true;
    }
    
    return false;
}

function isIdentifierStart2(code2) {
    if (code2 < 65)
        return code2 === 36;
    
    if (code2 <= 90)
        return true;
    
    if (code2 < 97)
        return code2 === 95;
    
    if (code2 <= 122)
        return true;
    
    if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifierStart2.test(String.fromCharCode(code2));
    }
    
    return isInAstralSet2(code2, astralIdentifierStartCodes2);
}

function isIdentifierChar2(code2) {
    if (code2 < 48)
        return code2 === 36;
    
    if (code2 < 58)
        return true;
    
    if (code2 < 65)
        return false;
    
    if (code2 <= 90)
        return true;
    
    if (code2 < 97)
        return code2 === 95;
    
    if (code2 <= 122)
        return true;
    
    if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifier2.test(String.fromCharCode(code2));
    }
    
    return isInAstralSet2(code2, astralIdentifierStartCodes2) || isInAstralSet2(code2, astralIdentifierCodes2);
}

var reservedWords2 = {
    keyword: [
        'break',
        'case',
        'catch',
        'continue',
        'debugger',
        'default',
        'do',
        'else',
        'finally',
        'for',
        'function',
        'if',
        'return',
        'switch',
        'throw',
        'try',
        'var',
        'const',
        'while',
        'with',
        'new',
        'this',
        'super',
        'class',
        'extends',
        'export',
        'import',
        'null',
        'true',
        'false',
        'in',
        'instanceof',
        'typeof',
        'void',
        'delete',
    ],
    strict: [
        'implements',
        'interface',
        'let',
        'package',
        'private',
        'protected',
        'public',
        'static',
        'yield',
    ],
    strictBind: ['eval', 'arguments'],
};

var keywords2 = new Set(reservedWords2.keyword);
var reservedWordsStrictSet2 = new Set(reservedWords2.strict);
var reservedWordsStrictBindSet2 = new Set(reservedWords2.strictBind);

function isReservedWord2(word, inModule) {
    return inModule && word === 'await' || word === 'enum';
}

function isStrictReservedWord2(word, inModule) {
    return isReservedWord2(word, inModule) || reservedWordsStrictSet2.has(word);
}

function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet2.has(word);
}

function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord2(word, inModule) || isStrictBindOnlyReservedWord(word);
}

function isKeyword2(word) {
    return keywords2.has(word);
}

var reservedWordLikeSet = /* @__PURE__ */new Set([
    'break',
    'case',
    'catch',
    'continue',
    'debugger',
    'default',
    'do',
    'else',
    'finally',
    'for',
    'function',
    'if',
    'return',
    'switch',
    'throw',
    'try',
    'var',
    'const',
    'while',
    'with',
    'new',
    'this',
    'super',
    'class',
    'extends',
    'export',
    'import',
    'null',
    'true',
    'false',
    'in',
    'instanceof',
    'typeof',
    'void',
    'delete',
    'implements',
    'interface',
    'let',
    'package',
    'private',
    'protected',
    'public',
    'static',
    'yield',
    'eval',
    'arguments',
    'enum',
    'await',
]);

function canBeReservedWord(word) {
    return reservedWordLikeSet.has(word);
}

var Scope = class {
    constructor(flags) {
        __publicField(this, 'flags', 0);
        __publicField(this, 'names',         /* @__PURE__ */new Map());
        __publicField(this, 'firstLexicalName', '');
        this.flags = flags;
    }
};

var ScopeHandler = class {
    constructor(parser, inModule) {
        __publicField(this, 'parser');
        __publicField(this, 'scopeStack', []);
        __publicField(this, 'inModule');
        __publicField(this, 'undefinedExports',         /* @__PURE__ */new Map());
        this.parser = parser;
        this.inModule = inModule;
    }
    
    get inTopLevel() {
        return (this.currentScope().flags & 1) > 0;
    }
    
    get inFunction() {
        return (this.currentVarScopeFlags() & 2) > 0;
    }
    
    get allowSuper() {
        return (this.currentThisScopeFlags() & 16) > 0;
    }
    
    get allowDirectSuper() {
        return (this.currentThisScopeFlags() & 32) > 0;
    }
    
    get allowNewTarget() {
        return (this.currentThisScopeFlags() & 512) > 0;
    }
    
    get inClass() {
        return (this.currentThisScopeFlags() & 64) > 0;
    }
    
    get inClassAndNotInNonArrowFunction() {
        const flags = this.currentThisScopeFlags();
        return (flags & 64) > 0 && (flags & 2) === 0;
    }
    
    get inStaticBlock() {
        for (let i = this.scopeStack.length - 1;; i--) {
            const {flags} = this.scopeStack[i];
            
            if (flags & 128) {
                return true;
            }
            
            if (flags & (1667 | 64)) {
                return false;
            }
        }
    }
    
    get inNonArrowFunction() {
        return (this.currentThisScopeFlags() & 2) > 0;
    }
    
    get inBareCaseStatement() {
        return (this.currentScope().flags & 256) > 0;
    }
    
    get treatFunctionsAsVar() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    
    createScope(flags) {
        return new Scope(flags);
    }
    
    enter(flags) {
        this.scopeStack.push(this.createScope(flags));
    }
    
    exit() {
        const scope2 = this.scopeStack.pop();
        return scope2.flags;
    }
    
    treatFunctionsAsVarInScope(scope2) {
        return !!(scope2.flags & (2 | 128) || !this.parser.inModule && scope2.flags & 1);
    }
    
    declareName(name, bindingType, loc) {
        let scope2 = this.currentScope();
        
        if (bindingType & 8 || bindingType & 16) {
            this.checkRedeclarationInScope(scope2, name, bindingType, loc);
            let type = scope2.names.get(name) || 0;
            
            if (bindingType & 16) {
                type = type | 4;
            } else {
                if (!scope2.firstLexicalName) {
                    scope2.firstLexicalName = name;
                }
                
                type = type | 2;
            }
            
            scope2.names.set(name, type);
            
            if (bindingType & 8) {
                this.maybeExportDefined(scope2, name);
            }
        } else if (bindingType & 4) {
            for (let i = this.scopeStack.length - 1; i >= 0; --i) {
                scope2 = this.scopeStack[i];
                this.checkRedeclarationInScope(scope2, name, bindingType, loc);
                scope2.names.set(name, (scope2.names.get(name) || 0) | 1);
                this.maybeExportDefined(scope2, name);
                
                if (scope2.flags & 1667)
                    break;
            }
        }
        
        if (this.parser.inModule && scope2.flags & 1) {
            this.undefinedExports.delete(name);
        }
    }
    
    maybeExportDefined(scope2, name) {
        if (this.parser.inModule && scope2.flags & 1) {
            this.undefinedExports.delete(name);
        }
    }
    
    checkRedeclarationInScope(scope2, name, bindingType, loc) {
        if (this.isRedeclaredInScope(scope2, name, bindingType)) {
            this.parser.raise(Errors.VarRedeclaration, loc, {
                identifierName: name,
            });
        }
    }
    
    isRedeclaredInScope(scope2, name, bindingType) {
        if (!(bindingType & 1))
            return false;
        
        if (bindingType & 8) {
            return scope2.names.has(name);
        }
        
        const type = scope2.names.get(name);
        
        if (bindingType & 16) {
            return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope2) && (type & 1) > 0;
        }
        
        return (type & 2) > 0 && !(scope2.flags & 8 && scope2.firstLexicalName === name)
            || !this.treatFunctionsAsVarInScope(scope2) && (type & 4) > 0;
    }
    
    checkLocalExport(id) {
        const {name} = id;
        
        const topLevelScope = this.scopeStack[0];
        
        if (!topLevelScope.names.has(name)) {
            this.undefinedExports.set(name, id.loc.start);
        }
    }
    
    currentScope() {
        return this.scopeStack[this.scopeStack.length - 1];
    }
    
    currentVarScopeFlags() {
        for (let i = this.scopeStack.length - 1;; i--) {
            const {flags} = this.scopeStack[i];
            
            if (flags & 1667) {
                return flags;
            }
        }
    }
    
    currentThisScopeFlags() {
        for (let i = this.scopeStack.length - 1;; i--) {
            const {flags} = this.scopeStack[i];
            
            if (flags & (1667 | 64) && !(flags & 4)) {
                return flags;
            }
        }
    }
};

var entities = {
    __proto__: null,
    quot: '"',
    amp: '&',
    apos: '\'',
    lt: '<',
    gt: '>',
    nbsp: '\xA0',
    iexcl: '\xA1',
    cent: '\xA2',
    pound: '\xA3',
    curren: '\xA4',
    yen: '\xA5',
    brvbar: '\xA6',
    sect: '\xA7',
    uml: '\xA8',
    copy: '\xA9',
    ordf: '\xAA',
    laquo: '\xAB',
    not: '\xAC',
    shy: '\xAD',
    reg: '\xAE',
    macr: '\xAF',
    deg: '\xB0',
    plusmn: '\xB1',
    sup2: '\xB2',
    sup3: '\xB3',
    acute: '\xB4',
    micro: '\xB5',
    para: '\xB6',
    middot: '\xB7',
    cedil: '\xB8',
    sup1: '\xB9',
    ordm: '\xBA',
    raquo: '\xBB',
    frac14: '\xBC',
    frac12: '\xBD',
    frac34: '\xBE',
    iquest: '\xBF',
    Agrave: '\xC0',
    Aacute: '\xC1',
    Acirc: '\xC2',
    Atilde: '\xC3',
    Auml: '\xC4',
    Aring: '\xC5',
    AElig: '\xC6',
    Ccedil: '\xC7',
    Egrave: '\xC8',
    Eacute: '\xC9',
    Ecirc: '\xCA',
    Euml: '\xCB',
    Igrave: '\xCC',
    Iacute: '\xCD',
    Icirc: '\xCE',
    Iuml: '\xCF',
    ETH: '\xD0',
    Ntilde: '\xD1',
    Ograve: '\xD2',
    Oacute: '\xD3',
    Ocirc: '\xD4',
    Otilde: '\xD5',
    Ouml: '\xD6',
    times: '\xD7',
    Oslash: '\xD8',
    Ugrave: '\xD9',
    Uacute: '\xDA',
    Ucirc: '\xDB',
    Uuml: '\xDC',
    Yacute: '\xDD',
    THORN: '\xDE',
    szlig: '\xDF',
    agrave: '\xE0',
    aacute: '\xE1',
    acirc: '\xE2',
    atilde: '\xE3',
    auml: '\xE4',
    aring: '\xE5',
    aelig: '\xE6',
    ccedil: '\xE7',
    egrave: '\xE8',
    eacute: '\xE9',
    ecirc: '\xEA',
    euml: '\xEB',
    igrave: '\xEC',
    iacute: '\xED',
    icirc: '\xEE',
    iuml: '\xEF',
    eth: '\xF0',
    ntilde: '\xF1',
    ograve: '\xF2',
    oacute: '\xF3',
    ocirc: '\xF4',
    otilde: '\xF5',
    ouml: '\xF6',
    divide: '\xF7',
    oslash: '\xF8',
    ugrave: '\xF9',
    uacute: '\xFA',
    ucirc: '\xFB',
    uuml: '\xFC',
    yacute: '\xFD',
    thorn: '\xFE',
    yuml: '\xFF',
    OElig: '\u0152',
    oelig: '\u0153',
    Scaron: '\u0160',
    scaron: '\u0161',
    Yuml: '\u0178',
    fnof: '\u0192',
    circ: '\u02C6',
    tilde: '\u02DC',
    Alpha: '\u0391',
    Beta: '\u0392',
    Gamma: '\u0393',
    Delta: '\u0394',
    Epsilon: '\u0395',
    Zeta: '\u0396',
    Eta: '\u0397',
    Theta: '\u0398',
    Iota: '\u0399',
    Kappa: '\u039A',
    Lambda: '\u039B',
    Mu: '\u039C',
    Nu: '\u039D',
    Xi: '\u039E',
    Omicron: '\u039F',
    Pi: '\u03A0',
    Rho: '\u03A1',
    Sigma: '\u03A3',
    Tau: '\u03A4',
    Upsilon: '\u03A5',
    Phi: '\u03A6',
    Chi: '\u03A7',
    Psi: '\u03A8',
    Omega: '\u03A9',
    alpha: '\u03B1',
    beta: '\u03B2',
    gamma: '\u03B3',
    delta: '\u03B4',
    epsilon: '\u03B5',
    zeta: '\u03B6',
    eta: '\u03B7',
    theta: '\u03B8',
    iota: '\u03B9',
    kappa: '\u03BA',
    lambda: '\u03BB',
    mu: '\u03BC',
    nu: '\u03BD',
    xi: '\u03BE',
    omicron: '\u03BF',
    pi: '\u03C0',
    rho: '\u03C1',
    sigmaf: '\u03C2',
    sigma: '\u03C3',
    tau: '\u03C4',
    upsilon: '\u03C5',
    phi: '\u03C6',
    chi: '\u03C7',
    psi: '\u03C8',
    omega: '\u03C9',
    thetasym: '\u03D1',
    upsih: '\u03D2',
    piv: '\u03D6',
    ensp: '\u2002',
    emsp: '\u2003',
    thinsp: '\u2009',
    zwnj: '\u200C',
    zwj: '\u200D',
    lrm: '\u200E',
    rlm: '\u200F',
    ndash: '\u2013',
    mdash: '\u2014',
    lsquo: '\u2018',
    rsquo: '\u2019',
    sbquo: '\u201A',
    ldquo: '\u201C',
    rdquo: '\u201D',
    bdquo: '\u201E',
    dagger: '\u2020',
    Dagger: '\u2021',
    bull: '\u2022',
    hellip: '\u2026',
    permil: '\u2030',
    prime: '\u2032',
    Prime: '\u2033',
    lsaquo: '\u2039',
    rsaquo: '\u203A',
    oline: '\u203E',
    frasl: '\u2044',
    euro: '\u20AC',
    image: '\u2111',
    weierp: '\u2118',
    real: '\u211C',
    trade: '\u2122',
    alefsym: '\u2135',
    larr: '\u2190',
    uarr: '\u2191',
    rarr: '\u2192',
    darr: '\u2193',
    harr: '\u2194',
    crarr: '\u21B5',
    lArr: '\u21D0',
    uArr: '\u21D1',
    rArr: '\u21D2',
    dArr: '\u21D3',
    hArr: '\u21D4',
    forall: '\u2200',
    part: '\u2202',
    exist: '\u2203',
    empty: '\u2205',
    nabla: '\u2207',
    isin: '\u2208',
    notin: '\u2209',
    ni: '\u220B',
    prod: '\u220F',
    sum: '\u2211',
    minus: '\u2212',
    lowast: '\u2217',
    radic: '\u221A',
    prop: '\u221D',
    infin: '\u221E',
    ang: '\u2220',
    and: '\u2227',
    or: '\u2228',
    cap: '\u2229',
    cup: '\u222A',
    int: '\u222B',
    there4: '\u2234',
    sim: '\u223C',
    cong: '\u2245',
    asymp: '\u2248',
    ne: '\u2260',
    equiv: '\u2261',
    le: '\u2264',
    ge: '\u2265',
    sub: '\u2282',
    sup: '\u2283',
    nsub: '\u2284',
    sube: '\u2286',
    supe: '\u2287',
    oplus: '\u2295',
    otimes: '\u2297',
    perp: '\u22A5',
    sdot: '\u22C5',
    lceil: '\u2308',
    rceil: '\u2309',
    lfloor: '\u230A',
    rfloor: '\u230B',
    lang: '\u2329',
    rang: '\u232A',
    loz: '\u25CA',
    spades: '\u2660',
    clubs: '\u2663',
    hearts: '\u2665',
    diams: '\u2666',
};

var lineBreak = /\r\n|[\r\n\u2028\u2029]/;
var lineBreakG = new RegExp(lineBreak.source, 'g');

function isNewLine$1(code2) {
    switch(code2) {
    case 10:    
    case 13:    
    case 8232:    
    case 8233:
        return true;
    
    default:
        return false;
    }
}

function hasNewLine(input, start, end) {
    for (let i = start; i < end; i++) {
        if (isNewLine$1(input.charCodeAt(i))) {
            return true;
        }
    }
    
    return false;
}

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;

function isWhitespace(code2) {
    switch(code2) {
    case 9:    
    case 11:    
    case 12:    
    case 32:    
    case 160:    
    case 5760:    
    case 8192:    
    case 8193:    
    case 8194:    
    case 8195:    
    case 8196:    
    case 8197:    
    case 8198:    
    case 8199:    
    case 8200:    
    case 8201:    
    case 8202:    
    case 8239:    
    case 8287:    
    case 12288:    
    case 65279:
        return true;
    
    default:
        return false;
    }
}

var JsxErrors = ParseErrorEnum`jsx`({
    AttributeIsEmpty: 'JSX attributes must only be assigned a non-empty expression.',
    MissingClosingTagElement: ({openingTagName}) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
    MissingClosingTagFragment: 'Expected corresponding JSX closing tag for <>.',
    UnexpectedSequenceExpression: 'Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?',
    UnexpectedToken: ({unexpected, HTMLEntity}) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
    UnsupportedJsxValue: 'JSX value should be either an expression or a quoted JSX text.',
    UnterminatedJsxContent: 'Unterminated JSX contents.',
    UnwrappedAdjacentJSXElements: 'Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?',
});

function isFragment(object) {
    return object ? object.type === 'JSXOpeningFragment' || object.type === 'JSXClosingFragment' : false;
}

function getQualifiedJSXName(object) {
    if (object.type === 'JSXIdentifier') {
        return object.name;
    }
    
    if (object.type === 'JSXNamespacedName') {
        return object.namespace.name + ':' + object.name.name;
    }
    
    if (object.type === 'JSXMemberExpression') {
        return getQualifiedJSXName(object.object) + '.' + getQualifiedJSXName(object.property);
    }
    
    throw new Error('Node had unexpected type: ' + object.type);
}

var jsx$3 = (superClass) => class JSXParserMixin extends superClass {
    jsxReadToken() {
        let out = '';
        let chunkStart = this.state.pos;
        
        for (;;) {
            if (this.state.pos >= this.length) {
                throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);
            }
            
            const ch = this.input.charCodeAt(this.state.pos);
            
            switch(ch) {
            case 60:            
            case 123:
                if (this.state.pos === this.state.start) {
                    if (ch === 60 && this.state.canStartJSXElement) {
                        ++this.state.pos;
                        this.finishToken(143);
                    } else {
                        super.getTokenFromCode(ch);
                    }
                    
                    return;
                }
                
                out += this.input.slice(chunkStart, this.state.pos);
                this.finishToken(142, out);
                return;
            
            case 38:
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadEntity();
                chunkStart = this.state.pos;
                break;
            
            case 62:            
            case 125: {
                this.raise(JsxErrors.UnexpectedToken, this.state.curPosition(), {
                    unexpected: this.input[this.state.pos],
                    HTMLEntity: ch === 125 ? '&rbrace;' : '&gt;',
                });
            }
            
            default:
                if (isNewLine$1(ch)) {
                    out += this.input.slice(chunkStart, this.state.pos);
                    out += this.jsxReadNewLine(true);
                    chunkStart = this.state.pos;
                } else {
                    ++this.state.pos;
                }
            }
        }
    }
    
    jsxReadNewLine(normalizeCRLF) {
        const ch = this.input.charCodeAt(this.state.pos);
        let out;
        ++this.state.pos;
        
        if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
            ++this.state.pos;
            out = normalizeCRLF ? '\n' : '\r\n';
        } else {
            out = String.fromCharCode(ch);
        }
        
        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        return out;
    }
    
    jsxReadString(quote) {
        let out = '';
        let chunkStart = ++this.state.pos;
        
        for (;;) {
            if (this.state.pos >= this.length) {
                throw this.raise(Errors.UnterminatedString, this.state.startLoc);
            }
            
            const ch = this.input.charCodeAt(this.state.pos);
            
            if (ch === quote)
                break;
            
            if (ch === 38) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadEntity();
                chunkStart = this.state.pos;
            } else if (isNewLine$1(ch)) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadNewLine(false);
                chunkStart = this.state.pos;
            } else {
                ++this.state.pos;
            }
        }
        
        out += this.input.slice(chunkStart, this.state.pos++);
        this.finishToken(134, out);
    }
    
    jsxReadEntity() {
        const startPos = ++this.state.pos;
        
        if (this.codePointAtPos(this.state.pos) === 35) {
            ++this.state.pos;
            let radix = 10;
            
            if (this.codePointAtPos(this.state.pos) === 120) {
                radix = 16;
                ++this.state.pos;
            }
            
            const codePoint = this.readInt(radix, void 0, false, 'bail');
            
            if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
                ++this.state.pos;
                return String.fromCodePoint(codePoint);
            }
        } else {
            let count = 0;
            let semi = false;
            
            while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59)) {
                ++this.state.pos;
            }
            
            if (semi) {
                const desc = this.input.slice(startPos, this.state.pos);
                const entity = entities[desc];
                ++this.state.pos;
                
                if (entity) {
                    return entity;
                }
            }
        }
        
        this.state.pos = startPos;
        return '&';
    }
    
    jsxReadWord() {
        let ch;
        const start = this.state.pos;
        
        do {
            ch = this.input.charCodeAt(++this.state.pos);
        } while (isIdentifierChar2(ch) || ch === 45)
        this.finishToken(141, this.input.slice(start, this.state.pos));
    }
    
    jsxParseIdentifier() {
        const node = this.startNode();
        
        if (this.match(141)) {
            node.name = this.state.value;
        } else if (tokenIsKeyword(this.state.type)) {
            node.name = tokenLabelName(this.state.type);
        } else {
            this.unexpected();
        }
        
        this.next();
        return this.finishNode(node, 'JSXIdentifier');
    }
    
    jsxParseNamespacedName() {
        const startLoc = this.state.startLoc;
        const name = this.jsxParseIdentifier();
        
        if (!this.eat(14))
            return name;
        
        const node = this.startNodeAt(startLoc);
        
        node.namespace = name;
        node.name = this.jsxParseIdentifier();
        return this.finishNode(node, 'JSXNamespacedName');
    }
    
    jsxParseElementName() {
        const startLoc = this.state.startLoc;
        let node = this.jsxParseNamespacedName();
        
        if (node.type === 'JSXNamespacedName') {
            return node;
        }
        
        while (this.eat(16)) {
            const newNode = this.startNodeAt(startLoc);
            
            newNode.object = node;
            newNode.property = this.jsxParseIdentifier();
            node = this.finishNode(newNode, 'JSXMemberExpression');
        }
        
        return node;
    }
    
    jsxParseAttributeValue() {
        let node;
        
        switch(this.state.type) {
        case 5:
            node = this.startNode();
            this.setContext(types$18.brace);
            this.next();
            node = this.jsxParseExpressionContainer(node, types$18.j_oTag);
            
            if (node.expression.type === 'JSXEmptyExpression') {
                this.raise(JsxErrors.AttributeIsEmpty, node);
            }
            
            return node;
        
        case 143:        
        case 134:
            return this.parseExprAtom();
        
        default:
            throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);
        }
    }
    
    jsxParseEmptyExpression() {
        const node = this.startNodeAt(this.state.lastTokEndLoc);
        return this.finishNodeAt(node, 'JSXEmptyExpression', this.state.startLoc);
    }
    
    jsxParseSpreadChild(node) {
        this.next();
        node.expression = this.parseExpression();
        this.setContext(types$18.j_expr);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node, 'JSXSpreadChild');
    }
    
    jsxParseExpressionContainer(node, previousContext) {
        if (this.match(8)) {
            node.expression = this.jsxParseEmptyExpression();
        } else {
            const expression2 = this.parseExpression();
            
            {
                if (expression2.type === 'SequenceExpression' && !expression2.extra?.parenthesized) {
                    this.raise(JsxErrors.UnexpectedSequenceExpression, expression2.expressions[1]);
                }
            }
            node.expression = expression2;
        }
        
        this.setContext(previousContext);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node, 'JSXExpressionContainer');
    }
    
    jsxParseAttribute() {
        const node = this.startNode();
        
        if (this.match(5)) {
            this.setContext(types$18.brace);
            this.next();
            this.expect(21);
            node.argument = this.parseMaybeAssignAllowIn();
            this.setContext(types$18.j_oTag);
            this.state.canStartJSXElement = true;
            this.expect(8);
            return this.finishNode(node, 'JSXSpreadAttribute');
        }
        
        node.name = this.jsxParseNamespacedName();
        node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
        return this.finishNode(node, 'JSXAttribute');
    }
    
    jsxParseOpeningElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        
        if (this.eat(144)) {
            return this.finishNode(node, 'JSXOpeningFragment');
        }
        
        node.name = this.jsxParseElementName();
        return this.jsxParseOpeningElementAfterName(node);
    }
    
    jsxParseOpeningElementAfterName(node) {
        const attributes = [];
        
        while (!this.match(56) && !this.match(144)) {
            attributes.push(this.jsxParseAttribute());
        }
        
        node.attributes = attributes;
        node.selfClosing = this.eat(56);
        this.expect(144);
        return this.finishNode(node, 'JSXOpeningElement');
    }
    
    jsxParseClosingElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        
        if (this.eat(144)) {
            return this.finishNode(node, 'JSXClosingFragment');
        }
        
        node.name = this.jsxParseElementName();
        this.expect(144);
        return this.finishNode(node, 'JSXClosingElement');
    }
    
    jsxParseElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        const children = [];
        const openingElement = this.jsxParseOpeningElementAt(startLoc);
        let closingElement = null;
        
        if (!openingElement.selfClosing) {
            contents:             for (;;) {
                switch(this.state.type) {
                case 143:
                    startLoc = this.state.startLoc;
                    this.next();
                    
                    if (this.eat(56)) {
                        closingElement = this.jsxParseClosingElementAt(startLoc);
                        break contents;
                    }
                    
                    children.push(this.jsxParseElementAt(startLoc));
                    break;
                
                case 142:
                    children.push(this.parseLiteral(this.state.value, 'JSXText'));
                    break;
                
                case 5: {
                    const node2 = this.startNode();
                    this.setContext(types$18.brace);
                    this.next();
                    
                    if (this.match(21)) {
                        children.push(this.jsxParseSpreadChild(node2));
                    } else {
                        children.push(this.jsxParseExpressionContainer(node2, types$18.j_expr));
                    }
                    
                    break;
                }
                
                default:
                    this.unexpected();
                }
            }
            if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
                this.raise(JsxErrors.MissingClosingTagFragment, closingElement);
            } else if (!isFragment(openingElement) && isFragment(closingElement)) {
                this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
                    openingTagName: getQualifiedJSXName(openingElement.name),
                });
            } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
                if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
                    this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
                        openingTagName: getQualifiedJSXName(openingElement.name),
                    });
                }
            }

        }
        
        if (isFragment(openingElement)) {
            node.openingFragment = openingElement;
            node.closingFragment = closingElement;
        } else {
            node.openingElement = openingElement;
            node.closingElement = closingElement;
        }
        
        node.children = children;
        
        if (this.match(47)) {
            throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);
        }
        
        return isFragment(openingElement) ? this.finishNode(node, 'JSXFragment') : this.finishNode(node, 'JSXElement');
    }
    
    jsxParseElement() {
        const startLoc = this.state.startLoc;
        this.next();
        return this.jsxParseElementAt(startLoc);
    }
    
    setContext(newContext) {
        const {context} = this.state;
        
        context[context.length - 1] = newContext;
    }
    
    parseExprAtom(refExpressionErrors) {
        if (this.match(143)) {
            return this.jsxParseElement();
        } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
            this.replaceToken(143);
            return this.jsxParseElement();
        } else {
            return super.parseExprAtom(refExpressionErrors);
        }
    }
    
    skipSpace() {
        const curContext = this.curContext();
        
        if (!curContext.preserveSpace)
            super.skipSpace();
    }
    
    getTokenFromCode(code2) {
        const context = this.curContext();
        
        if (context === types$18.j_expr) {
            this.jsxReadToken();
            return;
        }
        
        if (context === types$18.j_oTag || context === types$18.j_cTag) {
            if (isIdentifierStart2(code2)) {
                this.jsxReadWord();
                return;
            }
            
            if (code2 === 62) {
                ++this.state.pos;
                this.finishToken(144);
                return;
            }
            
            if ((code2 === 34 || code2 === 39) && context === types$18.j_oTag) {
                this.jsxReadString(code2);
                return;
            }
        }
        
        if (code2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
            ++this.state.pos;
            this.finishToken(143);
            return;
        }
        
        super.getTokenFromCode(code2);
    }
    
    updateContext(prevType) {
        const {context, type} = this.state;
        
        if (type === 56 && prevType === 143) {
            context.splice(-2, 2, types$18.j_cTag);
            this.state.canStartJSXElement = false;
        } else if (type === 143) {
            context.push(types$18.j_oTag);
        } else if (type === 144) {
            const out = context[context.length - 1];
            
            if (out === types$18.j_oTag && prevType === 56 || out === types$18.j_cTag) {
                context.pop();
                this.state.canStartJSXElement = context[context.length - 1] === types$18.j_expr;
            } else {
                this.setContext(types$18.j_expr);
                this.state.canStartJSXElement = true;
            }
        } else {
            this.state.canStartJSXElement = tokenComesBeforeExpression(type);
        }

    }
};

var TypeScriptScope = class extends Scope {
    constructor() {
        super(...arguments);
        __publicField(this, 'tsNames',         /* @__PURE__ */new Map());
    }
};

var TypeScriptScopeHandler = class extends ScopeHandler {
    constructor() {
        super(...arguments);
        __publicField(this, 'importsStack', []);
    }
    
    createScope(flags) {
        this.importsStack.push(        /* @__PURE__ */new Set());
        return new TypeScriptScope(flags);
    }
    
    enter(flags) {
        if (flags === 1024) {
            this.importsStack.push(            /* @__PURE__ */new Set());
        }
        
        super.enter(flags);
    }
    
    exit() {
        const flags = super.exit();
        
        if (flags === 1024) {
            this.importsStack.pop();
        }
        
        return flags;
    }
    
    hasImport(name, allowShadow) {
        const len = this.importsStack.length;
        
        if (this.importsStack[len - 1].has(name)) {
            return true;
        }
        
        if (!allowShadow && len > 1) {
            for (let i = 0; i < len - 1; i++) {
                if (this.importsStack[i].has(name))
                    return true;
            }
        }
        
        return false;
    }
    
    declareName(name, bindingType, loc) {
        if (bindingType & 4096) {
            if (this.hasImport(name, true)) {
                this.parser.raise(Errors.VarRedeclaration, loc, {
                    identifierName: name,
                });
            }
            
            this.importsStack[this.importsStack.length - 1].add(name);
            
            return;
        }
        
        const scope2 = this.currentScope();
        let type = scope2.tsNames.get(name) || 0;
        
        if (bindingType & 1024) {
            this.maybeExportDefined(scope2, name);
            scope2.tsNames.set(name, type | 16);
            return;
        }
        
        super.declareName(name, bindingType, loc);
        
        if (bindingType & 2) {
            if (!(bindingType & 1)) {
                this.checkRedeclarationInScope(scope2, name, bindingType, loc);
                this.maybeExportDefined(scope2, name);
            }
            
            type = type | 1;
        }
        
        if (bindingType & 256) {
            type = type | 2;
        }
        
        if (bindingType & 512) {
            type = type | 4;
        }
        
        if (bindingType & 128) {
            type = type | 8;
        }
        
        if (type)
            scope2.tsNames.set(name, type);
    }
    
    isRedeclaredInScope(scope2, name, bindingType) {
        const type = scope2.tsNames.get(name);
        
        if ((type & 2) > 0) {
            if (bindingType & 256) {
                const isConst = !!(bindingType & 512);
                const wasConst = (type & 4) > 0;
                
                return isConst !== wasConst;
            }
            
            return true;
        }
        
        if (bindingType & 128 && (type & 8) > 0) {
            if (scope2.names.get(name) & 2) {
                return !!(bindingType & 1);
            } else {
                return false;
            }
        }
        
        if (bindingType & 2 && (type & 1) > 0) {
            return true;
        }
        
        return super.isRedeclaredInScope(scope2, name, bindingType);
    }
    
    checkLocalExport(id) {
        const {name} = id;
        
        if (this.hasImport(name))
            return;
        
        const len = this.scopeStack.length;
        
        for (let i = len - 1; i >= 0; i--) {
            const scope2 = this.scopeStack[i];
            const type = scope2.tsNames.get(name);
            
            if ((type & 1) > 0 || (type & 16) > 0) {
                return;
            }
        }
        
        super.checkLocalExport(id);
    }
};

var ProductionParameterHandler = class {
    constructor() {
        __publicField(this, 'stacks', []);
    }
    
    enter(flags) {
        this.stacks.push(flags);
    }
    
    exit() {
        this.stacks.pop();
    }
    
    currentFlags() {
        return this.stacks[this.stacks.length - 1];
    }
    
    get hasAwait() {
        return (this.currentFlags() & 2) > 0;
    }
    
    get hasYield() {
        return (this.currentFlags() & 1) > 0;
    }
    
    get hasReturn() {
        return (this.currentFlags() & 4) > 0;
    }
    
    get hasIn() {
        return (this.currentFlags() & 8) > 0;
    }
};

function functionFlags(isAsync, isGenerator) {
    return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
}

var BaseParser = class {
    constructor() {
        __publicField(this, 'sawUnambiguousESM', false);
        __publicField(this, 'ambiguousScriptDifferentAst', false);
    }
    
    sourceToOffsetPos(sourcePos) {
        return sourcePos + this.startIndex;
    }
    
    offsetToSourcePos(offsetPos) {
        return offsetPos - this.startIndex;
    }
    
    hasPlugin(pluginConfig) {
        if (typeof pluginConfig === 'string') {
            return this.plugins.has(pluginConfig);
        } else {
            const [pluginName, pluginOptions] = pluginConfig;
            
            if (!this.hasPlugin(pluginName)) {
                return false;
            }
            
            const actualOptions = this.plugins.get(pluginName);
            
            for (const key of Object.keys(pluginOptions)) {
                if (actualOptions?.[key] !== pluginOptions[key]) {
                    return false;
                }
            }
            
            return true;
        }
    }
    
    getPluginOption(plugin, name) {
        return this.plugins.get(plugin)?.[name];
    }
};

function setTrailingComments(node, comments) {
    if (node.trailingComments === void 0) {
        node.trailingComments = comments;
    } else {
        node.trailingComments.unshift(...comments);
    }
}

function setLeadingComments(node, comments) {
    if (node.leadingComments === void 0) {
        node.leadingComments = comments;
    } else {
        node.leadingComments.unshift(...comments);
    }
}

function setInnerComments(node, comments) {
    if (node.innerComments === void 0) {
        node.innerComments = comments;
    } else {
        node.innerComments.unshift(...comments);
    }
}

function adjustInnerComments(node, elements, commentWS) {
    let lastElement = null;
    let i = elements.length;
    
    while (lastElement === null && i > 0) {
        lastElement = elements[--i];
    }
    
    if (lastElement === null || lastElement.start > commentWS.start) {
        setInnerComments(node, commentWS.comments);
    } else {
        setTrailingComments(lastElement, commentWS.comments);
    }
}

var CommentsParser = class extends BaseParser {
    addComment(comment) {
        if (this.filename)
            comment.loc.filename = this.filename;
        
        const {commentsLen} = this.state;
        
        if (this.comments.length !== commentsLen) {
            this.comments.length = commentsLen;
        }
        
        this.comments.push(comment);
        this.state.commentsLen++;
    }
    
    processComment(node) {
        const {commentStack} = this.state;
        
        const commentStackLength = commentStack.length;
        
        if (commentStackLength === 0)
            return;
        
        let i = commentStackLength - 1;
        const lastCommentWS = commentStack[i];
        
        if (lastCommentWS.start === node.end) {
            lastCommentWS.leadingNode = node;
            i--;
        }
        
        const {start: nodeStart} = node;
        
        for (; i >= 0; i--) {
            const commentWS = commentStack[i];
            const commentEnd = commentWS.end;
            
            if (commentEnd > nodeStart) {
                commentWS.containingNode = node;
                this.finalizeComment(commentWS);
                commentStack.splice(i, 1);
            } else {
                if (commentEnd === nodeStart) {
                    commentWS.trailingNode = node;
                }
                
                break;
            }
        }
    }
    
    finalizeComment(commentWS) {
        const {comments} = commentWS;
        
        if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
            if (commentWS.leadingNode !== null) {
                setTrailingComments(commentWS.leadingNode, comments);
            }
            
            if (commentWS.trailingNode !== null) {
                setLeadingComments(commentWS.trailingNode, comments);
            }
        } else {
            const {containingNode: node, start: commentStart} = commentWS;
            
            if (this.input.charCodeAt(this.offsetToSourcePos(commentStart) - 1) === 44) {
                switch(node.type) {
                case 'ObjectExpression':                
                case 'ObjectPattern':                
                case 'RecordExpression':
                    adjustInnerComments(node, node.properties, commentWS);
                    break;
                
                case 'CallExpression':                
                case 'OptionalCallExpression':
                    adjustInnerComments(node, node.arguments, commentWS);
                    break;
                
                case 'ImportExpression':
                    adjustInnerComments(node, [node.source, node.options ?? null], commentWS);
                    break;
                
                case 'FunctionDeclaration':                
                case 'FunctionExpression':                
                case 'ArrowFunctionExpression':                
                case 'ObjectMethod':                
                case 'ClassMethod':                
                case 'ClassPrivateMethod':
                    adjustInnerComments(node, node.params, commentWS);
                    break;
                
                case 'ArrayExpression':                
                case 'ArrayPattern':                
                case 'TupleExpression':
                    adjustInnerComments(node, node.elements, commentWS);
                    break;
                
                case 'ExportNamedDeclaration':                
                case 'ImportDeclaration':
                    adjustInnerComments(node, node.specifiers, commentWS);
                    break;
                
                case 'TSEnumDeclaration': {
                    setInnerComments(node, comments);
                }
                break;
                
                case 'TSEnumBody':
                    adjustInnerComments(node, node.members, commentWS);
                    break;
                
                default: {
                    setInnerComments(node, comments);
                }
                }
            } else {
                setInnerComments(node, comments);
            }
        }
    }
    
    finalizeRemainingComments() {
        const {commentStack} = this.state;
        
        for (let i = commentStack.length - 1; i >= 0; i--) {
            this.finalizeComment(commentStack[i]);
        }
        
        this.state.commentStack = [];
    }
    
    resetPreviousNodeTrailingComments(node) {
        const {commentStack} = this.state;
        
        const {length} = commentStack;
        
        if (length === 0)
            return;
        
        const commentWS = commentStack[length - 1];
        
        if (commentWS.leadingNode === node) {
            commentWS.leadingNode = null;
        }
    }
    
    takeSurroundingComments(node, start, end) {
        const {commentStack} = this.state;
        
        const commentStackLength = commentStack.length;
        
        if (commentStackLength === 0)
            return;
        
        let i = commentStackLength - 1;
        
        for (; i >= 0; i--) {
            const commentWS = commentStack[i];
            const commentEnd = commentWS.end;
            const commentStart = commentWS.start;
            
            if (commentStart === end) {
                commentWS.leadingNode = node;
            } else if (commentEnd === start) {
                commentWS.trailingNode = node;
            } else if (commentEnd < start) {
                break;
            }

        }
    }
};

var State$2 = class _State {
    constructor() {
        __publicField(this, 'flags', 1024);
        __publicField(this, 'startIndex');
        __publicField(this, 'curLine');
        __publicField(this, 'lineStart');
        __publicField(this, 'startLoc');
        __publicField(this, 'endLoc');
        __publicField(this, 'errors', []);
        __publicField(this, 'potentialArrowAt', -1);
        __publicField(this, 'noArrowAt', []);
        __publicField(this, 'noArrowParamsConversionAt', []);
        __publicField(this, 'topicContext', {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null,
        });
        __publicField(this, 'labels', []);
        __publicField(this, 'commentsLen', 0);
        __publicField(this, 'commentStack', []);
        __publicField(this, 'pos', 0);
        __publicField(this, 'type', 140);
        __publicField(this, 'value', null);
        __publicField(this, 'start', 0);
        __publicField(this, 'end', 0);
        __publicField(this, 'lastTokEndLoc', null);
        __publicField(this, 'lastTokStartLoc', null);
        __publicField(this, 'context', [types$18.brace]);
        __publicField(this, 'firstInvalidTemplateEscapePos', null);
        __publicField(this, 'strictErrors',         /* @__PURE__ */new Map());
        __publicField(this, 'tokensLength', 0);
    }
    
    get strict() {
        return (this.flags & 1) > 0;
    }
    
    set strict(v) {
        if (v)
            this.flags |= 1;
        else
            this.flags &= -2;
    }
    
    init({strictMode, sourceType, startIndex, startLine, startColumn}) {
        this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === 'module';
        this.startIndex = startIndex;
        this.curLine = startLine;
        this.lineStart = -startColumn;
        this.startLoc =
        this.endLoc = new Position(startLine, startColumn, startIndex);
    }
    
    get maybeInArrowParameters() {
        return (this.flags & 2) > 0;
    }
    
    set maybeInArrowParameters(v) {
        if (v)
            this.flags |= 2;
        else
            this.flags &= -3;
    }
    
    get inType() {
        return (this.flags & 4) > 0;
    }
    
    set inType(v) {
        if (v)
            this.flags |= 4;
        else
            this.flags &= -5;
    }
    
    get noAnonFunctionType() {
        return (this.flags & 8) > 0;
    }
    
    set noAnonFunctionType(v) {
        if (v)
            this.flags |= 8;
        else
            this.flags &= -9;
    }
    
    get hasFlowComment() {
        return (this.flags & 16) > 0;
    }
    
    set hasFlowComment(v) {
        if (v)
            this.flags |= 16;
        else
            this.flags &= -17;
    }
    
    get isAmbientContext() {
        return (this.flags & 32) > 0;
    }
    
    set isAmbientContext(v) {
        if (v)
            this.flags |= 32;
        else
            this.flags &= -33;
    }
    
    get inAbstractClass() {
        return (this.flags & 64) > 0;
    }
    
    set inAbstractClass(v) {
        if (v)
            this.flags |= 64;
        else
            this.flags &= -65;
    }
    
    get inDisallowConditionalTypesContext() {
        return (this.flags & 128) > 0;
    }
    
    set inDisallowConditionalTypesContext(v) {
        if (v)
            this.flags |= 128;
        else
            this.flags &= -129;
    }
    
    get soloAwait() {
        return (this.flags & 256) > 0;
    }
    
    set soloAwait(v) {
        if (v)
            this.flags |= 256;
        else
            this.flags &= -257;
    }
    
    get inFSharpPipelineDirectBody() {
        return (this.flags & 512) > 0;
    }
    
    set inFSharpPipelineDirectBody(v) {
        if (v)
            this.flags |= 512;
        else
            this.flags &= -513;
    }
    
    get canStartJSXElement() {
        return (this.flags & 1024) > 0;
    }
    
    set canStartJSXElement(v) {
        if (v)
            this.flags |= 1024;
        else
            this.flags &= -1025;
    }
    
    get containsEsc() {
        return (this.flags & 2048) > 0;
    }
    
    set containsEsc(v) {
        if (v)
            this.flags |= 2048;
        else
            this.flags &= -2049;
    }
    
    get hasTopLevelAwait() {
        return (this.flags & 4096) > 0;
    }
    
    set hasTopLevelAwait(v) {
        if (v)
            this.flags |= 4096;
        else
            this.flags &= -4097;
    }
    
    curPosition() {
        return new Position(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
    }
    
    clone() {
        const state = new _State();
        
        state.flags = this.flags;
        state.startIndex = this.startIndex;
        state.curLine = this.curLine;
        state.lineStart = this.lineStart;
        state.startLoc = this.startLoc;
        state.endLoc = this.endLoc;
        state.errors = this.errors.slice();
        state.potentialArrowAt = this.potentialArrowAt;
        state.noArrowAt = this.noArrowAt.slice();
        state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();
        state.topicContext = this.topicContext;
        state.labels = this.labels.slice();
        state.commentsLen = this.commentsLen;
        state.commentStack = this.commentStack.slice();
        state.pos = this.pos;
        state.type = this.type;
        state.value = this.value;
        state.start = this.start;
        state.end = this.end;
        state.lastTokEndLoc = this.lastTokEndLoc;
        state.lastTokStartLoc = this.lastTokStartLoc;
        state.context = this.context.slice();
        state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;
        state.strictErrors = this.strictErrors;
        state.tokensLength = this.tokensLength;
        return state;
    }
};

var _isDigit2 = function isDigit2(code2) {
    return code2 >= 48 && code2 <= 57;
};

var forbiddenNumericSeparatorSiblings2 = {
    decBinOct:     /* @__PURE__ */new Set([
        46,
        66,
        69,
        79,
        95,
        98,
        101,
        111,
    ]),
    hex:     /* @__PURE__ */new Set([
        46,
        88,
        95,
        120,
    ]),
};

var isAllowedNumericSeparatorSibling2 = {
    bin: (ch) => ch === 48 || ch === 49,
    oct: (ch) => ch >= 48 && ch <= 55,
    dec: (ch) => ch >= 48 && ch <= 57,
    hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102,
};

function readStringContents2(type, input, pos, lineStart, curLine, errors) {
    const initialPos = pos;
    const initialLineStart = lineStart;
    const initialCurLine = curLine;
    let out = '';
    let firstInvalidLoc = null;
    let chunkStart = pos;
    
    const {length} = input;
    
    for (;;) {
        if (pos >= length) {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
            out += input.slice(chunkStart, pos);
            break;
        }
        
        const ch = input.charCodeAt(pos);
        
        if (isStringEnd2(type, ch, input, pos)) {
            out += input.slice(chunkStart, pos);
            break;
        }
        
        if (ch === 92) {
            out += input.slice(chunkStart, pos);
            const res = readEscapedChar2(input, pos, lineStart, curLine, type === 'template', errors);
            
            if (res.ch === null && !firstInvalidLoc) {
                firstInvalidLoc = {
                    pos,
                    lineStart,
                    curLine,
                };
            } else {
                out += res.ch;
            }
            
            ({
                pos,
                lineStart,
                curLine,
            } = res);
            chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
            ++pos;
            ++curLine;
            lineStart = pos;
        } else if (ch === 10 || ch === 13) {
            if (type === 'template') {
                out += input.slice(chunkStart, pos) + '\n';
                ++pos;
                
                if (ch === 13 && input.charCodeAt(pos) === 10) {
                    ++pos;
                }
                
                ++curLine;
                chunkStart =
                lineStart = pos;
            } else {
                errors.unterminated(initialPos, initialLineStart, initialCurLine);
            }
        } else {
            ++pos;
        }

    }
    
    return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
    };
}

function isStringEnd2(type, ch, input, pos) {
    if (type === 'template') {
        return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
    }
    
    return ch === (type === 'double' ? 34 : 39);
}

function readEscapedChar2(input, pos, lineStart, curLine, inTemplate, errors) {
    const throwOnInvalid = !inTemplate;
    pos++;
    const res = (ch2) => ({
        pos,
        ch: ch2,
        lineStart,
        curLine,
    });
    
    const ch = input.charCodeAt(pos++);
    
    switch(ch) {
    case 110:
        return res('\n');
    
    case 114:
        return res('\r');
    
    case 120: {
        let code2;
        
        ({
            code: code2,
            pos,
        } = readHexChar2(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
        return res(code2 === null ? null : String.fromCharCode(code2));
    }
    
    case 117: {
        let code2;
        
        ({
            code: code2,
            pos,
        } = readCodePoint2(input, pos, lineStart, curLine, throwOnInvalid, errors));
        return res(code2 === null ? null : String.fromCodePoint(code2));
    }
    
    case 116:
        return res('	');
    
    case 98:
        return res('\b');
    
    case 118:
        return res('\v');
    
    case 102:
        return res('\f');
    
    case 13:
        if (input.charCodeAt(pos) === 10) {
            ++pos;
        }
    
    case 10:
        lineStart = pos;
        ++curLine;
    
    case 8232:    
    case 8233:
        return res('');
    
    case 56:    
    case 57:
        if (inTemplate) {
            return res(null);
        } else {
            errors.strictNumericEscape(pos - 1, lineStart, curLine);
        }
    
    default:
        if (ch >= 48 && ch <= 55) {
            const startPos = pos - 1;
            const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
            let octalStr = match[0];
            let octal = parseInt(octalStr, 8);
            
            if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
            }
            
            pos += octalStr.length - 1;
            const next = input.charCodeAt(pos);
            
            if (octalStr !== '0' || next === 56 || next === 57) {
                if (inTemplate) {
                    return res(null);
                } else {
                    errors.strictNumericEscape(startPos, lineStart, curLine);
                }
            }
            
            return res(String.fromCharCode(octal));
        }
        
        return res(String.fromCharCode(ch));
    }
}

function readHexChar2(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
    const initialPos = pos;
    let n2;
    
    ({n: n2, pos} = readInt2(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
    
    if (n2 === null) {
        if (throwOnInvalid) {
            errors.invalidEscapeSequence(initialPos, lineStart, curLine);
        } else {
            pos = initialPos - 1;
        }
    }
    
    return {
        code: n2,
        pos,
    };
}

function readInt2(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
    const start = pos;
    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings2.hex : forbiddenNumericSeparatorSiblings2.decBinOct;
    const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling2.hex : radix === 10 ? isAllowedNumericSeparatorSibling2.dec : radix === 8 ? isAllowedNumericSeparatorSibling2.oct : isAllowedNumericSeparatorSibling2.bin;
    let invalid = false;
    let total = 0;
    
    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        const code2 = input.charCodeAt(pos);
        let val;
        
        if (code2 === 95 && allowNumSeparator !== 'bail') {
            const prev = input.charCodeAt(pos - 1);
            const next = input.charCodeAt(pos + 1);
            
            if (!allowNumSeparator) {
                if (bailOnError)
                    return {
                        n: null,
                        pos,
                    };
                
                errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
            } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
                if (bailOnError)
                    return {
                        n: null,
                        pos,
                    };
                
                errors.unexpectedNumericSeparator(pos, lineStart, curLine);
            }
            
            ++pos;
            continue;
        }
        
        if (code2 >= 97) {
            val = code2 - 97 + 10;
        } else if (code2 >= 65) {
            val = code2 - 65 + 10;
        } else if (_isDigit2(code2)) {
            val = code2 - 48;
        } else {
            val = Infinity;
        }
        
        if (val >= radix) {
            if (val <= 9 && bailOnError) {
                return {
                    n: null,
                    pos,
                };
            } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
                val = 0;
            } else if (forceLen) {
                val = 0;
                invalid = true;
            } else {
                break;
            }

        }
        
        ++pos;
        total = total * radix + val;
    }
    
    if (pos === start || len != null && pos - start !== len || invalid) {
        return {
            n: null,
            pos,
        };
    }
    
    return {
        n: total,
        pos,
    };
}

function readCodePoint2(input, pos, lineStart, curLine, throwOnInvalid, errors) {
    const ch = input.charCodeAt(pos);
    let code2;
    
    if (ch === 123) {
        ++pos;
        ({
            code: code2,
            pos,
        } = readHexChar2(input, pos, lineStart, curLine, input.indexOf('}', pos) - pos, true, throwOnInvalid, errors));
        ++pos;
        
        if (code2 !== null && code2 > 1114111) {
            if (throwOnInvalid) {
                errors.invalidCodePoint(pos, lineStart, curLine);
            } else {
                return {
                    code: null,
                    pos,
                };
            }
        }
    } else {
        ({
            code: code2,
            pos,
        } = readHexChar2(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
    }
    
    return {
        code: code2,
        pos,
    };
}

function buildPosition(pos, lineStart, curLine) {
    return new Position(curLine, pos - lineStart, pos);
}

var VALID_REGEX_FLAGS = /* @__PURE__ */new Set([
    103,
    109,
    115,
    105,
    121,
    117,
    100,
    118,
]);

var Token = class {
    constructor(state) {
        const startIndex = state.startIndex || 0;
        
        this.type = state.type;
        this.value = state.value;
        this.start = startIndex + state.start;
        this.end = startIndex + state.end;
        this.loc = new SourceLocation(state.startLoc, state.endLoc);
    }
};

var Tokenizer = class extends CommentsParser {
    constructor(options, input) {
        super();
        __publicField(this, 'isLookahead');
        __publicField(this, 'tokens', []);
        __publicField(this, 'errorHandlers_readInt', {
            invalidDigit: (pos, lineStart, curLine, radix) => {
                if (!(this.optionFlags & 2048))
                    return false;
                
                this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {
                    radix,
                });
                return true;
            },
            numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
            unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator),
        });
        __publicField(this, 'errorHandlers_readCodePoint', Object.assign({}, this.errorHandlers_readInt, {
            invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
            invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint),
        }));
        __publicField(this, 'errorHandlers_readStringContents_string', Object.assign({}, this.errorHandlers_readCodePoint, {
            strictNumericEscape: (pos, lineStart, curLine) => {
                this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));
            },
            unterminated: (pos, lineStart, curLine) => {
                throw this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));
            },
        }));
        __publicField(this, 'errorHandlers_readStringContents_template', Object.assign({}, this.errorHandlers_readCodePoint, {
            strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
            unterminated: (pos, lineStart, curLine) => {
                throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));
            },
        }));
        this.state = new State$2();
        this.state.init(options);
        this.input = input;
        this.length = input.length;
        this.comments = [];
        this.isLookahead = false;
    }
    
    pushToken(token) {
        this.tokens.length = this.state.tokensLength;
        this.tokens.push(token);
        ++this.state.tokensLength;
    }
    
    next() {
        this.checkKeywordEscapes();
        
        if (this.optionFlags & 256) {
            this.pushToken(new Token(this.state));
        }
        
        this.state.lastTokEndLoc = this.state.endLoc;
        this.state.lastTokStartLoc = this.state.startLoc;
        this.nextToken();
    }
    
    eat(type) {
        if (this.match(type)) {
            this.next();
            return true;
        } else {
            return false;
        }
    }
    
    match(type) {
        return this.state.type === type;
    }
    
    createLookaheadState(state) {
        return {
            pos: state.pos,
            value: null,
            type: state.type,
            start: state.start,
            end: state.end,
            context: [this.curContext()],
            inType: state.inType,
            startLoc: state.startLoc,
            lastTokEndLoc: state.lastTokEndLoc,
            curLine: state.curLine,
            lineStart: state.lineStart,
            curPosition: state.curPosition,
        };
    }
    
    lookahead() {
        const old = this.state;
        
        this.state = this.createLookaheadState(old);
        this.isLookahead = true;
        this.nextToken();
        this.isLookahead = false;
        const curr = this.state;
        
        this.state = old;
        return curr;
    }
    
    nextTokenStart() {
        return this.nextTokenStartSince(this.state.pos);
    }
    
    nextTokenStartSince(pos) {
        skipWhiteSpace.lastIndex = pos;
        return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
    }
    
    lookaheadCharCode() {
        return this.lookaheadCharCodeSince(this.state.pos);
    }
    
    lookaheadCharCodeSince(pos) {
        return this.input.charCodeAt(this.nextTokenStartSince(pos));
    }
    
    nextTokenInLineStart() {
        return this.nextTokenInLineStartSince(this.state.pos);
    }
    
    nextTokenInLineStartSince(pos) {
        skipWhiteSpaceInLine.lastIndex = pos;
        return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
    }
    
    lookaheadInLineCharCode() {
        return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    
    codePointAtPos(pos) {
        let cp = this.input.charCodeAt(pos);
        
        if ((cp & 64512) === 55296 && ++pos < this.input.length) {
            const trail = this.input.charCodeAt(pos);
            
            if ((trail & 64512) === 56320) {
                cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
            }
        }
        
        return cp;
    }
    
    setStrict(strict) {
        this.state.strict = strict;
        
        if (strict) {
            this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at));
            this.state.strictErrors.clear();
        }
    }
    
    curContext() {
        return this.state.context[this.state.context.length - 1];
    }
    
    nextToken() {
        this.skipSpace();
        this.state.start = this.state.pos;
        
        if (!this.isLookahead)
            this.state.startLoc = this.state.curPosition();
        
        if (this.state.pos >= this.length) {
            this.finishToken(140);
            return;
        }
        
        this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    
    skipBlockComment(commentEnd) {
        let startLoc;
        
        if (!this.isLookahead)
            startLoc = this.state.curPosition();
        
        const start = this.state.pos;
        const end = this.input.indexOf(commentEnd, start + 2);
        
        if (end === -1) {
            throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
        }
        
        this.state.pos = end + commentEnd.length;
        lineBreakG.lastIndex = start + 2;
        while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
            ++this.state.curLine;
            this.state.lineStart = lineBreakG.lastIndex;
        }
        
        if (this.isLookahead)
            return;
        
        const comment = {
            type: 'CommentBlock',
            value: this.input.slice(start + 2, end),
            start: this.sourceToOffsetPos(start),
            end: this.sourceToOffsetPos(end + commentEnd.length),
            loc: new SourceLocation(startLoc, this.state.curPosition()),
        };
        
        if (this.optionFlags & 256)
            this.pushToken(comment);
        
        return comment;
    }
    
    skipLineComment(startSkip) {
        const start = this.state.pos;
        let startLoc;
        
        if (!this.isLookahead)
            startLoc = this.state.curPosition();
        
        let ch = this.input.charCodeAt(this.state.pos += startSkip);
        
        if (this.state.pos < this.length) {
            while (!isNewLine$1(ch) && ++this.state.pos < this.length) {
                ch = this.input.charCodeAt(this.state.pos);
            }
        }
        
        if (this.isLookahead)
            return;
        
        const end = this.state.pos;
        const value = this.input.slice(start + startSkip, end);
        
        const comment = {
            type: 'CommentLine',
            value,
            start: this.sourceToOffsetPos(start),
            end: this.sourceToOffsetPos(end),
            loc: new SourceLocation(startLoc, this.state.curPosition()),
        };
        
        if (this.optionFlags & 256)
            this.pushToken(comment);
        
        return comment;
    }
    
    skipSpace() {
        const spaceStart = this.state.pos;
        const comments = this.optionFlags & 4096 ? [] : null;
        
        loop:         while (this.state.pos < this.length) {
            const ch = this.input.charCodeAt(this.state.pos);
            
            switch(ch) {
            case 32:            
            case 160:            
            case 9:
                ++this.state.pos;
                break;
            
            case 13:
                if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                    ++this.state.pos;
                }
            
            case 10:            
            case 8232:            
            case 8233:
                ++this.state.pos;
                ++this.state.curLine;
                this.state.lineStart = this.state.pos;
                break;
            
            case 47:
                switch(this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                    const comment = this.skipBlockComment('*/');
                    
                    if (comment !== void 0) {
                        this.addComment(comment);
                        comments?.push(comment);
                    }
                    
                    break;
                }
                
                case 47: {
                    const comment = this.skipLineComment(2);
                    
                    if (comment !== void 0) {
                        this.addComment(comment);
                        comments?.push(comment);
                    }
                    
                    break;
                }
                
                default:
                    break loop;
                }
                
                break;
            
            default:
                if (isWhitespace(ch)) {
                    ++this.state.pos;
                } else if (ch === 45 && !this.inModule && this.optionFlags & 8192) {
                    const pos = this.state.pos;
                    
                    if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                        const comment = this.skipLineComment(3);
                        
                        if (comment !== void 0) {
                            this.addComment(comment);
                            comments?.push(comment);
                        }
                    } else {
                        break loop;
                    }
                } else if (ch === 60 && !this.inModule && this.optionFlags & 8192) {
                    const pos = this.state.pos;
                    
                    if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                        const comment = this.skipLineComment(4);
                        
                        if (comment !== void 0) {
                            this.addComment(comment);
                            comments?.push(comment);
                        }
                    } else {
                        break loop;
                    }
                } else {
                    break loop;
                }

            }
        }
        if (comments?.length > 0) {
            const end = this.state.pos;
            const commentWhitespace = {
                start: this.sourceToOffsetPos(spaceStart),
                end: this.sourceToOffsetPos(end),
                comments,
                leadingNode: null,
                trailingNode: null,
                containingNode: null,
            };
            
            this.state.commentStack.push(commentWhitespace);
        }
    }
    
    finishToken(type, val) {
        this.state.end = this.state.pos;
        this.state.endLoc = this.state.curPosition();
        const prevType = this.state.type;
        
        this.state.type = type;
        this.state.value = val;
        
        if (!this.isLookahead) {
            this.updateContext(prevType);
        }
    }
    
    replaceToken(type) {
        this.state.type = type;
        this.updateContext();
    }
    
    readToken_numberSign() {
        if (this.state.pos === 0 && this.readToken_interpreter()) {
            return;
        }
        
        const nextPos = this.state.pos + 1;
        const next = this.codePointAtPos(nextPos);
        
        if (next >= 48 && next <= 57) {
            throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());
        }
        
        if (isIdentifierStart2(next)) {
            ++this.state.pos;
            this.finishToken(139, this.readWord1(next));
        } else if (next === 92) {
            ++this.state.pos;
            this.finishToken(139, this.readWord1());
        } else {
            this.finishOp(27, 1);
        }
    }
    
    readToken_dot() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        
        if (next >= 48 && next <= 57) {
            this.readNumber(true);
            return;
        }
        
        if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
            this.state.pos += 3;
            this.finishToken(21);
        } else {
            ++this.state.pos;
            this.finishToken(16);
        }
    }
    
    readToken_slash() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        
        if (next === 61) {
            this.finishOp(31, 2);
        } else {
            this.finishOp(56, 1);
        }
    }
    
    readToken_interpreter() {
        if (this.state.pos !== 0 || this.length < 2)
            return false;
        
        let ch = this.input.charCodeAt(this.state.pos + 1);
        
        if (ch !== 33)
            return false;
        
        const start = this.state.pos;
        
        this.state.pos += 1;
        while (!isNewLine$1(ch) && ++this.state.pos < this.length) {
            ch = this.input.charCodeAt(this.state.pos);
        }
        
        const value = this.input.slice(start + 2, this.state.pos);
        this.finishToken(28, value);
        return true;
    }
    
    readToken_mult_modulo(code2) {
        let type = code2 === 42 ? 55 : 54;
        let width = 1;
        let next = this.input.charCodeAt(this.state.pos + 1);
        
        if (code2 === 42 && next === 42) {
            width++;
            next = this.input.charCodeAt(this.state.pos + 2);
            type = 57;
        }
        
        if (next === 61 && !this.state.inType) {
            width++;
            type = code2 === 37 ? 33 : 30;
        }
        
        this.finishOp(type, width);
    }
    
    readToken_pipe_amp(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        
        if (next === code2) {
            if (this.input.charCodeAt(this.state.pos + 2) === 61) {
                this.finishOp(30, 3);
            } else {
                this.finishOp(code2 === 124 ? 41 : 42, 2);
            }
            
            return;
        }
        
        if (code2 === 124) {
            if (next === 62) {
                this.finishOp(39, 2);
                return;
            }
        }
        
        if (next === 61) {
            this.finishOp(30, 2);
            return;
        }
        
        this.finishOp(code2 === 124 ? 43 : 45, 1);
    }
    
    readToken_caret() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        
        if (next === 61 && !this.state.inType) {
            this.finishOp(32, 2);
        } else if (next === 94 && this.hasPlugin(['pipelineOperator', {proposal: 'hack', topicToken: '^^'}])) {
            this.finishOp(37, 2);
            const lookaheadCh = this.input.codePointAt(this.state.pos);
            
            if (lookaheadCh === 94) {
                this.unexpected();
            }
        } else {
            this.finishOp(44, 1);
        }
    }
    
    readToken_atSign() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        
        if (next === 64 && this.hasPlugin(['pipelineOperator', {proposal: 'hack', topicToken: '@@'}])) {
            this.finishOp(38, 2);
        } else {
            this.finishOp(26, 1);
        }
    }
    
    readToken_plus_min(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        
        if (next === code2) {
            this.finishOp(34, 2);
            return;
        }
        
        if (next === 61) {
            this.finishOp(30, 2);
        } else {
            this.finishOp(53, 1);
        }
    }
    
    readToken_lt() {
        const {pos} = this.state;
        
        const next = this.input.charCodeAt(pos + 1);
        
        if (next === 60) {
            if (this.input.charCodeAt(pos + 2) === 61) {
                this.finishOp(30, 3);
                return;
            }
            
            this.finishOp(51, 2);
            return;
        }
        
        if (next === 61) {
            this.finishOp(49, 2);
            return;
        }
        
        this.finishOp(47, 1);
    }
    
    readToken_gt() {
        const {pos} = this.state;
        
        const next = this.input.charCodeAt(pos + 1);
        
        if (next === 62) {
            const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
            
            if (this.input.charCodeAt(pos + size) === 61) {
                this.finishOp(30, size + 1);
                return;
            }
            
            this.finishOp(52, size);
            return;
        }
        
        if (next === 61) {
            this.finishOp(49, 2);
            return;
        }
        
        this.finishOp(48, 1);
    }
    
    readToken_eq_excl(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        
        if (next === 61) {
            this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
            return;
        }
        
        if (code2 === 61 && next === 62) {
            this.state.pos += 2;
            this.finishToken(19);
            return;
        }
        
        this.finishOp(code2 === 61 ? 29 : 35, 1);
    }
    
    readToken_question() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        const next2 = this.input.charCodeAt(this.state.pos + 2);
        
        if (next === 63) {
            if (next2 === 61) {
                this.finishOp(30, 3);
            } else {
                this.finishOp(40, 2);
            }
        } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
            this.state.pos += 2;
            this.finishToken(18);
        } else {
            ++this.state.pos;
            this.finishToken(17);
        }
    }
    
    getTokenFromCode(code2) {
        switch(code2) {
        case 46:
            this.readToken_dot();
            return;
        
        case 40:
            ++this.state.pos;
            this.finishToken(10);
            return;
        
        case 41:
            ++this.state.pos;
            this.finishToken(11);
            return;
        
        case 59:
            ++this.state.pos;
            this.finishToken(13);
            return;
        
        case 44:
            ++this.state.pos;
            this.finishToken(12);
            return;
        
        case 91: {
            ++this.state.pos;
            this.finishToken(0);
        }
        
        return;
        
        case 93:
            ++this.state.pos;
            this.finishToken(3);
            return;
        
        case 123: {
            ++this.state.pos;
            this.finishToken(5);
        }
        
        return;
        
        case 125:
            ++this.state.pos;
            this.finishToken(8);
            return;
        
        case 58:
            if (this.hasPlugin('functionBind') && this.input.charCodeAt(this.state.pos + 1) === 58) {
                this.finishOp(15, 2);
            } else {
                ++this.state.pos;
                this.finishToken(14);
            }
            
            return;
        
        case 63:
            this.readToken_question();
            return;
        
        case 96:
            this.readTemplateToken();
            return;
        
        case 48: {
            const next = this.input.charCodeAt(this.state.pos + 1);
            
            if (next === 120 || next === 88) {
                this.readRadixNumber(16);
                return;
            }
            
            if (next === 111 || next === 79) {
                this.readRadixNumber(8);
                return;
            }
            
            if (next === 98 || next === 66) {
                this.readRadixNumber(2);
                return;
            }
        }
        
        case 49:        
        case 50:        
        case 51:        
        case 52:        
        case 53:        
        case 54:        
        case 55:        
        case 56:        
        case 57:
            this.readNumber(false);
            return;
        
        case 34:        
        case 39:
            this.readString(code2);
            return;
        
        case 47:
            this.readToken_slash();
            return;
        
        case 37:        
        case 42:
            this.readToken_mult_modulo(code2);
            return;
        
        case 124:        
        case 38:
            this.readToken_pipe_amp(code2);
            return;
        
        case 94:
            this.readToken_caret();
            return;
        
        case 43:        
        case 45:
            this.readToken_plus_min(code2);
            return;
        
        case 60:
            this.readToken_lt();
            return;
        
        case 62:
            this.readToken_gt();
            return;
        
        case 61:        
        case 33:
            this.readToken_eq_excl(code2);
            return;
        
        case 126:
            this.finishOp(36, 1);
            return;
        
        case 64:
            this.readToken_atSign();
            return;
        
        case 35:
            this.readToken_numberSign();
            return;
        
        case 92:
            this.readWord();
            return;
        
        default:
            if (isIdentifierStart2(code2)) {
                this.readWord(code2);
                return;
            }
        }
        
        throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {
            unexpected: String.fromCodePoint(code2),
        });
    }
    
    finishOp(type, size) {
        const str = this.input.slice(this.state.pos, this.state.pos + size);
        
        this.state.pos += size;
        this.finishToken(type, str);
    }
    
    readRegexp() {
        const startLoc = this.state.startLoc;
        const start = this.state.start + 1;
        let escaped, inClass;
        
        let {pos} = this.state;
        
        for (;; ++pos) {
            if (pos >= this.length) {
                throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
            }
            
            const ch = this.input.charCodeAt(pos);
            
            if (isNewLine$1(ch)) {
                throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
            }
            
            if (escaped) {
                escaped = false;
            } else {
                if (ch === 91) {
                    inClass = true;
                } else if (ch === 93 && inClass) {
                    inClass = false;
                } else if (ch === 47 && !inClass) {
                    break;
                }
                
                escaped = ch === 92;
            }
        }
        
        const content = this.input.slice(start, pos);
        ++pos;
        let mods = '';
        const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
        
        while (pos < this.length) {
            const cp = this.codePointAtPos(pos);
            const char = String.fromCharCode(cp);
            
            if (VALID_REGEX_FLAGS.has(cp)) {
                if (cp === 118) {
                    if (mods.includes('u')) {
                        this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
                    }
                } else if (cp === 117) {
                    if (mods.includes('v')) {
                        this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
                    }
                }
                
                if (mods.includes(char)) {
                    this.raise(Errors.DuplicateRegExpFlags, nextPos());
                }
            } else if (isIdentifierChar2(cp) || cp === 92) {
                this.raise(Errors.MalformedRegExpFlags, nextPos());
            } else {
                break;
            }
            
            ++pos;
            mods += char;
        }
        
        this.state.pos = pos;
        this.finishToken(138, {
            pattern: content,
            flags: mods,
        });
    }
    
    readInt(radix, len, forceLen = false, allowNumSeparator = true) {
        const {n: n2, pos} = readInt2(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);
        
        this.state.pos = pos;
        return n2;
    }
    
    readRadixNumber(radix) {
        const start = this.state.pos;
        const startLoc = this.state.curPosition();
        let isBigInt = false;
        
        this.state.pos += 2;
        const val = this.readInt(radix);
        
        if (val == null) {
            this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {
                radix,
            });
        }
        
        const next = this.input.charCodeAt(this.state.pos);
        
        if (next === 110) {
            ++this.state.pos;
            isBigInt = true;
        } else if (next === 109) {
            throw this.raise(Errors.InvalidDecimal, startLoc);
        }
        
        if (isIdentifierStart2(this.codePointAtPos(this.state.pos))) {
            throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
        }
        
        if (isBigInt) {
            const str = this
                .input
                .slice(start, this
                .state
                .pos)
                .replace(/[_n]/g, '');
            this.finishToken(136, str);
            return;
        }
        
        this.finishToken(135, val);
    }
    
    readNumber(startsWithDot) {
        const start = this.state.pos;
        const startLoc = this.state.curPosition();
        let isFloat = false;
        let isBigInt = false;
        let isOctal = false;
        
        if (!startsWithDot && this.readInt(10) === null) {
            this.raise(Errors.InvalidNumber, this.state.curPosition());
        }
        
        const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        
        if (hasLeadingZero) {
            const integer = this.input.slice(start, this.state.pos);
            this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);
            
            if (!this.state.strict) {
                const underscorePos = integer.indexOf('_');
                
                if (underscorePos > 0) {
                    this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(
                        startLoc,
                        underscorePos,
                    ));
                }
            }
            
            isOctal = hasLeadingZero && !/[89]/.test(integer);
        }
        
        let next = this.input.charCodeAt(this.state.pos);
        
        if (next === 46 && !isOctal) {
            ++this.state.pos;
            this.readInt(10);
            isFloat = true;
            next = this.input.charCodeAt(this.state.pos);
        }
        
        if ((next === 69 || next === 101) && !isOctal) {
            next = this.input.charCodeAt(++this.state.pos);
            
            if (next === 43 || next === 45) {
                ++this.state.pos;
            }
            
            if (this.readInt(10) === null) {
                this.raise(Errors.InvalidOrMissingExponent, startLoc);
            }
            
            isFloat = true;
            next = this.input.charCodeAt(this.state.pos);
        }
        
        if (next === 110) {
            if (isFloat || hasLeadingZero) {
                this.raise(Errors.InvalidBigIntLiteral, startLoc);
            }
            
            ++this.state.pos;
            isBigInt = true;
        }
        
        if (isIdentifierStart2(this.codePointAtPos(this.state.pos))) {
            throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
        }
        
        const str = this
            .input
            .slice(start, this
            .state
            .pos)
            .replace(/[_mn]/g, '');
        
        if (isBigInt) {
            this.finishToken(136, str);
            return;
        }
        
        const val = isOctal ? parseInt(str, 8) : parseFloat(str);
        this.finishToken(135, val);
    }
    
    readCodePoint(throwOnInvalid) {
        const {code: code2, pos} = readCodePoint2(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
        
        this.state.pos = pos;
        return code2;
    }
    
    readString(quote) {
        const {
            str,
            pos,
            curLine,
            lineStart,
        } = readStringContents2(quote === 34 ? 'double' : 'single', this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
        
        this.state.pos = pos + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        this.finishToken(134, str);
    }
    
    readTemplateContinuation() {
        if (!this.match(8)) {
            this.unexpected(null, 8);
        }
        
        this.state.pos--;
        this.readTemplateToken();
    }
    
    readTemplateToken() {
        const opening = this.input[this.state.pos];
        const {
            str,
            firstInvalidLoc,
            pos,
            curLine,
            lineStart,
        } = readStringContents2('template', this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
        
        this.state.pos = pos + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        
        if (firstInvalidLoc) {
            this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, this.sourceToOffsetPos(firstInvalidLoc.pos));
        }
        
        if (this.input.codePointAt(pos) === 96) {
            this.finishToken(24, firstInvalidLoc ? null : opening + str + '`');
        } else {
            this.state.pos++;
            this.finishToken(25, firstInvalidLoc ? null : opening + str + '${');
        }
    }
    
    recordStrictModeErrors(toParseError, at) {
        const index2 = at.index;
        
        if (this.state.strict && !this.state.strictErrors.has(index2)) {
            this.raise(toParseError, at);
        } else {
            this.state.strictErrors.set(index2, [toParseError, at]);
        }
    }
    
    readWord1(firstCode) {
        this.state.containsEsc = false;
        let word = '';
        const start = this.state.pos;
        let chunkStart = this.state.pos;
        
        if (firstCode !== void 0) {
            this.state.pos += firstCode <= 65535 ? 1 : 2;
        }
        
        while (this.state.pos < this.length) {
            const ch = this.codePointAtPos(this.state.pos);
            
            if (isIdentifierChar2(ch)) {
                this.state.pos += ch <= 65535 ? 1 : 2;
            } else if (ch === 92) {
                this.state.containsEsc = true;
                word += this.input.slice(chunkStart, this.state.pos);
                const escStart = this.state.curPosition();
                const identifierCheck = this.state.pos === start ? isIdentifierStart2 : isIdentifierChar2;
                
                if (this.input.charCodeAt(++this.state.pos) !== 117) {
                    this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());
                    chunkStart = this.state.pos - 1;
                    continue;
                }
                
                ++this.state.pos;
                const esc = this.readCodePoint(true);
                
                if (esc !== null) {
                    if (!identifierCheck(esc)) {
                        this.raise(Errors.EscapedCharNotAnIdentifier, escStart);
                    }
                    
                    word += String.fromCodePoint(esc);
                }
                
                chunkStart = this.state.pos;
            } else {
                break;
            }
        }
        
        return word + this.input.slice(chunkStart, this.state.pos);
    }
    
    readWord(firstCode) {
        const word = this.readWord1(firstCode);
        const type = keywords$1$1.get(word);
        
        if (type !== void 0) {
            this.finishToken(type, tokenLabelName(type));
        } else {
            this.finishToken(132, word);
        }
    }
    
    checkKeywordEscapes() {
        const {type} = this.state;
        
        if (tokenIsKeyword(type) && this.state.containsEsc) {
            this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {
                reservedWord: tokenLabelName(type),
            });
        }
    }
    
    raise(toParseError, at, details = {}) {
        const loc = at instanceof Position ? at : at.loc.start;
        const error = toParseError(loc, details);
        
        if (!(this.optionFlags & 2048))
            throw error;
        
        if (!this.isLookahead)
            this.state.errors.push(error);
        
        return error;
    }
    
    raiseOverwrite(toParseError, at, details = {}) {
        const loc = at instanceof Position ? at : at.loc.start;
        const pos = loc.index;
        const errors = this.state.errors;
        
        for (let i = errors.length - 1; i >= 0; i--) {
            const error = errors[i];
            
            if (error.loc.index === pos) {
                return errors[i] = toParseError(loc, details);
            }
            
            if (error.loc.index < pos)
                break;
        }
        
        return this.raise(toParseError, at, details);
    }
    
    updateContext(prevType) {}
    
    unexpected(loc, type) {
        throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {
            expected: type ? tokenLabelName(type) : null,
        });
    }
    
    expectPlugin(pluginName, loc) {
        if (this.hasPlugin(pluginName)) {
            return true;
        }
        
        throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {
            missingPlugin: [pluginName],
        });
    }
    
    expectOnePlugin(pluginNames) {
        if (!pluginNames.some((name) => this.hasPlugin(name))) {
            throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {
                missingPlugin: pluginNames,
            });
        }
    }
    
    errorBuilder(error) {
        return (pos, lineStart, curLine) => {
            this.raise(error, buildPosition(pos, lineStart, curLine));
        };
    }
};

var ClassScope = class {
    constructor() {
        __publicField(this, 'privateNames',         /* @__PURE__ */new Set());
        __publicField(this, 'loneAccessors',         /* @__PURE__ */new Map());
        __publicField(this, 'undefinedPrivateNames',         /* @__PURE__ */new Map());
    }
};

var ClassScopeHandler = class {
    constructor(parser) {
        __publicField(this, 'parser');
        __publicField(this, 'stack', []);
        __publicField(this, 'undefinedPrivateNames',         /* @__PURE__ */new Map());
        this.parser = parser;
    }
    
    current() {
        return this.stack[this.stack.length - 1];
    }
    
    enter() {
        this.stack.push(new ClassScope());
    }
    
    exit() {
        const oldClassScope = this.stack.pop();
        const current = this.current();
        
        for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
            if (current) {
                if (!current.undefinedPrivateNames.has(name)) {
                    current.undefinedPrivateNames.set(name, loc);
                }
            } else {
                this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
                    identifierName: name,
                });
            }
        }
    }
    
    declarePrivateName(name, elementType, loc) {
        const {
            privateNames,
            loneAccessors,
            undefinedPrivateNames,
        } = this.current();
        
        let redefined = privateNames.has(name);
        
        if (elementType & 3) {
            const accessor = redefined && loneAccessors.get(name);
            
            if (accessor) {
                const oldStatic = accessor & 4;
                const newStatic = elementType & 4;
                const oldKind = accessor & 3;
                const newKind = elementType & 3;
                
                redefined = oldKind === newKind || oldStatic !== newStatic;
                
                if (!redefined)
                    loneAccessors.delete(name);
            } else if (!redefined) {
                loneAccessors.set(name, elementType);
            }
        }
        
        if (redefined) {
            this.parser.raise(Errors.PrivateNameRedeclaration, loc, {
                identifierName: name,
            });
        }
        
        privateNames.add(name);
        undefinedPrivateNames.delete(name);
    }
    
    usePrivateName(name, loc) {
        let classScope;
        
        for (classScope of this.stack) {
            if (classScope.privateNames.has(name))
                return;
        }
        
        if (classScope) {
            classScope.undefinedPrivateNames.set(name, loc);
        } else {
            this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
                identifierName: name,
            });
        }
    }
};

var ExpressionScope = class {
    constructor(type = 0) {
        this.type = type;
    }
    
    canBeArrowParameterDeclaration() {
        return this.type === 2 || this.type === 1;
    }
    
    isCertainlyParameterDeclaration() {
        return this.type === 3;
    }
};

var ArrowHeadParsingScope = class extends ExpressionScope {
    constructor(type) {
        super(type);
        __publicField(this, 'declarationErrors',         /* @__PURE__ */new Map());
    }
    
    recordDeclarationError(ParsingErrorClass, at) {
        const index2 = at.index;
        this.declarationErrors.set(index2, [ParsingErrorClass, at]);
    }
    
    clearDeclarationError(index2) {
        this.declarationErrors.delete(index2);
    }
    
    iterateErrors(iterator) {
        this.declarationErrors.forEach(iterator);
    }
};

var ExpressionScopeHandler = class {
    constructor(parser) {
        __publicField(this, 'parser');
        __publicField(this, 'stack', [new ExpressionScope()]);
        this.parser = parser;
    }
    
    enter(scope2) {
        this.stack.push(scope2);
    }
    
    exit() {
        this.stack.pop();
    }
    
    recordParameterInitializerError(toParseError, node) {
        const origin = node.loc.start;
        const {stack} = this;
        
        let i = stack.length - 1;
        let scope2 = stack[i];
        
        while (!scope2.isCertainlyParameterDeclaration()) {
            if (scope2.canBeArrowParameterDeclaration()) {
                scope2.recordDeclarationError(toParseError, origin);
            } else {
                return;
            }
            
            scope2 = stack[--i];
        }
        
        this.parser.raise(toParseError, origin);
    }
    
    recordArrowParameterBindingError(error, node) {
        const {stack} = this;
        
        const scope2 = stack[stack.length - 1];
        const origin = node.loc.start;
        
        if (scope2.isCertainlyParameterDeclaration()) {
            this.parser.raise(error, origin);
        } else if (scope2.canBeArrowParameterDeclaration()) {
            scope2.recordDeclarationError(error, origin);
        } else {
            return;
        }
    }
    
    recordAsyncArrowParametersError(at) {
        const {stack} = this;
        
        let i = stack.length - 1;
        let scope2 = stack[i];
        
        while (scope2.canBeArrowParameterDeclaration()) {
            if (scope2.type === 2) {
                scope2.recordDeclarationError(Errors.AwaitBindingIdentifier, at);
            }
            
            scope2 = stack[--i];
        }
    }
    
    validateAsPattern() {
        const {stack} = this;
        
        const currentScope = stack[stack.length - 1];
        
        if (!currentScope.canBeArrowParameterDeclaration())
            return;
        
        currentScope.iterateErrors(([toParseError, loc]) => {
            this.parser.raise(toParseError, loc);
            let i = stack.length - 2;
            let scope2 = stack[i];
            
            while (scope2.canBeArrowParameterDeclaration()) {
                scope2.clearDeclarationError(loc.index);
                scope2 = stack[--i];
            }
        });
    }
};

function newParameterDeclarationScope() {
    return new ExpressionScope(3);
}

function newArrowHeadScope() {
    return new ArrowHeadParsingScope(1);
}

function newAsyncArrowScope() {
    return new ArrowHeadParsingScope(2);
}

function newExpressionScope() {
    return new ExpressionScope();
}

var UtilParser = class extends Tokenizer {
    addExtra(node, key, value, enumerable = true) {
        if (!node)
            return;
        
        let {extra} = node;
        
        if (extra == null) {
            extra = {};
            node.extra = extra;
        }
        
        if (enumerable) {
            extra[key] = value;
        } else {
            Object.defineProperty(extra, key, {
                enumerable,
                value,
            });
        }
    }
    
    isContextual(token) {
        return this.state.type === token && !this.state.containsEsc;
    }
    
    isUnparsedContextual(nameStart, name) {
        if (this.input.startsWith(name, nameStart)) {
            const nextCh = this.input.charCodeAt(nameStart + name.length);
            return !(isIdentifierChar2(nextCh) || (nextCh & 64512) === 55296);
        }
        
        return false;
    }
    
    isLookaheadContextual(name) {
        const next = this.nextTokenStart();
        return this.isUnparsedContextual(next, name);
    }
    
    eatContextual(token) {
        if (this.isContextual(token)) {
            this.next();
            return true;
        }
        
        return false;
    }
    
    expectContextual(token, toParseError) {
        if (!this.eatContextual(token)) {
            if (toParseError != null) {
                throw this.raise(toParseError, this.state.startLoc);
            }
            
            this.unexpected(null, token);
        }
    }
    
    canInsertSemicolon() {
        return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
    }
    
    hasPrecedingLineBreak() {
        return hasNewLine(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
    }
    
    hasFollowingLineBreak() {
        return hasNewLine(this.input, this.state.end, this.nextTokenStart());
    }
    
    isLineTerminator() {
        return this.eat(13) || this.canInsertSemicolon();
    }
    
    semicolon(allowAsi = true) {
        if (allowAsi ? this.isLineTerminator() : this.eat(13))
            return;
        
        this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);
    }
    
    expect(type, loc) {
        if (!this.eat(type)) {
            this.unexpected(loc, type);
        }
    }
    
    tryParse(fn, oldState = this.state.clone()) {
        const abortSignal = {
            node: null,
        };
        
        try {
            const node = fn((node2 = null) => {
                abortSignal.node = node2;
                throw abortSignal;
            });
            
            if (this.state.errors.length > oldState.errors.length) {
                const failState = this.state;
                
                this.state = oldState;
                this.state.tokensLength = failState.tokensLength;
                return {
                    node,
                    error: failState.errors[oldState.errors.length],
                    thrown: false,
                    aborted: false,
                    failState,
                };
            }
            
            return {
                node,
                error: null,
                thrown: false,
                aborted: false,
                failState: null,
            };
        } catch(error) {
            const failState = this.state;
            
            this.state = oldState;
            
            if (error instanceof SyntaxError) {
                return {
                    node: null,
                    error,
                    thrown: true,
                    aborted: false,
                    failState,
                };
            }
            
            if (error === abortSignal) {
                return {
                    node: abortSignal.node,
                    error: null,
                    thrown: false,
                    aborted: true,
                    failState,
                };
            }
            
            throw error;
        }
    }
    
    checkExpressionErrors(refExpressionErrors, andThrow) {
        if (!refExpressionErrors)
            return false;
        
        const {
            shorthandAssignLoc,
            doubleProtoLoc,
            privateKeyLoc,
            optionalParametersLoc,
            voidPatternLoc,
        } = refExpressionErrors;
        
        const hasErrors = !!shorthandAssignLoc
            || !!doubleProtoLoc
            || !!optionalParametersLoc
            || !!privateKeyLoc
            || !!voidPatternLoc;
        
        if (!andThrow) {
            return hasErrors;
        }
        
        if (shorthandAssignLoc != null) {
            this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
        }
        
        if (doubleProtoLoc != null) {
            this.raise(Errors.DuplicateProto, doubleProtoLoc);
        }
        
        if (privateKeyLoc != null) {
            this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
        }
        
        if (optionalParametersLoc != null) {
            this.unexpected(optionalParametersLoc);
        }
        
        if (voidPatternLoc != null) {
            this.raise(Errors.InvalidCoverDiscardElement, voidPatternLoc);
        }
    }
    
    isLiteralPropertyName() {
        return tokenIsLiteralPropertyName(this.state.type);
    }
    
    isPrivateName(node) {
        return node.type === 'PrivateName';
    }
    
    getPrivateNameSV(node) {
        return node.id.name;
    }
    
    hasPropertyAsPrivateName(node) {
        return (node.type === 'MemberExpression' || node.type === 'OptionalMemberExpression') && this.isPrivateName(node.property);
    }
    
    isObjectProperty(node) {
        return node.type === 'ObjectProperty';
    }
    
    isObjectMethod(node) {
        return node.type === 'ObjectMethod';
    }
    
    initializeScopes(inModule = this.options.sourceType === 'module') {
        const oldLabels = this.state.labels;
        
        this.state.labels = [];
        const oldExportedIdentifiers = this.exportedIdentifiers;
        
        this.exportedIdentifiers =         /* @__PURE__ */new Set();
        const oldInModule = this.inModule;
        
        this.inModule = inModule;
        const oldScope = this.scope;
        const ScopeHandler2 = this.getScopeHandler();
        
        this.scope = new ScopeHandler2(this, inModule);
        const oldProdParam = this.prodParam;
        
        this.prodParam = new ProductionParameterHandler();
        const oldClassScope = this.classScope;
        
        this.classScope = new ClassScopeHandler(this);
        const oldExpressionScope = this.expressionScope;
        
        this.expressionScope = new ExpressionScopeHandler(this);
        return () => {
            this.state.labels = oldLabels;
            this.exportedIdentifiers = oldExportedIdentifiers;
            this.inModule = oldInModule;
            this.scope = oldScope;
            this.prodParam = oldProdParam;
            this.classScope = oldClassScope;
            this.expressionScope = oldExpressionScope;
        };
    }
    
    enterInitialScopes() {
        let paramFlags = 0;
        
        if (this.inModule || this.optionFlags & 1) {
            paramFlags |= 2;
        }
        
        if (this.optionFlags & 32) {
            paramFlags |= 1;
        }
        
        const isCommonJS = !this.inModule && this.options.sourceType === 'commonjs';
        
        if (isCommonJS || this.optionFlags & 2) {
            paramFlags |= 4;
        }
        
        this.prodParam.enter(paramFlags);
        let scopeFlags = isCommonJS ? 514 : 1;
        
        if (this.optionFlags & 4) {
            scopeFlags |= 512;
        }
        
        this.scope.enter(scopeFlags);
    }
    
    checkDestructuringPrivate(refExpressionErrors) {
        const {privateKeyLoc} = refExpressionErrors;
        
        if (privateKeyLoc !== null) {
            this.expectPlugin('destructuringPrivate', privateKeyLoc);
        }
    }
};

var ExpressionErrors = class {
    constructor() {
        __publicField(this, 'shorthandAssignLoc', null);
        __publicField(this, 'doubleProtoLoc', null);
        __publicField(this, 'privateKeyLoc', null);
        __publicField(this, 'optionalParametersLoc', null);
        __publicField(this, 'voidPatternLoc', null);
    }
};

var Node$1 = class Node {
    constructor(parser, pos, loc) {
        __publicField(this, 'type', '');
        this.start = pos;
        this.end = 0;
        this.loc = new SourceLocation(loc);
        
        if (parser?.optionFlags & 128)
            this.range = [pos, 0];
        
        if (parser?.filename)
            this.loc.filename = parser.filename;
    }
};

var NodePrototype = Node$1.prototype;

var NodeUtils = class extends UtilParser {
    startNode() {
        const loc = this.state.startLoc;
        return new Node$1(this, loc.index, loc);
    }
    
    startNodeAt(loc) {
        return new Node$1(this, loc.index, loc);
    }
    
    startNodeAtNode(type) {
        return this.startNodeAt(type.loc.start);
    }
    
    finishNode(node, type) {
        return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
    }
    
    finishNodeAt(node, type, endLoc) {
        node.type = type;
        node.end = endLoc.index;
        node.loc.end = endLoc;
        
        if (this.optionFlags & 128)
            node.range[1] = endLoc.index;
        
        if (this.optionFlags & 4096) {
            this.processComment(node);
        }
        
        return node;
    }
    
    resetStartLocation(node, startLoc) {
        node.start = startLoc.index;
        node.loc.start = startLoc;
        
        if (this.optionFlags & 128)
            node.range[0] = startLoc.index;
    }
    
    resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
        node.end = endLoc.index;
        node.loc.end = endLoc;
        
        if (this.optionFlags & 128)
            node.range[1] = endLoc.index;
    }
    
    resetStartLocationFromNode(node, locationNode) {
        this.resetStartLocation(node, locationNode.loc.start);
    }
    
    castNodeTo(node, type) {
        node.type = type;
        return node;
    }
    
    cloneIdentifier(node) {
        const {
            type,
            start,
            end,
            loc,
            range,
            name,
        } = node;
        
        const cloned = Object.create(NodePrototype);
        
        cloned.type = type;
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range;
        cloned.name = name;
        
        if (node.extra)
            cloned.extra = node.extra;
        
        return cloned;
    }
    
    cloneStringLiteral(node) {
        const {
            type,
            start,
            end,
            loc,
            range,
            extra,
        } = node;
        
        const cloned = Object.create(NodePrototype);
        
        cloned.type = type;
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range;
        cloned.extra = extra;
        cloned.value = node.value;
        return cloned;
    }
};

var unwrapParenthesizedExpression = (node) => {
    return node.type === 'ParenthesizedExpression' ? unwrapParenthesizedExpression(node.expression) : node;
};

var LValParser = class extends NodeUtils {
    toAssignable(node, isLHS = false) {
        let parenthesized = void 0;
        
        if (node.type === 'ParenthesizedExpression' || node.extra?.parenthesized) {
            parenthesized = unwrapParenthesizedExpression(node);
            
            if (isLHS) {
                if (parenthesized.type === 'Identifier') {
                    this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);
                } else if (parenthesized.type !== 'MemberExpression' && !this.isOptionalMemberExpression(parenthesized)) {
                    this.raise(Errors.InvalidParenthesizedAssignment, node);
                }
            } else {
                this.raise(Errors.InvalidParenthesizedAssignment, node);
            }
        }
        
        switch(node.type) {
        case 'Identifier':        
        case 'ObjectPattern':        
        case 'ArrayPattern':        
        case 'AssignmentPattern':        
        case 'RestElement':        
        case 'VoidPattern':
            break;
        
        case 'ObjectExpression':
            this.castNodeTo(node, 'ObjectPattern');
            for (let i = 0, length = node.properties.length, last2 = length - 1; i < length; i++) {
                const prop = node.properties[i];
                const isLast = i === last2;
                this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
                
                if (isLast && prop.type === 'RestElement' && node.extra?.trailingCommaLoc) {
                    this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);
                }
            }
            
            break;
        
        case 'ObjectProperty': {
            const {key, value} = node;
            
            if (this.isPrivateName(key)) {
                this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
            }
            
            this.toAssignable(value, isLHS);
            break;
        }
        
        case 'SpreadElement': {
            throw new Error('Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable\'s caller.');
        }
        
        case 'ArrayExpression':
            this.castNodeTo(node, 'ArrayPattern');
            this.toAssignableList(node.elements, node.extra?.trailingCommaLoc, isLHS);
            break;
        
        case 'AssignmentExpression':
            if (node.operator !== '=') {
                this.raise(Errors.MissingEqInAssignment, node.left.loc.end);
            }
            
            this.castNodeTo(node, 'AssignmentPattern');
            delete node.operator;
            
            if (node.left.type === 'VoidPattern') {
                this.raise(Errors.VoidPatternInitializer, node.left);
            }
            
            this.toAssignable(node.left, isLHS);
            break;
        
        case 'ParenthesizedExpression':
            this.toAssignable(parenthesized, isLHS);
            break;
        }
    }
    
    toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === 'ObjectMethod') {
            this.raise(prop.kind === 'get' || prop.kind === 'set' ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);
        } else if (prop.type === 'SpreadElement') {
            this.castNodeTo(prop, 'RestElement');
            const arg = prop.argument;
            this.checkToRestConversion(arg, false);
            this.toAssignable(arg, isLHS);
            
            if (!isLast) {
                this.raise(Errors.RestTrailingComma, prop);
            }
        } else {
            this.toAssignable(prop, isLHS);
        }
    }
    
    toAssignableList(exprList, trailingCommaLoc, isLHS) {
        const end = exprList.length - 1;
        
        for (let i = 0; i <= end; i++) {
            const elt = exprList[i];
            
            if (!elt)
                continue;
            
            this.toAssignableListItem(exprList, i, isLHS);
            
            if (elt.type === 'RestElement') {
                if (i < end) {
                    this.raise(Errors.RestTrailingComma, elt);
                } else if (trailingCommaLoc) {
                    this.raise(Errors.RestTrailingComma, trailingCommaLoc);
                }
            }
        }
    }
    
    toAssignableListItem(exprList, index2, isLHS) {
        const node = exprList[index2];
        
        if (node.type === 'SpreadElement') {
            this.castNodeTo(node, 'RestElement');
            const arg = node.argument;
            this.checkToRestConversion(arg, true);
            this.toAssignable(arg, isLHS);
        } else {
            this.toAssignable(node, isLHS);
        }
    }
    
    isAssignable(node, isBinding3) {
        switch(node.type) {
        case 'Identifier':        
        case 'ObjectPattern':        
        case 'ArrayPattern':        
        case 'AssignmentPattern':        
        case 'RestElement':        
        case 'VoidPattern':
            return true;
        
        case 'ObjectExpression': {
            const last2 = node.properties.length - 1;
            
            return node.properties.every((prop, i) => {
                return prop.type !== 'ObjectMethod'
                    && (i === last2
                    || prop.type !== 'SpreadElement')
                    && this.isAssignable(prop);
            });
        }
        
        case 'ObjectProperty':
            return this.isAssignable(node.value);
        
        case 'SpreadElement':
            return this.isAssignable(node.argument);
        
        case 'ArrayExpression':
            return node.elements.every((element) => element === null || this.isAssignable(element));
        
        case 'AssignmentExpression':
            return node.operator === '=';
        
        case 'ParenthesizedExpression':
            return this.isAssignable(node.expression);
        
        case 'MemberExpression':        
        case 'OptionalMemberExpression':
            return !isBinding3;
        
        default:
            return false;
        }
    }
    
    toReferencedList(exprList, isParenthesizedExpr) {
        return exprList;
    }
    
    toReferencedListDeep(exprList, isParenthesizedExpr) {
        this.toReferencedList(exprList, isParenthesizedExpr);
        for (const expr of exprList) {
            if (expr?.type === 'ArrayExpression') {
                this.toReferencedListDeep(expr.elements);
            }
        }
    }
    
    parseSpread(refExpressionErrors) {
        const node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);
        return this.finishNode(node, 'SpreadElement');
    }
    
    parseRestBinding() {
        const node = this.startNode();
        this.next();
        const argument = this.parseBindingAtom();
        
        if (argument.type === 'VoidPattern') {
            this.raise(Errors.UnexpectedVoidPattern, argument);
        }
        
        node.argument = argument;
        return this.finishNode(node, 'RestElement');
    }
    
    parseBindingAtom() {
        switch(this.state.type) {
        case 0: {
            const node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(3, 93, 1);
            return this.finishNode(node, 'ArrayPattern');
        }
        
        case 5:
            return this.parseObjectLike(8, true);
        
        case 88:
            return this.parseVoidPattern(null);
        }
        
        return this.parseIdentifier();
    }
    
    parseBindingList(close, closeCharCode, flags) {
        const allowEmpty = flags & 1;
        const elts = [];
        let first = true;
        
        while (!this.eat(close)) {
            if (first) {
                first = false;
            } else {
                this.expect(12);
            }
            
            if (allowEmpty && this.match(12)) {
                elts.push(null);
            } else if (this.eat(close)) {
                break;
            } else if (this.match(21)) {
                let rest = this.parseRestBinding();
                
                if (flags & 2) {
                    rest = this.parseFunctionParamType(rest);
                }
                
                elts.push(rest);
                
                if (!this.checkCommaAfterRest(closeCharCode)) {
                    this.expect(close);
                    break;
                }
            } else {
                const decorators = [];
                
                if (flags & 2) {
                    if (this.match(26) && this.hasPlugin('decorators')) {
                        this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);
                    }
                    
                    while (this.match(26)) {
                        decorators.push(this.parseDecorator());
                    }
                }
                
                elts.push(this.parseBindingElement(flags, decorators));
            }

        }
        
        return elts;
    }
    
    parseBindingRestProperty(prop) {
        this.next();
        
        if (this.hasPlugin('discardBinding') && this.match(88)) {
            prop.argument = this.parseVoidPattern(null);
            this.raise(Errors.UnexpectedVoidPattern, prop.argument);
        } else {
            prop.argument = this.parseIdentifier();
        }
        
        this.checkCommaAfterRest(125);
        return this.finishNode(prop, 'RestElement');
    }
    
    parseBindingProperty() {
        const {type, startLoc} = this.state;
        
        if (type === 21) {
            return this.parseBindingRestProperty(this.startNode());
        }
        
        const prop = this.startNode();
        
        if (type === 139) {
            this.expectPlugin('destructuringPrivate', startLoc);
            this.classScope.usePrivateName(this.state.value, startLoc);
            prop.key = this.parsePrivateName();
        } else {
            this.parsePropertyName(prop);
        }
        
        prop.method = false;
        return this.parseObjPropValue(prop, startLoc, false, false, true, false);
    }
    
    parseBindingElement(flags, decorators) {
        const left = this.parseMaybeDefault();
        
        if (flags & 2) {
            this.parseFunctionParamType(left);
        }
        
        if (decorators.length) {
            left.decorators = decorators;
            this.resetStartLocationFromNode(left, decorators[0]);
        }
        
        const elt = this.parseMaybeDefault(left.loc.start, left);
        
        return elt;
    }
    
    parseFunctionParamType(param) {
        return param;
    }
    
    parseMaybeDefault(startLoc, left) {
        startLoc ?? (startLoc = this.state.startLoc);
        left = left ?? this.parseBindingAtom();
        
        if (!this.eat(29))
            return left;
        
        const node = this.startNodeAt(startLoc);
        
        if (left.type === 'VoidPattern') {
            this.raise(Errors.VoidPatternInitializer, left);
        }
        
        node.left = left;
        node.right = this.parseMaybeAssignAllowIn();
        return this.finishNode(node, 'AssignmentPattern');
    }
    
    isValidLVal(type, isUnparenthesizedInAssign, binding) {
        switch(type) {
        case 'AssignmentPattern':
            return 'left';
        
        case 'RestElement':
            return 'argument';
        
        case 'ObjectProperty':
            return 'value';
        
        case 'ParenthesizedExpression':
            return 'expression';
        
        case 'ArrayPattern':
            return 'elements';
        
        case 'ObjectPattern':
            return 'properties';
        
        case 'VoidPattern':
            return true;
        }
        
        return false;
    }
    
    isOptionalMemberExpression(expression2) {
        return expression2.type === 'OptionalMemberExpression';
    }
    
    checkLVal(expression2, ancestor, binding = 64, checkClashes = false, strictModeChanged = false, hasParenthesizedAncestor = false) {
        const type = expression2.type;
        
        if (this.isObjectMethod(expression2))
            return;
        
        const isOptionalMemberExpression3 = this.isOptionalMemberExpression(expression2);
        
        if (isOptionalMemberExpression3 || type === 'MemberExpression') {
            if (isOptionalMemberExpression3) {
                this.expectPlugin('optionalChainingAssign', expression2.loc.start);
                
                if (ancestor.type !== 'AssignmentExpression') {
                    this.raise(Errors.InvalidLhsOptionalChaining, expression2, {
                        ancestor,
                    });
                }
            }
            
            if (binding !== 64) {
                this.raise(Errors.InvalidPropertyBindingPattern, expression2);
            }
            
            return;
        }
        
        if (type === 'Identifier') {
            this.checkIdentifier(expression2, binding, strictModeChanged);
            const {name} = expression2;
            
            if (checkClashes) {
                if (checkClashes.has(name)) {
                    this.raise(Errors.ParamDupe, expression2);
                } else {
                    checkClashes.add(name);
                }
            }
            
            return;
        } else if (type === 'VoidPattern' && ancestor.type === 'CatchClause') {
            this.raise(Errors.VoidPatternCatchClauseParam, expression2);
        }
        
        const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || expression2.extra?.parenthesized) && ancestor.type === 'AssignmentExpression', binding);
        
        if (validity === true)
            return;
        
        if (validity === false) {
            const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
            
            this.raise(ParseErrorClass, expression2, {
                ancestor,
            });
            return;
        }
        
        let key, isParenthesizedExpression3;
        
        if (typeof validity === 'string') {
            key = validity;
            isParenthesizedExpression3 = type === 'ParenthesizedExpression';
        } else {
            [key, isParenthesizedExpression3] = validity;
        }
        
        const nextAncestor = type === 'ArrayPattern' || type === 'ObjectPattern' ? {
            type,
        } : ancestor;
        
        const val = expression2[key];
        
        if (Array.isArray(val)) {
            for (const child of val) {
                if (child) {
                    this.checkLVal(child, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression3);
                }
            }
        } else if (val) {
            this.checkLVal(val, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression3);
        }
    }
    
    checkIdentifier(at, bindingType, strictModeChanged = false) {
        if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
            if (bindingType === 64) {
                this.raise(Errors.StrictEvalArguments, at, {
                    referenceName: at.name,
                });
            } else {
                this.raise(Errors.StrictEvalArgumentsBinding, at, {
                    bindingName: at.name,
                });
            }
        }
        
        if (bindingType & 8192 && at.name === 'let') {
            this.raise(Errors.LetInLexicalBinding, at);
        }
        
        if (!(bindingType & 64)) {
            this.declareNameFromIdentifier(at, bindingType);
        }
    }
    
    declareNameFromIdentifier(identifier4, binding) {
        this.scope.declareName(identifier4.name, binding, identifier4.loc.start);
    }
    
    checkToRestConversion(node, allowPattern) {
        switch(node.type) {
        case 'ParenthesizedExpression':
            this.checkToRestConversion(node.expression, allowPattern);
            break;
        
        case 'Identifier':        
        case 'MemberExpression':
            break;
        
        case 'ArrayExpression':        
        case 'ObjectExpression':
            if (allowPattern)
                break;
        
        default:
            this.raise(Errors.InvalidRestAssignmentPattern, node);
        }
    }
    
    checkCommaAfterRest(close) {
        if (!this.match(12)) {
            return false;
        }
        
        this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);
        
        return true;
    }
};

function nonNull(x) {
    if (x == null) {
        throw new Error(`Unexpected ${x} value.`);
    }
    
    return x;
}

function assert2(x) {
    if (!x) {
        throw new Error('Assert fail');
    }
}

var TSErrors = ParseErrorEnum`typescript`({
    AbstractMethodHasImplementation: ({methodName}) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
    AbstractPropertyHasInitializer: ({propertyName}) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
    AccessorCannotBeOptional: 'An \'accessor\' property cannot be declared optional.',
    AccessorCannotDeclareThisParameter: '\'get\' and \'set\' accessors cannot declare \'this\' parameters.',
    AccessorCannotHaveTypeParameters: 'An accessor cannot have type parameters.',
    ClassMethodHasDeclare: 'Class methods cannot have the \'declare\' modifier.',
    ClassMethodHasReadonly: 'Class methods cannot have the \'readonly\' modifier.',
    ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: 'A \'const\' initializer in an ambient context must be a string or numeric literal or literal enum reference.',
    ConstructorHasTypeParameters: 'Type parameters cannot appear on a constructor declaration.',
    DeclareAccessor: ({kind}) => `'declare' is not allowed in ${kind}ters.`,
    DeclareClassFieldHasInitializer: 'Initializers are not allowed in ambient contexts.',
    DeclareFunctionHasImplementation: 'An implementation cannot be declared in ambient contexts.',
    DuplicateAccessibilityModifier: ({modifier}) => `Accessibility modifier already seen: '${modifier}'.`,
    DuplicateModifier: ({modifier}) => `Duplicate modifier: '${modifier}'.`,
    EmptyHeritageClauseType: ({token}) => `'${token}' list cannot be empty.`,
    EmptyTypeArguments: 'Type argument list cannot be empty.',
    EmptyTypeParameters: 'Type parameter list cannot be empty.',
    ExpectedAmbientAfterExportDeclare: '\'export declare\' must be followed by an ambient declaration.',
    ImportAliasHasImportType: 'An import alias can not use \'import type\'.',
    ImportReflectionHasImportType: 'An `import module` declaration can not use `type` modifier',
    IncompatibleModifiers: ({modifiers}) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
    IndexSignatureHasAbstract: 'Index signatures cannot have the \'abstract\' modifier.',
    IndexSignatureHasAccessibility: ({modifier}) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
    IndexSignatureHasDeclare: 'Index signatures cannot have the \'declare\' modifier.',
    IndexSignatureHasOverride: '\'override\' modifier cannot appear on an index signature.',
    IndexSignatureHasStatic: 'Index signatures cannot have the \'static\' modifier.',
    InitializerNotAllowedInAmbientContext: 'Initializers are not allowed in ambient contexts.',
    InvalidHeritageClauseType: ({token}) => `'${token}' list can only include identifiers or qualified-names with optional type arguments.`,
    InvalidModifierOnAwaitUsingDeclaration: (modifier) => `'${modifier}' modifier cannot appear on an await using declaration.`,
    InvalidModifierOnTypeMember: ({modifier}) => `'${modifier}' modifier cannot appear on a type member.`,
    InvalidModifierOnTypeParameter: ({modifier}) => `'${modifier}' modifier cannot appear on a type parameter.`,
    InvalidModifierOnTypeParameterPositions: ({modifier}) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
    InvalidModifierOnUsingDeclaration: (modifier) => `'${modifier}' modifier cannot appear on a using declaration.`,
    InvalidModifiersOrder: ({orderedModifiers}) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
    InvalidPropertyAccessAfterInstantiationExpression: 'Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.',
    InvalidTupleMemberLabel: 'Tuple members must be labeled with a simple identifier.',
    MissingInterfaceName: '\'interface\' declarations must be followed by an identifier.',
    NonAbstractClassHasAbstractMethod: 'Abstract methods can only appear within an abstract class.',
    NonClassMethodPropertyHasAbstractModifier: '\'abstract\' modifier can only appear on a class, method, or property declaration.',
    OptionalTypeBeforeRequired: 'A required element cannot follow an optional element.',
    OverrideNotInSubClass: 'This member cannot have an \'override\' modifier because its containing class does not extend another class.',
    PatternIsOptional: 'A binding pattern parameter cannot be optional in an implementation signature.',
    PrivateElementHasAbstract: 'Private elements cannot have the \'abstract\' modifier.',
    PrivateElementHasAccessibility: ({modifier}) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
    ReadonlyForMethodSignature: '\'readonly\' modifier can only appear on a property declaration or index signature.',
    ReservedArrowTypeParam: 'This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.',
    ReservedTypeAssertion: 'This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.',
    SetAccessorCannotHaveOptionalParameter: 'A \'set\' accessor cannot have an optional parameter.',
    SetAccessorCannotHaveRestParameter: 'A \'set\' accessor cannot have rest parameter.',
    SetAccessorCannotHaveReturnType: 'A \'set\' accessor cannot have a return type annotation.',
    SingleTypeParameterWithoutTrailingComma: ({typeParameterName}) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
    StaticBlockCannotHaveModifier: 'Static class blocks cannot have any modifier.',
    TupleOptionalAfterType: 'A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).',
    TypeAnnotationAfterAssign: 'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.',
    TypeImportCannotSpecifyDefaultAndNamed: 'A type-only import can specify a default import or named bindings, but not both.',
    TypeModifierIsUsedInTypeExports: 'The \'type\' modifier cannot be used on a named export when \'export type\' is used on its export statement.',
    TypeModifierIsUsedInTypeImports: 'The \'type\' modifier cannot be used on a named import when \'import type\' is used on its import statement.',
    UnexpectedParameterModifier: 'A parameter property is only allowed in a constructor implementation.',
    UnexpectedReadonly: '\'readonly\' type modifier is only permitted on array and tuple literal types.',
    UnexpectedTypeAnnotation: 'Did not expect a type annotation here.',
    UnexpectedTypeCastInParameter: 'Unexpected type cast in parameter position.',
    UnsupportedImportTypeArgument: 'Argument in a type import must be a string literal.',
    UnsupportedParameterPropertyKind: 'A parameter property may not be declared using a binding pattern.',
    UnsupportedSignatureParameterKind: ({type}) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`,
    UsingDeclarationInAmbientContext: (kind) => `'${kind}' declarations are not allowed in ambient contexts.`,
});

function keywordTypeFromName(value) {
    switch(value) {
    case 'any':
        return 'TSAnyKeyword';
    
    case 'boolean':
        return 'TSBooleanKeyword';
    
    case 'bigint':
        return 'TSBigIntKeyword';
    
    case 'never':
        return 'TSNeverKeyword';
    
    case 'number':
        return 'TSNumberKeyword';
    
    case 'object':
        return 'TSObjectKeyword';
    
    case 'string':
        return 'TSStringKeyword';
    
    case 'symbol':
        return 'TSSymbolKeyword';
    
    case 'undefined':
        return 'TSUndefinedKeyword';
    
    case 'unknown':
        return 'TSUnknownKeyword';
    
    default:
        return void 0;
    }
}

function tsIsAccessModifier(modifier) {
    return modifier === 'private' || modifier === 'public' || modifier === 'protected';
}

function tsIsVarianceAnnotations(modifier) {
    return modifier === 'in' || modifier === 'out';
}

function tsIsEntityName(node) {
    if (node.extra?.parenthesized) {
        return false;
    }
    
    switch(node.type) {
    case 'Identifier':
        return true;
    
    case 'MemberExpression':
        return !node.computed && tsIsEntityName(node.object);
    
    case 'TSInstantiationExpression':
        return tsIsEntityName(node.expression);
    
    default:
        return false;
    }
}

var typescript$3 = (superClass) => class TypeScriptParserMixin extends superClass {
    constructor() {
        super(...arguments);
        __publicField(this, 'tsParseInOutModifiers', this.tsParseModifiers.bind(this, {
            allowedModifiers: ['in', 'out'],
            disallowedModifiers: [
                'const',
                'public',
                'private',
                'protected',
                'readonly',
                'declare',
                'abstract',
                'override',
            ],
            errorTemplate: TSErrors.InvalidModifierOnTypeParameter,
        }));
        __publicField(this, 'tsParseConstModifier', this.tsParseModifiers.bind(this, {
            allowedModifiers: ['const'],
            disallowedModifiers: ['in', 'out'],
            errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions,
        }));
        __publicField(this, 'tsParseInOutConstModifiers', this.tsParseModifiers.bind(this, {
            allowedModifiers: [
                'in',
                'out',
                'const',
            ],
            disallowedModifiers: [
                'public',
                'private',
                'protected',
                'readonly',
                'declare',
                'abstract',
                'override',
            ],
            errorTemplate: TSErrors.InvalidModifierOnTypeParameter,
        }));
    }
    
    getScopeHandler() {
        return TypeScriptScopeHandler;
    }
    
    tsIsIdentifier() {
        return tokenIsIdentifier(this.state.type);
    }
    
    tsTokenCanFollowModifier() {
        return this.match(0)
            || this.match(5)
            || this.match(55)
            || this.match(21)
            || this.match(139)
            || this.isLiteralPropertyName();
    }
    
    tsNextTokenOnSameLineAndCanFollowModifier() {
        this.next();
        
        if (this.hasPrecedingLineBreak()) {
            return false;
        }
        
        return this.tsTokenCanFollowModifier();
    }
    
    tsNextTokenCanFollowModifier() {
        if (this.match(106)) {
            this.next();
            return this.tsTokenCanFollowModifier();
        }
        
        return this.tsNextTokenOnSameLineAndCanFollowModifier();
    }
    
    tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock, hasSeenStaticModifier) {
        if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {
            return void 0;
        }
        
        const modifier = this.state.value;
        
        if (allowedModifiers.includes(modifier)) {
            if (hasSeenStaticModifier && this.match(106)) {
                return void 0;
            }
            
            if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
                return void 0;
            }
            
            if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
                return modifier;
            }
        }
        
        return void 0;
    }
    
    tsParseModifiers({allowedModifiers, disallowedModifiers, stopOnStartOfClassStaticBlock, errorTemplate = TSErrors.InvalidModifierOnTypeMember}, modified) {
        const enforceOrder = (loc, modifier, before, after) => {
            if (modifier === before && modified[after]) {
                this.raise(TSErrors.InvalidModifiersOrder, loc, {
                    orderedModifiers: [before, after],
                });
            }
        };
        
        const incompatible = (loc, modifier, mod1, mod2) => {
            if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
                this.raise(TSErrors.IncompatibleModifiers, loc, {
                    modifiers: [mod1, mod2],
                });
            }
        };
        
        for (;;) {
            const {startLoc} = this.state;
            
            const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers ?? []), stopOnStartOfClassStaticBlock, modified.static);
            
            if (!modifier)
                break;
            
            if (tsIsAccessModifier(modifier)) {
                if (modified.accessibility) {
                    this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {
                        modifier,
                    });
                } else {
                    enforceOrder(startLoc, modifier, modifier, 'override');
                    enforceOrder(startLoc, modifier, modifier, 'static');
                    enforceOrder(startLoc, modifier, modifier, 'readonly');
                    modified.accessibility = modifier;
                }
            } else if (tsIsVarianceAnnotations(modifier)) {
                if (modified[modifier]) {
                    this.raise(TSErrors.DuplicateModifier, startLoc, {
                        modifier,
                    });
                }
                
                modified[modifier] = true;
                enforceOrder(startLoc, modifier, 'in', 'out');
            } else {
                if (Object.hasOwn(modified, modifier)) {
                    this.raise(TSErrors.DuplicateModifier, startLoc, {
                        modifier,
                    });
                } else {
                    enforceOrder(startLoc, modifier, 'static', 'readonly');
                    enforceOrder(startLoc, modifier, 'static', 'override');
                    enforceOrder(startLoc, modifier, 'override', 'readonly');
                    enforceOrder(startLoc, modifier, 'abstract', 'override');
                    incompatible(startLoc, modifier, 'declare', 'override');
                    incompatible(startLoc, modifier, 'static', 'abstract');
                }
                
                modified[modifier] = true;
            }
            
            if (disallowedModifiers?.includes(modifier)) {
                this.raise(errorTemplate, startLoc, {
                    modifier,
                });
            }
        }
    }
    
    tsIsListTerminator(kind) {
        switch(kind) {
        case 'EnumMembers':        
        case 'TypeMembers':
            return this.match(8);
        
        case 'HeritageClauseElement':
            return this.match(5);
        
        case 'TupleElementTypes':
            return this.match(3);
        
        case 'TypeParametersOrArguments':
            return this.match(48);
        }
    }
    
    tsParseList(kind, parseElement) {
        const result = [];
        
        while (!this.tsIsListTerminator(kind)) {
            result.push(parseElement());
        }
        
        return result;
    }
    
    tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
        return nonNull(this.tsParseDelimitedListWorker(
            kind,
            parseElement,
            true,
            refTrailingCommaPos,
        ));
    }
    
    tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
        const result = [];
        let trailingCommaPos = -1;
        
        for (;;) {
            if (this.tsIsListTerminator(kind)) {
                break;
            }
            
            trailingCommaPos = -1;
            const element = parseElement();
            
            if (element == null) {
                return void 0;
            }
            
            result.push(element);
            
            if (this.eat(12)) {
                trailingCommaPos = this.state.lastTokStartLoc.index;
                continue;
            }
            
            if (this.tsIsListTerminator(kind)) {
                break;
            }
            
            if (expectSuccess) {
                this.expect(12);
            }
            
            return void 0;
        }
        
        if (refTrailingCommaPos) {
            refTrailingCommaPos.value = trailingCommaPos;
        }
        
        return result;
    }
    
    tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
        if (!skipFirstToken) {
            if (bracket) {
                this.expect(0);
            } else {
                this.expect(47);
            }
        }
        
        const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
        
        if (bracket) {
            this.expect(3);
        } else {
            this.expect(48);
        }
        
        return result;
    }
    
    tsParseImportType() {
        const node = this.startNode();
        this.expect(83);
        this.expect(10);
        
        if (!this.match(134)) {
            this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);
            {
                node.argument = this.tsParseNonConditionalType();
            }
        } else {
            {
                node.argument = this.tsParseLiteralTypeNode();
            }
        }
        
        if (this.eat(12)) {
            node.options = this.tsParseImportTypeOptions();
        } else {
            node.options = null;
        }
        
        this.expect(11);
        
        if (this.eat(16)) {
            node.qualifier = this.tsParseEntityName(1 | 2);
        }
        
        if (this.match(47)) {
            {
                node.typeArguments = this.tsParseTypeArguments();
            }
        }
        
        return this.finishNode(node, 'TSImportType');
    }
    
    tsParseImportTypeOptions() {
        const node = this.startNode();
        this.expect(5);
        const withProperty = this.startNode();
        
        if (this.isContextual(76)) {
            withProperty.method = false;
            withProperty.key = this.parseIdentifier(true);
            withProperty.computed = false;
            withProperty.shorthand = false;
        } else {
            this.unexpected(null, 76);
        }
        
        this.expect(14);
        withProperty.value = this.tsParseImportTypeWithPropertyValue();
        node.properties = [
            this.finishObjectProperty(withProperty),
        ];
        this.eat(12);
        this.expect(8);
        return this.finishNode(node, 'ObjectExpression');
    }
    
    tsParseImportTypeWithPropertyValue() {
        const node = this.startNode();
        const properties = [];
        this.expect(5);
        while (!this.match(8)) {
            const type = this.state.type;
            
            if (tokenIsIdentifier(type) || type === 134) {
                properties.push(super.parsePropertyDefinition(null));
            } else {
                this.unexpected();
            }
            
            this.eat(12);
        }
        
        node.properties = properties;
        this.next();
        return this.finishNode(node, 'ObjectExpression');
    }
    
    tsParseEntityName(flags) {
        let entity;
        
        if (flags & 1 && this.match(78)) {
            if (flags & 2) {
                entity = this.parseIdentifier(true);
            } else {
                const node = this.startNode();
                this.next();
                entity = this.finishNode(node, 'ThisExpression');
            }
        } else {
            entity = this.parseIdentifier(!!(flags & 1));
        }
        
        while (this.eat(16)) {
            const node = this.startNodeAtNode(entity);
            
            node.left = entity;
            node.right = this.parseIdentifier(!!(flags & 1));
            entity = this.finishNode(node, 'TSQualifiedName');
        }
        
        return entity;
    }
    
    tsParseTypeReference() {
        const node = this.startNode();
        
        node.typeName = this.tsParseEntityName(1);
        
        if (!this.hasPrecedingLineBreak() && this.match(47)) {
            {
                node.typeArguments = this.tsParseTypeArguments();
            }
        }
        
        return this.finishNode(node, 'TSTypeReference');
    }
    
    tsParseThisTypePredicate(lhs) {
        this.next();
        const node = this.startNodeAtNode(lhs);
        
        node.parameterName = lhs;
        node.typeAnnotation = this.tsParseTypeAnnotation(false);
        node.asserts = false;
        return this.finishNode(node, 'TSTypePredicate');
    }
    
    tsParseThisTypeNode() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, 'TSThisType');
    }
    
    tsParseTypeQuery() {
        const node = this.startNode();
        this.expect(87);
        
        if (this.match(83)) {
            node.exprName = this.tsParseImportType();
        } else {
            {
                node.exprName = this.tsParseEntityName(1);
            }
        }
        
        if (!this.hasPrecedingLineBreak() && this.match(47)) {
            {
                node.typeArguments = this.tsParseTypeArguments();
            }
        }
        
        return this.finishNode(node, 'TSTypeQuery');
    }
    
    tsParseTypeParameter(parseModifiers) {
        const node = this.startNode();
        parseModifiers(node);
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsEatThenParseType(81);
        node.default = this.tsEatThenParseType(29);
        return this.finishNode(node, 'TSTypeParameter');
    }
    
    tsTryParseTypeParameters(parseModifiers) {
        if (this.match(47)) {
            return this.tsParseTypeParameters(parseModifiers);
        }
    }
    
    tsParseTypeParameters(parseModifiers) {
        const node = this.startNode();
        
        if (this.match(47) || this.match(143)) {
            this.next();
        } else {
            this.unexpected();
        }
        
        const refTrailingCommaPos = {
            value: -1,
        };
        
        node.params = this.tsParseBracketedList('TypeParametersOrArguments', this.tsParseTypeParameter.bind(
            this,
            parseModifiers,
        ), false, true, refTrailingCommaPos);
        
        if (node.params.length === 0) {
            this.raise(TSErrors.EmptyTypeParameters, node);
        }
        
        if (refTrailingCommaPos.value !== -1) {
            this.addExtra(node, 'trailingComma', refTrailingCommaPos.value);
        }
        
        return this.finishNode(node, 'TSTypeParameterDeclaration');
    }
    
    tsFillSignature(returnToken, signature) {
        const returnTokenRequired = returnToken === 19;
        const paramsKey = 'params';
        const returnTypeKey = 'returnType';
        
        signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        this.expect(10);
        signature[paramsKey] = this.tsParseBindingListForSignature();
        
        if (returnTokenRequired) {
            signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        } else if (this.match(returnToken)) {
            signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
    }
    
    tsParseBindingListForSignature() {
        const list = super.parseBindingList(11, 41, 2);
        
        for (const pattern of list) {
            const {type} = pattern;
            
            if (type === 'AssignmentPattern' || type === 'TSParameterProperty') {
                this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {
                    type,
                });
            }
        }
        
        return list;
    }
    
    tsParseTypeMemberSemicolon() {
        if (!this.eat(12) && !this.isLineTerminator()) {
            this.expect(13);
        }
    }
    
    tsParseSignatureMember(kind, node) {
        this.tsFillSignature(14, node);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, kind);
    }
    
    tsIsUnambiguouslyIndexSignature() {
        this.next();
        
        if (tokenIsIdentifier(this.state.type)) {
            this.next();
            return this.match(14);
        }
        
        return false;
    }
    
    tsTryParseIndexSignature(node) {
        if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
            return;
        }
        
        this.expect(0);
        const id = this.parseIdentifier();
        
        id.typeAnnotation = this.tsParseTypeAnnotation();
        this.resetEndLocation(id);
        this.expect(3);
        node.parameters = [id];
        const type = this.tsTryParseTypeAnnotation();
        
        if (type)
            node.typeAnnotation = type;
        
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, 'TSIndexSignature');
    }
    
    tsParsePropertyOrMethodSignature(node, readonly) {
        if (this.eat(17))
            node.optional = true;
        
        if (this.match(10) || this.match(47)) {
            if (readonly) {
                this.raise(TSErrors.ReadonlyForMethodSignature, node);
            }
            
            const method = node;
            
            if (method.kind && this.match(47)) {
                this.raise(TSErrors.AccessorCannotHaveTypeParameters, this.state.curPosition());
            }
            
            this.tsFillSignature(14, method);
            this.tsParseTypeMemberSemicolon();
            const paramsKey = 'params';
            const returnTypeKey = 'returnType';
            
            if (method.kind === 'get') {
                if (method[paramsKey].length > 0) {
                    this.raise(Errors.BadGetterArity, this.state.curPosition());
                    
                    if (this.isThisParam(method[paramsKey][0])) {
                        this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
                    }
                }
            } else if (method.kind === 'set') {
                if (method[paramsKey].length !== 1) {
                    this.raise(Errors.BadSetterArity, this.state.curPosition());
                } else {
                    const firstParameter = method[paramsKey][0];
                    
                    if (this.isThisParam(firstParameter)) {
                        this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
                    }
                    
                    if (firstParameter.type === 'Identifier' && firstParameter.optional) {
                        this.raise(TSErrors.SetAccessorCannotHaveOptionalParameter, this.state.curPosition());
                    }
                    
                    if (firstParameter.type === 'RestElement') {
                        this.raise(TSErrors.SetAccessorCannotHaveRestParameter, this.state.curPosition());
                    }
                }
                
                if (method[returnTypeKey]) {
                    this.raise(TSErrors.SetAccessorCannotHaveReturnType, method[returnTypeKey]);
                }
            } else {
                method.kind = 'method';
            }
            
            return this.finishNode(method, 'TSMethodSignature');
        } else {
            const property = node;
            
            if (readonly)
                property.readonly = true;
            
            const type = this.tsTryParseTypeAnnotation();
            
            if (type)
                property.typeAnnotation = type;
            
            this.tsParseTypeMemberSemicolon();
            return this.finishNode(property, 'TSPropertySignature');
        }
    }
    
    tsParseTypeMember() {
        const node = this.startNode();
        
        if (this.match(10) || this.match(47)) {
            return this.tsParseSignatureMember('TSCallSignatureDeclaration', node);
        }
        
        if (this.match(77)) {
            const id = this.startNode();
            this.next();
            
            if (this.match(10) || this.match(47)) {
                return this.tsParseSignatureMember('TSConstructSignatureDeclaration', node);
            } else {
                node.key = this.createIdentifier(id, 'new');
                return this.tsParsePropertyOrMethodSignature(node, false);
            }
        }
        
        this.tsParseModifiers({
            allowedModifiers: ['readonly'],
            disallowedModifiers: [
                'declare',
                'abstract',
                'private',
                'protected',
                'public',
                'static',
                'override',
            ],
        }, node);
        const idx = this.tsTryParseIndexSignature(node);
        
        if (idx) {
            return idx;
        }
        
        super.parsePropertyName(node);
        
        if (!node.computed && node.key.type === 'Identifier' && (node.key.name === 'get' || node.key.name === 'set') && this.tsTokenCanFollowModifier()) {
            node.kind = node.key.name;
            super.parsePropertyName(node);
            
            if (!this.match(10) && !this.match(47)) {
                this.unexpected(null, 10);
            }
        }
        
        return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
    }
    
    tsParseTypeLiteral() {
        const node = this.startNode();
        
        node.members = this.tsParseObjectTypeMembers();
        return this.finishNode(node, 'TSTypeLiteral');
    }
    
    tsParseObjectTypeMembers() {
        this.expect(5);
        const members = this.tsParseList('TypeMembers', this.tsParseTypeMember.bind(this));
        this.expect(8);
        return members;
    }
    
    tsIsStartOfMappedType() {
        this.next();
        
        if (this.eat(53)) {
            return this.isContextual(122);
        }
        
        if (this.isContextual(122)) {
            this.next();
        }
        
        if (!this.match(0)) {
            return false;
        }
        
        this.next();
        
        if (!this.tsIsIdentifier()) {
            return false;
        }
        
        this.next();
        return this.match(58);
    }
    
    tsParseMappedType() {
        const node = this.startNode();
        this.expect(5);
        
        if (this.match(53)) {
            node.readonly = this.state.value;
            this.next();
            this.expectContextual(122);
        } else if (this.eatContextual(122)) {
            node.readonly = true;
        }
        
        this.expect(0);
        {
            node.key = this.tsParseTypeParameterName();
            node.constraint = this.tsExpectThenParseType(58);
        }
        node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
        this.expect(3);
        
        if (this.match(53)) {
            node.optional = this.state.value;
            this.next();
            this.expect(17);
        } else if (this.eat(17)) {
            node.optional = true;
        }
        
        node.typeAnnotation = this.tsTryParseType();
        this.semicolon();
        this.expect(8);
        return this.finishNode(node, 'TSMappedType');
    }
    
    tsParseTupleType() {
        const node = this.startNode();
        
        node.elementTypes = this.tsParseBracketedList('TupleElementTypes', this.tsParseTupleElementType.bind(this), true, false);
        let seenOptionalElement = false;
        
        node.elementTypes.forEach((elementNode) => {
            const {type} = elementNode;
            
            if (seenOptionalElement && type !== 'TSRestType' && type !== 'TSOptionalType' && !(type === 'TSNamedTupleMember' && elementNode.optional)) {
                this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);
            }
            
            seenOptionalElement || (seenOptionalElement = type === 'TSNamedTupleMember' && elementNode.optional || type === 'TSOptionalType');
        });
        return this.finishNode(node, 'TSTupleType');
    }
    
    tsParseTupleElementType() {
        const restStartLoc = this.state.startLoc;
        const rest = this.eat(21);
        const {startLoc} = this.state;
        
        let labeled;
        let label;
        let optional;
        let type;
        const isWord = tokenIsKeywordOrIdentifier(this.state.type);
        const chAfterWord = isWord ? this.lookaheadCharCode() : null;
        
        if (chAfterWord === 58) {
            labeled = true;
            optional = false;
            label = this.parseIdentifier(true);
            this.expect(14);
            type = this.tsParseType();
        } else if (chAfterWord === 63) {
            optional = true;
            const wordName = this.state.value;
            const typeOrLabel = this.tsParseNonArrayType();
            
            if (this.lookaheadCharCode() === 58) {
                labeled = true;
                label = this.createIdentifier(this.startNodeAt(startLoc), wordName);
                this.expect(17);
                this.expect(14);
                type = this.tsParseType();
            } else {
                labeled = false;
                type = typeOrLabel;
                this.expect(17);
            }
        } else {
            type = this.tsParseType();
            optional = this.eat(17);
            labeled = this.eat(14);
        }
        
        if (labeled) {
            let labeledNode;
            
            if (label) {
                labeledNode = this.startNodeAt(startLoc);
                labeledNode.optional = optional;
                labeledNode.label = label;
                labeledNode.elementType = type;
                
                if (this.eat(17)) {
                    labeledNode.optional = true;
                    this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);
                }
            } else {
                labeledNode = this.startNodeAt(startLoc);
                labeledNode.optional = optional;
                this.raise(TSErrors.InvalidTupleMemberLabel, type);
                labeledNode.label = type;
                labeledNode.elementType = this.tsParseType();
            }
            
            type = this.finishNode(labeledNode, 'TSNamedTupleMember');
        } else if (optional) {
            const optionalTypeNode = this.startNodeAt(startLoc);
            
            optionalTypeNode.typeAnnotation = type;
            type = this.finishNode(optionalTypeNode, 'TSOptionalType');
        }
        
        if (rest) {
            const restNode = this.startNodeAt(restStartLoc);
            
            restNode.typeAnnotation = type;
            type = this.finishNode(restNode, 'TSRestType');
        }
        
        return type;
    }
    
    tsParseParenthesizedType() {
        const node = this.startNode();
        this.expect(10);
        node.typeAnnotation = this.tsParseType();
        this.expect(11);
        return this.finishNode(node, 'TSParenthesizedType');
    }
    
    tsParseFunctionOrConstructorType(type, abstract) {
        const node = this.startNode();
        
        if (type === 'TSConstructorType') {
            node.abstract = !!abstract;
            
            if (abstract)
                this.next();
            
            this.next();
        }
        
        this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));
        return this.finishNode(node, type);
    }
    
    tsParseLiteralTypeNode() {
        const node = this.startNode();
        
        switch(this.state.type) {
        case 135:        
        case 136:        
        case 134:        
        case 85:        
        case 86:
            node.literal = super.parseExprAtom();
            break;
        
        default:
            this.unexpected();
        }
        
        
        return this.finishNode(node, 'TSLiteralType');
    }
    
    tsParseTemplateLiteralType() {
        {
            const startLoc = this.state.startLoc;
            let curElt = this.parseTemplateElement(false);
            const quasis = [curElt];
            
            if (curElt.tail) {
                const node = this.startNodeAt(startLoc);
                const literal = this.startNodeAt(startLoc);
                
                literal.expressions = [];
                literal.quasis = quasis;
                node.literal = this.finishNode(literal, 'TemplateLiteral');
                return this.finishNode(node, 'TSLiteralType');
            } else {
                const substitutions = [];
                
                while (!curElt.tail) {
                    substitutions.push(this.tsParseType());
                    this.readTemplateContinuation();
                    quasis.push(curElt = this.parseTemplateElement(false));
                }
                
                const node = this.startNodeAt(startLoc);
                
                node.types = substitutions;
                node.quasis = quasis;
                return this.finishNode(node, 'TSTemplateLiteralType');
            }
        }
    }
    
    parseTemplateSubstitution() {
        if (this.state.inType)
            return this.tsParseType();
        
        return super.parseTemplateSubstitution();
    }
    
    tsParseThisTypeOrThisTypePredicate() {
        const thisKeyword = this.tsParseThisTypeNode();
        
        if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
            return this.tsParseThisTypePredicate(thisKeyword);
        } else {
            return thisKeyword;
        }
    }
    
    tsParseNonArrayType() {
        switch(this.state.type) {
        case 134:        
        case 135:        
        case 136:        
        case 85:        
        case 86:
            return this.tsParseLiteralTypeNode();
        
        case 53:
            if (this.state.value === '-') {
                const node = this.startNode();
                const nextToken = this.lookahead();
                
                if (nextToken.type !== 135 && nextToken.type !== 136) {
                    this.unexpected();
                }
                
                node.literal = this.parseMaybeUnary();
                return this.finishNode(node, 'TSLiteralType');
            }
            
            break;
        
        case 78:
            return this.tsParseThisTypeOrThisTypePredicate();
        
        case 87:
            return this.tsParseTypeQuery();
        
        case 83:
            return this.tsParseImportType();
        
        case 5:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        
        case 0:
            return this.tsParseTupleType();
        
        case 10: {
            if (!(this.optionFlags & 1024)) {
                const startLoc = this.state.startLoc;
                this.next();
                const type = this.tsParseType();
                this.expect(11);
                this.addExtra(type, 'parenthesized', true);
                this.addExtra(type, 'parenStart', startLoc.index);
                return type;
            }
        }
        
        return this.tsParseParenthesizedType();
        
        case 25:        
        case 24:
            return this.tsParseTemplateLiteralType();
        
        default: {
            const {type} = this.state;
            
            if (tokenIsIdentifier(type) || type === 88 || type === 84) {
                const nodeType = type === 88 ? 'TSVoidKeyword' : type === 84 ? 'TSNullKeyword' : keywordTypeFromName(this.state.value);
                
                if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                    const node = this.startNode();
                    this.next();
                    return this.finishNode(node, nodeType);
                }
                
                return this.tsParseTypeReference();
            }
        }
        }
        
        this.unexpected();
    }
    
    tsParseArrayTypeOrHigher() {
        const {startLoc} = this.state;
        
        let type = this.tsParseNonArrayType();
        
        while (!this.hasPrecedingLineBreak() && this.eat(0)) {
            if (this.match(3)) {
                const node = this.startNodeAt(startLoc);
                
                node.elementType = type;
                this.expect(3);
                type = this.finishNode(node, 'TSArrayType');
            } else {
                const node = this.startNodeAt(startLoc);
                
                node.objectType = type;
                node.indexType = this.tsParseType();
                this.expect(3);
                type = this.finishNode(node, 'TSIndexedAccessType');
            }
        }
        
        return type;
    }
    
    tsParseTypeOperator() {
        const node = this.startNode();
        const operator = this.state.value;
        this.next();
        node.operator = operator;
        node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
        
        if (operator === 'readonly') {
            this.tsCheckTypeAnnotationForReadOnly(node);
        }
        
        return this.finishNode(node, 'TSTypeOperator');
    }
    
    tsCheckTypeAnnotationForReadOnly(node) {
        switch(node.typeAnnotation.type) {
        case 'TSTupleType':        
        case 'TSArrayType':
            return;
        
        default:
            this.raise(TSErrors.UnexpectedReadonly, node);
        }
    }
    
    tsParseInferType() {
        const node = this.startNode();
        this.expectContextual(115);
        const typeParameter2 = this.startNode();
        
        typeParameter2.name = this.tsParseTypeParameterName();
        typeParameter2.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
        node.typeParameter = this.finishNode(typeParameter2, 'TSTypeParameter');
        return this.finishNode(node, 'TSInferType');
    }
    
    tsParseConstraintForInferType() {
        if (this.eat(81)) {
            const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
            
            if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
                return constraint;
            }
        }
    }
    
    tsParseTypeOperatorOrHigher() {
        const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
        return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    
    tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        const node = this.startNode();
        const hasLeadingOperator = this.eat(operator);
        const types2 = [];
        
        do {
            types2.push(parseConstituentType());
        } while (this.eat(operator))
        if (types2.length === 1 && !hasLeadingOperator) {
            return types2[0];
        }
        
        node.types = types2;
        return this.finishNode(node, kind);
    }
    
    tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType('TSIntersectionType', this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    
    tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType('TSUnionType', this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    
    tsIsStartOfFunctionType() {
        if (this.match(47)) {
            return true;
        }
        
        return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    
    tsSkipParameterStart() {
        if (tokenIsIdentifier(this.state.type) || this.match(78)) {
            this.next();
            return true;
        }
        
        if (this.match(5)) {
            const {errors} = this.state;
            
            const previousErrorCount = errors.length;
            
            try {
                this.parseObjectLike(8, true);
                return errors.length === previousErrorCount;
            } catch {
                return false;
            }
        }
        
        if (this.match(0)) {
            this.next();
            const {errors} = this.state;
            
            const previousErrorCount = errors.length;
            
            try {
                super.parseBindingList(3, 93, 1);
                return errors.length === previousErrorCount;
            } catch {
                return false;
            }
        }
        
        return false;
    }
    
    tsIsUnambiguouslyStartOfFunctionType() {
        this.next();
        
        if (this.match(11) || this.match(21)) {
            return true;
        }
        
        if (this.tsSkipParameterStart()) {
            if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
                return true;
            }
            
            if (this.match(11)) {
                this.next();
                
                if (this.match(19)) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    tsParseTypeOrTypePredicateAnnotation(returnToken) {
        return this.tsInType(() => {
            const t = this.startNode();
            this.expect(returnToken);
            const node = this.startNode();
            const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
            
            if (asserts && this.match(78)) {
                let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
                
                if (thisTypePredicate.type === 'TSThisType') {
                    node.parameterName = thisTypePredicate;
                    node.asserts = true;
                    node.typeAnnotation = null;
                    thisTypePredicate = this.finishNode(node, 'TSTypePredicate');
                } else {
                    this.resetStartLocationFromNode(thisTypePredicate, node);
                    thisTypePredicate.asserts = true;
                }
                
                t.typeAnnotation = thisTypePredicate;
                return this.finishNode(t, 'TSTypeAnnotation');
            }
            
            const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
            
            if (!typePredicateVariable) {
                if (!asserts) {
                    return this.tsParseTypeAnnotation(false, t);
                }
                
                node.parameterName = this.parseIdentifier();
                node.asserts = asserts;
                node.typeAnnotation = null;
                t.typeAnnotation = this.finishNode(node, 'TSTypePredicate');
                return this.finishNode(t, 'TSTypeAnnotation');
            }
            
            const type = this.tsParseTypeAnnotation(false);
            
            node.parameterName = typePredicateVariable;
            node.typeAnnotation = type;
            node.asserts = asserts;
            t.typeAnnotation = this.finishNode(node, 'TSTypePredicate');
            return this.finishNode(t, 'TSTypeAnnotation');
        });
    }
    
    tsTryParseTypeOrTypePredicateAnnotation() {
        if (this.match(14)) {
            return this.tsParseTypeOrTypePredicateAnnotation(14);
        }
    }
    
    tsTryParseTypeAnnotation() {
        if (this.match(14)) {
            return this.tsParseTypeAnnotation();
        }
    }
    
    tsTryParseType() {
        return this.tsEatThenParseType(14);
    }
    
    tsParseTypePredicatePrefix() {
        const id = this.parseIdentifier();
        
        if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
            this.next();
            return id;
        }
    }
    
    tsParseTypePredicateAsserts() {
        if (this.state.type !== 109) {
            return false;
        }
        
        const containsEsc = this.state.containsEsc;
        this.next();
        
        if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
            return false;
        }
        
        if (containsEsc) {
            this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
                reservedWord: 'asserts',
            });
        }
        
        return true;
    }
    
    tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
        this.tsInType(() => {
            if (eatColon)
                this.expect(14);
            
            t.typeAnnotation = this.tsParseType();
        });
        return this.finishNode(t, 'TSTypeAnnotation');
    }
    
    tsParseType() {
        assert2(this.state.inType);
        const type = this.tsParseNonConditionalType();
        
        if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
            return type;
        }
        
        const node = this.startNodeAtNode(type);
        
        node.checkType = type;
        node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
        this.expect(17);
        node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        this.expect(14);
        node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        return this.finishNode(node, 'TSConditionalType');
    }
    
    isAbstractConstructorSignature() {
        return this.isContextual(124) && this.isLookaheadContextual('new');
    }
    
    tsParseNonConditionalType() {
        if (this.tsIsStartOfFunctionType()) {
            return this.tsParseFunctionOrConstructorType('TSFunctionType');
        }
        
        if (this.match(77)) {
            return this.tsParseFunctionOrConstructorType('TSConstructorType');
        } else if (this.isAbstractConstructorSignature()) {
            return this.tsParseFunctionOrConstructorType('TSConstructorType', true);
        }
        
        return this.tsParseUnionTypeOrHigher();
    }
    
    tsParseTypeAssertion() {
        if (this.getPluginOption('typescript', 'disallowAmbiguousJSXLike')) {
            this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);
        }
        
        const node = this.startNode();
        
        node.typeAnnotation = this.tsInType(() => {
            this.next();
            return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
        });
        this.expect(48);
        node.expression = this.parseMaybeUnary();
        return this.finishNode(node, 'TSTypeAssertion');
    }
    
    tsParseHeritageClause(token) {
        const originalStartLoc = this.state.startLoc;
        const delimitedList = this.tsParseDelimitedList('HeritageClauseElement', () => {
            {
                const expression2 = super.parseExprSubscripts();
                
                if (!tsIsEntityName(expression2)) {
                    this.raise(TSErrors.InvalidHeritageClauseType, expression2.loc.start, {
                        token,
                    });
                }
                
                const nodeType = token === 'extends' ? 'TSInterfaceHeritage' : 'TSClassImplements';
                
                if (expression2.type === 'TSInstantiationExpression') {
                    expression2.type = nodeType;
                    return expression2;
                }
                
                const node = this.startNodeAtNode(expression2);
                
                node.expression = expression2;
                
                if (this.match(47) || this.match(51)) {
                    node.typeArguments = this.tsParseTypeArgumentsInExpression();
                }
                
                return this.finishNode(node, nodeType);
            }
        });
        
        if (!delimitedList.length) {
            this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {
                token,
            });
        }
        
        return delimitedList;
    }
    
    tsParseInterfaceDeclaration(node, properties = {}) {
        if (this.hasFollowingLineBreak())
            return null;
        
        this.expectContextual(129);
        
        if (properties.declare)
            node.declare = true;
        
        if (tokenIsIdentifier(this.state.type)) {
            node.id = this.parseIdentifier();
            this.checkIdentifier(node.id, 130);
        } else {
            node.id = null;
            this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);
        }
        
        node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        
        if (this.eat(81)) {
            node.extends = this.tsParseHeritageClause('extends');
        }
        
        const body = this.startNode();
        
        body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
        node.body = this.finishNode(body, 'TSInterfaceBody');
        return this.finishNode(node, 'TSInterfaceDeclaration');
    }
    
    tsParseTypeAliasDeclaration(node) {
        node.id = this.parseIdentifier();
        this.checkIdentifier(node.id, 2);
        node.typeAnnotation = this.tsInType(() => {
            node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);
            this.expect(29);
            
            if (this.isContextual(114) && this.lookaheadCharCode() !== 46) {
                const node2 = this.startNode();
                this.next();
                return this.finishNode(node2, 'TSIntrinsicKeyword');
            }
            
            return this.tsParseType();
        });
        this.semicolon();
        return this.finishNode(node, 'TSTypeAliasDeclaration');
    }
    
    tsInTopLevelContext(cb) {
        if (this.curContext() !== types$18.brace) {
            const oldContext = this.state.context;
            
            this.state.context = [oldContext[0]];
            try {
                return cb();
            } finally {
                this.state.context = oldContext;
            }
        } else {
            return cb();
        }
    }
    
    tsInType(cb) {
        const oldInType = this.state.inType;
        
        this.state.inType = true;
        try {
            return cb();
        } finally {
            this.state.inType = oldInType;
        }
    }
    
    tsInDisallowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        
        this.state.inDisallowConditionalTypesContext = true;
        try {
            return cb();
        } finally {
            this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
    }
    
    tsInAllowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        
        this.state.inDisallowConditionalTypesContext = false;
        try {
            return cb();
        } finally {
            this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
    }
    
    tsEatThenParseType(token) {
        if (this.match(token)) {
            return this.tsNextThenParseType();
        }
    }
    
    tsExpectThenParseType(token) {
        return this.tsInType(() => {
            this.expect(token);
            return this.tsParseType();
        });
    }
    
    tsNextThenParseType() {
        return this.tsInType(() => {
            this.next();
            return this.tsParseType();
        });
    }
    
    tsParseEnumMember() {
        const node = this.startNode();
        
        node.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
        
        if (this.eat(29)) {
            node.initializer = super.parseMaybeAssignAllowIn();
        }
        
        return this.finishNode(node, 'TSEnumMember');
    }
    
    tsParseEnumDeclaration(node, properties = {}) {
        if (properties.const)
            node.const = true;
        
        if (properties.declare)
            node.declare = true;
        
        this.expectContextual(126);
        node.id = this.parseIdentifier();
        this.checkIdentifier(node.id, node.const ? 8971 : 8459);
        {
            node.body = this.tsParseEnumBody();
        }
        
        return this.finishNode(node, 'TSEnumDeclaration');
    }
    
    tsParseEnumBody() {
        const node = this.startNode();
        this.expect(5);
        node.members = this.tsParseDelimitedList('EnumMembers', this.tsParseEnumMember.bind(this));
        this.expect(8);
        return this.finishNode(node, 'TSEnumBody');
    }
    
    tsParseModuleBlock() {
        const node = this.startNode();
        this.scope.enter(0);
        this.expect(5);
        super.parseBlockOrModuleBlockBody(node.body = [], void 0, true, 8);
        this.scope.exit();
        return this.finishNode(node, 'TSModuleBlock');
    }
    
    tsParseModuleOrNamespaceDeclaration(node, nested = false) {
        node.id = this.tsParseEntityName(1);
        
        if (node.id.type === 'Identifier') {
            this.checkIdentifier(node.id, 1024);
        }
        
        {
            this.scope.enter(1024);
            this.prodParam.enter(0);
            node.body = this.tsParseModuleBlock();
            this.prodParam.exit();
            this.scope.exit();
        }
        
        return this.finishNode(node, 'TSModuleDeclaration');
    }
    
    tsParseAmbientExternalModuleDeclaration(node) {
        if (this.isContextual(112)) {
            node.kind = 'global';
            node.id = this.parseIdentifier();
        } else if (this.match(134)) {
            node.kind = 'module';
            node.id = super.parseStringLiteral(this.state.value);
        } else {
            this.unexpected();
        }
        
        if (this.match(5)) {
            this.scope.enter(1024);
            this.prodParam.enter(0);
            node.body = this.tsParseModuleBlock();
            this.prodParam.exit();
            this.scope.exit();
        } else {
            this.semicolon();
        }
        
        return this.finishNode(node, 'TSModuleDeclaration');
    }
    
    tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {
        node.id = maybeDefaultIdentifier || this.parseIdentifier();
        this.checkIdentifier(node.id, 4096);
        this.expect(29);
        const moduleReference = this.tsParseModuleReference();
        
        if (node.importKind === 'type' && moduleReference.type !== 'TSExternalModuleReference') {
            this.raise(TSErrors.ImportAliasHasImportType, moduleReference);
        }
        
        node.moduleReference = moduleReference;
        this.semicolon();
        return this.finishNode(node, 'TSImportEqualsDeclaration');
    }
    
    tsIsExternalModuleReference() {
        return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    
    tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
    }
    
    tsParseExternalModuleReference() {
        const node = this.startNode();
        this.expectContextual(119);
        this.expect(10);
        
        if (!this.match(134)) {
            this.unexpected();
        }
        
        node.expression = super.parseExprAtom();
        this.expect(11);
        this.sawUnambiguousESM = true;
        return this.finishNode(node, 'TSExternalModuleReference');
    }
    
    tsLookAhead(f) {
        const state = this.state.clone();
        const res = f();
        
        this.state = state;
        return res;
    }
    
    tsTryParseAndCatch(f) {
        const result = this.tryParse((abort) => f() || abort());
        
        if (result.aborted || !result.node)
            return;
        
        if (result.error)
            this.state = result.failState;
        
        return result.node;
    }
    
    tsTryParse(f) {
        const state = this.state.clone();
        const result = f();
        
        if (result !== void 0 && result !== false) {
            return result;
        }
        
        this.state = state;
    }
    
    tsTryParseDeclare(node) {
        if (this.isLineTerminator()) {
            return;
        }
        
        const startType = this.state.type;
        
        return this.tsInAmbientContext(() => {
            switch(startType) {
            case 68:
                node.declare = true;
                return super.parseFunctionStatement(node, false, false);
            
            case 80:
                node.declare = true;
                return this.parseClass(node, true, false);
            
            case 126:
                return this.tsParseEnumDeclaration(node, {
                    declare: true,
                });
            
            case 112:
                return this.tsParseAmbientExternalModuleDeclaration(node);
            
            case 100:
                if (this.state.containsEsc) {
                    return;
                }
            
            case 75:            
            case 74:
                if (!this.match(75) || !this.isLookaheadContextual('enum')) {
                    node.declare = true;
                    return this.parseVarStatement(node, this.state.value, true);
                }
                
                this.expect(75);
                return this.tsParseEnumDeclaration(node, {
                    const: true,
                    declare: true,
                });
            
            case 107:
                if (this.isUsing()) {
                    this.raise(TSErrors.InvalidModifierOnUsingDeclaration, this.state.startLoc, 'declare');
                    node.declare = true;
                    return this.parseVarStatement(node, 'using', true);
                }
                
                break;
            
            case 96:
                if (this.isAwaitUsing()) {
                    this.raise(TSErrors.InvalidModifierOnAwaitUsingDeclaration, this.state.startLoc, 'declare');
                    node.declare = true;
                    this.next();
                    return this.parseVarStatement(node, 'await using', true);
                }
                
                break;
            
            case 129: {
                const result = this.tsParseInterfaceDeclaration(node, {
                    declare: true,
                });
                
                if (result)
                    return result;
            }
            
            default:
                if (tokenIsIdentifier(startType)) {
                    return this.tsParseDeclaration(node, this.state.value, true, null);
                }
            }
        });
    }
    
    tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
    }
    
    tsParseExpressionStatement(node, expr, decorators) {
        switch(expr.name) {
        case 'declare': {
            const declaration = this.tsTryParseDeclare(node);
            
            if (declaration) {
                declaration.declare = true;
            }
            
            return declaration;
        }
        
        case 'global':
            if (this.match(5)) {
                this.scope.enter(1024);
                this.prodParam.enter(0);
                const mod = node;
                
                mod.kind = 'global';
                mod.id = expr;
                mod.body = this.tsParseModuleBlock();
                this.scope.exit();
                this.prodParam.exit();
                return this.finishNode(mod, 'TSModuleDeclaration');
            }
            
            break;
        
        default:
            return this.tsParseDeclaration(node, expr.name, false, decorators);
        }
    }
    
    tsParseDeclaration(node, value, next, decorators) {
        switch(value) {
        case 'abstract':
            if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
                return this.tsParseAbstractDeclaration(node, decorators);
            }
            
            break;
        
        case 'module':
            if (this.tsCheckLineTerminator(next)) {
                if (this.match(134)) {
                    return this.tsParseAmbientExternalModuleDeclaration(node);
                } else if (tokenIsIdentifier(this.state.type)) {
                    node.kind = 'module';
                    return this.tsParseModuleOrNamespaceDeclaration(node);
                }
            }
            
            break;
        
        case 'namespace':
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
                node.kind = 'namespace';
                return this.tsParseModuleOrNamespaceDeclaration(node);
            }
            
            break;
        
        case 'type':
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
                return this.tsParseTypeAliasDeclaration(node);
            }
            
            break;
        }
    }
    
    tsCheckLineTerminator(next) {
        if (next) {
            if (this.hasFollowingLineBreak())
                return false;
            
            this.next();
            return true;
        }
        
        return !this.isLineTerminator();
    }
    
    tsTryParseGenericAsyncArrowFunction(startLoc) {
        if (!this.match(47))
            return;
        
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        
        this.state.maybeInArrowParameters = true;
        const res = this.tsTryParseAndCatch(() => {
            const node = this.startNodeAt(startLoc);
            
            node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
            super.parseFunctionParams(node);
            node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
            this.expect(19);
            return node;
        });
        
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        
        if (!res)
            return;
        
        return super.parseArrowExpression(res, null, true);
    }
    
    tsParseTypeArgumentsInExpression() {
        if (this.reScan_lt() !== 47)
            return;
        
        return this.tsParseTypeArguments();
    }
    
    tsParseTypeArguments() {
        const node = this.startNode();
        
        node.params = this.tsInType(() => this.tsInTopLevelContext(() => {
            this.expect(47);
            return this.tsParseDelimitedList('TypeParametersOrArguments', this.tsParseType.bind(this));
        }));
        
        if (node.params.length === 0) {
            this.raise(TSErrors.EmptyTypeArguments, node);
        } else if (!this.state.inType && this.curContext() === types$18.brace) {
            this.reScan_lt_gt();
        }
        
        this.expect(48);
        return this.finishNode(node, 'TSTypeParameterInstantiation');
    }
    
    tsIsDeclarationStart() {
        return tokenIsTSDeclarationStart(this.state.type);
    }
    
    isExportDefaultSpecifier() {
        if (this.tsIsDeclarationStart())
            return false;
        
        return super.isExportDefaultSpecifier();
    }
    
    parseBindingElement(flags, decorators) {
        const startLoc = decorators.length ? decorators[0].loc.start : this.state.startLoc;
        const modified = {};
        
        this.tsParseModifiers({
            allowedModifiers: [
                'public',
                'private',
                'protected',
                'override',
                'readonly',
            ],
        }, modified);
        const accessibility = modified.accessibility;
        const override = modified.override;
        const readonly = modified.readonly;
        
        if (!(flags & 4) && (accessibility || readonly || override)) {
            this.raise(TSErrors.UnexpectedParameterModifier, startLoc);
        }
        
        const left = this.parseMaybeDefault();
        
        if (flags & 2) {
            this.parseFunctionParamType(left);
        }
        
        const elt = this.parseMaybeDefault(left.loc.start, left);
        
        if (accessibility || readonly || override) {
            const pp = this.startNodeAt(startLoc);
            
            if (decorators.length) {
                pp.decorators = decorators;
            }
            
            if (accessibility)
                pp.accessibility = accessibility;
            
            if (readonly)
                pp.readonly = readonly;
            
            if (override)
                pp.override = override;
            
            if (elt.type !== 'Identifier' && elt.type !== 'AssignmentPattern') {
                this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);
            }
            
            pp.parameter = elt;
            return this.finishNode(pp, 'TSParameterProperty');
        }
        
        if (decorators.length) {
            left.decorators = decorators;
        }
        
        return elt;
    }
    
    isSimpleParameter(node) {
        return node.type === 'TSParameterProperty' && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
    }
    
    tsDisallowOptionalPattern(node) {
        for (const param of node.params) {
            if (param.type !== 'Identifier' && param.optional && !this.state.isAmbientContext) {
                this.raise(TSErrors.PatternIsOptional, param);
            }
        }
    }
    
    setArrowFunctionParameters(node, params, trailingCommaLoc) {
        super.setArrowFunctionParameters(node, params, trailingCommaLoc);
        this.tsDisallowOptionalPattern(node);
    }
    
    parseFunctionBodyAndFinish(node, type, isMethod3 = false) {
        if (this.match(14)) {
            node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
        }
        
        const bodilessType = type === 'FunctionDeclaration' ? 'TSDeclareFunction' : type === 'ClassMethod' || type === 'ClassPrivateMethod' ? 'TSDeclareMethod' : void 0;
        
        if (bodilessType && !this.match(5) && this.isLineTerminator()) {
            return this.finishNode(node, bodilessType);
        }
        
        if (bodilessType === 'TSDeclareFunction' && this.state.isAmbientContext) {
            this.raise(TSErrors.DeclareFunctionHasImplementation, node);
            
            if (node.declare) {
                return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod3);
            }
        }
        
        this.tsDisallowOptionalPattern(node);
        return super.parseFunctionBodyAndFinish(node, type, isMethod3);
    }
    
    registerFunctionStatementId(node) {
        if (!node.body && node.id) {
            this.checkIdentifier(node.id, 1024);
        } else {
            super.registerFunctionStatementId(node);
        }
    }
    
    tsCheckForInvalidTypeCasts(items) {
        items.forEach((node) => {
            if (node?.type === 'TSTypeCastExpression') {
                this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);
            }
        });
    }
    
    toReferencedList(exprList, isInParens) {
        this.tsCheckForInvalidTypeCasts(exprList);
        return exprList;
    }
    
    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
        
        if (node.type === 'ArrayExpression') {
            this.tsCheckForInvalidTypeCasts(node.elements);
        }
        
        return node;
    }
    
    parseSubscript(base, startLoc, noCalls, state) {
        if (!this.hasPrecedingLineBreak() && this.match(35)) {
            this.state.canStartJSXElement = false;
            this.next();
            const nonNullExpression = this.startNodeAt(startLoc);
            
            nonNullExpression.expression = base;
            return this.finishNode(nonNullExpression, 'TSNonNullExpression');
        }
        
        let isOptionalCall = false;
        
        if (this.match(18) && this.lookaheadCharCode() === 60) {
            if (noCalls) {
                state.stop = true;
                return base;
            }
            
            state.optionalChainMember =
            isOptionalCall = true;
            this.next();
        }
        
        if (this.match(47) || this.match(51)) {
            let missingParenErrorLoc;
            const result = this.tsTryParseAndCatch(() => {
                if (!noCalls && this.atPossibleAsyncArrow(base)) {
                    const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
                    
                    if (asyncArrowFn) {
                        state.stop = true;
                        return asyncArrowFn;
                    }
                }
                
                const typeArguments = this.tsParseTypeArgumentsInExpression();
                
                if (!typeArguments)
                    return;
                
                if (isOptionalCall && !this.match(10)) {
                    missingParenErrorLoc = this.state.curPosition();
                    return;
                }
                
                if (tokenIsTemplate(this.state.type)) {
                    const result2 = super.parseTaggedTemplateExpression(base, startLoc, state);
                    
                    {
                        result2.typeArguments = typeArguments;
                    }
                    
                    return result2;
                }
                
                if (!noCalls && this.eat(10)) {
                    const node2 = this.startNodeAt(startLoc);
                    
                    node2.callee = base;
                    node2.arguments = this.parseCallExpressionArguments();
                    this.tsCheckForInvalidTypeCasts(node2.arguments);
                    {
                        node2.typeArguments = typeArguments;
                    }
                    if (state.optionalChainMember) {
                        node2.optional = isOptionalCall;
                    }
                    
                    return this.finishCallExpression(node2, state.optionalChainMember);
                }
                
                const tokenType = this.state.type;
                
                if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {
                    return;
                }
                
                const node = this.startNodeAt(startLoc);
                
                node.expression = base;
                {
                    node.typeArguments = typeArguments;
                }
                
                return this.finishNode(node, 'TSInstantiationExpression');
            });
            
            if (missingParenErrorLoc) {
                this.unexpected(missingParenErrorLoc, 10);
            }
            
            if (result) {
                if (result.type === 'TSInstantiationExpression') {
                    if (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) {
                        this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);
                    }
                    
                    if (!this.match(16) && !this.match(18)) {
                        result.expression = super.stopParseSubscript(base, state);
                    }
                }
                
                return result;
            }
        }
        
        return super.parseSubscript(base, startLoc, noCalls, state);
    }
    
    parseNewCallee(node) {
        super.parseNewCallee(node);
        const {callee} = node;
        
        if (callee.type === 'TSInstantiationExpression' && !callee.extra?.parenthesized) {
            {
                node.typeArguments = callee.typeArguments;
            }
            node.callee = callee.expression;
        }
    }
    
    parseExprOp(left, leftStartLoc, minPrec) {
        let isSatisfies;
        
        if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
            const node = this.startNodeAt(leftStartLoc);
            
            node.expression = left;
            node.typeAnnotation = this.tsInType(() => {
                this.next();
                
                if (this.match(75)) {
                    if (isSatisfies) {
                        this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {
                            keyword: 'const',
                        });
                    }
                    
                    return this.tsParseTypeReference();
                }
                
                return this.tsParseType();
            });
            this.finishNode(node, isSatisfies ? 'TSSatisfiesExpression' : 'TSAsExpression');
            this.reScan_lt_gt();
            return this.parseExprOp(node, leftStartLoc, minPrec);
        }
        
        return super.parseExprOp(left, leftStartLoc, minPrec);
    }
    
    checkReservedWord(word, startLoc, checkKeywords, isBinding3) {
        if (!this.state.isAmbientContext) {
            super.checkReservedWord(word, startLoc, checkKeywords, isBinding3);
        }
    }
    
    checkImportReflection(node) {
        super.checkImportReflection(node);
        
        if (node.module && node.importKind !== 'value') {
            this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
        }
    }
    
    checkDuplicateExports() {}
    
    isPotentialImportPhase(isExport) {
        if (super.isPotentialImportPhase(isExport))
            return true;
        
        if (this.isContextual(130)) {
            const ch = this.lookaheadCharCode();
            return isExport ? ch === 123 || ch === 42 : ch !== 61;
        }
        
        return !isExport && this.isContextual(87);
    }
    
    applyImportPhase(node, isExport, phase, loc) {
        super.applyImportPhase(node, isExport, phase, loc);
        
        if (isExport) {
            node.exportKind = phase === 'type' ? 'type' : 'value';
        } else {
            node.importKind = phase === 'type' || phase === 'typeof' ? phase : 'value';
        }
    }
    
    parseImport(node) {
        if (this.match(134)) {
            node.importKind = 'value';
            return super.parseImport(node);
        }
        
        let importNode;
        
        if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
            node.importKind = 'value';
            return this.tsParseImportEqualsDeclaration(node);
        } else if (this.isContextual(130)) {
            const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
            
            if (this.lookaheadCharCode() === 61) {
                return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);
            } else {
                importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);
            }
        } else {
            importNode = super.parseImport(node);
        }
        
        if (importNode.importKind === 'type' && importNode.specifiers.length > 1 && importNode.specifiers[0].type === 'ImportDefaultSpecifier') {
            this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);
        }
        
        return importNode;
    }
    
    parseExport(node, decorators) {
        if (this.match(83)) {
            const nodeImportEquals = this.startNode();
            this.next();
            let maybeDefaultIdentifier = null;
            
            if (this.isContextual(130) && this.isPotentialImportPhase(false)) {
                maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, false);
            } else {
                nodeImportEquals.importKind = 'value';
            }
            
            const declaration = this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier, true);
            
            {
                node.attributes = [];
                node.declaration = declaration;
                node.exportKind = 'value';
                node.source = null;
                node.specifiers = [];
                return this.finishNode(node, 'ExportNamedDeclaration');
            }
        } else if (this.eat(29)) {
            const assign = node;
            
            assign.expression = super.parseExpression();
            this.semicolon();
            this.sawUnambiguousESM = true;
            return this.finishNode(assign, 'TSExportAssignment');
        } else if (this.eatContextual(93)) {
            const decl = node;
            this.expectContextual(128);
            decl.id = this.parseIdentifier();
            this.semicolon();
            return this.finishNode(decl, 'TSNamespaceExportDeclaration');
        } else {
            return super.parseExport(node, decorators);
        }

    }
    
    isAbstractClass() {
        return this.isContextual(124) && this.isLookaheadContextual('class');
    }
    
    parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
            const cls = this.startNode();
            this.next();
            cls.abstract = true;
            return this.parseClass(cls, true, true);
        }
        
        if (this.match(129)) {
            const result = this.tsParseInterfaceDeclaration(this.startNode());
            
            if (result)
                return result;
        }
        
        return super.parseExportDefaultExpression();
    }
    
    parseVarStatement(node, kind, allowMissingInitializer = false) {
        const {isAmbientContext} = this.state;
        
        const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
        
        if (!isAmbientContext)
            return declaration;
        
        if (!node.declare && (kind === 'using' || kind === 'await using')) {
            this.raiseOverwrite(TSErrors.UsingDeclarationInAmbientContext, node, kind);
            return declaration;
        }
        
        for (const {id, init} of declaration.declarations) {
            if (!init)
                continue;
            
            if (kind === 'var' || kind === 'let' || !!id.typeAnnotation) {
                this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);
            } else if (!isValidAmbientConstInitializer(init, this.hasPlugin('estree'))) {
                this.raise(TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);
            }
        }
        
        return declaration;
    }
    
    parseStatementContent(flags, decorators) {
        if (this.match(75) && this.isLookaheadContextual('enum')) {
            const node = this.startNode();
            this.expect(75);
            return this.tsParseEnumDeclaration(node, {
                const: true,
            });
        }
        
        if (this.isContextual(126)) {
            return this.tsParseEnumDeclaration(this.startNode());
        }
        
        if (this.isContextual(129)) {
            const result = this.tsParseInterfaceDeclaration(this.startNode());
            
            if (result)
                return result;
        }
        
        return super.parseStatementContent(flags, decorators);
    }
    
    parseAccessModifier() {
        return this.tsParseModifier(['public', 'protected', 'private']);
    }
    
    tsHasSomeModifiers(member, modifiers) {
        return modifiers.some((modifier) => {
            if (tsIsAccessModifier(modifier)) {
                return member.accessibility === modifier;
            }
            
            return !!member[modifier];
        });
    }
    
    tsIsStartOfStaticBlocks() {
        return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    
    parseClassMember(classBody2, member, state) {
        const modifiers = [
            'declare',
            'private',
            'public',
            'protected',
            'override',
            'abstract',
            'readonly',
            'static',
        ];
        
        this.tsParseModifiers({
            allowedModifiers: modifiers,
            disallowedModifiers: ['in', 'out'],
            stopOnStartOfClassStaticBlock: true,
            errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions,
        }, member);
        const callParseClassMemberWithIsStatic = () => {
            if (this.tsIsStartOfStaticBlocks()) {
                this.next();
                this.next();
                
                if (this.tsHasSomeModifiers(member, modifiers)) {
                    this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition());
                }
                
                super.parseClassStaticBlock(classBody2, member);
            } else {
                this.parseClassMemberWithIsStatic(classBody2, member, state, !!member.static);
            }
        };
        
        if (member.declare) {
            this.tsInAmbientContext(callParseClassMemberWithIsStatic);
        } else {
            callParseClassMemberWithIsStatic();
        }
    }
    
    parseClassMemberWithIsStatic(classBody2, member, state, isStatic2) {
        const idx = this.tsTryParseIndexSignature(member);
        
        if (idx) {
            classBody2.body.push(idx);
            
            if (member.abstract) {
                this.raise(TSErrors.IndexSignatureHasAbstract, member);
            }
            
            if (member.accessibility) {
                this.raise(TSErrors.IndexSignatureHasAccessibility, member, {
                    modifier: member.accessibility,
                });
            }
            
            if (member.declare) {
                this.raise(TSErrors.IndexSignatureHasDeclare, member);
            }
            
            if (member.override) {
                this.raise(TSErrors.IndexSignatureHasOverride, member);
            }
            
            return;
        }
        
        if (!this.state.inAbstractClass && member.abstract) {
            this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);
        }
        
        if (member.override) {
            if (!state.hadSuperClass) {
                this.raise(TSErrors.OverrideNotInSubClass, member);
            }
        }
        
        super.parseClassMemberWithIsStatic(classBody2, member, state, isStatic2);
    }
    
    parsePostMemberNameModifiers(methodOrProp) {
        const optional = this.eat(17);
        
        if (optional)
            methodOrProp.optional = true;
        
        if (methodOrProp.readonly && this.match(10)) {
            this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);
        }
        
        if (methodOrProp.declare && this.match(10)) {
            this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);
        }
    }
    
    parseExpressionStatement(node, expr, decorators) {
        const decl = expr.type === 'Identifier' ? this.tsParseExpressionStatement(node, expr, decorators) : void 0;
        return decl || super.parseExpressionStatement(node, expr, decorators);
    }
    
    shouldParseExportDeclaration() {
        if (this.tsIsDeclarationStart())
            return true;
        
        return super.shouldParseExportDeclaration();
    }
    
    parseConditional(expr, startLoc, refExpressionErrors) {
        if (!this.match(17))
            return expr;
        
        if (this.state.maybeInArrowParameters) {
            const nextCh = this.lookaheadCharCode();
            
            if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
                this.setOptionalParametersError(refExpressionErrors);
                return expr;
            }
        }
        
        return super.parseConditional(expr, startLoc, refExpressionErrors);
    }
    
    parseParenItem(node, startLoc) {
        const newNode = super.parseParenItem(node, startLoc);
        
        if (this.eat(17)) {
            newNode.optional = true;
            this.resetEndLocation(node);
        }
        
        if (this.match(14)) {
            const typeCastNode = this.startNodeAt(startLoc);
            
            typeCastNode.expression = node;
            typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
            return this.finishNode(typeCastNode, 'TSTypeCastExpression');
        }
        
        return node;
    }
    
    parseExportDeclaration(node) {
        if (!this.state.isAmbientContext && this.isContextual(125)) {
            return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
        }
        
        const startLoc = this.state.startLoc;
        const isDeclare = this.eatContextual(125);
        
        if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {
            throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
        }
        
        const isIdentifier5 = tokenIsIdentifier(this.state.type);
        const declaration = isIdentifier5 && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
        
        if (!declaration)
            return null;
        
        if (declaration.type === 'TSInterfaceDeclaration' || declaration.type === 'TSTypeAliasDeclaration' || isDeclare) {
            node.exportKind = 'type';
        }
        
        if (isDeclare && declaration.type !== 'TSImportEqualsDeclaration') {
            this.resetStartLocation(declaration, startLoc);
            declaration.declare = true;
        }
        
        return declaration;
    }
    
    parseClassId(node, isStatement5, optionalId, bindingType) {
        if ((!isStatement5 || optionalId) && this.isContextual(113)) {
            return;
        }
        
        super.parseClassId(node, isStatement5, optionalId, node.declare ? 1024 : 8331);
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        
        if (typeParameters)
            node.typeParameters = typeParameters;
    }
    
    parseClassPropertyAnnotation(node) {
        if (!node.optional) {
            if (this.eat(35)) {
                node.definite = true;
            } else if (this.eat(17)) {
                node.optional = true;
            }
        }
        
        const type = this.tsTryParseTypeAnnotation();
        
        if (type)
            node.typeAnnotation = type;
    }
    
    parseClassProperty(node) {
        this.parseClassPropertyAnnotation(node);
        
        if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {
            this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);
        }
        
        if (node.abstract && this.match(29)) {
            const {key} = node;
            
            this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {
                propertyName: key.type === 'Identifier' && !node.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`,
            });
        }
        
        return super.parseClassProperty(node);
    }
    
    parseClassPrivateProperty(node) {
        if (node.abstract) {
            this.raise(TSErrors.PrivateElementHasAbstract, node);
        }
        
        if (node.accessibility) {
            this.raise(TSErrors.PrivateElementHasAccessibility, node, {
                modifier: node.accessibility,
            });
        }
        
        this.parseClassPropertyAnnotation(node);
        return super.parseClassPrivateProperty(node);
    }
    
    parseClassAccessorProperty(node) {
        this.parseClassPropertyAnnotation(node);
        
        if (node.optional) {
            this.raise(TSErrors.AccessorCannotBeOptional, node);
        }
        
        return super.parseClassAccessorProperty(node);
    }
    
    pushClassMethod(classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        
        if (typeParameters && isConstructor) {
            this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);
        }
        
        const {declare = false, kind} = method;
        
        if (declare && (kind === 'get' || kind === 'set')) {
            this.raise(TSErrors.DeclareAccessor, method, {
                kind,
            });
        }
        
        if (typeParameters)
            method.typeParameters = typeParameters;
        
        super.pushClassMethod(classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
    }
    
    pushClassPrivateMethod(classBody2, method, isGenerator, isAsync) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        
        if (typeParameters)
            method.typeParameters = typeParameters;
        
        super.pushClassPrivateMethod(classBody2, method, isGenerator, isAsync);
    }
    
    declareClassPrivateMethodInScope(node, kind) {
        if (node.type === 'TSDeclareMethod')
            return;
        
        if (node.type === 'MethodDefinition' && node.value.body == null) {
            return;
        }
        
        super.declareClassPrivateMethodInScope(node, kind);
    }
    
    parseClassSuper(node) {
        super.parseClassSuper(node);
        
        if (node.superClass && (this.match(47) || this.match(51))) {
            {
                node.superTypeArguments = this.tsParseTypeArgumentsInExpression();
            }
        }
        
        if (this.eatContextual(113)) {
            node.implements = this.tsParseHeritageClause('implements');
        }
    }
    
    parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern3, isAccessor2, refExpressionErrors) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        
        if (typeParameters)
            prop.typeParameters = typeParameters;
        
        return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern3, isAccessor2, refExpressionErrors);
    }
    
    parseFunctionParams(node, isConstructor) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        
        if (typeParameters)
            node.typeParameters = typeParameters;
        
        super.parseFunctionParams(node, isConstructor);
    }
    
    parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        
        if (decl.id.type === 'Identifier' && !this.hasPrecedingLineBreak() && this.eat(35)) {
            decl.definite = true;
        }
        
        const type = this.tsTryParseTypeAnnotation();
        
        if (type) {
            decl.id.typeAnnotation = type;
            this.resetEndLocation(decl.id);
        }
    }
    
    parseAsyncArrowFromCallExpression(node, call2) {
        if (this.match(14)) {
            node.returnType = this.tsParseTypeAnnotation();
        }
        
        return super.parseAsyncArrowFromCallExpression(node, call2);
    }
    
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        let state;
        let jsx2;
        let typeCast;
        
        if (this.hasPlugin('jsx') && (this.match(143) || this.match(47))) {
            state = this.state.clone();
            jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
            
            if (!jsx2.error)
                return jsx2.node;
            
            const {context} = this.state;
            
            const currentContext = context[context.length - 1];
            
            if (currentContext === types$18.j_oTag || currentContext === types$18.j_expr) {
                context.pop();
            }
        }
        
        if (!jsx2?.error && !this.match(47)) {
            return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        }
        
        if (!state || state === this.state)
            state = this.state.clone();
        
        let typeParameters;
        
        const arrow = this.tryParse((abort) => {
            typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
            const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
            
            if (expr.type !== 'ArrowFunctionExpression' || expr.extra?.parenthesized) {
                abort();
            }
            
            if (typeParameters?.params.length !== 0) {
                this.resetStartLocationFromNode(expr, typeParameters);
            }
            
            expr.typeParameters = typeParameters;
            {
                if (this.hasPlugin('jsx') && expr.typeParameters.params.length === 1 && !expr.typeParameters.extra?.trailingComma) {
                    const parameter = expr.typeParameters.params[0];
                    
                    if (!parameter.constraint) {
                        this.raise(TSErrors.SingleTypeParameterWithoutTrailingComma, createPositionWithColumnOffset(parameter.loc.end, 1), {
                            typeParameterName: parameter.name.name,
                        });
                    }
                }
            }
            
            return expr;
        }, state);
        
        if (!arrow.error && !arrow.aborted) {
            if (typeParameters)
                this.reportReservedArrowTypeParam(typeParameters);
            
            return arrow.node;
        }
        
        if (!jsx2) {
            assert2(!this.hasPlugin('jsx'));
            typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
            
            if (!typeCast.error)
                return typeCast.node;
        }
        
        if (jsx2?.node) {
            this.state = jsx2.failState;
            return jsx2.node;
        }
        
        if (arrow.node) {
            this.state = arrow.failState;
            
            if (typeParameters)
                this.reportReservedArrowTypeParam(typeParameters);
            
            return arrow.node;
        }
        
        if (typeCast?.node) {
            this.state = typeCast.failState;
            return typeCast.node;
        }
        
        throw jsx2?.error || arrow.error || typeCast?.error;
    }
    
    reportReservedArrowTypeParam(node) {
        if (node.params.length === 1 && !node.params[0].constraint && !node.extra?.trailingComma && this.getPluginOption('typescript', 'disallowAmbiguousJSXLike')) {
            this.raise(TSErrors.ReservedArrowTypeParam, node);
        }
    }
    
    parseMaybeUnary(refExpressionErrors, sawUnary) {
        if (!this.hasPlugin('jsx') && this.match(47)) {
            return this.tsParseTypeAssertion();
        }
        
        return super.parseMaybeUnary(refExpressionErrors, sawUnary);
    }
    
    parseArrow(node) {
        if (this.match(14)) {
            const result = this.tryParse((abort) => {
                const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
                
                if (this.canInsertSemicolon() || !this.match(19))
                    abort();
                
                return returnType;
            });
            
            if (result.aborted)
                return;
            
            if (!result.thrown) {
                if (result.error)
                    this.state = result.failState;
                
                node.returnType = result.node;
            }
        }
        
        return super.parseArrow(node);
    }
    
    parseFunctionParamType(param) {
        if (this.eat(17)) {
            param.optional = true;
        }
        
        const type = this.tsTryParseTypeAnnotation();
        
        if (type)
            param.typeAnnotation = type;
        
        this.resetEndLocation(param);
        return param;
    }
    
    isAssignable(node, isBinding3) {
        switch(node.type) {
        case 'TSTypeCastExpression':
            return this.isAssignable(node.expression, isBinding3);
        
        case 'TSParameterProperty':
            return true;
        
        default:
            return super.isAssignable(node, isBinding3);
        }
    }
    
    toAssignable(node, isLHS = false) {
        switch(node.type) {
        case 'ParenthesizedExpression':
            this.toAssignableParenthesizedExpression(node, isLHS);
            break;
        
        case 'TSAsExpression':        
        case 'TSSatisfiesExpression':        
        case 'TSNonNullExpression':        
        case 'TSTypeAssertion':
            if (isLHS) {
                this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);
            } else {
                this.raise(TSErrors.UnexpectedTypeCastInParameter, node);
            }
            
            this.toAssignable(node.expression, isLHS);
            break;
        
        case 'AssignmentExpression':
            if (!isLHS && node.left.type === 'TSTypeCastExpression') {
                node.left = this.typeCastToParameter(node.left);
            }
        
        default:
            super.toAssignable(node, isLHS);
        }
    }
    
    toAssignableParenthesizedExpression(node, isLHS) {
        switch(node.expression.type) {
        case 'TSAsExpression':        
        case 'TSSatisfiesExpression':        
        case 'TSNonNullExpression':        
        case 'TSTypeAssertion':        
        case 'ParenthesizedExpression':
            this.toAssignable(node.expression, isLHS);
            break;
        
        default:
            super.toAssignable(node, isLHS);
        }
    }
    
    checkToRestConversion(node, allowPattern) {
        switch(node.type) {
        case 'TSAsExpression':        
        case 'TSSatisfiesExpression':        
        case 'TSTypeAssertion':        
        case 'TSNonNullExpression':
            this.checkToRestConversion(node.expression, false);
            break;
        
        default:
            super.checkToRestConversion(node, allowPattern);
        }
    }
    
    isValidLVal(type, isUnparenthesizedInAssign, binding) {
        switch(type) {
        case 'TSTypeCastExpression':
            return true;
        
        case 'TSParameterProperty':
            return 'parameter';
        
        case 'TSNonNullExpression':
            return 'expression';
        
        case 'TSAsExpression':        
        case 'TSSatisfiesExpression':        
        case 'TSTypeAssertion':
            return (binding !== 64 || !isUnparenthesizedInAssign) && [
                'expression',
                true,
            ];
        
        default:
            return super.isValidLVal(type, isUnparenthesizedInAssign, binding);
        }
    }
    
    parseBindingAtom() {
        if (this.state.type === 78) {
            return this.parseIdentifier(true);
        }
        
        return super.parseBindingAtom();
    }
    
    parseMaybeDecoratorArguments(expr, startLoc) {
        if (this.match(47) || this.match(51)) {
            const typeArguments = this.tsParseTypeArgumentsInExpression();
            
            if (this.match(10)) {
                const call2 = super.parseMaybeDecoratorArguments(expr, startLoc);
                
                {
                    call2.typeArguments = typeArguments;
                }
                
                return call2;
            }
            
            this.unexpected(null, 10);
        }
        
        return super.parseMaybeDecoratorArguments(expr, startLoc);
    }
    
    checkCommaAfterRest(close) {
        if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
            this.next();
            return false;
        }
        
        return super.checkCommaAfterRest(close);
    }
    
    isClassMethod() {
        return this.match(47) || super.isClassMethod();
    }
    
    isClassProperty() {
        return this.match(35) || this.match(14) || super.isClassProperty();
    }
    
    parseMaybeDefault(startLoc, left) {
        const node = super.parseMaybeDefault(startLoc, left);
        
        if (node.type === 'AssignmentPattern' && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
            this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);
        }
        
        return node;
    }
    
    getTokenFromCode(code2) {
        if (this.state.inType) {
            if (code2 === 62) {
                this.finishOp(48, 1);
                return;
            }
            
            if (code2 === 60) {
                this.finishOp(47, 1);
                return;
            }
        }
        
        super.getTokenFromCode(code2);
    }
    
    reScan_lt_gt() {
        const {type} = this.state;
        
        if (type === 47) {
            this.state.pos -= 1;
            this.readToken_lt();
        } else if (type === 48) {
            this.state.pos -= 1;
            this.readToken_gt();
        }
    }
    
    reScan_lt() {
        const {type} = this.state;
        
        if (type === 51) {
            this.state.pos -= 2;
            this.finishOp(47, 1);
            return 47;
        }
        
        return type;
    }
    
    toAssignableListItem(exprList, index2, isLHS) {
        const node = exprList[index2];
        
        if (node.type === 'TSTypeCastExpression') {
            exprList[index2] = this.typeCastToParameter(node);
        }
        
        super.toAssignableListItem(exprList, index2, isLHS);
    }
    
    typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
        return node.expression;
    }
    
    shouldParseArrow(params) {
        if (this.match(14)) {
            return params.every((expr) => this.isAssignable(expr, true));
        }
        
        return super.shouldParseArrow(params);
    }
    
    shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
    }
    
    canHaveLeadingDecorator() {
        return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    
    jsxParseOpeningElementAfterName(node) {
        if (this.match(47) || this.match(51)) {
            const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
            
            if (typeArguments) {
                {
                    node.typeArguments = typeArguments;
                }
            }
        }
        
        return super.jsxParseOpeningElementAfterName(node);
    }
    
    getGetterSetterExpectedParamCount(method) {
        const baseCount = super.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        const firstParam = params[0];
        const hasContextParam = firstParam && this.isThisParam(firstParam);
        
        return hasContextParam ? baseCount + 1 : baseCount;
    }
    
    parseCatchClauseParam() {
        const param = super.parseCatchClauseParam();
        const type = this.tsTryParseTypeAnnotation();
        
        if (type) {
            param.typeAnnotation = type;
            this.resetEndLocation(param);
        }
        
        return param;
    }
    
    tsInAmbientContext(cb) {
        const {
            isAmbientContext: oldIsAmbientContext,
            strict: oldStrict,
        } = this.state;
        
        this.state.isAmbientContext = true;
        this.state.strict = false;
        try {
            return cb();
        } finally {
            this.state.isAmbientContext = oldIsAmbientContext;
            this.state.strict = oldStrict;
        }
    }
    
    parseClass(node, isStatement5, optionalId) {
        const oldInAbstractClass = this.state.inAbstractClass;
        
        this.state.inAbstractClass = !!node.abstract;
        try {
            return super.parseClass(node, isStatement5, optionalId);
        } finally {
            this.state.inAbstractClass = oldInAbstractClass;
        }
    }
    
    tsParseAbstractDeclaration(node, decorators) {
        if (this.match(80)) {
            node.abstract = true;
            return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));
        } else if (this.isContextual(129)) {
            if (!this.hasFollowingLineBreak()) {
                node.abstract = true;
                this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifier, node);
                return this.tsParseInterfaceDeclaration(node);
            }
        } else {
            this.unexpected(null, 80);
        }
    }
    
    parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
        const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        
        if (method.abstract || method.type === 'TSAbstractMethodDefinition') {
            const hasEstreePlugin = this.hasPlugin('estree');
            const methodFn = hasEstreePlugin ? method.value : method;
            
            if (methodFn.body) {
                const {key} = method;
                
                this.raise(TSErrors.AbstractMethodHasImplementation, method, {
                    methodName: key.type === 'Identifier' && !method.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`,
                });
            }
        }
        
        return method;
    }
    
    tsParseTypeParameterName() {
        const typeName = this.parseIdentifier();
        return typeName;
    }
    
    shouldParseAsAmbientContext() {
        return !!this.getPluginOption('typescript', 'dts');
    }
    
    parse() {
        if (this.shouldParseAsAmbientContext()) {
            this.state.isAmbientContext = true;
        }
        
        return super.parse();
    }
    
    getExpression() {
        if (this.shouldParseAsAmbientContext()) {
            this.state.isAmbientContext = true;
        }
        
        return super.getExpression();
    }
    
    parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
        if (!isString && isMaybeTypeOnly) {
            this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
            return this.finishNode(node, 'ExportSpecifier');
        }
        
        node.exportKind = 'value';
        return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);
    }
    
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        if (!importedIsString && isMaybeTypeOnly) {
            this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
            return this.finishNode(specifier, 'ImportSpecifier');
        }
        
        specifier.importKind = 'value';
        return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);
    }
    
    parseTypeOnlyImportExportSpecifier(node, isImport2, isInTypeOnlyImportExport) {
        const leftOfAsKey = isImport2 ? 'imported' : 'local';
        const rightOfAsKey = isImport2 ? 'local' : 'exported';
        let leftOfAs = node[leftOfAsKey];
        let rightOfAs;
        let hasTypeSpecifier = false;
        let canParseAsKeyword = true;
        const loc = leftOfAs.loc.start;
        
        if (this.isContextual(93)) {
            const firstAs = this.parseIdentifier();
            
            if (this.isContextual(93)) {
                const secondAs = this.parseIdentifier();
                
                if (tokenIsKeywordOrIdentifier(this.state.type)) {
                    hasTypeSpecifier = true;
                    leftOfAs = firstAs;
                    rightOfAs = isImport2 ? this.parseIdentifier() : this.parseModuleExportName();
                    canParseAsKeyword = false;
                } else {
                    rightOfAs = secondAs;
                    canParseAsKeyword = false;
                }
            } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
                canParseAsKeyword = false;
                rightOfAs = isImport2 ? this.parseIdentifier() : this.parseModuleExportName();
            } else {
                hasTypeSpecifier = true;
                leftOfAs = firstAs;
            }
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            hasTypeSpecifier = true;
            
            if (isImport2) {
                leftOfAs = this.parseIdentifier(true);
                
                if (!this.isContextual(93)) {
                    this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
                }
            } else {
                leftOfAs = this.parseModuleExportName();
            }
        }
        
        if (hasTypeSpecifier && isInTypeOnlyImportExport) {
            this.raise(isImport2 ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);
        }
        
        node[leftOfAsKey] = leftOfAs;
        node[rightOfAsKey] = rightOfAs;
        const kindKey = isImport2 ? 'importKind' : 'exportKind';
        
        node[kindKey] = hasTypeSpecifier ? 'type' : 'value';
        
        if (canParseAsKeyword && this.eatContextual(93)) {
            node[rightOfAsKey] = isImport2 ? this.parseIdentifier() : this.parseModuleExportName();
        }
        
        if (!node[rightOfAsKey]) {
            node[rightOfAsKey] = this.cloneIdentifier(node[leftOfAsKey]);
        }
        
        if (isImport2) {
            this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
        }
    }
    
    fillOptionalPropertiesForTSESLint(node) {
        switch(node.type) {
        case 'ExpressionStatement':
            node.directive ?? (node.directive = void 0);
            return;
        
        case 'RestElement':
            node.value = void 0;
        
        case 'Identifier':        
        case 'ArrayPattern':        
        case 'AssignmentPattern':        
        case 'ObjectPattern':
            node.decorators ?? (node.decorators = []);
            node.optional ?? (node.optional = false);
            node.typeAnnotation ?? (node.typeAnnotation = void 0);
            return;
        
        case 'TSParameterProperty':
            node.accessibility ?? (node.accessibility = void 0);
            node.decorators ?? (node.decorators = []);
            node.override ?? (node.override = false);
            node.readonly ?? (node.readonly = false);
            node.static ?? (node.static = false);
            return;
        
        case 'TSEmptyBodyFunctionExpression':
            node.body = null;
        
        case 'TSDeclareFunction':        
        case 'FunctionDeclaration':        
        case 'FunctionExpression':        
        case 'ClassMethod':        
        case 'ClassPrivateMethod':
            node.declare ?? (node.declare = false);
            node.returnType ?? (node.returnType = void 0);
            node.typeParameters ?? (node.typeParameters = void 0);
            return;
        
        case 'Property':
            node.optional ?? (node.optional = false);
            return;
        
        case 'TSMethodSignature':        
        case 'TSPropertySignature':
            node.optional ?? (node.optional = false);
        
        case 'TSIndexSignature':
            node.accessibility ?? (node.accessibility = void 0);
            node.readonly ?? (node.readonly = false);
            node.static ?? (node.static = false);
            return;
        
        case 'TSAbstractPropertyDefinition':        
        case 'PropertyDefinition':        
        case 'TSAbstractAccessorProperty':        
        case 'AccessorProperty':
            node.declare ?? (node.declare = false);
            node.definite ?? (node.definite = false);
            node.readonly ?? (node.readonly = false);
            node.typeAnnotation ?? (node.typeAnnotation = void 0);
        
        case 'TSAbstractMethodDefinition':        
        case 'MethodDefinition':
            node.accessibility ?? (node.accessibility = void 0);
            node.decorators ?? (node.decorators = []);
            node.override ?? (node.override = false);
            node.optional ?? (node.optional = false);
            return;
        
        case 'ClassExpression':
            node.id ?? (node.id = null);
        
        case 'ClassDeclaration':
            node.abstract ?? (node.abstract = false);
            node.declare ?? (node.declare = false);
            node.decorators ?? (node.decorators = []);
            node.implements ?? (node.implements = []);
            node.superTypeArguments ?? (node.superTypeArguments = void 0);
            node.typeParameters ?? (node.typeParameters = void 0);
            return;
        
        case 'TSTypeAliasDeclaration':        
        case 'VariableDeclaration':
            node.declare ?? (node.declare = false);
            return;
        
        case 'VariableDeclarator':
            node.definite ?? (node.definite = false);
            return;
        
        case 'TSEnumDeclaration':
            node.const ?? (node.const = false);
            node.declare ?? (node.declare = false);
            return;
        
        case 'TSEnumMember':
            node.computed ?? (node.computed = false);
            return;
        
        case 'TSImportType':
            node.qualifier ?? (node.qualifier = null);
            node.options ?? (node.options = null);
 {
                node.typeArguments ?? (node.typeArguments = null);
            }
            
            return;
        
        case 'TSInterfaceDeclaration':
            node.declare ?? (node.declare = false);
            node.extends ?? (node.extends = []);
            return;
        
        case 'TSMappedType':
            node.optional ?? (node.optional = false);
            node.readonly ?? (node.readonly = void 0);
            return;
        
        case 'TSModuleDeclaration':
            node.declare ?? (node.declare = false);
            node.global ?? (node.global = node.kind === 'global');
            return;
        
        case 'TSTypeParameter':
            node.const ?? (node.const = false);
            node.in ?? (node.in = false);
            node.out ?? (node.out = false);
            return;
        }
    }
};

function isPossiblyLiteralEnum(expression2) {
    if (expression2.type !== 'MemberExpression')
        return false;
    
    const {computed, property} = expression2;
    
    if (computed && property.type !== 'StringLiteral' && (property.type !== 'TemplateLiteral' || property.expressions.length > 0)) {
        return false;
    }
    
    return isUncomputedMemberExpressionChain(expression2.object);
}

function isValidAmbientConstInitializer(expression2, estree2) {
    const {type} = expression2;
    
    if (expression2.extra?.parenthesized) {
        return false;
    }
    
    if (estree2) {
        if (type === 'Literal') {
            const {value} = expression2;
            
            if (typeof value === 'string' || typeof value === 'boolean') {
                return true;
            }
        }
    } else {
        if (type === 'StringLiteral' || type === 'BooleanLiteral') {
            return true;
        }
    }
    
    if (isNumber$3(expression2, estree2) || isNegativeNumber(expression2, estree2)) {
        return true;
    }
    
    if (type === 'TemplateLiteral' && expression2.expressions.length === 0) {
        return true;
    }
    
    if (isPossiblyLiteralEnum(expression2)) {
        return true;
    }
    
    return false;
}

function isNumber$3(expression2, estree2) {
    if (estree2) {
        return expression2.type === 'Literal' && (typeof expression2.value === 'number' || 'bigint' in expression2);
    }
    
    return expression2.type === 'NumericLiteral' || expression2.type === 'BigIntLiteral';
}

function isNegativeNumber(expression2, estree2) {
    if (expression2.type === 'UnaryExpression') {
        const {operator, argument} = expression2;
        
        if (operator === '-' && isNumber$3(argument, estree2)) {
            return true;
        }
    }
    
    return false;
}

function isUncomputedMemberExpressionChain(expression2) {
    if (expression2.type === 'Identifier')
        return true;
    
    if (expression2.type !== 'MemberExpression' || expression2.computed) {
        return false;
    }
    
    return isUncomputedMemberExpressionChain(expression2.object);
}

var PlaceholderErrors = ParseErrorEnum`placeholders`({
    ClassNameIsRequired: 'A class name is required.',
    UnexpectedSpace: 'Unexpected space in placeholder.',
});

var placeholders = (superClass) => class PlaceholdersParserMixin extends superClass {
    parsePlaceholder(expectedNode) {
        if (this.match(133)) {
            const node = this.startNode();
            this.next();
            this.assertNoSpace();
            node.name = super.parseIdentifier(true);
            this.assertNoSpace();
            this.expect(133);
            return this.finishPlaceholder(node, expectedNode);
        }
    }
    
    finishPlaceholder(node, expectedNode) {
        let placeholder2 = node;
        
        if (!placeholder2.expectedNode || !placeholder2.type) {
            placeholder2 = this.finishNode(placeholder2, 'Placeholder');
        }
        
        placeholder2.expectedNode = expectedNode;
        return placeholder2;
    }
    
    getTokenFromCode(code2) {
        if (code2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
            this.finishOp(133, 2);
        } else {
            super.getTokenFromCode(code2);
        }
    }
    
    parseExprAtom(refExpressionErrors) {
        return this.parsePlaceholder('Expression') || super.parseExprAtom(refExpressionErrors);
    }
    
    parseIdentifier(liberal) {
        return this.parsePlaceholder('Identifier') || super.parseIdentifier(liberal);
    }
    
    checkReservedWord(word, startLoc, checkKeywords, isBinding3) {
        if (word !== void 0) {
            super.checkReservedWord(word, startLoc, checkKeywords, isBinding3);
        }
    }
    
    cloneIdentifier(node) {
        const cloned = super.cloneIdentifier(node);
        
        if (cloned.type === 'Placeholder') {
            cloned.expectedNode = node.expectedNode;
        }
        
        return cloned;
    }
    
    cloneStringLiteral(node) {
        if (node.type === 'Placeholder') {
            return this.cloneIdentifier(node);
        }
        
        return super.cloneStringLiteral(node);
    }
    
    parseBindingAtom() {
        return this.parsePlaceholder('Pattern') || super.parseBindingAtom();
    }
    
    isValidLVal(type, isParenthesized, binding) {
        return type === 'Placeholder' || super.isValidLVal(type, isParenthesized, binding);
    }
    
    toAssignable(node, isLHS) {
        if (node && node.type === 'Placeholder' && node.expectedNode === 'Expression') {
            node.expectedNode = 'Pattern';
        } else {
            super.toAssignable(node, isLHS);
        }
    }
    
    chStartsBindingIdentifier(ch, pos) {
        if (super.chStartsBindingIdentifier(ch, pos)) {
            return true;
        }
        
        const next = this.nextTokenStart();
        
        if (this.input.charCodeAt(next) === 37 && this.input.charCodeAt(next + 1) === 37) {
            return true;
        }
        
        return false;
    }
    
    verifyBreakContinue(node, isBreak) {
        if (node.label && node.label.type === 'Placeholder')
            return;
        
        super.verifyBreakContinue(node, isBreak);
    }
    
    parseExpressionStatement(node, expr) {
        if (expr.type !== 'Placeholder' || expr.extra?.parenthesized) {
            return super.parseExpressionStatement(node, expr);
        }
        
        if (this.match(14)) {
            const stmt = node;
            
            stmt.label = this.finishPlaceholder(expr, 'Identifier');
            this.next();
            stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();
            return this.finishNode(stmt, 'LabeledStatement');
        }
        
        this.semicolon();
        const stmtPlaceholder = node;
        
        stmtPlaceholder.name = expr.name;
        return this.finishPlaceholder(stmtPlaceholder, 'Statement');
    }
    
    parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
        return this.parsePlaceholder('BlockStatement') || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
    }
    
    parseFunctionId(requireId) {
        return this.parsePlaceholder('Identifier') || super.parseFunctionId(requireId);
    }
    
    parseClass(node, isStatement5, optionalId) {
        const type = isStatement5 ? 'ClassDeclaration' : 'ClassExpression';
        this.next();
        const oldStrict = this.state.strict;
        const placeholder2 = this.parsePlaceholder('Identifier');
        
        if (placeholder2) {
            if (this.match(81) || this.match(133) || this.match(5)) {
                node.id = placeholder2;
            } else if (optionalId || !isStatement5) {
                node.id = null;
                node.body = this.finishPlaceholder(placeholder2, 'ClassBody');
                return this.finishNode(node, type);
            } else {
                throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);
            }
        } else {
            this.parseClassId(node, isStatement5, optionalId);
        }
        
        super.parseClassSuper(node);
        node.body = this.parsePlaceholder('ClassBody') || super.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, type);
    }
    
    parseExport(node, decorators) {
        const placeholder2 = this.parsePlaceholder('Identifier');
        
        if (!placeholder2)
            return super.parseExport(node, decorators);
        
        const node2 = node;
        
        if (!this.isContextual(98) && !this.match(12)) {
            node2.specifiers = [];
            node2.source = null;
            node2.declaration = this.finishPlaceholder(placeholder2, 'Declaration');
            return this.finishNode(node2, 'ExportNamedDeclaration');
        }
        
        this.expectPlugin('exportDefaultFrom');
        const specifier = this.startNode();
        
        specifier.exported = placeholder2;
        node2.specifiers = [
            this.finishNode(specifier, 'ExportDefaultSpecifier'),
        ];
        return super.parseExport(node2, decorators);
    }
    
    isExportDefaultSpecifier() {
        if (this.match(65)) {
            const next = this.nextTokenStart();
            
            if (this.isUnparsedContextual(next, 'from')) {
                if (this.input.startsWith(tokenLabelName(133), this.nextTokenStartSince(next + 4))) {
                    return true;
                }
            }
        }
        
        return super.isExportDefaultSpecifier();
    }
    
    maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
        if (node.specifiers?.length) {
            return true;
        }
        
        return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
    }
    
    checkExport(node) {
        const {specifiers} = node;
        
        if (specifiers?.length) {
            node.specifiers = specifiers.filter((node2) => node2.exported.type === 'Placeholder');
        }
        
        super.checkExport(node);
        node.specifiers = specifiers;
    }
    
    parseImport(node) {
        const placeholder2 = this.parsePlaceholder('Identifier');
        
        if (!placeholder2)
            return super.parseImport(node);
        
        node.specifiers = [];
        
        if (!this.isContextual(98) && !this.match(12)) {
            node.source = this.finishPlaceholder(placeholder2, 'StringLiteral');
            this.semicolon();
            return this.finishNode(node, 'ImportDeclaration');
        }
        
        const specifier = this.startNodeAtNode(placeholder2);
        
        specifier.local = placeholder2;
        node.specifiers.push(this.finishNode(specifier, 'ImportDefaultSpecifier'));
        
        if (this.eat(12)) {
            const hasStarImport = this.maybeParseStarImportSpecifier(node);
            
            if (!hasStarImport)
                this.parseNamedImportSpecifiers(node);
        }
        
        this.expectContextual(98);
        node.source = this.parseImportSource();
        this.semicolon();
        return this.finishNode(node, 'ImportDeclaration');
    }
    
    parseImportSource() {
        return this.parsePlaceholder('StringLiteral') || super.parseImportSource();
    }
    
    assertNoSpace() {
        if (this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index)) {
            this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);
        }
    }
};

var v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {
    parseV8Intrinsic() {
        if (this.match(54)) {
            const v8IntrinsicStartLoc = this.state.startLoc;
            const node = this.startNode();
            this.next();
            
            if (tokenIsIdentifier(this.state.type)) {
                const name = this.parseIdentifierName();
                const identifier4 = this.createIdentifier(node, name);
                this.castNodeTo(identifier4, 'V8IntrinsicIdentifier');
                
                if (this.match(10)) {
                    return identifier4;
                }
            }
            
            this.unexpected(v8IntrinsicStartLoc);
        }
    }
    
    parseExprAtom(refExpressionErrors) {
        return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
    }
};

var PIPELINE_PROPOSALS = [
    'fsharp',
    'hack',
];
var TOPIC_TOKENS = [
    '^^',
    '@@',
    '^',
    '%',
    '#',
];

function validatePlugins(pluginsMap) {
    if (pluginsMap.has('decorators')) {
        if (pluginsMap.has('decorators-legacy')) {
            throw new Error('Cannot use the decorators and decorators-legacy plugin together');
        }
        
        const decoratorsBeforeExport = pluginsMap.get('decorators').decoratorsBeforeExport;
        
        if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== 'boolean') {
            throw new Error('\'decoratorsBeforeExport\' must be a boolean, if specified.');
        }
        
        const allowCallParenthesized = pluginsMap.get('decorators').allowCallParenthesized;
        
        if (allowCallParenthesized != null && typeof allowCallParenthesized !== 'boolean') {
            throw new Error('\'allowCallParenthesized\' must be a boolean.');
        }
    }
    
    if (pluginsMap.has('flow') && pluginsMap.has('typescript')) {
        throw new Error('Cannot combine flow and typescript plugins.');
    }
    
    if (pluginsMap.has('placeholders') && pluginsMap.has('v8intrinsic')) {
        throw new Error('Cannot combine placeholders and v8intrinsic plugins.');
    }
    
    if (pluginsMap.has('pipelineOperator')) {
        const proposal = pluginsMap.get('pipelineOperator').proposal;
        
        if (!PIPELINE_PROPOSALS.includes(proposal)) {
            const proposalList = PIPELINE_PROPOSALS
                .map((p) => `"${p}"`)
                .join(', ');
            throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
        }
        
        if (proposal === 'hack') {
            if (pluginsMap.has('placeholders')) {
                throw new Error('Cannot combine placeholders plugin and Hack-style pipes.');
            }
            
            if (pluginsMap.has('v8intrinsic')) {
                throw new Error('Cannot combine v8intrinsic plugin and Hack-style pipes.');
            }
            
            const topicToken = pluginsMap.get('pipelineOperator').topicToken;
            
            if (!TOPIC_TOKENS.includes(topicToken)) {
                const tokenList = TOPIC_TOKENS
                    .map((t) => `"${t}"`)
                    .join(', ');
                throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
            }
        }
    }
    
    if (pluginsMap.has('moduleAttributes')) {
        {
            throw new Error('`moduleAttributes` has been removed in Babel 8, please migrate to import attributes instead.');
        }
    }
    
    if (pluginsMap.has('importAssertions')) {
        {
            throw new Error('`importAssertions` has been removed in Babel 8, please use import attributes instead. To use the non-standard `assert` syntax you can enable the `deprecatedImportAssert` parser plugin.');
        }
    }
    
    if (!pluginsMap.has('deprecatedImportAssert') && pluginsMap.has('importAttributes') && pluginsMap.get('importAttributes').deprecatedAssertSyntax) {
        {
            throw new Error('The \'importAttributes\' plugin has been removed in Babel 8. If you need to enable support for the deprecated `assert` syntax, you can enable the `deprecatedImportAssert` parser plugin.');
        }
    }
    
    if (pluginsMap.has('recordAndTuple')) {
        {
            throw new Error('The \'recordAndTuple\' plugin has been removed in Babel 8. Please remove it from your configuration.');
        }
    }
    
    if (pluginsMap.has('asyncDoExpressions') && !pluginsMap.has('doExpressions')) {
        const error = new Error('\'asyncDoExpressions\' requires \'doExpressions\', please add \'doExpressions\' to parser plugins.');
        
        error.missingPlugins = 'doExpressions';
        throw error;
    }
    
    if (pluginsMap.has('optionalChainingAssign') && pluginsMap.get('optionalChainingAssign').version !== '2023-07') {
        throw new Error('The \'optionalChainingAssign\' plugin requires a \'version\' option, representing the last proposal update. Currently, the only supported value is \'2023-07\'.');
    }
    
    if (pluginsMap.has('discardBinding') && pluginsMap.get('discardBinding').syntaxType !== 'void') {
        throw new Error('The \'discardBinding\' plugin requires a \'syntaxType\' option. Currently the only supported value is \'void\'.');
    }
    
    {
        if (pluginsMap.has('decimal')) {
            throw new Error('The \'decimal\' plugin has been removed in Babel 8. Please remove it from your configuration.');
        }
        
        if (pluginsMap.has('importReflection')) {
            throw new Error('The \'importReflection\' plugin has been removed in Babel 8. Use \'sourcePhaseImports\' instead, and replace \'import module\' with \'import source\' in your code.');
        }
    }
}

var mixinPlugins = {
    estree,
    jsx: jsx$3,
    typescript: typescript$3,
    v8intrinsic,
    placeholders,
};

var mixinPluginNames = Object.keys(mixinPlugins);

var ExpressionParser = class extends LValParser {
    checkProto(prop, isRecord, sawProto, refExpressionErrors) {
        if (prop.type === 'SpreadElement' || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
            return sawProto;
        }
        
        const key = prop.key;
        const name = key.type === 'Identifier' ? key.name : key.value;
        
        if (name === '__proto__') {
            if (isRecord) {
                this.raise(Errors.RecordNoProto, key);
                return true;
            }
            
            if (sawProto) {
                if (refExpressionErrors) {
                    if (refExpressionErrors.doubleProtoLoc === null) {
                        refExpressionErrors.doubleProtoLoc = key.loc.start;
                    }
                } else {
                    this.raise(Errors.DuplicateProto, key);
                }
            }
            
            return true;
        }
        
        return sawProto;
    }
    
    shouldExitDescending(expr, potentialArrowAt) {
        return expr.type === 'ArrowFunctionExpression' && this.offsetToSourcePos(expr.start) === potentialArrowAt;
    }
    
    getExpression() {
        this.enterInitialScopes();
        this.nextToken();
        
        if (this.match(140)) {
            throw this.raise(Errors.ParseExpressionEmptyInput, this.state.startLoc);
        }
        
        const expr = this.parseExpression();
        
        if (!this.match(140)) {
            throw this.raise(Errors.ParseExpressionExpectsEOF, this.state.startLoc, {
                unexpected: this.input.codePointAt(this.state.start),
            });
        }
        
        this.finalizeRemainingComments();
        expr.comments = this.comments;
        expr.errors = this.state.errors;
        
        if (this.optionFlags & 256) {
            expr.tokens = this.tokens;
        }
        
        return expr;
    }
    
    parseExpression(disallowIn, refExpressionErrors) {
        if (disallowIn) {
            return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
        }
        
        return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
    }
    
    parseExpressionBase(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const expr = this.parseMaybeAssign(refExpressionErrors);
        
        if (this.match(12)) {
            const node = this.startNodeAt(startLoc);
            
            node.expressions = [expr];
            while (this.eat(12)) {
                node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
            }
            
            this.toReferencedList(node.expressions);
            return this.finishNode(node, 'SequenceExpression');
        }
        
        return expr;
    }
    
    parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
        return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
    }
    
    parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
        return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
    }
    
    setOptionalParametersError(refExpressionErrors) {
        refExpressionErrors.optionalParametersLoc = this.state.startLoc;
    }
    
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        const startLoc = this.state.startLoc;
        const isYield = this.isContextual(108);
        
        if (isYield) {
            if (this.prodParam.hasYield) {
                this.next();
                let left2 = this.parseYield(startLoc);
                
                if (afterLeftParse) {
                    left2 = afterLeftParse.call(this, left2, startLoc);
                }
                
                return left2;
            }
        }
        
        let ownExpressionErrors;
        
        if (refExpressionErrors) {
            ownExpressionErrors = false;
        } else {
            refExpressionErrors = new ExpressionErrors();
            ownExpressionErrors = true;
        }
        
        const {type} = this.state;
        
        if (type === 10 || tokenIsIdentifier(type)) {
            this.state.potentialArrowAt = this.state.start;
        }
        
        let left = this.parseMaybeConditional(refExpressionErrors);
        
        if (afterLeftParse) {
            left = afterLeftParse.call(this, left, startLoc);
        }
        
        if (tokenIsAssignment(this.state.type)) {
            const node = this.startNodeAt(startLoc);
            const operator = this.state.value;
            
            node.operator = operator;
            
            if (this.match(29)) {
                this.toAssignable(left, true);
                node.left = left;
                const startIndex = startLoc.index;
                
                if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
                    refExpressionErrors.doubleProtoLoc = null;
                }
                
                if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
                    refExpressionErrors.shorthandAssignLoc = null;
                }
                
                if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
                    this.checkDestructuringPrivate(refExpressionErrors);
                    refExpressionErrors.privateKeyLoc = null;
                }
                
                if (refExpressionErrors.voidPatternLoc != null && refExpressionErrors.voidPatternLoc.index >= startIndex) {
                    refExpressionErrors.voidPatternLoc = null;
                }
            } else {
                node.left = left;
            }
            
            this.next();
            node.right = this.parseMaybeAssign();
            this.checkLVal(left, this.finishNode(node, 'AssignmentExpression'));
            return node;
        } else if (ownExpressionErrors) {
            this.checkExpressionErrors(refExpressionErrors, true);
        }
        
        if (isYield) {
            const {type: type2} = this.state;
            
            const startsExpr2 = this.hasPlugin('v8intrinsic') ? tokenCanStartExpression(type2) : tokenCanStartExpression(type2) && !this.match(54);
            
            if (startsExpr2 && !this.isAmbiguousPrefixOrIdentifier()) {
                this.raiseOverwrite(Errors.YieldNotInGeneratorFunction, startLoc);
                return this.parseYield(startLoc);
            }
        }
        
        return left;
    }
    
    parseMaybeConditional(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprOps(refExpressionErrors);
        
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
        }
        
        return this.parseConditional(expr, startLoc, refExpressionErrors);
    }
    
    parseConditional(expr, startLoc, refExpressionErrors) {
        if (this.eat(17)) {
            const node = this.startNodeAt(startLoc);
            
            node.test = expr;
            node.consequent = this.parseMaybeAssignAllowIn();
            this.expect(14);
            node.alternate = this.parseMaybeAssign();
            return this.finishNode(node, 'ConditionalExpression');
        }
        
        return expr;
    }
    
    parseMaybeUnaryOrPrivate(refExpressionErrors) {
        return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
    }
    
    parseExprOps(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
        
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
        }
        
        return this.parseExprOp(expr, startLoc, -1);
    }
    
    parseExprOp(left, leftStartLoc, minPrec) {
        if (this.isPrivateName(left)) {
            const value = this.getPrivateNameSV(left);
            
            if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
                this.raise(Errors.PrivateInExpectedIn, left, {
                    identifierName: value,
                });
            }
            
            this.classScope.usePrivateName(value, left.loc.start);
        }
        
        const op = this.state.type;
        
        if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
            let prec = tokenOperatorPrecedence(op);
            
            if (prec > minPrec) {
                if (op === 39) {
                    this.expectPlugin('pipelineOperator');
                    
                    if (this.state.inFSharpPipelineDirectBody) {
                        return left;
                    }
                    
                    this.checkPipelineAtInfixOperator(left, leftStartLoc);
                }
                
                const node = this.startNodeAt(leftStartLoc);
                
                node.left = left;
                node.operator = this.state.value;
                const logical = op === 41 || op === 42;
                const coalesce = op === 40;
                
                if (coalesce) {
                    prec = tokenOperatorPrecedence(42);
                }
                
                this.next();
                node.right = this.parseExprOpRightExpr(op, prec);
                const finishedNode = this.finishNode(node, logical || coalesce ? 'LogicalExpression' : 'BinaryExpression');
                const nextOp = this.state.type;
                
                if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
                    throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);
                }
                
                return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
            }
        }
        
        return left;
    }
    
    parseExprOpRightExpr(op, prec) {
        this.state.startLoc;
        switch(op) {
        case 39:
            switch(this.getPluginOption('pipelineOperator', 'proposal')) {
            case 'hack':
                return this.withTopicBindingContext(() => {
                    return this.parseHackPipeBody();
                });
            
            case 'fsharp':
                return this.withSoloAwaitPermittingContext(() => {
                    return this.parseFSharpPipelineBody(prec);
                });
            }
        
        default:
            return this.parseExprOpBaseRightExpr(op, prec);
        }
    }
    
    parseExprOpBaseRightExpr(op, prec) {
        const startLoc = this.state.startLoc;
        return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
    }
    
    parseHackPipeBody() {
        const {startLoc} = this.state;
        
        const body = this.parseMaybeAssign();
        const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
        
        if (requiredParentheses && !body.extra?.parenthesized) {
            this.raise(Errors.PipeUnparenthesizedBody, startLoc, {
                type: body.type,
            });
        }
        
        if (!this.topicReferenceWasUsedInCurrentContext()) {
            this.raise(Errors.PipeTopicUnused, startLoc);
        }
        
        return body;
    }
    
    checkExponentialAfterUnary(node) {
        if (this.match(57)) {
            this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);
        }
    }
    
    parseMaybeUnary(refExpressionErrors, sawUnary) {
        const startLoc = this.state.startLoc;
        const isAwait = this.isContextual(96);
        
        if (isAwait && this.recordAwaitIfAllowed()) {
            this.next();
            const expr2 = this.parseAwait(startLoc);
            
            if (!sawUnary)
                this.checkExponentialAfterUnary(expr2);
            
            return expr2;
        }
        
        const update = this.match(34);
        const node = this.startNode();
        
        if (tokenIsPrefix(this.state.type)) {
            node.operator = this.state.value;
            node.prefix = true;
            
            if (this.match(72)) {
                this.expectPlugin('throwExpressions');
            }
            
            const isDelete = this.match(89);
            this.next();
            node.argument = this.parseMaybeUnary(null, true);
            this.checkExpressionErrors(refExpressionErrors, true);
            
            if (this.state.strict && isDelete) {
                const arg = node.argument;
                
                if (arg.type === 'Identifier') {
                    this.raise(Errors.StrictDelete, node);
                } else if (this.hasPropertyAsPrivateName(arg)) {
                    this.raise(Errors.DeletePrivateField, node);
                }
            }
            
            if (!update) {
                if (!sawUnary) {
                    this.checkExponentialAfterUnary(node);
                }
                
                return this.finishNode(node, 'UnaryExpression');
            }
        }
        
        const expr = this.parseUpdate(node, update, refExpressionErrors);
        
        if (isAwait) {
            const {type} = this.state;
            
            const startsExpr2 = this.hasPlugin('v8intrinsic') ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
            
            if (startsExpr2 && !this.isAmbiguousPrefixOrIdentifier()) {
                this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);
                return this.parseAwait(startLoc);
            }
        }
        
        return expr;
    }
    
    parseUpdate(node, update, refExpressionErrors) {
        if (update) {
            const updateExpressionNode = node;
            this.checkLVal(updateExpressionNode.argument, this.finishNode(
                updateExpressionNode,
                'UpdateExpression',
            ));
            return node;
        }
        
        const startLoc = this.state.startLoc;
        let expr = this.parseExprSubscripts(refExpressionErrors);
        
        if (this.checkExpressionErrors(refExpressionErrors, false))
            return expr;
        
        while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
            const node2 = this.startNodeAt(startLoc);
            
            node2.operator = this.state.value;
            node2.prefix = false;
            node2.argument = expr;
            this.next();
            this.checkLVal(expr, expr = this.finishNode(node2, 'UpdateExpression'));
        }
        
        return expr;
    }
    
    parseExprSubscripts(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprAtom(refExpressionErrors);
        
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
        }
        
        return this.parseSubscripts(expr, startLoc);
    }
    
    parseSubscripts(base, startLoc, noCalls) {
        const state = {
            optionalChainMember: false,
            maybeAsyncArrow: this.atPossibleAsyncArrow(base),
            stop: false,
        };
        
        do {
            base = this.parseSubscript(base, startLoc, noCalls, state);
            state.maybeAsyncArrow = false;
        } while (!state.stop)
        
        return base;
    }
    
    parseSubscript(base, startLoc, noCalls, state) {
        const {type} = this.state;
        
        if (!noCalls && type === 15) {
            return this.parseBind(base, startLoc, noCalls, state);
        } else if (tokenIsTemplate(type)) {
            return this.parseTaggedTemplateExpression(base, startLoc, state);
        }
        
        let optional = false;
        
        if (type === 18) {
            if (noCalls) {
                this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);
                
                if (this.lookaheadCharCode() === 40) {
                    return this.stopParseSubscript(base, state);
                }
            }
            
            state.optionalChainMember =
            optional = true;
            this.next();
        }
        
        if (!noCalls && this.match(10)) {
            return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
        } else {
            const computed = this.eat(0);
            
            if (computed || optional || this.eat(16)) {
                return this.parseMember(base, startLoc, state, computed, optional);
            } else {
                return this.stopParseSubscript(base, state);
            }
        }
    }
    
    stopParseSubscript(base, state) {
        state.stop = true;
        return base;
    }
    
    parseMember(base, startLoc, state, computed, optional) {
        const node = this.startNodeAt(startLoc);
        
        node.object = base;
        node.computed = computed;
        
        if (computed) {
            node.property = this.parseExpression();
            this.expect(3);
        } else if (this.match(139)) {
            if (base.type === 'Super') {
                this.raise(Errors.SuperPrivateField, startLoc);
            }
            
            this.classScope.usePrivateName(this.state.value, this.state.startLoc);
            node.property = this.parsePrivateName();
        } else {
            node.property = this.parseIdentifier(true);
        }
        
        if (state.optionalChainMember) {
            node.optional = optional;
            return this.finishNode(node, 'OptionalMemberExpression');
        } else {
            return this.finishNode(node, 'MemberExpression');
        }
    }
    
    parseBind(base, startLoc, noCalls, state) {
        const node = this.startNodeAt(startLoc);
        
        node.object = base;
        this.next();
        node.callee = this.parseNoCallExpr();
        state.stop = true;
        return this.parseSubscripts(this.finishNode(node, 'BindExpression'), startLoc, noCalls);
    }
    
    parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        let refExpressionErrors = null;
        
        this.state.maybeInArrowParameters = true;
        this.next();
        const node = this.startNodeAt(startLoc);
        
        node.callee = base;
        const {
            maybeAsyncArrow,
            optionalChainMember,
        } = state;
        
        if (maybeAsyncArrow) {
            this.expressionScope.enter(newAsyncArrowScope());
            refExpressionErrors = new ExpressionErrors();
        }
        
        if (optionalChainMember) {
            node.optional = optional;
        }
        
        if (optional) {
            node.arguments = this.parseCallExpressionArguments();
        } else {
            node.arguments = this.parseCallExpressionArguments(base.type !== 'Super', node, refExpressionErrors);
        }
        
        let finishedNode = this.finishCallExpression(node, optionalChainMember);
        
        if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
            state.stop = true;
            this.checkDestructuringPrivate(refExpressionErrors);
            this.expressionScope.validateAsPattern();
            this.expressionScope.exit();
            finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
        } else {
            if (maybeAsyncArrow) {
                this.checkExpressionErrors(refExpressionErrors, true);
                this.expressionScope.exit();
            }
            
            this.toReferencedArguments(finishedNode);
        }
        
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return finishedNode;
    }
    
    toReferencedArguments(node, isParenthesizedExpr) {
        this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
    }
    
    parseTaggedTemplateExpression(base, startLoc, state) {
        const node = this.startNodeAt(startLoc);
        
        node.tag = base;
        node.quasi = this.parseTemplate(true);
        
        if (state.optionalChainMember) {
            this.raise(Errors.OptionalChainingNoTemplate, startLoc);
        }
        
        return this.finishNode(node, 'TaggedTemplateExpression');
    }
    
    atPossibleAsyncArrow(base) {
        return base.type === 'Identifier'
            && base.name === 'async'
            && this.state.lastTokEndLoc.index === base.end
            && !this.canInsertSemicolon()
            && base.end - base.start === 5
            && this.offsetToSourcePos(base.start) === this.state.potentialArrowAt;
    }
    
    finishCallExpression(node, optional) {
        if (node.callee.type === 'Import') {
            if (node.arguments.length === 0 || node.arguments.length > 2) {
                this.raise(Errors.ImportCallArity, node);
            } else {
                for (const arg of node.arguments) {
                    if (arg.type === 'SpreadElement') {
                        this.raise(Errors.ImportCallSpreadArgument, arg);
                    }
                }
            }
        }
        
        return this.finishNode(node, optional ? 'OptionalCallExpression' : 'CallExpression');
    }
    
    parseCallExpressionArguments(allowPlaceholder, nodeForExtra, refExpressionErrors) {
        const elts = [];
        let first = true;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        
        this.state.inFSharpPipelineDirectBody = false;
        while (!this.eat(11)) {
            if (first) {
                first = false;
            } else {
                this.expect(12);
                
                if (this.match(11)) {
                    if (nodeForExtra) {
                        this.addTrailingCommaExtraToNode(nodeForExtra);
                    }
                    
                    this.next();
                    break;
                }
            }
            
            elts.push(this.parseExprListItem(
                11,
                false,
                refExpressionErrors,
                allowPlaceholder,
            ));
        }
        
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return elts;
    }
    
    shouldParseAsyncArrow() {
        return this.match(19) && !this.canInsertSemicolon();
    }
    
    parseAsyncArrowFromCallExpression(node, call2) {
        this.resetPreviousNodeTrailingComments(call2);
        this.expect(19);
        this.parseArrowExpression(node, call2.arguments, true, call2.extra?.trailingCommaLoc);
        
        if (call2.innerComments) {
            setInnerComments(node, call2.innerComments);
        }
        
        if (call2.callee.trailingComments) {
            setInnerComments(node, call2.callee.trailingComments);
        }
        
        return node;
    }
    
    parseNoCallExpr() {
        const startLoc = this.state.startLoc;
        return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
    }
    
    parseExprAtom(refExpressionErrors) {
        let node;
        let decorators = null;
        const {type} = this.state;
        
        switch(type) {
        case 79:
            return this.parseSuper();
        
        case 83:
            node = this.startNode();
            this.next();
            
            if (this.match(16)) {
                return this.parseImportMetaPropertyOrPhaseCall(node);
            }
            
            if (this.match(10)) {
                if (this.optionFlags & 512) {
                    return this.parseImportCall(node);
                } else {
                    return this.finishNode(node, 'Import');
                }
            } else {
                this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);
                return this.finishNode(node, 'Import');
            }
        
        case 78:
            node = this.startNode();
            this.next();
            return this.finishNode(node, 'ThisExpression');
        
        case 90: {
            return this.parseDo(this.startNode(), false);
        }
        
        case 56:        
        case 31: {
            this.readRegexp();
            return this.parseRegExpLiteral(this.state.value);
        }
        
        case 135:
            return this.parseNumericLiteral(this.state.value);
        
        case 136:
            return this.parseBigIntLiteral(this.state.value);
        
        case 134:
            return this.parseStringLiteral(this.state.value);
        
        case 84:
            return this.parseNullLiteral();
        
        case 85:
            return this.parseBooleanLiteral(true);
        
        case 86:
            return this.parseBooleanLiteral(false);
        
        case 10: {
            const canBeArrow = this.state.potentialArrowAt === this.state.start;
            return this.parseParenAndDistinguishExpression(canBeArrow);
        }
        
        case 0: {
            return this.parseArrayLike(3, true, false, refExpressionErrors);
        }
        
        case 5: {
            return this.parseObjectLike(8, false, false, refExpressionErrors);
        }
        
        case 68:
            return this.parseFunctionOrFunctionSent();
        
        case 26:
            decorators = this.parseDecorators();
        
        case 80:
            return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
        
        case 77:
            return this.parseNewOrNewTarget();
        
        case 25:        
        case 24:
            return this.parseTemplate(false);
        
        case 15: {
            node = this.startNode();
            this.next();
            node.object = null;
            const callee = node.callee = this.parseNoCallExpr();
            
            if (callee.type === 'MemberExpression') {
                return this.finishNode(node, 'BindExpression');
            } else {
                throw this.raise(Errors.UnsupportedBind, callee);
            }
        }
        
        case 139: {
            this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {
                identifierName: this.state.value,
            });
            return this.parsePrivateName();
        }
        
        case 33: {
            return this.parseTopicReferenceThenEqualsSign(54, '%');
        }
        
        case 32: {
            return this.parseTopicReferenceThenEqualsSign(44, '^');
        }
        
        case 37:        
        case 38: {
            return this.parseTopicReference('hack');
        }
        
        case 44:        
        case 54:        
        case 27: {
            const pipeProposal = this.getPluginOption('pipelineOperator', 'proposal');
            
            if (pipeProposal) {
                return this.parseTopicReference(pipeProposal);
            }
            
            this.unexpected();
            break;
        }
        
        case 47: {
            const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
            
            if (isIdentifierStart2(lookaheadCh) || lookaheadCh === 62) {
                this.expectOnePlugin(['jsx', 'flow', 'typescript']);
            } else {
                this.unexpected();
            }
            
            break;
        }
        
        default:
            if (tokenIsIdentifier(type)) {
                if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {
                    return this.parseModuleExpression();
                }
                
                const canBeArrow = this.state.potentialArrowAt === this.state.start;
                const containsEsc = this.state.containsEsc;
                const id = this.parseIdentifier();
                
                if (!containsEsc && id.name === 'async' && !this.canInsertSemicolon()) {
                    const {type: type2} = this.state;
                    
                    if (type2 === 68) {
                        this.resetPreviousNodeTrailingComments(id);
                        this.next();
                        return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
                    } else if (tokenIsIdentifier(type2)) {
                        if (this.lookaheadCharCode() === 61) {
                            return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                        } else {
                            return id;
                        }
                    } else if (type2 === 90) {
                        this.resetPreviousNodeTrailingComments(id);
                        return this.parseDo(this.startNodeAtNode(id), true);
                    }

                }
                
                if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
                    this.next();
                    return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
                }
                
                return id;
            } else {
                this.unexpected();
            }
        }
    }
    
    parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
        const pipeProposal = this.getPluginOption('pipelineOperator', 'proposal');
        
        if (pipeProposal) {
            this.state.type = topicTokenType;
            this.state.value = topicTokenValue;
            this.state.pos--;
            this.state.end--;
            this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
            return this.parseTopicReference(pipeProposal);
        } else {
            this.unexpected();
        }
    }
    
    parseTopicReference(pipeProposal) {
        const node = this.startNode();
        const startLoc = this.state.startLoc;
        const tokenType = this.state.type;
        
        this.next();
        return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
    }
    
    finishTopicReference(node, startLoc, pipeProposal, tokenType) {
        if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
            {
                if (!this.topicReferenceIsAllowedInCurrentContext()) {
                    this.raise(Errors.PipeTopicUnbound, startLoc);
                }
                
                this.registerTopicReference();
                return this.finishNode(node, 'TopicReference');
            }
        } else {
            throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {
                token: tokenLabelName(tokenType),
            });
        }
    }
    
    testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
        switch(pipeProposal) {
        case 'hack': {
            return this.hasPlugin(['pipelineOperator', {
                topicToken: tokenLabelName(tokenType),
            }]);
        }
        
        case 'smart':
            return tokenType === 27;
        
        default:
            throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);
        }
    }
    
    parseAsyncArrowUnaryFunction(node) {
        this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
        const params = [
            this.parseIdentifier(),
        ];
        this.prodParam.exit();
        
        if (this.hasPrecedingLineBreak()) {
            this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());
        }
        
        this.expect(19);
        return this.parseArrowExpression(node, params, true);
    }
    
    parseDo(node, isAsync) {
        this.expectPlugin('doExpressions');
        
        if (isAsync) {
            this.expectPlugin('asyncDoExpressions');
        }
        
        node.async = isAsync;
        this.next();
        const oldLabels = this.state.labels;
        
        this.state.labels = [];
        
        if (isAsync) {
            this.prodParam.enter(2);
            node.body = this.parseBlock();
            this.prodParam.exit();
        } else {
            node.body = this.parseBlock();
        }
        
        this.state.labels = oldLabels;
        return this.finishNode(node, 'DoExpression');
    }
    
    parseSuper() {
        const node = this.startNode();
        this.next();
        
        if (this.match(10) && !this.scope.allowDirectSuper && !(this.optionFlags & 16)) {
            this.raise(Errors.SuperNotAllowed, node);
        } else if (!this.scope.allowSuper && !(this.optionFlags & 16)) {
            this.raise(Errors.UnexpectedSuper, node);
        }
        
        if (!this.match(10) && !this.match(0) && !this.match(16)) {
            this.raise(Errors.UnsupportedSuper, node);
        }
        
        return this.finishNode(node, 'Super');
    }
    
    parsePrivateName() {
        const node = this.startNode();
        const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
        const name = this.state.value;
        
        this.next();
        node.id = this.createIdentifier(id, name);
        return this.finishNode(node, 'PrivateName');
    }
    
    parseFunctionOrFunctionSent() {
        const node = this.startNode();
        this.next();
        
        if (this.prodParam.hasYield && this.match(16)) {
            const meta = this.createIdentifier(this.startNodeAtNode(node), 'function');
            this.next();
            
            if (this.match(103)) {
                this.expectPlugin('functionSent');
            } else if (!this.hasPlugin('functionSent')) {
                this.unexpected();
            }
            
            return this.parseMetaProperty(node, meta, 'sent');
        }
        
        return this.parseFunction(node);
    }
    
    parseMetaProperty(node, meta, propertyName) {
        node.meta = meta;
        const containsEsc = this.state.containsEsc;
        
        node.property = this.parseIdentifier(true);
        
        if (node.property.name !== propertyName || containsEsc) {
            this.raise(Errors.UnsupportedMetaProperty, node.property, {
                target: meta.name,
                onlyValidPropertyName: propertyName,
            });
        }
        
        return this.finishNode(node, 'MetaProperty');
    }
    
    parseImportMetaPropertyOrPhaseCall(node) {
        this.next();
        
        if (this.isContextual(105) || this.isContextual(97)) {
            const isSource = this.isContextual(105);
            this.expectPlugin(isSource ? 'sourcePhaseImports' : 'deferredImportEvaluation');
            this.next();
            node.phase = isSource ? 'source' : 'defer';
            return this.parseImportCall(node);
        } else {
            const id = this.createIdentifierAt(this.startNodeAtNode(node), 'import', this.state.lastTokStartLoc);
            
            if (this.isContextual(101)) {
                if (!this.inModule) {
                    this.raise(Errors.ImportMetaOutsideModule, id);
                }
                
                this.sawUnambiguousESM = true;
            }
            
            return this.parseMetaProperty(node, id, 'meta');
        }
    }
    
    parseLiteralAtNode(value, type, node) {
        this.addExtra(node, 'rawValue', value);
        this.addExtra(node, 'raw', this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
        node.value = value;
        this.next();
        return this.finishNode(node, type);
    }
    
    parseLiteral(value, type) {
        const node = this.startNode();
        return this.parseLiteralAtNode(value, type, node);
    }
    
    parseStringLiteral(value) {
        return this.parseLiteral(value, 'StringLiteral');
    }
    
    parseNumericLiteral(value) {
        return this.parseLiteral(value, 'NumericLiteral');
    }
    
    parseBigIntLiteral(value) {
        {
            let bigInt;
            
            try {
                bigInt = BigInt(value);
            } catch {
                bigInt = null;
            }


                        const node = this.parseLiteral(bigInt, 'BigIntLiteral');
            
            return node;
        }
    }
    
    parseDecimalLiteral(value) {
        return this.parseLiteral(value, 'DecimalLiteral');
    }
    
    parseRegExpLiteral(value) {
        const node = this.startNode();
        this.addExtra(node, 'raw', this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
        node.pattern = value.pattern;
        node.flags = value.flags;
        this.next();
        return this.finishNode(node, 'RegExpLiteral');
    }
    
    parseBooleanLiteral(value) {
        const node = this.startNode();
        
        node.value = value;
        this.next();
        return this.finishNode(node, 'BooleanLiteral');
    }
    
    parseNullLiteral() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, 'NullLiteral');
    }
    
    parseParenAndDistinguishExpression(canBeArrow) {
        const startLoc = this.state.startLoc;
        let val;
        this.next();
        this.expressionScope.enter(newArrowHeadScope());
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        
        this.state.maybeInArrowParameters = true;
        this.state.inFSharpPipelineDirectBody = false;
        const innerStartLoc = this.state.startLoc;
        const exprList = [];
        const refExpressionErrors = new ExpressionErrors();
        let first = true;
        let spreadStartLoc;
        let optionalCommaStartLoc;
        
        while (!this.match(11)) {
            if (first) {
                first = false;
            } else {
                this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
                
                if (this.match(11)) {
                    optionalCommaStartLoc = this.state.startLoc;
                    break;
                }
            }
            
            if (this.match(21)) {
                const spreadNodeStartLoc = this.state.startLoc;
                
                spreadStartLoc = this.state.startLoc;
                exprList.push(this.parseParenItem(
                    this.parseRestBinding(),
                    spreadNodeStartLoc,
                ));
                
                if (!this.checkCommaAfterRest(41)) {
                    break;
                }
            } else {
                exprList.push(this.parseMaybeAssignAllowInOrVoidPattern(
                    11,
                    refExpressionErrors,
                    this.parseParenItem,
                ));
            }
        }
        
        const innerEndLoc = this.state.lastTokEndLoc;
        this.expect(11);
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let arrowNode = this.startNodeAt(startLoc);
        
        if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
            this.checkDestructuringPrivate(refExpressionErrors);
            this.expressionScope.validateAsPattern();
            this.expressionScope.exit();
            this.parseArrowExpression(arrowNode, exprList, false);
            return arrowNode;
        }
        
        this.expressionScope.exit();
        
        if (!exprList.length) {
            this.unexpected(this.state.lastTokStartLoc);
        }
        
        if (optionalCommaStartLoc)
            this.unexpected(optionalCommaStartLoc);
        
        if (spreadStartLoc)
            this.unexpected(spreadStartLoc);
        
        this.checkExpressionErrors(refExpressionErrors, true);
        this.toReferencedListDeep(exprList, true);
        
        if (exprList.length > 1) {
            val = this.startNodeAt(innerStartLoc);
            val.expressions = exprList;
            this.finishNode(val, 'SequenceExpression');
            this.resetEndLocation(val, innerEndLoc);
        } else {
            val = exprList[0];
        }
        
        return this.wrapParenthesis(startLoc, val);
    }
    
    wrapParenthesis(startLoc, expression2) {
        if (!(this.optionFlags & 1024)) {
            this.addExtra(expression2, 'parenthesized', true);
            this.addExtra(expression2, 'parenStart', startLoc.index);
            this.takeSurroundingComments(expression2, startLoc.index, this.state.lastTokEndLoc.index);
            return expression2;
        }
        
        const parenExpression = this.startNodeAt(startLoc);
        
        parenExpression.expression = expression2;
        return this.finishNode(parenExpression, 'ParenthesizedExpression');
    }
    
    shouldParseArrow(params) {
        return !this.canInsertSemicolon();
    }
    
    parseArrow(node) {
        if (this.eat(19)) {
            return node;
        }
    }
    
    parseParenItem(node, startLoc) {
        return node;
    }
    
    parseNewOrNewTarget() {
        const node = this.startNode();
        this.next();
        
        if (this.match(16)) {
            const meta = this.createIdentifier(this.startNodeAtNode(node), 'new');
            this.next();
            const metaProp = this.parseMetaProperty(node, meta, 'target');
            
            if (!this.scope.allowNewTarget) {
                this.raise(Errors.UnexpectedNewTarget, metaProp);
            }
            
            return metaProp;
        }
        
        return this.parseNew(node);
    }
    
    parseNew(node) {
        this.parseNewCallee(node);
        
        if (this.eat(10)) {
            const args = this.parseExprList(11);
            this.toReferencedList(args);
            node.arguments = args;
        } else {
            node.arguments = [];
        }
        
        return this.finishNode(node, 'NewExpression');
    }
    
    parseNewCallee(node) {
        const isImport2 = this.match(83);
        const callee = this.parseNoCallExpr();
        
        node.callee = callee;
        
        if (isImport2 && (callee.type === 'Import' || callee.type === 'ImportExpression')) {
            this.raise(Errors.ImportCallNotNewExpression, callee);
        }
    }
    
    parseTemplateElement(isTagged) {
        const {
            start,
            startLoc,
            end,
            value,
        } = this.state;
        
        const elemStart = start + 1;
        const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
        
        if (value === null) {
            if (!isTagged) {
                this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));
            }
        }
        
        const isTail = this.match(24);
        const endOffset = isTail ? -1 : -2;
        const elemEnd = end + endOffset;
        
        elem.value = {
            raw: this
                .input
                .slice(elemStart, elemEnd)
                .replace(/\r\n?/g, '\n'),
            cooked: value === null ? null : value.slice(1, endOffset),
        };
        elem.tail = isTail;
        this.next();
        const finishedNode = this.finishNode(elem, 'TemplateElement');
        this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
        return finishedNode;
    }
    
    parseTemplate(isTagged) {
        const node = this.startNode();
        let curElt = this.parseTemplateElement(isTagged);
        const quasis = [curElt];
        const substitutions = [];
        
        while (!curElt.tail) {
            substitutions.push(this.parseTemplateSubstitution());
            this.readTemplateContinuation();
            quasis.push(curElt = this.parseTemplateElement(isTagged));
        }
        
        node.expressions = substitutions;
        node.quasis = quasis;
        return this.finishNode(node, 'TemplateLiteral');
    }
    
    parseTemplateSubstitution() {
        return this.parseExpression();
    }
    
    parseObjectLike(close, isPattern3, isRecord, refExpressionErrors) {
        if (isRecord) {
            this.expectPlugin('recordAndTuple');
        }
        
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        
        this.state.inFSharpPipelineDirectBody = false;
        let sawProto = false;
        let first = true;
        const node = this.startNode();
        
        node.properties = [];
        this.next();
        while (!this.match(close)) {
            if (first) {
                first = false;
            } else {
                this.expect(12);
                
                if (this.match(close)) {
                    this.addTrailingCommaExtraToNode(node);
                    break;
                }
            }
            
            let prop;
            
            if (isPattern3) {
                prop = this.parseBindingProperty();
            } else {
                prop = this.parsePropertyDefinition(refExpressionErrors);
                sawProto = this.checkProto(prop, isRecord, sawProto, refExpressionErrors);
            }
            
            if (isRecord && !this.isObjectProperty(prop) && prop.type !== 'SpreadElement') {
                this.raise(Errors.InvalidRecordProperty, prop);
            }
            
            node.properties.push(prop);
        }
        
        this.next();
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let type = 'ObjectExpression';
        
        if (isPattern3) {
            type = 'ObjectPattern';
        } else if (isRecord) {
            type = 'RecordExpression';
        }
        
        return this.finishNode(node, type);
    }
    
    addTrailingCommaExtraToNode(node) {
        this.addExtra(node, 'trailingComma', this.state.lastTokStartLoc.index);
        this.addExtra(node, 'trailingCommaLoc', this.state.lastTokStartLoc, false);
    }
    
    maybeAsyncOrAccessorProp(prop) {
        return !prop.computed && prop.key.type === 'Identifier'
            && (this.isLiteralPropertyName()
            || this.match(0)
            || this.match(55));
    }
    
    parsePropertyDefinition(refExpressionErrors) {
        let decorators = [];
        
        if (this.match(26)) {
            if (this.hasPlugin('decorators')) {
                this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);
            }
            
            while (this.match(26)) {
                decorators.push(this.parseDecorator());
            }
        }
        
        const prop = this.startNode();
        let isAsync = false;
        let isAccessor2 = false;
        let startLoc;
        
        if (this.match(21)) {
            if (decorators.length)
                this.unexpected();
            
            return this.parseSpread();
        }
        
        if (decorators.length) {
            prop.decorators = decorators;
            decorators = [];
        }
        
        prop.method = false;
        
        if (refExpressionErrors) {
            startLoc = this.state.startLoc;
        }
        
        let isGenerator = this.eat(55);
        this.parsePropertyNamePrefixOperator(prop);
        const containsEsc = this.state.containsEsc;
        this.parsePropertyName(prop, refExpressionErrors);
        
        if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
            const {key} = prop;
            
            const keyName = key.name;
            
            if (keyName === 'async' && !this.hasPrecedingLineBreak()) {
                isAsync = true;
                this.resetPreviousNodeTrailingComments(key);
                isGenerator = this.eat(55);
                this.parsePropertyName(prop);
            }
            
            if (keyName === 'get' || keyName === 'set') {
                isAccessor2 = true;
                this.resetPreviousNodeTrailingComments(key);
                prop.kind = keyName;
                
                if (this.match(55)) {
                    isGenerator = true;
                    this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {
                        kind: keyName,
                    });
                    this.next();
                }
                
                this.parsePropertyName(prop);
            }
        }
        
        return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor2, refExpressionErrors);
    }
    
    getGetterSetterExpectedParamCount(method) {
        return method.kind === 'get' ? 0 : 1;
    }
    
    getObjectOrClassMethodParams(method) {
        return method.params;
    }
    
    checkGetterSetterParams(method) {
        const paramCount = this.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        
        if (params.length !== paramCount) {
            this.raise(method.kind === 'get' ? Errors.BadGetterArity : Errors.BadSetterArity, method);
        }
        
        if (method.kind === 'set' && params[params.length - 1]?.type === 'RestElement') {
            this.raise(Errors.BadSetterRestParameter, method);
        }
    }
    
    parseObjectMethod(prop, isGenerator, isAsync, isPattern3, isAccessor2) {
        if (isAccessor2) {
            const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, 'ObjectMethod');
            this.checkGetterSetterParams(finishedProp);
            return finishedProp;
        }
        
        if (isAsync || isGenerator || this.match(10)) {
            if (isPattern3)
                this.unexpected();
            
            prop.kind = 'method';
            prop.method = true;
            return this.parseMethod(prop, isGenerator, isAsync, false, false, 'ObjectMethod');
        }
    }
    
    parseObjectProperty(prop, startLoc, isPattern3, refExpressionErrors) {
        prop.shorthand = false;
        
        if (this.eat(14)) {
            prop.value = isPattern3 ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowInOrVoidPattern(8, refExpressionErrors);
            return this.finishObjectProperty(prop);
        }
        
        if (!prop.computed && prop.key.type === 'Identifier') {
            this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
            
            if (isPattern3) {
                prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));
            } else if (this.match(29)) {
                const shorthandAssignLoc = this.state.startLoc;
                
                if (refExpressionErrors != null) {
                    if (refExpressionErrors.shorthandAssignLoc === null) {
                        refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
                    }
                } else {
                    this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
                }
                
                prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));
            } else {
                prop.value = this.cloneIdentifier(prop.key);
            }
            
            prop.shorthand = true;
            return this.finishObjectProperty(prop);
        }
    }
    
    finishObjectProperty(node) {
        return this.finishNode(node, 'ObjectProperty');
    }
    
    parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern3, isAccessor2, refExpressionErrors) {
        const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern3, isAccessor2) || this.parseObjectProperty(prop, startLoc, isPattern3, refExpressionErrors);
        
        if (!node)
            this.unexpected();
        
        return node;
    }
    
    parsePropertyName(prop, refExpressionErrors) {
        if (this.eat(0)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssignAllowIn();
            this.expect(3);
        } else {
            const {type, value} = this.state;
            
            let key;
            
            if (tokenIsKeywordOrIdentifier(type)) {
                key = this.parseIdentifier(true);
            } else {
                switch(type) {
                case 135:
                    key = this.parseNumericLiteral(value);
                    break;
                
                case 134:
                    key = this.parseStringLiteral(value);
                    break;
                
                case 136:
                    key = this.parseBigIntLiteral(value);
                    break;
                
                case 139: {
                    const privateKeyLoc = this.state.startLoc;
                    
                    if (refExpressionErrors != null) {
                        if (refExpressionErrors.privateKeyLoc === null) {
                            refExpressionErrors.privateKeyLoc = privateKeyLoc;
                        }
                    } else {
                        this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
                    }
                    
                    key = this.parsePrivateName();
                    break;
                }
                
                default:
                    this.unexpected();
                }
            }
            
            prop.key = key;
            
            if (type !== 139) {
                prop.computed = false;
            }
        }
    }
    
    initFunction(node, isAsync) {
        node.id = null;
        node.generator = false;
        node.async = isAsync;
    }
    
    parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        this.initFunction(node, isAsync);
        node.generator = isGenerator;
        this.scope.enter(514 | 16 | (inClassScope ? 576 : 0) | (allowDirectSuper ? 32 : 0));
        this.prodParam.enter(functionFlags(isAsync, node.generator));
        this.parseFunctionParams(node, isConstructor);
        const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
        this.prodParam.exit();
        this.scope.exit();
        return finishedNode;
    }
    
    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        if (isTuple) {
            this.expectPlugin('recordAndTuple');
        }
        
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        
        this.state.inFSharpPipelineDirectBody = false;
        const node = this.startNode();
        this.next();
        node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return this.finishNode(node, isTuple ? 'TupleExpression' : 'ArrayExpression');
    }
    
    parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
        this.scope.enter(514 | 4);
        let flags = functionFlags(isAsync, false);
        
        if (!this.match(5) && this.prodParam.hasIn) {
            flags |= 8;
        }
        
        this.prodParam.enter(flags);
        this.initFunction(node, isAsync);
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        
        if (params) {
            this.state.maybeInArrowParameters = true;
            this.setArrowFunctionParameters(node, params, trailingCommaLoc);
        }
        
        this.state.maybeInArrowParameters = false;
        this.parseFunctionBody(node, true);
        this.prodParam.exit();
        this.scope.exit();
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return this.finishNode(node, 'ArrowFunctionExpression');
    }
    
    setArrowFunctionParameters(node, params, trailingCommaLoc) {
        this.toAssignableList(params, trailingCommaLoc, false);
        node.params = params;
    }
    
    parseFunctionBodyAndFinish(node, type, isMethod3 = false) {
        this.parseFunctionBody(node, false, isMethod3);
        return this.finishNode(node, type);
    }
    
    parseFunctionBody(node, allowExpression, isMethod3 = false) {
        const isExpression4 = allowExpression && !this.match(5);
        this.expressionScope.enter(newExpressionScope());
        
        if (isExpression4) {
            node.body = this.parseMaybeAssign();
            this.checkParams(node, false, allowExpression, false);
        } else {
            const oldStrict = this.state.strict;
            const oldLabels = this.state.labels;
            
            this.state.labels = [];
            this.prodParam.enter(this.prodParam.currentFlags() | 4);
            node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
                const nonSimple = !this.isSimpleParamList(node.params);
                
                if (hasStrictModeDirective && nonSimple) {
                    this.raise(Errors.IllegalLanguageModeDirective, (node.kind === 'method' || node.kind === 'constructor') && !!node.key ? node.key.loc.end : node);
                }
                
                const strictModeChanged = !oldStrict && this.state.strict;
                this.checkParams(node, !this.state.strict && !allowExpression && !isMethod3 && !nonSimple, allowExpression, strictModeChanged);
                
                if (this.state.strict && node.id) {
                    this.checkIdentifier(node.id, 65, strictModeChanged);
                }
            });
            this.prodParam.exit();
            this.state.labels = oldLabels;
        }
        
        this.expressionScope.exit();
    }
    
    isSimpleParameter(node) {
        return node.type === 'Identifier';
    }
    
    isSimpleParamList(params) {
        for (let i = 0, len = params.length; i < len; i++) {
            if (!this.isSimpleParameter(params[i]))
                return false;
        }
        
        return true;
    }
    
    checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        const checkClashes = !allowDuplicates &&         /* @__PURE__ */new Set();
        const formalParameters = {
            type: 'FormalParameters',
        };
        
        for (const param of node.params) {
            this.checkLVal(param, formalParameters, 5, checkClashes, strictModeChanged);
        }
    }
    
    parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
        const elts = [];
        let first = true;
        
        while (!this.eat(close)) {
            if (first) {
                first = false;
            } else {
                this.expect(12);
                
                if (this.match(close)) {
                    if (nodeForExtra) {
                        this.addTrailingCommaExtraToNode(nodeForExtra);
                    }
                    
                    this.next();
                    break;
                }
            }
            
            elts.push(this.parseExprListItem(
                close,
                allowEmpty,
                refExpressionErrors,
            ));
        }
        
        return elts;
    }
    
    parseExprListItem(close, allowEmpty, refExpressionErrors, allowPlaceholder) {
        let elt;
        
        if (this.match(12)) {
            if (!allowEmpty) {
                this.raise(Errors.UnexpectedToken, this.state.curPosition(), {
                    unexpected: ',',
                });
            }
            
            elt = null;
        } else if (this.match(21)) {
            const spreadNodeStartLoc = this.state.startLoc;
            elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
        } else if (this.match(17)) {
            this.expectPlugin('partialApplication');
            
            if (!allowPlaceholder) {
                this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);
            }
            
            const node = this.startNode();
            this.next();
            elt = this.finishNode(node, 'ArgumentPlaceholder');
        } else {
            elt = this.parseMaybeAssignAllowInOrVoidPattern(close, refExpressionErrors, this.parseParenItem);
        }
        
        return elt;
    }
    
    parseIdentifier(liberal) {
        const node = this.startNode();
        const name = this.parseIdentifierName(liberal);
        
        return this.createIdentifier(node, name);
    }
    
    createIdentifier(node, name) {
        node.name = name;
        node.loc.identifierName = name;
        return this.finishNode(node, 'Identifier');
    }
    
    createIdentifierAt(node, name, endLoc) {
        node.name = name;
        node.loc.identifierName = name;
        return this.finishNodeAt(node, 'Identifier', endLoc);
    }
    
    parseIdentifierName(liberal) {
        let name;
        const {startLoc, type} = this.state;
        
        if (tokenIsKeywordOrIdentifier(type)) {
            name = this.state.value;
        } else {
            this.unexpected();
        }
        
        const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
        
        if (liberal) {
            if (tokenIsKeyword2) {
                this.replaceToken(132);
            }
        } else {
            this.checkReservedWord(name, startLoc, tokenIsKeyword2, false);
        }
        
        this.next();
        return name;
    }
    
    checkReservedWord(word, startLoc, checkKeywords, isBinding3) {
        if (word.length > 10) {
            return;
        }
        
        if (!canBeReservedWord(word)) {
            return;
        }
        
        if (checkKeywords && isKeyword2(word)) {
            this.raise(Errors.UnexpectedKeyword, startLoc, {
                keyword: word,
            });
            return;
        }
        
        const reservedTest = !this.state.strict ? isReservedWord2 : isBinding3 ? isStrictBindReservedWord : isStrictReservedWord2;
        
        if (reservedTest(word, this.inModule)) {
            this.raise(Errors.UnexpectedReservedWord, startLoc, {
                reservedWord: word,
            });
            return;
        } else if (word === 'yield') {
            if (this.prodParam.hasYield) {
                this.raise(Errors.YieldBindingIdentifier, startLoc);
                return;
            }
        } else if (word === 'await') {
            if (this.prodParam.hasAwait) {
                this.raise(Errors.AwaitBindingIdentifier, startLoc);
                return;
            }
            
            if (this.scope.inStaticBlock) {
                this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);
                return;
            }
            
            this.expressionScope.recordAsyncArrowParametersError(startLoc);
        } else if (word === 'arguments') {
            if (this.scope.inClassAndNotInNonArrowFunction) {
                this.raise(Errors.ArgumentsInClass, startLoc);
                return;
            }
        }


    }
    
    recordAwaitIfAllowed() {
        const isAwaitAllowed = this.prodParam.hasAwait;
        
        if (isAwaitAllowed && !this.scope.inFunction) {
            this.state.hasTopLevelAwait = true;
        }
        
        return isAwaitAllowed;
    }
    
    parseAwait(startLoc) {
        const node = this.startNodeAt(startLoc);
        this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);
        
        if (this.eat(55)) {
            this.raise(Errors.ObsoleteAwaitStar, node);
        }
        
        if (!this.scope.inFunction && !(this.optionFlags & 1)) {
            if (this.isAmbiguousPrefixOrIdentifier()) {
                this.ambiguousScriptDifferentAst = true;
            } else {
                this.sawUnambiguousESM = true;
            }
        }
        
        if (!this.state.soloAwait) {
            node.argument = this.parseMaybeUnary(null, true);
        }
        
        return this.finishNode(node, 'AwaitExpression');
    }
    
    isAmbiguousPrefixOrIdentifier() {
        if (this.hasPrecedingLineBreak())
            return true;
        
        const {type} = this.state;
        
        return type === 53
            || type === 10
            || type === 0
            || tokenIsTemplate(type)
            || type === 102
            && !this.state.containsEsc
            || type === 138
            || type === 56
            || this.hasPlugin('v8intrinsic') && type === 54;
    }
    
    parseYield(startLoc) {
        const node = this.startNodeAt(startLoc);
        this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);
        let delegating = false;
        let argument = null;
        
        if (!this.hasPrecedingLineBreak()) {
            delegating = this.eat(55);
            switch(this.state.type) {
            case 13:            
            case 140:            
            case 8:            
            case 11:            
            case 3:            
            case 9:            
            case 14:            
            case 12:
                if (!delegating)
                    break;
            
            default:
                argument = this.parseMaybeAssign();
            }
        }
        
        node.delegate = delegating;
        node.argument = argument;
        return this.finishNode(node, 'YieldExpression');
    }
    
    parseImportCall(node) {
        this.next();
        node.source = this.parseMaybeAssignAllowIn();
        node.options = null;
        
        if (this.eat(12)) {
            if (!this.match(11)) {
                node.options = this.parseMaybeAssignAllowIn();
                
                if (this.eat(12)) {
                    this.addTrailingCommaExtraToNode(node.options);
                    
                    if (!this.match(11)) {
                        do {
                            this.parseMaybeAssignAllowIn();
                        } while (this.eat(12) && !this.match(11))
                        this.raise(Errors.ImportCallArity, node);
                    }
                }
            } else {
                this.addTrailingCommaExtraToNode(node.source);
            }
        }
        
        this.expect(11);
        return this.finishNode(node, 'ImportExpression');
    }
    
    checkPipelineAtInfixOperator(left, leftStartLoc) {
        if (this.hasPlugin(['pipelineOperator', {proposal: 'smart'}])) {
            if (left.type === 'SequenceExpression') {
                this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);
            }
        }
    }
    
    parseSmartPipelineBodyInStyle(childExpr, startLoc) {
        if (this.isSimpleReference(childExpr)) {
            const bodyNode = this.startNodeAt(startLoc);
            
            bodyNode.callee = childExpr;
            return this.finishNode(bodyNode, 'PipelineBareFunction');
        } else {
            const bodyNode = this.startNodeAt(startLoc);
            this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
            bodyNode.expression = childExpr;
            return this.finishNode(bodyNode, 'PipelineTopicExpression');
        }
    }
    
    isSimpleReference(expression2) {
        switch(expression2.type) {
        case 'MemberExpression':
            return !expression2.computed && this.isSimpleReference(expression2.object);
        
        case 'Identifier':
            return true;
        
        default:
            return false;
        }
    }
    
    checkSmartPipeTopicBodyEarlyErrors(startLoc) {
        if (this.match(19)) {
            throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);
        }
        
        if (!this.topicReferenceWasUsedInCurrentContext()) {
            this.raise(Errors.PipelineTopicUnused, startLoc);
        }
    }
    
    withTopicBindingContext(callback) {
        const outerContextTopicState = this.state.topicContext;
        
        this.state.topicContext = {
            maxNumOfResolvableTopics: 1,
            maxTopicIndex: null,
        };
        try {
            return callback();
        } finally {
            this.state.topicContext = outerContextTopicState;
        }
    }
    
    withSmartMixTopicForbiddingContext(callback) {
        {
            return callback();
        }
    }
    
    withSoloAwaitPermittingContext(callback) {
        const outerContextSoloAwaitState = this.state.soloAwait;
        
        this.state.soloAwait = true;
        try {
            return callback();
        } finally {
            this.state.soloAwait = outerContextSoloAwaitState;
        }
    }
    
    allowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToSet = 8 & ~flags;
        
        if (prodParamToSet) {
            this.prodParam.enter(flags | 8);
            try {
                return callback();
            } finally {
                this.prodParam.exit();
            }
        }
        
        return callback();
    }
    
    disallowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToClear = 8 & flags;
        
        if (prodParamToClear) {
            this.prodParam.enter(flags & -9);
            try {
                return callback();
            } finally {
                this.prodParam.exit();
            }
        }
        
        return callback();
    }
    
    registerTopicReference() {
        this.state.topicContext.maxTopicIndex = 0;
    }
    
    topicReferenceIsAllowedInCurrentContext() {
        return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    
    topicReferenceWasUsedInCurrentContext() {
        return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    
    parseFSharpPipelineBody(prec) {
        const startLoc = this.state.startLoc;
        
        this.state.potentialArrowAt = this.state.start;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        
        this.state.inFSharpPipelineDirectBody = true;
        const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
        
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return ret;
    }
    
    parseModuleExpression() {
        this.expectPlugin('moduleBlocks');
        const node = this.startNode();
        this.next();
        
        if (!this.match(5)) {
            this.unexpected(null, 5);
        }
        
        const program3 = this.startNodeAt(this.state.endLoc);
        this.next();
        const revertScopes = this.initializeScopes(true);
        this.enterInitialScopes();
        try {
            node.body = this.parseProgram(program3, 8, 'module');
        } finally {
            revertScopes();
        }

                
        return this.finishNode(node, 'ModuleExpression');
    }
    
    parseVoidPattern(refExpressionErrors) {
        this.expectPlugin('discardBinding');
        const node = this.startNode();
        
        if (refExpressionErrors != null) {
            refExpressionErrors.voidPatternLoc = this.state.startLoc;
        }
        
        this.next();
        return this.finishNode(node, 'VoidPattern');
    }
    
    parseMaybeAssignAllowInOrVoidPattern(close, refExpressionErrors, afterLeftParse) {
        if (refExpressionErrors != null && this.match(88)) {
            const nextCode = this.lookaheadCharCode();
            
            if (nextCode === 44 || nextCode === (close === 3 ? 93 : close === 8 ? 125 : 41) || nextCode === 61) {
                return this.parseMaybeDefault(this.state.startLoc, this.parseVoidPattern(refExpressionErrors));
            }
        }
        
        return this.parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse);
    }
    
    parsePropertyNamePrefixOperator(prop) {}
};

var loopLabel = {
    kind: 1,
};

var switchLabel = {
    kind: 2,
};

var loneSurrogate = /[\uD800-\uDFFF]/u;
var keywordRelationalOperator = /in(?:stanceof)?/y;

function babel7CompatTokens(tokens, input, startIndex) {
    for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        const {type} = token;
        
        if (typeof type === 'number') {
            token.type = getExportedToken(type);
        }
    }
    
    return tokens;
}

var StatementParser = class extends ExpressionParser {
    parseTopLevel(file2, program3) {
        file2.program = this.parseProgram(program3, 140, this.options.sourceType === 'module' ? 'module' : 'script');
        file2.comments = this.comments;
        
        if (this.optionFlags & 256) {
            file2.tokens = babel7CompatTokens(this.tokens, this.input, this.startIndex);
        }
        
        return this.finishNode(file2, 'File');
    }
    
    parseProgram(program3, end, sourceType) {
        program3.sourceType = sourceType;
        program3.interpreter = this.parseInterpreterDirective();
        this.parseBlockBody(program3, true, true, end);
        
        if (this.inModule) {
            if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0) {
                for (const [localName, at] of Array.from(this.scope.undefinedExports)) {
                    this.raise(Errors.ModuleExportUndefined, at, {
                        localName,
                    });
                }
            }
            
            this.addExtra(program3, 'topLevelAwait', this.state.hasTopLevelAwait);
        }
        
        let finishedProgram;
        
        if (end === 140) {
            finishedProgram = this.finishNode(program3, 'Program');
        } else {
            finishedProgram = this.finishNodeAt(program3, 'Program', createPositionWithColumnOffset(this.state.startLoc, -1));
        }
        
        return finishedProgram;
    }
    
    stmtToDirective(stmt) {
        const directive2 = this.castNodeTo(stmt, 'Directive');
        const directiveLiteral2 = this.castNodeTo(stmt.expression, 'DirectiveLiteral');
        const expressionValue = directiveLiteral2.value;
        const raw = this.input.slice(this.offsetToSourcePos(directiveLiteral2.start), this.offsetToSourcePos(directiveLiteral2.end));
        const val = directiveLiteral2.value = raw.slice(1, -1);
        
        this.addExtra(directiveLiteral2, 'raw', raw);
        this.addExtra(directiveLiteral2, 'rawValue', val);
        this.addExtra(directiveLiteral2, 'expressionValue', expressionValue);
        directive2.value = directiveLiteral2;
        delete stmt.expression;
        return directive2;
    }
    
    parseInterpreterDirective() {
        if (!this.match(28)) {
            return null;
        }
        
        const node = this.startNode();
        
        node.value = this.state.value;
        this.next();
        return this.finishNode(node, 'InterpreterDirective');
    }
    
    isLet() {
        if (!this.isContextual(100)) {
            return false;
        }
        
        return this.hasFollowingBindingAtom();
    }
    
    isUsing() {
        if (!this.isContextual(107)) {
            return false;
        }
        
        const next = this.nextTokenInLineStart();
        const nextCh = this.codePointAtPos(next);
        
        return this.chStartsBindingIdentifier(nextCh, next);
    }
    
    isForUsing() {
        if (!this.isContextual(107)) {
            return false;
        }
        
        const next = this.nextTokenInLineStart();
        const nextCh = this.codePointAtPos(next);
        
        if (this.isUnparsedContextual(next, 'of')) {
            const nextCharAfterOf = this.lookaheadCharCodeSince(next + 2);
            
            if (nextCharAfterOf !== 61 && nextCharAfterOf !== 58 && nextCharAfterOf !== 59) {
                return false;
            }
        }
        
        if (this.chStartsBindingIdentifier(nextCh, next) || this.isUnparsedContextual(next, 'void')) {
            return true;
        }
        
        return false;
    }
    
    isAwaitUsing() {
        if (!this.isContextual(96)) {
            return false;
        }
        
        let next = this.nextTokenInLineStart();
        
        if (this.isUnparsedContextual(next, 'using')) {
            next = this.nextTokenInLineStartSince(next + 5);
            const nextCh = this.codePointAtPos(next);
            
            if (this.chStartsBindingIdentifier(nextCh, next)) {
                return true;
            }
        }
        
        return false;
    }
    
    chStartsBindingIdentifier(ch, pos) {
        if (isIdentifierStart2(ch)) {
            keywordRelationalOperator.lastIndex = pos;
            
            if (keywordRelationalOperator.test(this.input)) {
                const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
                
                if (!isIdentifierChar2(endCh) && endCh !== 92) {
                    return false;
                }
            }
            
            return true;
        } else if (ch === 92) {
            return true;
        } else {
            return false;
        }
    }
    
    chStartsBindingPattern(ch) {
        return ch === 91 || ch === 123;
    }
    
    hasFollowingBindingAtom() {
        const next = this.nextTokenStart();
        const nextCh = this.codePointAtPos(next);
        
        return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
    }
    
    hasInLineFollowingBindingIdentifierOrBrace() {
        const next = this.nextTokenInLineStart();
        const nextCh = this.codePointAtPos(next);
        
        return nextCh === 123 || this.chStartsBindingIdentifier(nextCh, next);
    }
    
    allowsUsing() {
        return (this.scope.inModule || !this.scope.inTopLevel) && !this.scope.inBareCaseStatement;
    }
    
    parseModuleItem() {
        return this.parseStatementLike(1 | 2 | 4 | 8);
    }
    
    parseStatementListItem() {
        return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    
    parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {
        let flags = 0;
        
        if (this.options.annexB && !this.state.strict) {
            flags |= 4;
            
            if (allowLabeledFunction) {
                flags |= 8;
            }
        }
        
        return this.parseStatementLike(flags);
    }
    
    parseStatement() {
        return this.parseStatementLike(0);
    }
    
    parseStatementLike(flags) {
        let decorators = null;
        
        if (this.match(26)) {
            decorators = this.parseDecorators(true);
        }
        
        return this.parseStatementContent(flags, decorators);
    }
    
    parseStatementContent(flags, decorators) {
        const startType = this.state.type;
        const node = this.startNode();
        const allowDeclaration = !!(flags & 2);
        const allowFunctionDeclaration = !!(flags & 4);
        const topLevel = flags & 1;
        
        switch(startType) {
        case 60:
            return this.parseBreakContinueStatement(node, true);
        
        case 63:
            return this.parseBreakContinueStatement(node, false);
        
        case 64:
            return this.parseDebuggerStatement(node);
        
        case 90:
            return this.parseDoWhileStatement(node);
        
        case 91:
            return this.parseForStatement(node);
        
        case 68:
            if (this.lookaheadCharCode() === 46)
                break;
            
            if (!allowFunctionDeclaration) {
                this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);
            }
            
            return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);
        
        case 80:
            if (!allowDeclaration)
                this.unexpected();
            
            return this.parseClass(this.maybeTakeDecorators(decorators, node), true);
        
        case 69:
            return this.parseIfStatement(node);
        
        case 70:
            return this.parseReturnStatement(node);
        
        case 71:
            return this.parseSwitchStatement(node);
        
        case 72:
            return this.parseThrowStatement(node);
        
        case 73:
            return this.parseTryStatement(node);
        
        case 96:
            if (this.isAwaitUsing()) {
                if (!this.allowsUsing()) {
                    this.raise(Errors.UnexpectedUsingDeclaration, node);
                } else if (!allowDeclaration) {
                    this.raise(Errors.UnexpectedLexicalDeclaration, node);
                } else if (!this.recordAwaitIfAllowed()) {
                    this.raise(Errors.AwaitUsingNotInAsyncContext, node);
                }
                
                this.next();
                return this.parseVarStatement(node, 'await using');
            }
            
            break;
        
        case 107:
            if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) {
                break;
            }
            
            if (!this.allowsUsing()) {
                this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);
            } else if (!allowDeclaration) {
                this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
            }
            
            return this.parseVarStatement(node, 'using');
        
        case 100: {
            if (this.state.containsEsc) {
                break;
            }
            
            const next = this.nextTokenStart();
            const nextCh = this.codePointAtPos(next);
            
            if (nextCh !== 91) {
                if (!allowDeclaration && this.hasFollowingLineBreak())
                    break;
                
                if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
                    break;
                }
            }
        }
        
        case 75: {
            if (!allowDeclaration) {
                this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
            }
        }
        
        case 74: {
            const kind = this.state.value;
            return this.parseVarStatement(node, kind);
        }
        
        case 92:
            return this.parseWhileStatement(node);
        
        case 76:
            return this.parseWithStatement(node);
        
        case 5:
            return this.parseBlock();
        
        case 13:
            return this.parseEmptyStatement(node);
        
        case 83: {
            const nextTokenCharCode = this.lookaheadCharCode();
            
            if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
                break;
            }
        }
        
        case 82: {
            if (!(this.optionFlags & 8) && !topLevel) {
                this.raise(Errors.UnexpectedImportExport, this.state.startLoc);
            }
            
            this.next();
            let result;
            
            if (startType === 83) {
                result = this.parseImport(node);
            } else {
                result = this.parseExport(node, decorators);
            }
            
            this.assertModuleNodeAllowed(result);
            return result;
        }
        
        default: {
            if (this.isAsyncFunction()) {
                if (!allowDeclaration) {
                    this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);
                }
                
                this.next();
                return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);
            }
        }
        }
        
        const maybeName = this.state.value;
        const expr = this.parseExpression();
        
        if (tokenIsIdentifier(startType) && expr.type === 'Identifier' && this.eat(14)) {
            return this.parseLabeledStatement(node, maybeName, expr, flags);
        } else {
            return this.parseExpressionStatement(node, expr, decorators);
        }
    }
    
    assertModuleNodeAllowed(node) {
        if (!(this.optionFlags & 8) && !this.inModule) {
            this.raise(Errors.ImportOutsideModule, node);
        }
    }
    
    decoratorsEnabledBeforeExport() {
        if (this.hasPlugin('decorators-legacy'))
            return true;
        
        return this.hasPlugin('decorators') && this.getPluginOption('decorators', 'decoratorsBeforeExport') !== false;
    }
    
    maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
        if (maybeDecorators) {
            if (classNode.decorators?.length) {
                if (typeof this.getPluginOption('decorators', 'decoratorsBeforeExport') !== 'boolean') {
                    this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);
                }
                
                classNode.decorators.unshift(...maybeDecorators);
            } else {
                classNode.decorators = maybeDecorators;
            }
            
            this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
            
            if (exportNode)
                this.resetStartLocationFromNode(exportNode, classNode);
        }
        
        return classNode;
    }
    
    canHaveLeadingDecorator() {
        return this.match(80);
    }
    
    parseDecorators(allowExport) {
        const decorators = [];
        
        do {
            decorators.push(this.parseDecorator());
        } while (this.match(26))
        if (this.match(82)) {
            if (!allowExport) {
                this.unexpected();
            }
            
            if (!this.decoratorsEnabledBeforeExport()) {
                this.raise(Errors.DecoratorExportClass, this.state.startLoc);
            }
        } else if (!this.canHaveLeadingDecorator()) {
            throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);
        }
        
        return decorators;
    }
    
    parseDecorator() {
        this.expectOnePlugin(['decorators', 'decorators-legacy']);
        const node = this.startNode();
        this.next();
        
        if (this.hasPlugin('decorators')) {
            const startLoc = this.state.startLoc;
            let expr;
            
            if (this.match(10)) {
                const startLoc2 = this.state.startLoc;
                this.next();
                expr = this.parseExpression();
                this.expect(11);
                expr = this.wrapParenthesis(startLoc2, expr);
                const paramsStartLoc = this.state.startLoc;
                
                node.expression = this.parseMaybeDecoratorArguments(expr, startLoc2);
                
                if (this.getPluginOption('decorators', 'allowCallParenthesized') === false && node.expression !== expr) {
                    this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);
                }
            } else {
                expr = this.parseIdentifier(false);
                while (this.eat(16)) {
                    const node2 = this.startNodeAt(startLoc);
                    
                    node2.object = expr;
                    
                    if (this.match(139)) {
                        this.classScope.usePrivateName(this.state.value, this.state.startLoc);
                        node2.property = this.parsePrivateName();
                    } else {
                        node2.property = this.parseIdentifier(true);
                    }
                    
                    node2.computed = false;
                    expr = this.finishNode(node2, 'MemberExpression');
                }
                
                node.expression = this.parseMaybeDecoratorArguments(expr, startLoc);
            }
        } else {
            node.expression = this.parseExprSubscripts();
        }
        
        return this.finishNode(node, 'Decorator');
    }
    
    parseMaybeDecoratorArguments(expr, startLoc) {
        if (this.eat(10)) {
            const node = this.startNodeAt(startLoc);
            
            node.callee = expr;
            node.arguments = this.parseCallExpressionArguments();
            this.toReferencedList(node.arguments);
            return this.finishNode(node, 'CallExpression');
        }
        
        return expr;
    }
    
    parseBreakContinueStatement(node, isBreak) {
        this.next();
        
        if (this.isLineTerminator()) {
            node.label = null;
        } else {
            node.label = this.parseIdentifier();
            this.semicolon();
        }
        
        this.verifyBreakContinue(node, isBreak);
        return this.finishNode(node, isBreak ? 'BreakStatement' : 'ContinueStatement');
    }
    
    verifyBreakContinue(node, isBreak) {
        let i;
        
        for (i = 0; i < this.state.labels.length; ++i) {
            const lab = this.state.labels[i];
            
            if (node.label == null || lab.name === node.label.name) {
                if (lab.kind != null && (isBreak || lab.kind === 1)) {
                    break;
                }
                
                if (node.label && isBreak)
                    break;
            }
        }
        
        if (i === this.state.labels.length) {
            const type = isBreak ? 'BreakStatement' : 'ContinueStatement';
            
            this.raise(Errors.IllegalBreakContinue, node, {
                type,
            });
        }
    }
    
    parseDebuggerStatement(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, 'DebuggerStatement');
    }
    
    parseHeaderExpression() {
        this.expect(10);
        const val = this.parseExpression();
        this.expect(11);
        return val;
    }
    
    parseDoWhileStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.state.labels.pop();
        this.expect(92);
        node.test = this.parseHeaderExpression();
        this.eat(13);
        return this.finishNode(node, 'DoWhileStatement');
    }
    
    parseForStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        let awaitAt = null;
        
        if (this.isContextual(96) && this.recordAwaitIfAllowed()) {
            awaitAt = this.state.startLoc;
            this.next();
        }
        
        this.scope.enter(0);
        this.expect(10);
        
        if (this.match(13)) {
            if (awaitAt !== null) {
                this.unexpected(awaitAt);
            }
            
            return this.parseFor(node, null);
        }
        
        const startsWithLet = this.isContextual(100);
        
        {
            const startsWithAwaitUsing = this.isAwaitUsing();
            const starsWithUsingDeclaration = startsWithAwaitUsing || this.isForUsing();
            const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
            
            if (this.match(74) || this.match(75) || isLetOrUsing) {
                const initNode = this.startNode();
                let kind;
                
                if (startsWithAwaitUsing) {
                    kind = 'await using';
                    
                    if (!this.recordAwaitIfAllowed()) {
                        this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);
                    }
                    
                    this.next();
                } else {
                    kind = this.state.value;
                }
                
                this.next();
                this.parseVar(initNode, true, kind);
                const init2 = this.finishNode(initNode, 'VariableDeclaration');
                const isForIn = this.match(58);
                
                if (isForIn && starsWithUsingDeclaration) {
                    this.raise(Errors.ForInUsing, init2);
                }
                
                if ((isForIn || this.isContextual(102)) && init2.declarations.length === 1) {
                    return this.parseForIn(node, init2, awaitAt);
                }
                
                if (awaitAt !== null) {
                    this.unexpected(awaitAt);
                }
                
                return this.parseFor(node, init2);
            }
        }
        const startsWithAsync = this.isContextual(95);
        const refExpressionErrors = new ExpressionErrors();
        const init = this.parseExpression(true, refExpressionErrors);
        const isForOf = this.isContextual(102);
        
        if (isForOf) {
            if (startsWithLet) {
                this.raise(Errors.ForOfLet, init);
            }
            
            if (awaitAt === null && startsWithAsync && init.type === 'Identifier') {
                this.raise(Errors.ForOfAsync, init);
            }
        }
        
        if (isForOf || this.match(58)) {
            this.checkDestructuringPrivate(refExpressionErrors);
            this.toAssignable(init, true);
            const type = isForOf ? 'ForOfStatement' : 'ForInStatement';
            
            this.checkLVal(init, {
                type,
            });
            return this.parseForIn(node, init, awaitAt);
        } else {
            this.checkExpressionErrors(refExpressionErrors, true);
        }
        
        if (awaitAt !== null) {
            this.unexpected(awaitAt);
        }
        
        return this.parseFor(node, init);
    }
    
    parseFunctionStatement(node, isAsync, isHangingDeclaration) {
        this.next();
        return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
    }
    
    parseIfStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
        node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
        return this.finishNode(node, 'IfStatement');
    }
    
    parseReturnStatement(node) {
        if (!this.prodParam.hasReturn) {
            this.raise(Errors.IllegalReturn, this.state.startLoc);
        }
        
        this.next();
        
        if (this.isLineTerminator()) {
            node.argument = null;
        } else {
            node.argument = this.parseExpression();
            this.semicolon();
        }
        
        return this.finishNode(node, 'ReturnStatement');
    }
    
    parseSwitchStatement(node) {
        this.next();
        node.discriminant = this.parseHeaderExpression();
        const cases = node.cases = [];
        this.expect(5);
        this.state.labels.push(switchLabel);
        this.scope.enter(256);
        let cur;
        
        for (let sawDefault; !this.match(8);) {
            if (this.match(61) || this.match(65)) {
                const isCase = this.match(61);
                
                if (cur)
                    this.finishNode(cur, 'SwitchCase');
                
                cases.push(cur = this.startNode());
                cur.consequent = [];
                this.next();
                
                if (isCase) {
                    cur.test = this.parseExpression();
                } else {
                    if (sawDefault) {
                        this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);
                    }
                    
                    sawDefault = true;
                    cur.test = null;
                }
                
                this.expect(14);
            } else {
                if (cur) {
                    cur.consequent.push(this.parseStatementListItem());
                } else {
                    this.unexpected();
                }
            }
        }
        
        this.scope.exit();
        
        if (cur)
            this.finishNode(cur, 'SwitchCase');
        
        this.next();
        this.state.labels.pop();
        return this.finishNode(node, 'SwitchStatement');
    }
    
    parseThrowStatement(node) {
        this.next();
        
        if (this.hasPrecedingLineBreak()) {
            this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);
        }
        
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, 'ThrowStatement');
    }
    
    parseCatchClauseParam() {
        const param = this.parseBindingAtom();
        this.scope.enter(this.options.annexB && param.type === 'Identifier' ? 8 : 0);
        this.checkLVal(param, {
            type: 'CatchClause',
        }, 9);
        return param;
    }
    
    parseTryStatement(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        
        if (this.match(62)) {
            const clause = this.startNode();
            this.next();
            
            if (this.match(10)) {
                this.expect(10);
                clause.param = this.parseCatchClauseParam();
                this.expect(11);
            } else {
                clause.param = null;
                this.scope.enter(0);
            }
            
            clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
            this.scope.exit();
            node.handler = this.finishNode(clause, 'CatchClause');
        }
        
        node.finalizer = this.eat(67) ? this.parseBlock() : null;
        
        if (!node.handler && !node.finalizer) {
            this.raise(Errors.NoCatchOrFinally, node);
        }
        
        return this.finishNode(node, 'TryStatement');
    }
    
    parseVarStatement(node, kind, allowMissingInitializer = false) {
        this.next();
        this.parseVar(node, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node, 'VariableDeclaration');
    }
    
    parseWhileStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        this.state.labels.push(loopLabel);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.state.labels.pop();
        return this.finishNode(node, 'WhileStatement');
    }
    
    parseWithStatement(node) {
        if (this.state.strict) {
            this.raise(Errors.StrictWith, this.state.startLoc);
        }
        
        this.next();
        node.object = this.parseHeaderExpression();
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        return this.finishNode(node, 'WithStatement');
    }
    
    parseEmptyStatement(node) {
        this.next();
        return this.finishNode(node, 'EmptyStatement');
    }
    
    parseLabeledStatement(node, maybeName, expr, flags) {
        for (const label of this.state.labels) {
            if (label.name === maybeName) {
                this.raise(Errors.LabelRedeclaration, expr, {
                    labelName: maybeName,
                });
            }
        }
        
        const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;
        
        for (let i = this.state.labels.length - 1; i >= 0; i--) {
            const label = this.state.labels[i];
            
            if (label.statementStart === node.start) {
                label.statementStart = this.sourceToOffsetPos(this.state.start);
                label.kind = kind;
            } else {
                break;
            }
        }
        
        this.state.labels.push({
            name: maybeName,
            kind,
            statementStart: this.sourceToOffsetPos(this.state.start),
        });
        node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
        this.state.labels.pop();
        node.label = expr;
        return this.finishNode(node, 'LabeledStatement');
    }
    
    parseExpressionStatement(node, expr, decorators) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, 'ExpressionStatement');
    }
    
    parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
        const node = this.startNode();
        
        if (allowDirectives) {
            this.state.strictErrors.clear();
        }
        
        this.expect(5);
        
        if (createNewLexicalScope) {
            this.scope.enter(0);
        }
        
        this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
        
        if (createNewLexicalScope) {
            this.scope.exit();
        }
        
        return this.finishNode(node, 'BlockStatement');
    }
    
    isValidDirective(stmt) {
        return stmt.type === 'ExpressionStatement' && stmt.expression.type === 'StringLiteral' && !stmt.expression.extra.parenthesized;
    }
    
    parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        const body = node.body = [];
        const directives = node.directives = [];
        this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
    }
    
    parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
        const oldStrict = this.state.strict;
        let hasStrictModeDirective = false;
        let parsedNonDirective = false;
        
        while (!this.match(end)) {
            const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
            
            if (directives && !parsedNonDirective) {
                if (this.isValidDirective(stmt)) {
                    const directive2 = this.stmtToDirective(stmt);
                    directives.push(directive2);
                    
                    if (!hasStrictModeDirective && directive2.value.value === 'use strict') {
                        hasStrictModeDirective = true;
                        this.setStrict(true);
                    }
                    
                    continue;
                }
                
                parsedNonDirective = true;
                this.state.strictErrors.clear();
            }
            
            body.push(stmt);
        }
        
        afterBlockParse?.call(this, hasStrictModeDirective);
        
        if (!oldStrict) {
            this.setStrict(false);
        }
        
        this.next();
    }
    
    parseFor(node, init) {
        node.init = init;
        this.semicolon(false);
        node.test = this.match(13) ? null : this.parseExpression();
        this.semicolon(false);
        node.update = this.match(11) ? null : this.parseExpression();
        this.expect(11);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, 'ForStatement');
    }
    
    parseForIn(node, init, awaitAt) {
        const isForIn = this.match(58);
        this.next();
        
        if (isForIn) {
            if (awaitAt !== null)
                this.unexpected(awaitAt);
        } else {
            node.await = awaitAt !== null;
        }
        
        if (init.type === 'VariableDeclaration' && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== 'var' || init.declarations[0].id.type !== 'Identifier')) {
            this.raise(Errors.ForInOfLoopInitializer, init, {
                type: isForIn ? 'ForInStatement' : 'ForOfStatement',
            });
        }
        
        if (init.type === 'AssignmentPattern') {
            this.raise(Errors.InvalidLhs, init, {
                ancestor: {
                    type: 'ForStatement',
                },
            });
        }
        
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
        this.expect(11);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, isForIn ? 'ForInStatement' : 'ForOfStatement');
    }
    
    parseVar(node, isFor3, kind, allowMissingInitializer = false) {
        const declarations = node.declarations = [];
        
        node.kind = kind;
        for (;;) {
            const decl = this.startNode();
            this.parseVarId(decl, kind);
            decl.init = !this.eat(29) ? null : isFor3 ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
            
            if (decl.init === null && !allowMissingInitializer) {
                if (decl.id.type !== 'Identifier' && !(isFor3 && (this.match(58) || this.isContextual(102)))) {
                    this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                        kind: 'destructuring',
                    });
                } else if ((kind === 'const' || kind === 'using' || kind === 'await using') && !(this.match(58) || this.isContextual(102))) {
                    this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                        kind,
                    });
                }
            }
            
            declarations.push(this.finishNode(decl, 'VariableDeclarator'));
            
            if (!this.eat(12))
                break;
        }
        
        return node;
    }
    
    parseVarId(decl, kind) {
        const id = this.parseBindingAtom();
        
        if (kind === 'using' || kind === 'await using') {
            if (id.type === 'ArrayPattern' || id.type === 'ObjectPattern') {
                this.raise(Errors.UsingDeclarationHasBindingPattern, id.loc.start);
            }
        } else {
            if (id.type === 'VoidPattern') {
                this.raise(Errors.UnexpectedVoidPattern, id.loc.start);
            }
        }
        
        this.checkLVal(id, {
            type: 'VariableDeclarator',
        }, kind === 'var' ? 5 : 8201);
        decl.id = id;
    }
    
    parseAsyncFunctionExpression(node) {
        return this.parseFunction(node, 8);
    }
    
    parseFunction(node, flags = 0) {
        const hangingDeclaration = flags & 2;
        const isDeclaration2 = !!(flags & 1);
        const requireId = isDeclaration2 && !(flags & 4);
        const isAsync = !!(flags & 8);
        
        this.initFunction(node, isAsync);
        
        if (this.match(55)) {
            if (hangingDeclaration) {
                this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);
            }
            
            this.next();
            node.generator = true;
        }
        
        if (isDeclaration2) {
            node.id = this.parseFunctionId(requireId);
        }
        
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        
        this.state.maybeInArrowParameters = false;
        this.scope.enter(514);
        this.prodParam.enter(functionFlags(isAsync, node.generator));
        
        if (!isDeclaration2) {
            node.id = this.parseFunctionId();
        }
        
        this.parseFunctionParams(node, false);
        this.withSmartMixTopicForbiddingContext(() => {
            this.parseFunctionBodyAndFinish(node, isDeclaration2 ? 'FunctionDeclaration' : 'FunctionExpression');
        });
        this.prodParam.exit();
        this.scope.exit();
        
        if (isDeclaration2 && !hangingDeclaration) {
            this.registerFunctionStatementId(node);
        }
        
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return node;
    }
    
    parseFunctionId(requireId) {
        return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
    }
    
    parseFunctionParams(node, isConstructor) {
        this.expect(10);
        this.expressionScope.enter(newParameterDeclarationScope());
        node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));
        this.expressionScope.exit();
    }
    
    registerFunctionStatementId(node) {
        if (!node.id)
            return;
        
        this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);
    }
    
    parseClass(node, isStatement5, optionalId) {
        this.next();
        const oldStrict = this.state.strict;
        
        this.state.strict = true;
        this.parseClassId(node, isStatement5, optionalId);
        this.parseClassSuper(node);
        node.body = this.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, isStatement5 ? 'ClassDeclaration' : 'ClassExpression');
    }
    
    isClassProperty() {
        return this.match(29) || this.match(13) || this.match(8);
    }
    
    isClassMethod() {
        return this.match(10);
    }
    
    nameIsConstructor(key) {
        return key.type === 'Identifier' && key.name === 'constructor'
            || key.type === 'StringLiteral' && key.value === 'constructor';
    }
    
    isNonstaticConstructor(method) {
        return !method.computed && !method.static && this.nameIsConstructor(method.key);
    }
    
    parseClassBody(hadSuperClass, oldStrict) {
        this.classScope.enter();
        const state = {
            hadConstructor: false,
            hadSuperClass,
        };
        
        let decorators = [];
        const classBody2 = this.startNode();
        
        classBody2.body = [];
        this.expect(5);
        this.withSmartMixTopicForbiddingContext(() => {
            while (!this.match(8)) {
                if (this.eat(13)) {
                    if (decorators.length > 0) {
                        throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);
                    }
                    
                    continue;
                }
                
                if (this.match(26)) {
                    decorators.push(this.parseDecorator());
                    continue;
                }
                
                const member = this.startNode();
                
                if (decorators.length) {
                    member.decorators = decorators;
                    this.resetStartLocationFromNode(member, decorators[0]);
                    decorators = [];
                }
                
                this.parseClassMember(classBody2, member, state);
                
                if (member.kind === 'constructor' && member.decorators && member.decorators.length > 0) {
                    this.raise(Errors.DecoratorConstructor, member);
                }
            }
        });
        this.state.strict = oldStrict;
        this.next();
        
        if (decorators.length) {
            throw this.raise(Errors.TrailingDecorator, this.state.startLoc);
        }
        
        this.classScope.exit();
        return this.finishNode(classBody2, 'ClassBody');
    }
    
    parseClassMemberFromModifier(classBody2, member) {
        const key = this.parseIdentifier(true);
        
        if (this.isClassMethod()) {
            const method = member;
            
            method.kind = 'method';
            method.computed = false;
            method.key = key;
            method.static = false;
            this.pushClassMethod(classBody2, method, false, false, false, false);
            return true;
        } else if (this.isClassProperty()) {
            const prop = member;
            
            prop.computed = false;
            prop.key = key;
            prop.static = false;
            classBody2.body.push(this.parseClassProperty(prop));
            return true;
        }
        
        this.resetPreviousNodeTrailingComments(key);
        return false;
    }
    
    parseClassMember(classBody2, member, state) {
        const isStatic2 = this.isContextual(106);
        
        if (isStatic2) {
            if (this.parseClassMemberFromModifier(classBody2, member)) {
                return;
            }
            
            if (this.eat(5)) {
                this.parseClassStaticBlock(classBody2, member);
                return;
            }
        }
        
        this.parseClassMemberWithIsStatic(classBody2, member, state, isStatic2);
    }
    
    parseClassMemberWithIsStatic(classBody2, member, state, isStatic2) {
        const publicMethod = member;
        const privateMethod = member;
        const publicProp = member;
        const privateProp = member;
        const accessorProp = member;
        const method = publicMethod;
        const publicMember = publicMethod;
        
        member.static = isStatic2;
        this.parsePropertyNamePrefixOperator(member);
        
        if (this.eat(55)) {
            method.kind = 'method';
            const isPrivateName3 = this.match(139);
            this.parseClassElementName(method);
            this.parsePostMemberNameModifiers(method);
            
            if (isPrivateName3) {
                this.pushClassPrivateMethod(classBody2, privateMethod, true, false);
                return;
            }
            
            if (this.isNonstaticConstructor(publicMethod)) {
                this.raise(Errors.ConstructorIsGenerator, publicMethod.key);
            }
            
            this.pushClassMethod(classBody2, publicMethod, true, false, false, false);
            return;
        }
        
        const isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type);
        const key = this.parseClassElementName(member);
        const maybeContextualKw = isContextual ? key.name : null;
        const isPrivate2 = this.isPrivateName(key);
        const maybeQuestionTokenStartLoc = this.state.startLoc;
        
        this.parsePostMemberNameModifiers(publicMember);
        
        if (this.isClassMethod()) {
            method.kind = 'method';
            
            if (isPrivate2) {
                this.pushClassPrivateMethod(classBody2, privateMethod, false, false);
                return;
            }
            
            const isConstructor = this.isNonstaticConstructor(publicMethod);
            let allowsDirectSuper = false;
            
            if (isConstructor) {
                publicMethod.kind = 'constructor';
                
                if (state.hadConstructor && !this.hasPlugin('typescript')) {
                    this.raise(Errors.DuplicateConstructor, key);
                }
                
                if (isConstructor && this.hasPlugin('typescript') && member.override) {
                    this.raise(Errors.OverrideOnConstructor, key);
                }
                
                state.hadConstructor = true;
                allowsDirectSuper = state.hadSuperClass;
            }
            
            this.pushClassMethod(classBody2, publicMethod, false, false, isConstructor, allowsDirectSuper);
        } else if (this.isClassProperty()) {
            if (isPrivate2) {
                this.pushClassPrivateProperty(classBody2, privateProp);
            } else {
                this.pushClassProperty(classBody2, publicProp);
            }
        } else if (maybeContextualKw === 'async' && !this.isLineTerminator()) {
            this.resetPreviousNodeTrailingComments(key);
            const isGenerator = this.eat(55);
            
            if (publicMember.optional) {
                this.unexpected(maybeQuestionTokenStartLoc);
            }
            
            method.kind = 'method';
            const isPrivate3 = this.match(139);
            this.parseClassElementName(method);
            this.parsePostMemberNameModifiers(publicMember);
            
            if (isPrivate3) {
                this.pushClassPrivateMethod(classBody2, privateMethod, isGenerator, true);
            } else {
                if (this.isNonstaticConstructor(publicMethod)) {
                    this.raise(Errors.ConstructorIsAsync, publicMethod.key);
                }
                
                this.pushClassMethod(classBody2, publicMethod, isGenerator, true, false, false);
            }
        } else if ((maybeContextualKw === 'get' || maybeContextualKw === 'set') && !(this.match(55) && this.isLineTerminator())) {
            this.resetPreviousNodeTrailingComments(key);
            method.kind = maybeContextualKw;
            const isPrivate3 = this.match(139);
            this.parseClassElementName(publicMethod);
            
            if (isPrivate3) {
                this.pushClassPrivateMethod(classBody2, privateMethod, false, false);
            } else {
                if (this.isNonstaticConstructor(publicMethod)) {
                    this.raise(Errors.ConstructorIsAccessor, publicMethod.key);
                }
                
                this.pushClassMethod(classBody2, publicMethod, false, false, false, false);
            }
            
            this.checkGetterSetterParams(publicMethod);
        } else if (maybeContextualKw === 'accessor' && !this.isLineTerminator()) {
            this.expectPlugin('decoratorAutoAccessors');
            this.resetPreviousNodeTrailingComments(key);
            const isPrivate3 = this.match(139);
            this.parseClassElementName(publicProp);
            this.pushClassAccessorProperty(classBody2, accessorProp, isPrivate3);
        } else if (this.isLineTerminator()) {
            if (isPrivate2) {
                this.pushClassPrivateProperty(classBody2, privateProp);
            } else {
                this.pushClassProperty(classBody2, publicProp);
            }
        } else {
            this.unexpected();
        }




    }
    
    parseClassElementName(member) {
        const {type, value} = this.state;
        
        if ((type === 132 || type === 134) && member.static && value === 'prototype') {
            this.raise(Errors.StaticPrototype, this.state.startLoc);
        }
        
        if (type === 139) {
            if (value === 'constructor') {
                this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);
            }
            
            const key = this.parsePrivateName();
            
            member.key = key;
            return key;
        }
        
        this.parsePropertyName(member);
        return member.key;
    }
    
    parseClassStaticBlock(classBody2, member) {
        this.scope.enter(576 | 128 | 16);
        const oldLabels = this.state.labels;
        
        this.state.labels = [];
        this.prodParam.enter(0);
        const body = member.body = [];
        this.parseBlockOrModuleBlockBody(body, void 0, false, 8);
        this.prodParam.exit();
        this.scope.exit();
        this.state.labels = oldLabels;
        classBody2.body.push(this.finishNode(member, 'StaticBlock'));
        
        if (member.decorators?.length) {
            this.raise(Errors.DecoratorStaticBlock, member);
        }
    }
    
    pushClassProperty(classBody2, prop) {
        if (!prop.computed && this.nameIsConstructor(prop.key)) {
            this.raise(Errors.ConstructorClassField, prop.key);
        }
        
        classBody2.body.push(this.parseClassProperty(prop));
    }
    
    pushClassPrivateProperty(classBody2, prop) {
        const node = this.parseClassPrivateProperty(prop);
        classBody2.body.push(node);
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
    }
    
    pushClassAccessorProperty(classBody2, prop, isPrivate2) {
        if (!isPrivate2 && !prop.computed && this.nameIsConstructor(prop.key)) {
            this.raise(Errors.ConstructorClassField, prop.key);
        }
        
        const node = this.parseClassAccessorProperty(prop);
        classBody2.body.push(node);
        
        if (isPrivate2) {
            this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
        }
    }
    
    pushClassMethod(classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        classBody2.body.push(this.parseMethod(
            method,
            isGenerator,
            isAsync,
            isConstructor,
            allowsDirectSuper,
            'ClassMethod',
            true,
        ));
    }
    
    pushClassPrivateMethod(classBody2, method, isGenerator, isAsync) {
        const node = this.parseMethod(method, isGenerator, isAsync, false, false, 'ClassPrivateMethod', true);
        classBody2.body.push(node);
        const kind = node.kind === 'get' ? node.static ? 6 : 2 : node.kind === 'set' ? node.static ? 5 : 1 : 0;
        this.declareClassPrivateMethodInScope(node, kind);
    }
    
    declareClassPrivateMethodInScope(node, kind) {
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
    }
    
    parsePostMemberNameModifiers(methodOrProp) {}
    
    parseClassPrivateProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, 'ClassPrivateProperty');
    }
    
    parseClassProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, 'ClassProperty');
    }
    
    parseClassAccessorProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, 'ClassAccessorProperty');
    }
    
    parseInitializer(node) {
        this.scope.enter(576 | 16);
        this.expressionScope.enter(newExpressionScope());
        this.prodParam.enter(0);
        node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
        this.expressionScope.exit();
        this.prodParam.exit();
        this.scope.exit();
    }
    
    parseClassId(node, isStatement5, optionalId, bindingType = 8331) {
        if (tokenIsIdentifier(this.state.type)) {
            node.id = this.parseIdentifier();
            
            if (isStatement5) {
                this.declareNameFromIdentifier(node.id, bindingType);
            }
        } else {
            if (optionalId || !isStatement5) {
                node.id = null;
            } else {
                throw this.raise(Errors.MissingClassName, this.state.startLoc);
            }
        }
    }
    
    parseClassSuper(node) {
        node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    
    parseExport(node, decorators) {
        const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);
        const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
        const parseAfterDefault = !hasDefault || this.eat(12);
        const hasStar = parseAfterDefault && this.eatExportStar(node);
        const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
        const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
        const isFromRequired = hasDefault || hasStar;
        
        if (hasStar && !hasNamespace) {
            if (hasDefault)
                this.unexpected();
            
            if (decorators) {
                throw this.raise(Errors.UnsupportedDecoratorExport, node);
            }
            
            this.parseExportFrom(node, true);
            this.sawUnambiguousESM = true;
            return this.finishNode(node, 'ExportAllDeclaration');
        }
        
        const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
        
        if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {
            this.unexpected(null, 5);
        }
        
        if (hasNamespace && parseAfterNamespace) {
            this.unexpected(null, 98);
        }
        
        let hasDeclaration;
        
        if (isFromRequired || hasSpecifiers) {
            hasDeclaration = false;
            
            if (decorators) {
                throw this.raise(Errors.UnsupportedDecoratorExport, node);
            }
            
            this.parseExportFrom(node, isFromRequired);
        } else {
            hasDeclaration = this.maybeParseExportDeclaration(node);
        }
        
        if (isFromRequired || hasSpecifiers || hasDeclaration) {
            const node2 = node;
            this.checkExport(node2, true, false, !!node2.source);
            
            if (node2.declaration?.type === 'ClassDeclaration') {
                this.maybeTakeDecorators(decorators, node2.declaration, node2);
            } else if (decorators) {
                throw this.raise(Errors.UnsupportedDecoratorExport, node);
            }
            
            this.sawUnambiguousESM = true;
            return this.finishNode(node2, 'ExportNamedDeclaration');
        }
        
        if (this.eat(65)) {
            const node2 = node;
            const decl = this.parseExportDefaultExpression();
            
            node2.declaration = decl;
            
            if (decl.type === 'ClassDeclaration') {
                this.maybeTakeDecorators(decorators, decl, node2);
            } else if (decorators) {
                throw this.raise(Errors.UnsupportedDecoratorExport, node);
            }
            
            this.checkExport(node2, true, true);
            this.sawUnambiguousESM = true;
            return this.finishNode(node2, 'ExportDefaultDeclaration');
        }
        
        this.unexpected(null, 5);
    }
    
    eatExportStar(node) {
        return this.eat(55);
    }
    
    maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
        if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
            this.expectPlugin('exportDefaultFrom', maybeDefaultIdentifier?.loc.start);
            const id = maybeDefaultIdentifier || this.parseIdentifier(true);
            const specifier = this.startNodeAtNode(id);
            
            specifier.exported = id;
            node.specifiers = [
                this.finishNode(specifier, 'ExportDefaultSpecifier'),
            ];
            return true;
        }
        
        return false;
    }
    
    maybeParseExportNamespaceSpecifier(node) {
        if (this.isContextual(93)) {
            node.specifiers ?? (node.specifiers = []);
            const specifier = this.startNodeAt(this.state.lastTokStartLoc);
            this.next();
            specifier.exported = this.parseModuleExportName();
            node.specifiers.push(this.finishNode(specifier, 'ExportNamespaceSpecifier'));
            return true;
        }
        
        return false;
    }
    
    maybeParseExportNamedSpecifiers(node) {
        if (this.match(5)) {
            const node2 = node;
            
            if (!node2.specifiers)
                node2.specifiers = [];
            
            const isTypeExport = node2.exportKind === 'type';
            node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
            node2.source = null;
            {
                node2.attributes = [];
            }
            node2.declaration = null;
            return true;
        }
        
        return false;
    }
    
    maybeParseExportDeclaration(node) {
        if (this.shouldParseExportDeclaration()) {
            node.specifiers = [];
            node.source = null;
            {
                node.attributes = [];
            }
            node.declaration = this.parseExportDeclaration(node);
            return true;
        }
        
        return false;
    }
    
    isAsyncFunction() {
        if (!this.isContextual(95))
            return false;
        
        const next = this.nextTokenInLineStart();
        
        return this.isUnparsedContextual(next, 'function');
    }
    
    parseExportDefaultExpression() {
        const expr = this.startNode();
        
        if (this.match(68)) {
            this.next();
            return this.parseFunction(expr, 1 | 4);
        } else if (this.isAsyncFunction()) {
            this.next();
            this.next();
            return this.parseFunction(expr, 1 | 4 | 8);
        }
        
        if (this.match(80)) {
            return this.parseClass(expr, true, true);
        }
        
        if (this.match(26)) {
            if (this.hasPlugin('decorators') && this.getPluginOption('decorators', 'decoratorsBeforeExport') === true) {
                this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
            }
            
            return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
        }
        
        if (this.match(75) || this.match(74) || this.isLet() || this.isUsing() || this.isAwaitUsing()) {
            throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);
        }
        
        const res = this.parseMaybeAssignAllowIn();
        this.semicolon();
        return res;
    }
    
    parseExportDeclaration(node) {
        if (this.match(80)) {
            const node2 = this.parseClass(this.startNode(), true, false);
            return node2;
        }
        
        return this.parseStatementListItem();
    }
    
    isExportDefaultSpecifier() {
        const {type} = this.state;
        
        if (tokenIsIdentifier(type)) {
            if (type === 95 && !this.state.containsEsc || type === 100) {
                return false;
            }
            
            if ((type === 130 || type === 129) && !this.state.containsEsc) {
                const next2 = this.nextTokenStart();
                const nextChar = this.input.charCodeAt(next2);
                
                if (nextChar === 123 || this.chStartsBindingIdentifier(nextChar, next2) && !this.input.startsWith('from', next2)) {
                    this.expectOnePlugin(['flow', 'typescript']);
                    return false;
                }
            }
        } else if (!this.match(65)) {
            return false;
        }
        
        const next = this.nextTokenStart();
        const hasFrom = this.isUnparsedContextual(next, 'from');
        
        if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
            return true;
        }
        
        if (this.match(65) && hasFrom) {
            const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
            return nextAfterFrom === 34 || nextAfterFrom === 39;
        }
        
        return false;
    }
    
    parseExportFrom(node, expect) {
        if (this.eatContextual(98)) {
            node.source = this.parseImportSource();
            this.checkExport(node);
            this.maybeParseImportAttributes(node);
            this.checkJSONModuleImport(node);
        } else if (expect) {
            this.unexpected();
        }
        
        this.semicolon();
    }
    
    shouldParseExportDeclaration() {
        const {type} = this.state;
        
        if (type === 26) {
            this.expectOnePlugin(['decorators', 'decorators-legacy']);
            
            if (this.hasPlugin('decorators')) {
                if (this.getPluginOption('decorators', 'decoratorsBeforeExport') === true) {
                    this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
                }
                
                return true;
            }
        }
        
        if (this.isUsing()) {
            this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
            return true;
        }
        
        if (this.isAwaitUsing()) {
            this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
            return true;
        }
        
        return type === 74
            || type === 75
            || type === 68
            || type === 80
            || this.isLet()
            || this.isAsyncFunction();
    }
    
    checkExport(node, checkNames, isDefault, isFrom) {
        if (checkNames) {
            if (isDefault) {
                this.checkDuplicateExports(node, 'default');
                
                if (this.hasPlugin('exportDefaultFrom')) {
                    const declaration = node.declaration;
                    
                    if (declaration.type === 'Identifier' && declaration.name === 'from' && declaration.end - declaration.start === 4 && !declaration.extra?.parenthesized) {
                        this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);
                    }
                }
            } else if (node.specifiers?.length) {
                for (const specifier of node.specifiers) {
                    const {exported} = specifier;
                    
                    const exportName = exported.type === 'Identifier' ? exported.name : exported.value;
                    this.checkDuplicateExports(specifier, exportName);
                    
                    if (!isFrom && specifier.local) {
                        const {local} = specifier;
                        
                        if (local.type !== 'Identifier') {
                            this.raise(Errors.ExportBindingIsString, specifier, {
                                localName: local.value,
                                exportName,
                            });
                        } else {
                            this.checkReservedWord(local.name, local.loc.start, true, false);
                            this.scope.checkLocalExport(local);
                        }
                    }
                }
            } else if (node.declaration) {
                const decl = node.declaration;
                
                if (decl.type === 'FunctionDeclaration' || decl.type === 'ClassDeclaration') {
                    const {id} = decl;
                    
                    if (!id)
                        throw new Error('Assertion failure');
                    
                    this.checkDuplicateExports(node, id.name);
                } else if (decl.type === 'VariableDeclaration') {
                    for (const declaration of decl.declarations) {
                        this.checkDeclaration(declaration.id);
                    }
                }
            }

        }
    }
    
    checkDeclaration(node) {
        if (node.type === 'Identifier') {
            this.checkDuplicateExports(node, node.name);
        } else if (node.type === 'ObjectPattern') {
            for (const prop of node.properties) {
                this.checkDeclaration(prop);
            }
        } else if (node.type === 'ArrayPattern') {
            for (const elem of node.elements) {
                if (elem) {
                    this.checkDeclaration(elem);
                }
            }
        } else if (node.type === 'ObjectProperty') {
            this.checkDeclaration(node.value);
        } else if (node.type === 'RestElement') {
            this.checkDeclaration(node.argument);
        } else if (node.type === 'AssignmentPattern') {
            this.checkDeclaration(node.left);
        }




    }
    
    checkDuplicateExports(node, exportName) {
        if (this.exportedIdentifiers.has(exportName)) {
            if (exportName === 'default') {
                this.raise(Errors.DuplicateDefaultExport, node);
            } else {
                this.raise(Errors.DuplicateExport, node, {
                    exportName,
                });
            }
        }
        
        this.exportedIdentifiers.add(exportName);
    }
    
    parseExportSpecifiers(isInTypeExport) {
        const nodes2 = [];
        let first = true;
        this.expect(5);
        while (!this.eat(8)) {
            if (first) {
                first = false;
            } else {
                this.expect(12);
                
                if (this.eat(8))
                    break;
            }
            
            const isMaybeTypeOnly = this.isContextual(130);
            const isString = this.match(134);
            const node = this.startNode();
            
            node.local = this.parseModuleExportName();
            nodes2.push(this.parseExportSpecifier(
                node,
                isString,
                isInTypeExport,
                isMaybeTypeOnly,
            ));
        }
        
        return nodes2;
    }
    
    parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
        if (this.eatContextual(93)) {
            node.exported = this.parseModuleExportName();
        } else if (isString) {
            node.exported = this.cloneStringLiteral(node.local);
        } else if (!node.exported) {
            node.exported = this.cloneIdentifier(node.local);
        }
        
        return this.finishNode(node, 'ExportSpecifier');
    }
    
    parseModuleExportName() {
        if (this.match(134)) {
            const result = this.parseStringLiteral(this.state.value);
            const surrogate = loneSurrogate.exec(result.value);
            
            if (surrogate) {
                this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {
                    surrogateCharCode: surrogate[0].charCodeAt(0),
                });
            }
            
            return result;
        }
        
        return this.parseIdentifier(true);
    }
    
    isJSONModuleImport(node) {
        if (node.assertions != null) {
            return node.assertions.some(({key, value}) => {
                return value.value === 'json' && (key.type === 'Identifier' ? key.name === 'type' : key.value === 'type');
            });
        }
        
        return false;
    }
    
    checkImportReflection(node) {
        const {specifiers} = node;
        
        const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
        
        if (node.phase === 'source') {
            if (singleBindingType !== 'ImportDefaultSpecifier') {
                this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);
            }
        } else if (node.phase === 'defer') {
            if (singleBindingType !== 'ImportNamespaceSpecifier') {
                this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);
            }
        } else if (node.module) {
            if (singleBindingType !== 'ImportDefaultSpecifier') {
                this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);
            }
            
            if (node.assertions?.length > 0) {
                this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);
            }
        }

    }
    
    checkJSONModuleImport(node) {
        if (this.isJSONModuleImport(node) && node.type !== 'ExportAllDeclaration') {
            const {specifiers} = node;
            
            if (specifiers != null) {
                const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
                    let imported;
                    
                    if (specifier.type === 'ExportSpecifier') {
                        imported = specifier.local;
                    } else if (specifier.type === 'ImportSpecifier') {
                        imported = specifier.imported;
                    }
                    
                    if (imported !== void 0) {
                        return imported.type === 'Identifier' ? imported.name !== 'default' : imported.value !== 'default';
                    }
                });
                
                if (nonDefaultNamedSpecifier !== void 0) {
                    this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);
                }
            }
        }
    }
    
    isPotentialImportPhase(isExport) {
        if (isExport)
            return false;
        
        return this.isContextual(105) || this.isContextual(97);
    }
    
    applyImportPhase(node, isExport, phase, loc) {
        if (isExport) {
            return;
        }
        
        if (this.hasPlugin('importReflection')) {
            node.module = false;
        }
        
        if (phase === 'source') {
            this.expectPlugin('sourcePhaseImports', loc);
            node.phase = 'source';
        } else if (phase === 'defer') {
            this.expectPlugin('deferredImportEvaluation', loc);
            node.phase = 'defer';
        } else if (this.hasPlugin('sourcePhaseImports')) {
            node.phase = null;
        }

    }
    
    parseMaybeImportPhase(node, isExport) {
        if (!this.isPotentialImportPhase(isExport)) {
            this.applyImportPhase(node, isExport, null);
            return null;
        }
        
        const phaseIdentifier = this.startNode();
        const phaseIdentifierName = this.parseIdentifierName(true);
        
        const {type} = this.state;
        
        const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
        
        if (isImportPhase) {
            this.applyImportPhase(node, isExport, phaseIdentifierName, phaseIdentifier.loc.start);
            return null;
        } else {
            this.applyImportPhase(node, isExport, null);
            return this.createIdentifier(phaseIdentifier, phaseIdentifierName);
        }
    }
    
    isPrecedingIdImportPhase(phase) {
        const {type} = this.state;
        
        return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
    }
    
    parseImport(node) {
        if (this.match(134)) {
            return this.parseImportSourceAndAttributes(node);
        }
        
        return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));
    }
    
    parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {
        node.specifiers = [];
        const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);
        const parseNext = !hasDefault || this.eat(12);
        const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
        
        if (parseNext && !hasStar)
            this.parseNamedImportSpecifiers(node);
        
        this.expectContextual(98);
        return this.parseImportSourceAndAttributes(node);
    }
    
    parseImportSourceAndAttributes(node) {
        node.specifiers ?? (node.specifiers = []);
        node.source = this.parseImportSource();
        this.maybeParseImportAttributes(node);
        this.checkImportReflection(node);
        this.checkJSONModuleImport(node);
        this.semicolon();
        this.sawUnambiguousESM = true;
        return this.finishNode(node, 'ImportDeclaration');
    }
    
    parseImportSource() {
        if (!this.match(134))
            this.unexpected();
        
        return this.parseExprAtom();
    }
    
    parseImportSpecifierLocal(node, specifier, type) {
        specifier.local = this.parseIdentifier();
        node.specifiers.push(this.finishImportSpecifier(specifier, type));
    }
    
    finishImportSpecifier(specifier, type, bindingType = 8201) {
        this.checkLVal(specifier.local, {
            type,
        }, bindingType);
        return this.finishNode(specifier, type);
    }
    
    parseImportAttributes() {
        this.expect(5);
        const attrs = [];
        const attrNames =         /* @__PURE__ */new Set();
        
        do {
            if (this.match(8)) {
                break;
            }
            
            const node = this.startNode();
            const keyName = this.state.value;
            
            if (attrNames.has(keyName)) {
                this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
                    key: keyName,
                });
            }
            
            attrNames.add(keyName);
            
            if (this.match(134)) {
                node.key = this.parseStringLiteral(keyName);
            } else {
                node.key = this.parseIdentifier(true);
            }
            
            this.expect(14);
            
            if (!this.match(134)) {
                throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
            }
            
            node.value = this.parseStringLiteral(this.state.value);
            attrs.push(this.finishNode(node, 'ImportAttribute'));
        } while (this.eat(12))
        this.expect(8);
        return attrs;
    }
    
    parseModuleAttributes() {
        const attrs = [];
        const attributes =         /* @__PURE__ */new Set();
        
        do {
            const node = this.startNode();
            
            node.key = this.parseIdentifier(true);
            
            if (node.key.name !== 'type') {
                this.raise(Errors.ModuleAttributeDifferentFromType, node.key);
            }
            
            if (attributes.has(node.key.name)) {
                this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {
                    key: node.key.name,
                });
            }
            
            attributes.add(node.key.name);
            this.expect(14);
            
            if (!this.match(134)) {
                throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
            }
            
            node.value = this.parseStringLiteral(this.state.value);
            attrs.push(this.finishNode(node, 'ImportAttribute'));
        } while (this.eat(12))
        
        return attrs;
    }
    
    maybeParseImportAttributes(node) {
        let attributes;
        
        if (this.match(76)) {
            if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {
                return;
            }
            
            this.next();
            {
                attributes = this.parseImportAttributes();
            }
        } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
            if (!this.hasPlugin('deprecatedImportAssert')) {
                this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);
            }
            
            {
                this.addExtra(node, 'deprecatedAssertSyntax', true);
            }
            this.next();
            attributes = this.parseImportAttributes();
        } else {
            attributes = [];
        }
        
        {
            node.attributes = attributes;
        }
    }
    
    maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {
        if (maybeDefaultIdentifier) {
            const specifier = this.startNodeAtNode(maybeDefaultIdentifier);
            
            specifier.local = maybeDefaultIdentifier;
            node.specifiers.push(this.finishImportSpecifier(specifier, 'ImportDefaultSpecifier'));
            return true;
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            this.parseImportSpecifierLocal(node, this.startNode(), 'ImportDefaultSpecifier');
            return true;
        }
        
        return false;
    }
    
    maybeParseStarImportSpecifier(node) {
        if (this.match(55)) {
            const specifier = this.startNode();
            this.next();
            this.expectContextual(93);
            this.parseImportSpecifierLocal(node, specifier, 'ImportNamespaceSpecifier');
            return true;
        }
        
        return false;
    }
    
    parseNamedImportSpecifiers(node) {
        let first = true;
        this.expect(5);
        while (!this.eat(8)) {
            if (first) {
                first = false;
            } else {
                if (this.eat(14)) {
                    throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);
                }
                
                this.expect(12);
                
                if (this.eat(8))
                    break;
            }
            
            const specifier = this.startNode();
            const importedIsString = this.match(134);
            const isMaybeTypeOnly = this.isContextual(130);
            
            specifier.imported = this.parseModuleExportName();
            const importSpecifier2 = this.parseImportSpecifier(specifier, importedIsString, node.importKind === 'type' || node.importKind === 'typeof', isMaybeTypeOnly, void 0);
            node.specifiers.push(importSpecifier2);
        }
    }
    
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        if (this.eatContextual(93)) {
            specifier.local = this.parseIdentifier();
        } else {
            const {imported} = specifier;
            
            if (importedIsString) {
                throw this.raise(Errors.ImportBindingIsString, specifier, {
                    importName: imported.value,
                });
            }
            
            this.checkReservedWord(imported.name, specifier.loc.start, true, true);
            
            if (!specifier.local) {
                specifier.local = this.cloneIdentifier(imported);
            }
        }
        
        return this.finishImportSpecifier(specifier, 'ImportSpecifier', bindingType);
    }
    
    isThisParam(param) {
        return param.type === 'Identifier' && param.name === 'this';
    }
};

var Parser = class extends StatementParser {
    constructor(options, input, pluginsMap) {
        options = getOptions(options);
        super(options, input);
        this.options = options;
        this.initializeScopes();
        this.plugins = pluginsMap;
        this.filename = options.sourceFilename;
        this.startIndex = options.startIndex;
        let optionFlags = 0;
        
        if (options.allowAwaitOutsideFunction) {
            optionFlags |= 1;
        }
        
        if (options.allowReturnOutsideFunction) {
            optionFlags |= 2;
        }
        
        if (options.allowImportExportEverywhere) {
            optionFlags |= 8;
        }
        
        if (options.allowSuperOutsideMethod) {
            optionFlags |= 16;
        }
        
        if (options.allowUndeclaredExports) {
            optionFlags |= 64;
        }
        
        if (options.allowNewTargetOutsideFunction) {
            optionFlags |= 4;
        }
        
        if (options.allowYieldOutsideFunction) {
            optionFlags |= 32;
        }
        
        if (options.ranges) {
            optionFlags |= 128;
        }
        
        if (options.tokens) {
            optionFlags |= 256;
        }
        
        if (options.createImportExpressions) {
            optionFlags |= 512;
        }
        
        if (options.createParenthesizedExpressions) {
            optionFlags |= 1024;
        }
        
        if (options.errorRecovery) {
            optionFlags |= 2048;
        }
        
        if (options.attachComment) {
            optionFlags |= 4096;
        }
        
        if (options.annexB) {
            optionFlags |= 8192;
        }
        
        this.optionFlags = optionFlags;
    }
    
    getScopeHandler() {
        return ScopeHandler;
    }
    
    parse() {
        this.enterInitialScopes();
        const file2 = this.startNode();
        const program3 = this.startNode();
        
        this.nextToken();
        file2.errors = null;
        this.parseTopLevel(file2, program3);
        file2.errors = this.state.errors;
        file2.comments.length = this.state.commentsLen;
        return file2;
    }
};

function parse$6(input, options) {
    if (options?.sourceType === 'unambiguous') {
        options = Object.assign({}, options);
        try {
            options.sourceType = 'module';
            const parser = getParser$1(options, input);
            const ast = parser.parse();
            
            if (parser.sawUnambiguousESM) {
                return ast;
            }
            
            if (parser.ambiguousScriptDifferentAst) {
                try {
                    options.sourceType = 'script';
                    return getParser$1(options, input).parse();
                } catch {}
            } else {
                ast.program.sourceType = 'script';
            }
            
            return ast;
        } catch(moduleError) {
            try {
                options.sourceType = 'script';
                return getParser$1(options, input).parse();
            } catch {}


                        throw moduleError;
        }
    } else {
        return getParser$1(options, input).parse();
    }
}

function parseExpression$1(input, options) {
    const parser = getParser$1(options, input);
    
    if (parser.options.strictMode) {
        parser.state.strict = true;
    }
    
    return parser.getExpression();
}

function generateExportedTokenTypes(internalTokenTypes) {
    const tokenTypes2 = {};
    
    for (const typeName of Object.keys(internalTokenTypes)) {
        tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
    }
    
    return tokenTypes2;
}

var tokTypes = generateExportedTokenTypes(tt);

function getParser$1(options, input) {
    let cls = Parser;
    const pluginsMap =     /* @__PURE__ */new Map();
    
    if (options?.plugins) {
        for (const plugin of options.plugins) {
            let name, opts;
            
            if (typeof plugin === 'string') {
                name = plugin;
            } else {
                [name, opts] = plugin;
            }
            
            if (!pluginsMap.has(name)) {
                pluginsMap.set(name, opts || {});
            }
        }
        
        validatePlugins(pluginsMap);
        cls = getParserClass(pluginsMap);
    }
    
    return new cls(options, input, pluginsMap);
}

var parserClassCache = /* @__PURE__ */new Map();

function getParserClass(pluginsMap) {
    const pluginList = [];
    
    for (const name of mixinPluginNames) {
        if (pluginsMap.has(name)) {
            pluginList.push(name);
        }
    }
    
    const key = pluginList.join('|');
    let cls = parserClassCache.get(key);
    
    if (!cls) {
        cls = Parser;
        for (const plugin of pluginList) {
            cls = mixinPlugins[plugin](cls);
        }
        
        parserClassCache.set(key, cls);
    }
    
    return cls;
}

// node_modules/@babel/code-frame/lib/index.js
var import_picocolors = __toESM(require_picocolors());
var import_js_tokens = __toESM(require_js_tokens());

function isColorSupported() {
    return typeof browser$1$1 === 'object' && (browser$1$1.env.FORCE_COLOR === '0' || browser$1$1.env.FORCE_COLOR === 'false') ? false : import_picocolors.default.isColorSupported;
}

var compose = (f, g) => (v) => f(g(v));

function buildDefs(colors) {
    return {
        keyword: colors.cyan,
        capitalized: colors.yellow,
        jsxIdentifier: colors.yellow,
        punctuator: colors.yellow,
        number: colors.magenta,
        string: colors.green,
        regex: colors.magenta,
        comment: colors.gray,
        invalid: compose(compose(colors.white, colors.bgRed), colors.bold),
        gutter: colors.gray,
        marker: compose(colors.red, colors.bold),
        message: compose(colors.red, colors.bold),
        reset: colors.reset,
    };
}

var defsOn = buildDefs((0, import_picocolors.createColors)(true));
var defsOff = buildDefs((0, import_picocolors.createColors)(false));

function getDefs(enabled) {
    return enabled ? defsOn : defsOff;
}

var sometimesKeywords = /* @__PURE__ */new Set([
    'as',
    'async',
    'from',
    'get',
    'of',
    'set',
]);
var NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
var BRACKET = /^[()[\]{}]$/;
var tokenize$2;

{
    const getTokenType = function(token) {
        if (token.type === 'IdentifierName') {
            if (isKeyword(token.value) || isStrictReservedWord(token.value, true) || sometimesKeywords.has(token.value)) {
                return 'keyword';
            }
            
            if (token.value[0] !== token.value[0].toLowerCase()) {
                return 'capitalized';
            }
        }
        
        if (token.type === 'Punctuator' && BRACKET.test(token.value)) {
            return 'uncolored';
        }
        
        if (token.type === 'Invalid' && token.value === '@') {
            return 'punctuator';
        }
        
        switch(token.type) {
        case 'NumericLiteral':
            return 'number';
        
        case 'StringLiteral':        
        case 'JSXString':        
        case 'NoSubstitutionTemplate':
            return 'string';
        
        case 'RegularExpressionLiteral':
            return 'regex';
        
        case 'Punctuator':        
        case 'JSXPunctuator':
            return 'punctuator';
        
        case 'MultiLineComment':        
        case 'SingleLineComment':
            return 'comment';
        
        case 'Invalid':        
        case 'JSXInvalid':
            return 'invalid';
        
        case 'JSXIdentifier':
            return 'jsxIdentifier';
        
        default:
            return 'uncolored';
        }
    };
    
    tokenize$2 = function*(text) {
        for (const token of (0, import_js_tokens.default)(text, {jsx: true})) {
            switch(token.type) {
            case 'TemplateHead':
                yield {
                    type: 'string',
                    value: token.value.slice(0, -2),
                };
                yield {
                    type: 'punctuator',
                    value: '${',
                };
                break;
            
            case 'TemplateMiddle':
                yield {
                    type: 'punctuator',
                    value: '}',
                };
                yield {
                    type: 'string',
                    value: token.value.slice(1, -2),
                };
                yield {
                    type: 'punctuator',
                    value: '${',
                };
                break;
            
            case 'TemplateTail':
                yield {
                    type: 'punctuator',
                    value: '}',
                };
                yield {
                    type: 'string',
                    value: token.value.slice(1),
                };
                break;
            
            default:
                yield {
                    type: getTokenType(token),
                    value: token.value,
                };
            }
        }
    };
}
function highlight(text) {
    if (text === '')
        return '';
    
    const defs = getDefs(true);
    let highlighted = '';
    
    for (const {type, value} of tokenize$2(text)) {
        if (type in defs) {
            highlighted += value
                .split(NEWLINE$1)
                .map((str) => defs[type](str))
                .join('\n');
        } else {
            highlighted += value;
        }
    }
    
    return highlighted;
}

var NEWLINE$2 = /\r\n|[\n\r\u2028\u2029]/;

function getMarkerLines(loc, source, opts) {
    const startLoc = Object.assign({
        column: 0,
        line: -1,
    }, loc.start);
    
    const endLoc = Object.assign({}, startLoc, loc.end);
    const {linesAbove = 2, linesBelow = 3} = opts || {};
    
    const startLine = startLoc.line;
    const startColumn = startLoc.column;
    const endLine = endLoc.line;
    const endColumn = endLoc.column;
    let start = Math.max(startLine - (linesAbove + 1), 0);
    let end = Math.min(source.length, endLine + linesBelow);
    
    if (startLine === -1) {
        start = 0;
    }
    
    if (endLine === -1) {
        end = source.length;
    }
    
    const lineDiff = endLine - startLine;
    const markerLines = {};
    
    if (lineDiff) {
        for (let i = 0; i <= lineDiff; i++) {
            const lineNumber = i + startLine;
            
            if (!startColumn) {
                markerLines[lineNumber] = true;
            } else if (i === 0) {
                const sourceLength = source[lineNumber - 1].length;
                markerLines[lineNumber] = [
                    startColumn,
                    sourceLength - startColumn + 1,
                ];
            } else if (i === lineDiff) {
                markerLines[lineNumber] = [0, endColumn];
            } else {
                const sourceLength = source[lineNumber - i].length;
                markerLines[lineNumber] = [0, sourceLength];
            }

        }
    } else {
        if (startColumn === endColumn) {
            if (startColumn) {
                markerLines[startLine] = [startColumn, 0];
            } else {
                markerLines[startLine] = true;
            }
        } else {
            markerLines[startLine] = [
                startColumn,
                endColumn - startColumn,
            ];
        }
    }
    
    return {
        start,
        end,
        markerLines,
    };
}

function codeFrameColumns$2(rawLines, loc, opts = {}) {
    const shouldHighlight = opts.forceColor || isColorSupported() && opts.highlightCode;
    const defs = getDefs(shouldHighlight);
    const lines = rawLines.split(NEWLINE$2);
    
    const {
        start,
        end,
        markerLines,
    } = getMarkerLines(loc, lines, opts);
    
    const hasColumns = loc.start && typeof loc.start.column === 'number';
    const numberMaxWidth = String(end).length;
    const highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;
    
    let frame = highlightedLines
        .split(NEWLINE$2, end)
        .slice(start, end)
        .map((line, index2) => {
        const number = start + 1 + index2;
        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
        const gutter = ` ${paddedNumber} |`;
        const hasMarker = markerLines[number];
        const lastMarkerLine = !markerLines[number + 1];
        
        if (hasMarker) {
            let markerLine = '';
            
            if (Array.isArray(hasMarker)) {
                const markerSpacing = line
                    .slice(0, Math.max(hasMarker[0] - 1, 0))
                    .replace(/[^\t]/g, ' ');
                const numberOfMarkers = hasMarker[1] || 1;
                
                markerLine = [
                    '\n ',
                    defs.gutter(gutter.replace(/\d/g, ' ')),
                    ' ',
                    markerSpacing,
                    defs
                        .marker('^')
                        .repeat(numberOfMarkers),
                ].join('');
                
                if (lastMarkerLine && opts.message) {
                    markerLine += ' ' + defs.message(opts.message);
                }
            }
            
            return [
                defs.marker('>'),
                defs.gutter(gutter),
                line.length > 0 ? ` ${line}` : '',
                markerLine,
            ].join('');
        } else {
            return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : ''}`;
        }
    })
        .join('\n');
    
    if (opts.message && !hasColumns) {
        frame = `${' '.repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
    }
    
    if (shouldHighlight) {
        return defs.reset(frame);
    } else {
        return frame;
    }
}

// node_modules/@babel/template/lib/index.js
var {assertExpressionStatement: assertExpressionStatement2} = lib_exports;

function makeStatementFormatter(fn) {
    return {
        code: (str) => `/* @babel/template */;
${str}`,
        validate: () => {},
        unwrap: (ast) => {
            return fn(ast.program.body.slice(1));
        },
    };
}

var smart$1 = makeStatementFormatter((body) => {
    if (body.length > 1) {
        return body;
    } else {
        return body[0];
    }
});

var statements$1$1 = makeStatementFormatter((body) => body);

var statement$1 = makeStatementFormatter((body) => {
    if (body.length === 0) {
        throw new Error('Found nothing to return.');
    }
    
    if (body.length > 1) {
        throw new Error('Found multiple statements but wanted one');
    }
    
    return body[0];
});

var expression$1 = {
    code: (str) => `(
${str}
)`,
    validate: (ast) => {
        if (ast.program.body.length > 1) {
            throw new Error('Found multiple statements but wanted one');
        }
        
        if (expression$1.unwrap(ast).start === 0) {
            throw new Error('Parse result included parens.');
        }
    },
    unwrap: ({program: program3}) => {
        const [stmt] = program3.body;
        assertExpressionStatement2(stmt);
        return stmt.expression;
    },
};

var program$1$1 = {
    code: (str) => str,
    validate: () => {},
    unwrap: (ast) => ast.program,
};

function _objectWithoutPropertiesLoose2(r, e) {
    if (null == r)
        return {};
    
    var t = {};
    
    for (var n2 in r)    if ({}.hasOwnProperty.call(r, n2)) {
        if (-1 !== e.indexOf(n2))
            continue;
        
        t[n2] = r[n2];
    }
    
    return t;
}

var _excluded2 = [
    'placeholderWhitelist',
    'placeholderPattern',
    'preserveComments',
    'syntacticPlaceholders',
];

function merge$3(a, b2) {
    const {
        placeholderWhitelist = a.placeholderWhitelist,
        placeholderPattern = a.placeholderPattern,
        preserveComments = a.preserveComments,
        syntacticPlaceholders = a.syntacticPlaceholders,
    } = b2;
    
    return {
        parser: Object.assign({}, a.parser, b2.parser),
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders,
    };
}

function validate$12(opts) {
    if (opts != null && typeof opts !== 'object') {
        throw new Error('Unknown template options.');
    }
    
    const _ref = opts || {}, {
            placeholderWhitelist,
            placeholderPattern,
            preserveComments,
            syntacticPlaceholders,
        } = _ref, parser = _objectWithoutPropertiesLoose2(_ref, _excluded2);
    
    if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
        throw new Error('\'.placeholderWhitelist\' must be a Set, null, or undefined');
    }
    
    if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
        throw new Error('\'.placeholderPattern\' must be a RegExp, false, null, or undefined');
    }
    
    if (preserveComments != null && typeof preserveComments !== 'boolean') {
        throw new Error('\'.preserveComments\' must be a boolean, null, or undefined');
    }
    
    if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== 'boolean') {
        throw new Error('\'.syntacticPlaceholders\' must be a boolean, null, or undefined');
    }
    
    if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
        throw new Error('\'.placeholderWhitelist\' and \'.placeholderPattern\' aren\'t compatible with \'.syntacticPlaceholders: true\'');
    }
    
    return {
        parser,
        placeholderWhitelist: placeholderWhitelist || void 0,
        placeholderPattern: placeholderPattern == null ? void 0 : placeholderPattern,
        preserveComments: preserveComments == null ? void 0 : preserveComments,
        syntacticPlaceholders: syntacticPlaceholders == null ? void 0 : syntacticPlaceholders,
    };
}

function normalizeReplacements(replacements) {
    if (Array.isArray(replacements)) {
        return replacements.reduce((acc, replacement, i) => {
            acc['$' + i] = replacement;
            return acc;
        }, {});
    } else if (typeof replacements === 'object' || replacements == null) {
        return replacements || void 0;
    }
    
    throw new Error('Template replacements must be an array, object, null, or undefined');
}

var {
    isCallExpression: isCallExpression2,
    isExpressionStatement: isExpressionStatement2,
    isFunction: isFunction2,
    isIdentifier: isIdentifier2,
    isJSXIdentifier: isJSXIdentifier2,
    isNewExpression: isNewExpression2,
    isPlaceholder: isPlaceholder2,
    isStatement: isStatement$1$1,
    isStringLiteral: isStringLiteral$1$1,
    removePropertiesDeep: removePropertiesDeep2,
    traverse: traverse2,
} = lib_exports;

var PATTERN = /^[_$A-Z0-9]+$/;

function parseAndBuildMetadata(formatter, code2, opts) {
    const {
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders,
    } = opts;
    
    const ast = parseWithCodeFrame(code2, opts.parser, syntacticPlaceholders);
    
    removePropertiesDeep2(ast, {
        preserveComments,
    });
    formatter.validate(ast);
    const state = {
        syntactic: {
            placeholders: [],
            placeholderNames:             /* @__PURE__ */new Set(),
        },
        legacy: {
            placeholders: [],
            placeholderNames:             /* @__PURE__ */new Set(),
        },
        placeholderWhitelist,
        placeholderPattern,
        syntacticPlaceholders,
    };
    
    traverse2(ast, placeholderVisitorHandler, state);
    return Object.assign({
        ast,
    }, state.syntactic.placeholders.length ? state.syntactic : state.legacy);
}

function placeholderVisitorHandler(node, ancestors, state) {
    let name;
    let hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;
    
    if (isPlaceholder2(node)) {
        if (state.syntacticPlaceholders === false) {
            throw new Error('%%foo%%-style placeholders can\'t be used when \'.syntacticPlaceholders\' is false.');
        }
        
        name = node.name.name;
        hasSyntacticPlaceholders = true;
    } else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {
        return;
    } else if (isIdentifier2(node) || isJSXIdentifier2(node)) {
        name = node.name;
    } else if (isStringLiteral$1$1(node)) {
        name = node.value;
    } else {
        return;
    }

    
    if (hasSyntacticPlaceholders && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
        throw new Error('\'.placeholderWhitelist\' and \'.placeholderPattern\' aren\'t compatible with \'.syntacticPlaceholders: true\'');
    }
    
    if (!hasSyntacticPlaceholders && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !state.placeholderWhitelist?.has(name)) {
        return;
    }
    
    ancestors = ancestors.slice();
    const {node: parent, key} = ancestors[ancestors.length - 1];
    
    let type;
    
    if (isStringLiteral$1$1(node) || isPlaceholder2(node, {expectedNode: 'StringLiteral'})) {
        type = 'string';
    } else if (isNewExpression2(parent) && key === 'arguments' || isCallExpression2(parent) && key === 'arguments' || isFunction2(parent) && key === 'params') {
        type = 'param';
    } else if (isExpressionStatement2(parent) && !isPlaceholder2(node)) {
        type = 'statement';
        ancestors = ancestors.slice(0, -1);
    } else if (isStatement$1$1(node) && isPlaceholder2(node)) {
        type = 'statement';
    } else {
        type = 'other';
    }

    
    const {
        placeholders: placeholders2,
        placeholderNames,
    } = !hasSyntacticPlaceholders ? state.legacy : state.syntactic;
    
    placeholders2.push({
        name,
        type,
        resolve: (ast) => resolveAncestors(ast, ancestors),
        isDuplicate: placeholderNames.has(name),
    });
    placeholderNames.add(name);
}

function resolveAncestors(ast, ancestors) {
    let parent = ast;
    
    for (let i = 0; i < ancestors.length - 1; i++) {
        const {key: key2, index: index3} = ancestors[i];
        
        if (index3 === void 0) {
            parent = parent[key2];
        } else {
            parent = parent[key2][index3];
        }
    }
    
    const {key, index: index2} = ancestors[ancestors.length - 1];
    
    return {
        parent,
        key,
        index: index2,
    };
}

function parseWithCodeFrame(code2, parserOpts, syntacticPlaceholders) {
    const plugins = (parserOpts.plugins || []).slice();
    
    if (syntacticPlaceholders !== false) {
        plugins.push('placeholders');
    }
    
    parserOpts = Object.assign({
        allowAwaitOutsideFunction: true,
        allowReturnOutsideFunction: true,
        allowNewTargetOutsideFunction: true,
        allowSuperOutsideMethod: true,
        allowYieldOutsideFunction: true,
        sourceType: 'module',
    }, parserOpts, {
        plugins,
    });
    try {
        return parse$6(code2, parserOpts);
    } catch(err) {
        const loc = err.loc;
        
        if (loc) {
            err.message += '\n' + codeFrameColumns$2(code2, {
                start: loc,
            });
            err.code = 'BABEL_TEMPLATE_PARSE_ERROR';
        }
        
        throw err;
    }
}

var {
    blockStatement: blockStatement2,
    cloneNode: cloneNode2,
    emptyStatement: emptyStatement2,
    expressionStatement: expressionStatement2,
    identifier: identifier2,
    isStatement: isStatement2,
    isStringLiteral: isStringLiteral2,
    stringLiteral: stringLiteral2,
    validate: validate2,
} = lib_exports;

function populatePlaceholders(metadata, replacements) {
    const ast = cloneNode2(metadata.ast);
    
    if (replacements) {
        metadata.placeholders.forEach((placeholder2) => {
            if (!Object.hasOwn(replacements, placeholder2.name)) {
                const placeholderName = placeholder2.name;
                
                throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`);
            }
        });
        Object
            .keys(replacements)
            .forEach((key) => {
                if (!metadata.placeholderNames.has(key)) {
                    throw new Error(`Unknown substitution "${key}" given`);
                }
            });
    }
    
    metadata.placeholders
        .slice()
        .reverse()
        .forEach((placeholder2) => {
            try {
                applyReplacement(placeholder2, ast, (replacements && replacements[placeholder2.name]) ?? null);
            } catch(e) {
                e.message = `@babel/template placeholder "${placeholder2.name}": ${e.message}`;
                throw e;
            }
        });
    return ast;
}

function applyReplacement(placeholder2, ast, replacement) {
    if (placeholder2.isDuplicate) {
        if (Array.isArray(replacement)) {
            replacement = replacement.map((node) => cloneNode2(node));
        } else if (typeof replacement === 'object') {
            replacement = cloneNode2(replacement);
        }
    }
    
    const {
        parent,
        key,
        index: index2,
    } = placeholder2.resolve(ast);
    
    if (placeholder2.type === 'string') {
        if (typeof replacement === 'string') {
            replacement = stringLiteral2(replacement);
        }
        
        if (!replacement || !isStringLiteral2(replacement)) {
            throw new Error('Expected string substitution');
        }
    } else if (placeholder2.type === 'statement') {
        if (index2 === void 0) {
            if (!replacement) {
                replacement = emptyStatement2();
            } else if (Array.isArray(replacement)) {
                replacement = blockStatement2(replacement);
            } else if (typeof replacement === 'string') {
                replacement = expressionStatement2(identifier2(replacement));
            } else if (!isStatement2(replacement)) {
                replacement = expressionStatement2(replacement);
            }


        } else {
            if (replacement && !Array.isArray(replacement)) {
                if (typeof replacement === 'string') {
                    replacement = identifier2(replacement);
                }
                
                if (!isStatement2(replacement)) {
                    replacement = expressionStatement2(replacement);
                }
            }
        }
    } else if (placeholder2.type === 'param') {
        if (typeof replacement === 'string') {
            replacement = identifier2(replacement);
        }
        
        if (index2 === void 0)
            throw new Error('Assertion failure.');
    } else {
        if (typeof replacement === 'string') {
            replacement = identifier2(replacement);
        }
        
        if (Array.isArray(replacement)) {
            throw new Error('Cannot replace single expression with an array.');
        }
    }
    
    function set(parent2, key2, value) {
        const node = parent2[key2];
        
        parent2[key2] = value;
        
        if (node.type === 'Identifier' || node.type === 'Placeholder') {
            if (node.typeAnnotation) {
                value.typeAnnotation = node.typeAnnotation;
            }
            
            if (node.optional) {
                value.optional = node.optional;
            }
            
            if (node.decorators) {
                value.decorators = node.decorators;
            }
        }
    }
    
    if (index2 === void 0) {
        validate2(parent, key, replacement);
        set(parent, key, replacement);
    } else {
        const items = parent[key].slice();
        
        if (placeholder2.type === 'statement' || placeholder2.type === 'param') {
            if (replacement == null) {
                items.splice(index2, 1);
            } else if (Array.isArray(replacement)) {
                items.splice(index2, 1, ...replacement);
            } else {
                set(items, index2, replacement);
            }
        } else {
            set(items, index2, replacement);
        }
        
        validate2(parent, key, items);
        parent[key] = items;
    }
}

function stringTemplate(formatter, code2, opts) {
    code2 = formatter.code(code2);
    let metadata;
    
    return (arg) => {
        const replacements = normalizeReplacements(arg);
        
        if (!metadata)
            metadata = parseAndBuildMetadata(formatter, code2, opts);
        
        return formatter.unwrap(populatePlaceholders(
            metadata,
            replacements,
        ));
    };
}

function literalTemplate(formatter, tpl, opts) {
    const {metadata, names} = buildLiteralData(formatter, tpl, opts);
    
    return (arg) => {
        const defaultReplacements = {};
        
        arg.forEach((replacement, i) => {
            defaultReplacements[names[i]] = replacement;
        });
        return (arg2) => {
            const replacements = normalizeReplacements(arg2);
            
            if (replacements) {
                Object
                    .keys(replacements)
                    .forEach((key) => {
                        if (Object.hasOwn(defaultReplacements, key)) {
                            throw new Error('Unexpected replacement overlap.');
                        }
                    });
            }
            
            return formatter.unwrap(populatePlaceholders(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
        };
    };
}

function buildLiteralData(formatter, tpl, opts) {
    let prefix2 = 'BABEL_TPL$';
    const raw = tpl.join('');
    
    do {
        prefix2 = '$$' + prefix2;
    } while (raw.includes(prefix2))
    const {names, code: code2} = buildTemplateCode(tpl, prefix2);
    
    const metadata = parseAndBuildMetadata(formatter, formatter.code(code2), {
        parser: opts.parser,
        placeholderWhitelist: new Set(names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
        placeholderPattern: opts.placeholderPattern,
        preserveComments: opts.preserveComments,
        syntacticPlaceholders: opts.syntacticPlaceholders,
    });
    
    return {
        metadata,
        names,
    };
}

function buildTemplateCode(tpl, prefix2) {
    const names = [];
    let code2 = tpl[0];
    
    for (let i = 1; i < tpl.length; i++) {
        const value = `${prefix2}${i - 1}`;
        names.push(value);
        code2 += value + tpl[i];
    }
    
    return {
        names,
        code: code2,
    };
}

var NO_PLACEHOLDER = validate$12({
    placeholderPattern: false,
});

function createTemplateBuilder(formatter, defaultOpts) {
    const templateFnCache =     /* @__PURE__ */new WeakMap();
    const templateAstCache =     /* @__PURE__ */new WeakMap();
    const cachedOpts = defaultOpts || validate$12(null);
    
    return Object.assign((tpl, ...args) => {
        if (typeof tpl === 'string') {
            if (args.length > 1)
                throw new Error('Unexpected extra params.');
            
            return extendedTrace(stringTemplate(formatter, tpl, merge$3(cachedOpts, validate$12(args[0]))));
        } else if (Array.isArray(tpl)) {
            let builder = templateFnCache.get(tpl);
            
            if (!builder) {
                builder = literalTemplate(formatter, tpl, cachedOpts);
                templateFnCache.set(tpl, builder);
            }
            
            return extendedTrace(builder(args));
        } else if (typeof tpl === 'object' && tpl) {
            if (args.length > 0)
                throw new Error('Unexpected extra params.');
            
            return createTemplateBuilder(formatter, merge$3(cachedOpts, validate$12(tpl)));
        }
        
        throw new Error(`Unexpected template param ${typeof tpl}`);
    }, {
        ast: (tpl, ...args) => {
            if (typeof tpl === 'string') {
                if (args.length > 1)
                    throw new Error('Unexpected extra params.');
                
                return stringTemplate(formatter, tpl, merge$3(
                    merge$3(cachedOpts, validate$12(args[0])),
                    NO_PLACEHOLDER,
                ))();
            } else if (Array.isArray(tpl)) {
                let builder = templateAstCache.get(tpl);
                
                if (!builder) {
                    builder = literalTemplate(formatter, tpl, merge$3(
                        cachedOpts,
                        NO_PLACEHOLDER,
                    ));
                    templateAstCache.set(tpl, builder);
                }
                
                return builder(args)();
            }
            
            throw new Error(`Unexpected template param ${typeof tpl}`);
        },
    });
}

function extendedTrace(fn) {
    let rootStack = '';
    
    try {
        throw new Error();
    } catch(error) {
        if (error.stack) {
            rootStack = error.stack
                .split('\n')
                .slice(3)
                .join('\n');
        }
    }


        
    return (arg) => {
        try {
            return fn(arg);
        } catch(err) {
            err.stack += `
    =============
${rootStack}`;
            throw err;
        }
    };
}

var smart = createTemplateBuilder(smart$1);
var statement = createTemplateBuilder(statement$1);
var statements$3 = createTemplateBuilder(statements$1$1);
var expression = createTemplateBuilder(expression$1);
var program2 = createTemplateBuilder(program$1$1);

var index$1 = Object.assign(smart.bind(void 0), {
    smart,
    statement,
    statements: statements$3,
    expression,
    program: program2,
    ast: smart.ast,
});

// node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
var comma = ','.charCodeAt(0);
var semicolon = ';'.charCodeAt(0);
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);

for (let i = 0; i < chars.length; i++) {
    const c = chars.charCodeAt(i);
    
    intToChar[i] = c;
    charToInt[c] = i;
}

function decodeInteger(reader, relative) {
    let value = 0;
    let shift = 0;
    let integer = 0;
    
    do {
        const c = reader.next();
        
        integer = charToInt[c];
        value |= (integer & 31) << shift;
        shift += 5;
    } while (integer & 32)
    const shouldNegate = value & 1;
    
    value >>>= 1;
    
    if (shouldNegate) {
        value = -2147483648 | -value;
    }
    
    return relative + value;
}

function encodeInteger(builder, num, relative) {
    let delta = num - relative;
    
    delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
    do {
        let clamped = delta & 31;
        
        delta >>>= 5;
        
        if (delta > 0)
            clamped |= 32;
        
        builder.write(intToChar[clamped]);
    } while (delta > 0)
    
    return num;
}

function hasMoreVlq(reader, max) {
    if (reader.pos >= max)
        return false;
    
    return reader.peek() !== comma;
}

var bufLength = 1024 * 16;

var td = typeof TextDecoder !== 'undefined' ? /* @__PURE__ */new TextDecoder() : typeof Buffer !== 'undefined' ? {
    decode(buf) {
        const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
        return out.toString();
    },
} : {
    decode(buf) {
        let out = '';
        
        for (let i = 0; i < buf.length; i++) {
            out += String.fromCharCode(buf[i]);
        }
        
        return out;
    },
};

var StringWriter = class {
    constructor() {
        this.pos = 0;
        this.out = '';
        this.buffer = new Uint8Array(bufLength);
    }
    
    write(v) {
        const {buffer} = this;
        
        buffer[this.pos++] = v;
        
        if (this.pos === bufLength) {
            this.out += td.decode(buffer);
            this.pos = 0;
        }
    }
    
    flush() {
        const {
            buffer,
            out,
            pos,
        } = this;
        return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
    }
};

var StringReader = class {
    constructor(buffer) {
        this.pos = 0;
        this.buffer = buffer;
    }
    
    next() {
        return this.buffer.charCodeAt(this.pos++);
    }
    
    peek() {
        return this.buffer.charCodeAt(this.pos);
    }
    
    indexOf(char) {
        const {buffer, pos} = this;
        const idx = buffer.indexOf(char, pos);
        
        return idx === -1 ? buffer.length : idx;
    }
};

function decode(mappings) {
    const {length} = mappings;
    const reader = new StringReader(mappings);
    const decoded = [];
    let genColumn = 0;
    let sourcesIndex = 0;
    let sourceLine = 0;
    let sourceColumn = 0;
    let namesIndex = 0;
    
    do {
        const semi = reader.indexOf(';');
        const line = [];
        let sorted = true;
        let lastCol = 0;
        
        genColumn = 0;
        while (reader.pos < semi) {
            let seg;
            
            genColumn = decodeInteger(reader, genColumn);
            
            if (genColumn < lastCol)
                sorted = false;
            
            lastCol = genColumn;
            
            if (hasMoreVlq(reader, semi)) {
                sourcesIndex = decodeInteger(reader, sourcesIndex);
                sourceLine = decodeInteger(reader, sourceLine);
                sourceColumn = decodeInteger(reader, sourceColumn);
                
                if (hasMoreVlq(reader, semi)) {
                    namesIndex = decodeInteger(reader, namesIndex);
                    seg = [
                        genColumn,
                        sourcesIndex,
                        sourceLine,
                        sourceColumn,
                        namesIndex,
                    ];
                } else {
                    seg = [
                        genColumn,
                        sourcesIndex,
                        sourceLine,
                        sourceColumn,
                    ];
                }
            } else {
                seg = [genColumn];
            }
            
            line.push(seg);
            reader.pos++;
        }
        
        if (!sorted)
            sort(line);
        
        decoded.push(line);
        reader.pos = semi + 1;
    } while (reader.pos <= length)
    
    return decoded;
}

function sort(line) {
    line.sort(sortComparator);
}

function sortComparator(a, b2) {
    return a[0] - b2[0];
}

function encode(decoded) {
    const writer = new StringWriter();
    let sourcesIndex = 0;
    let sourceLine = 0;
    let sourceColumn = 0;
    let namesIndex = 0;
    
    for (let i = 0; i < decoded.length; i++) {
        const line = decoded[i];
        
        if (i > 0)
            writer.write(semicolon);
        
        if (line.length === 0)
            continue;
        
        let genColumn = 0;
        
        for (let j = 0; j < line.length; j++) {
            const segment = line[j];
            
            if (j > 0)
                writer.write(comma);
            
            genColumn = encodeInteger(writer, segment[0], genColumn);
            
            if (segment.length === 1)
                continue;
            
            sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
            sourceLine = encodeInteger(writer, segment[2], sourceLine);
            sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
            
            if (segment.length === 4)
                continue;
            
            namesIndex = encodeInteger(writer, segment[4], namesIndex);
        }
    }
    
    return writer.flush();
}

// node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs
var schemeRegex = /^[\w+.-]+:\/\//;
var urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
var fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;

function isAbsoluteUrl(input) {
    return schemeRegex.test(input);
}

function isSchemeRelativeUrl(input) {
    return input.startsWith('//');
}

function isAbsolutePath(input) {
    return input.startsWith('/');
}

function isFileUrl(input) {
    return input.startsWith('file:');
}

function isRelative(input) {
    return /^[.?#]/.test(input);
}

function parseAbsoluteUrl(input) {
    const match = urlRegex.exec(input);
    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');
}

function parseFileUrl(input) {
    const match = fileRegex.exec(input);
    const path = match[2];
    
    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');
}

function makeUrl(scheme, user, host, port, path, query, hash) {
    return {
        scheme,
        user,
        host,
        port,
        path,
        query,
        hash,
        type: 7,
    };
}

function parseUrl(input) {
    if (isSchemeRelativeUrl(input)) {
        const url2 = parseAbsoluteUrl('http:' + input);
        
        url2.scheme = '';
        url2.type = 6;
        return url2;
    }
    
    if (isAbsolutePath(input)) {
        const url2 = parseAbsoluteUrl('http://foo.com' + input);
        
        url2.scheme = '';
        url2.host = '';
        url2.type = 5;
        return url2;
    }
    
    if (isFileUrl(input))
        return parseFileUrl(input);
    
    if (isAbsoluteUrl(input))
        return parseAbsoluteUrl(input);
    
    const url = parseAbsoluteUrl('http://foo.com/' + input);
    
    url.scheme = '';
    url.host = '';
    url.type = input ? input.startsWith('?') ? 3 : input.startsWith('#') ? 2 : 4 : 1;
    return url;
}

function stripPathFilename(path) {
    if (path.endsWith('/..'))
        return path;
    
    const index2 = path.lastIndexOf('/');
    
    return path.slice(0, index2 + 1);
}

function mergePaths(url, base) {
    normalizePath(base, base.type);
    
    if (url.path === '/') {
        url.path = base.path;
    } else {
        url.path = stripPathFilename(base.path) + url.path;
    }
}

function normalizePath(url, type) {
    const rel = type <= 4;
    const pieces = url.path.split('/');
    let pointer = 1;
    let positive = 0;
    let addTrailingSlash = false;
    
    for (let i = 1; i < pieces.length; i++) {
        const piece = pieces[i];
        
        if (!piece) {
            addTrailingSlash = true;
            continue;
        }
        
        addTrailingSlash = false;
        
        if (piece === '.')
            continue;
        
        if (piece === '..') {
            if (positive) {
                addTrailingSlash = true;
                positive--;
                pointer--;
            } else if (rel) {
                pieces[pointer++] = piece;
            }
            
            continue;
        }
        
        pieces[pointer++] = piece;
        positive++;
    }
    
    let path = '';
    
    for (let i = 1; i < pointer; i++) {
        path += '/' + pieces[i];
    }
    
    if (!path || addTrailingSlash && !path.endsWith('/..')) {
        path += '/';
    }
    
    url.path = path;
}

function resolve$1(input, base) {
    if (!input && !base)
        return '';
    
    const url = parseUrl(input);
    let inputType = url.type;
    
    if (base && inputType !== 7) {
        const baseUrl = parseUrl(base);
        const baseType = baseUrl.type;
        
        switch(inputType) {
        case 1:
            url.hash = baseUrl.hash;
        
        // fall through
case 2:
            url.query = baseUrl.query;
        
        // fall through
case 3:        
        case 4:
            mergePaths(url, baseUrl);
        
        // fall through
case 5:
            url.user = baseUrl.user;
            url.host = baseUrl.host;
            url.port = baseUrl.port;
        
        // fall through
case 6:
            url.scheme = baseUrl.scheme;
        }
        
        if (baseType > inputType)
            inputType = baseType;
    }
    
    normalizePath(url, inputType);
    const queryHash = url.query + url.hash;
    
    switch(inputType) {
    // This is impossible, because of the empty checks at the start of the function.
// case UrlType.Empty:
case 2:    
    case 3:
        return queryHash;
    
    case 4: {
        const path = url.path.slice(1);
        
        if (!path)
            return queryHash || '.';
        
        if (isRelative(base || input) && !isRelative(path)) {
            return './' + path + queryHash;
        }
        
        return path + queryHash;
    }
    
    case 5:
        return url.path + queryHash;
    
    default:
        return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;
    }
}

// node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs
function stripFilename(path) {
    if (!path)
        return '';
    
    const index2 = path.lastIndexOf('/');
    
    return path.slice(0, index2 + 1);
}

function resolver(mapUrl, sourceRoot) {
    const from = stripFilename(mapUrl);
    const prefix2 = sourceRoot ? sourceRoot + '/' : '';
    
    return (source) => resolve$1(prefix2 + (source || ''), from);
}

var COLUMN = 0;
var SOURCES_INDEX = 1;
var SOURCE_LINE = 2;
var SOURCE_COLUMN = 3;
var NAMES_INDEX = 4;

function maybeSort(mappings, owned) {
    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
    
    if (unsortedIndex === mappings.length)
        return mappings;
    
    if (!owned)
        mappings = mappings.slice();
    
    for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
        mappings[i] = sortSegments(mappings[i], owned);
    }
    
    return mappings;
}

function nextUnsortedSegmentLine(mappings, start) {
    for (let i = start; i < mappings.length; i++) {
        if (!isSorted(mappings[i]))
            return i;
    }
    
    return mappings.length;
}

function isSorted(line) {
    for (let j = 1; j < line.length; j++) {
        if (line[j][COLUMN] < line[j - 1][COLUMN]) {
            return false;
        }
    }
    
    return true;
}

function sortSegments(line, owned) {
    if (!owned)
        line = line.slice();
    
    return line.sort(sortComparator2);
}

function sortComparator2(a, b2) {
    return a[COLUMN] - b2[COLUMN];
}

var found = false;

function binarySearch(haystack, needle, low, high) {
    while (low <= high) {
        const mid = low + (high - low >> 1);
        const cmp = haystack[mid][COLUMN] - needle;
        
        if (cmp === 0) {
            found = true;
            return mid;
        }
        
        if (cmp < 0) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    
    found = false;
    return low - 1;
}

function upperBound(haystack, needle, index2) {
    for (let i = index2 + 1; i < haystack.length; index2 = i++) {
        if (haystack[i][COLUMN] !== needle)
            break;
    }
    
    return index2;
}

function lowerBound(haystack, needle, index2) {
    for (let i = index2 - 1; i >= 0; index2 = i--) {
        if (haystack[i][COLUMN] !== needle)
            break;
    }
    
    return index2;
}

function memoizedState() {
    return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1,
    };
}

function memoizedBinarySearch(haystack, needle, state, key) {
    const {
        lastKey,
        lastNeedle,
        lastIndex,
    } = state;
    let low = 0;
    let high = haystack.length - 1;
    
    if (key === lastKey) {
        if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
        }
        
        if (needle >= lastNeedle) {
            low = lastIndex === -1 ? 0 : lastIndex;
        } else {
            high = lastIndex;
        }
    }
    
    state.lastKey = key;
    state.lastNeedle = needle;
    return state.lastIndex = binarySearch(haystack, needle, low, high);
}

function parse2(map) {
    return typeof map === 'string' ? JSON.parse(map) : map;
}

var LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';
var COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';
var LEAST_UPPER_BOUND = -1;
var GREATEST_LOWER_BOUND = 1;

var TraceMap = class {
    constructor(map, mapUrl) {
        const isString = typeof map === 'string';
        
        if (!isString && map._decodedMemo)
            return map;
        
        const parsed = parse2(map);
        const {
            version,
            file: file2,
            names,
            sourceRoot,
            sources,
            sourcesContent,
        } = parsed;
        
        this.version = version;
        this.file = file2;
        this.names = names || [];
        this.sourceRoot = sourceRoot;
        this.sources = sources;
        this.sourcesContent = sourcesContent;
        this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
        const resolve3 = resolver(mapUrl, sourceRoot);
        
        this.resolvedSources = sources.map(resolve3);
        const {mappings} = parsed;
        
        if (typeof mappings === 'string') {
            this._encoded = mappings;
            this._decoded = void 0;
        } else if (Array.isArray(mappings)) {
            this._encoded = void 0;
            this._decoded = maybeSort(mappings, isString);
        } else if (parsed.sections) {
            throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);
        } else {
            throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);
        }
        
        this._decodedMemo = memoizedState();
        this._bySources = void 0;
        this._bySourceMemos = void 0;
    }
};

function cast(map) {
    return map;
}

function decodedMappings(map) {
    var _a;
    return (_a = cast(map))._decoded || (_a._decoded = decode(cast(map)._encoded));
}

function originalPositionFor(map, needle) {
    let {
        line,
        column,
        bias,
    } = needle;
    line--;
    
    if (line < 0)
        throw new Error(LINE_GTR_ZERO);
    
    if (column < 0)
        throw new Error(COL_GTR_EQ_ZERO);
    
    const decoded = decodedMappings(map);
    
    if (line >= decoded.length)
        return OMapping(null, null, null, null);
    
    const segments = decoded[line];
    
    const index2 = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
    
    if (index2 === -1)
        return OMapping(null, null, null, null);
    
    const segment = segments[index2];
    
    if (segment.length === 1)
        return OMapping(null, null, null, null);
    
    const {
        names,
        resolvedSources,
    } = map;
    
    return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
}

function OMapping(source, line, column, name) {
    return {
        source,
        line,
        column,
        name,
    };
}

function traceSegmentInternal(segments, memo, line, column, bias) {
    let index2 = memoizedBinarySearch(segments, column, memo, line);
    
    if (found) {
        index2 = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index2);
    }    else if (bias === LEAST_UPPER_BOUND)
        index2++;
    
    if (index2 === -1 || index2 === segments.length)
        return -1;
    
    return index2;
}

// node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs
var SetArray = class {
    constructor() {
        this._indexes = {
            __proto__: null,
        };
        this.array = [];
    }
};

function cast2(set) {
    return set;
}

function get$1(setarr, key) {
    return cast2(setarr)._indexes[key];
}

function put(setarr, key) {
    const index2 = get$1(setarr, key);
    
    if (index2 !== void 0)
        return index2;
    
    const {array, _indexes: indexes} = cast2(setarr);
    const length = array.push(key);
    
    return indexes[key] = length - 1;
}

var COLUMN2 = 0;
var SOURCES_INDEX2 = 1;
var SOURCE_LINE2 = 2;
var SOURCE_COLUMN2 = 3;
var NAMES_INDEX2 = 4;
var NO_NAME = -1;

var GenMapping = class {
    constructor({file: file2, sourceRoot} = {}) {
        this._names = new SetArray();
        this._sources = new SetArray();
        this._sourcesContent = [];
        this._mappings = [];
        this.file = file2;
        this.sourceRoot = sourceRoot;
        this._ignoreList = new SetArray();
    }
};

function cast22(map) {
    return map;
}

var maybeAddMapping = (map, mapping) => {
    return addMappingInternal(true, map, mapping);
};

function setSourceContent(map, source, content) {
    const {
        _sources: sources,
        _sourcesContent: sourcesContent,
    } = cast22(map);
    
    const index2 = put(sources, source);
    
    sourcesContent[index2] = content;
}

function toDecodedMap(map) {
    const {
        _mappings: mappings,
        _sources: sources,
        _sourcesContent: sourcesContent,
        _names: names,
        _ignoreList: ignoreList,
    } = cast22(map);
    
    removeEmptyFinalLines(mappings);
    return {
        version: 3,
        file: map.file || void 0,
        names: names.array,
        sourceRoot: map.sourceRoot || void 0,
        sources: sources.array,
        sourcesContent,
        mappings,
        // originalScopes,

        // generatedRanges,
        ignoreList: ignoreList.array,
    };
}

function toEncodedMap(map) {
    const decoded = toDecodedMap(map);
    
    return Object.assign({}, decoded, {
        // originalScopes: decoded.originalScopes.map((os) => encodeOriginalScopes(os)),
        // generatedRanges: encodeGeneratedRanges(decoded.generatedRanges as GeneratedRange[]),
        mappings: encode(decoded.mappings),
    });
}

function allMappings(map) {
    const out = [];
    const {
        _mappings: mappings,
        _sources: sources,
        _names: names,
    } = cast22(map);
    
    for (let i = 0; i < mappings.length; i++) {
        const line = mappings[i];
        
        for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const generated = {
                line: i + 1,
                column: seg[COLUMN2],
            };
            let source = void 0;
            let original = void 0;
            let name = void 0;
            
            if (seg.length !== 1) {
                source = sources.array[seg[SOURCES_INDEX2]];
                original = {
                    line: seg[SOURCE_LINE2] + 1,
                    column: seg[SOURCE_COLUMN2],
                };
                
                if (seg.length === 5)
                    name = names.array[seg[NAMES_INDEX2]];
            }
            
            out.push({
                generated,
                source,
                original,
                name,
            });
        }
    }
    
    return out;
}

function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
    const {
        _mappings: mappings,
        _sources: sources,
        _sourcesContent: sourcesContent,
        _names: names,
    } = cast22(map);
    
    const line = getIndex(mappings, genLine);
    const index2 = getColumnIndex(line, genColumn);
    
    if (!source) {
        if (skipSourceless(line, index2))
            return;
        
        return insert$1(line, index2, [genColumn]);
    }
    const sourcesIndex = put(sources, source);
    const namesIndex = name ? put(names, name) : NO_NAME;
    
    if (sourcesIndex === sourcesContent.length)
        sourcesContent[sourcesIndex] = content != null ? content : null;
    
    if (skipSource(line, index2, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
        return;
    }
    
    return insert$1(line, index2, name ? [
        genColumn,
        sourcesIndex,
        sourceLine,
        sourceColumn,
        namesIndex,
    ] : [
        genColumn,
        sourcesIndex,
        sourceLine,
        sourceColumn,
    ]);
}

function getIndex(arr, index2) {
    for (let i = arr.length; i <= index2; i++) {
        arr[i] = [];
    }
    
    return arr[index2];
}

function getColumnIndex(line, genColumn) {
    let index2 = line.length;
    
    for (let i = index2 - 1; i >= 0; index2 = i--) {
        const current = line[i];
        
        if (genColumn >= current[COLUMN2])
            break;
    }
    
    return index2;
}

function insert$1(array, index2, value) {
    for (let i = array.length; i > index2; i--) {
        array[i] = array[i - 1];
    }
    
    array[index2] = value;
}

function removeEmptyFinalLines(mappings) {
    const {length} = mappings;
    let len = length;
    
    for (let i = len - 1; i >= 0; (len = i, i--)) {
        if (mappings[i].length > 0)
            break;
    }
    
    if (len < length)
        mappings.length = len;
}

function skipSourceless(line, index2) {
    if (index2 === 0)
        return true;
    
    const prev = line[index2 - 1];
    
    return prev.length === 1;
}

function skipSource(line, index2, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
    if (index2 === 0)
        return false;
    
    const prev = line[index2 - 1];
    
    if (prev.length === 1)
        return false;
    
    return sourcesIndex === prev[SOURCES_INDEX2]
        && sourceLine === prev[SOURCE_LINE2]
        && sourceColumn === prev[SOURCE_COLUMN2]
        && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX2] : NO_NAME);
}

function addMappingInternal(skipable, map, mapping) {
    const {
        generated,
        source,
        original,
        name,
        content,
    } = mapping;
    
    if (!source) {
        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
    }
    return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name, content);
}

// node_modules/@babel/generator/lib/index.js
var import_jsesc = __toESM(require_jsesc());

var SourceMap = class {
    constructor(opts, code2) {
        __publicField(this, '_map');
        __publicField(this, '_rawMappings');
        __publicField(this, '_sourceFileName');
        __publicField(this, '_lastGenLine', 0);
        __publicField(this, '_lastSourceLine', 0);
        __publicField(this, '_lastSourceColumn', 0);
        __publicField(this, '_inputMap');
        const map = this._map = new GenMapping({
            sourceRoot: opts.sourceRoot,
        });
        
        this._sourceFileName = opts.sourceFileName?.replace(/\\/g, '/');
        this._rawMappings = void 0;
        
        if (opts.inputSourceMap) {
            this._inputMap = new TraceMap(opts.inputSourceMap);
            const resolvedSources = this._inputMap.resolvedSources;
            
            if (resolvedSources.length) {
                for (let i = 0; i < resolvedSources.length; i++) {
                    setSourceContent(map, resolvedSources[i], this._inputMap.sourcesContent?.[i]);
                }
            }
        }
        
        if (typeof code2 === 'string' && !opts.inputSourceMap) {
            setSourceContent(map, this._sourceFileName, code2);
        } else if (typeof code2 === 'object') {
            for (const sourceFileName of Object.keys(code2)) {
                setSourceContent(map, sourceFileName.replace(/\\/g, '/'), code2[sourceFileName]);
            }
        }
    }
    
    get() {
        return toEncodedMap(this._map);
    }
    
    getDecoded() {
        return toDecodedMap(this._map);
    }
    
    getRawMappings() {
        return this._rawMappings || (this._rawMappings = allMappings(this._map));
    }
    
    mark(generated, line, column, identifierName, identifierNamePos, filename) {
        this._rawMappings = void 0;
        let originalMapping;
        
        if (line != null) {
            if (this._inputMap) {
                originalMapping = originalPositionFor(this._inputMap, {
                    line,
                    column,
                });
                
                if (!originalMapping.name && identifierNamePos) {
                    const originalIdentifierMapping = originalPositionFor(this._inputMap, identifierNamePos);
                    
                    if (originalIdentifierMapping.name) {
                        identifierName = originalIdentifierMapping.name;
                    }
                }
            } else {
                originalMapping = {
                    source: filename?.replace(/\\/g, '/') || this._sourceFileName,
                    line,
                    column,
                };
            }
        }
        
        maybeAddMapping(this._map, {
            name: identifierName,
            generated,
            source: originalMapping?.source,
            original: originalMapping,
        });
    }
};

var Buffer2 = class {
    constructor(map, indentChar) {
        __publicField(this, '_map', null);
        __publicField(this, '_buf', '');
        __publicField(this, '_str', '');
        __publicField(this, '_appendCount', 0);
        __publicField(this, '_last', 0);
        __publicField(this, '_queue', []);
        __publicField(this, '_queueCursor', 0);
        __publicField(this, '_canMarkIdName', true);
        __publicField(this, '_indentChar', '');
        __publicField(this, '_fastIndentations', []);
        __publicField(this, '_position', {
            line: 1,
            column: 0,
        });
        __publicField(this, '_sourcePosition', {
            identifierName: void 0,
            identifierNamePos: void 0,
            line: void 0,
            column: void 0,
            filename: void 0,
        });
        this._map = map;
        this._indentChar = indentChar;
        for (let i = 0; i < 64; i++) {
            this._fastIndentations.push(indentChar.repeat(i));
        }
        
        this._allocQueue();
    }
    
    _allocQueue() {
        const queue = this._queue;
        
        for (let i = 0; i < 16; i++) {
            queue.push({
                char: 0,
                repeat: 1,
                line: void 0,
                column: void 0,
                identifierName: void 0,
                identifierNamePos: void 0,
                filename: '',
            });
        }
    }
    
    _pushQueue(char, repeat, line, column, filename) {
        const cursor = this._queueCursor;
        
        if (cursor === this._queue.length) {
            this._allocQueue();
        }
        
        const item = this._queue[cursor];
        
        item.char = char;
        item.repeat = repeat;
        item.line = line;
        item.column = column;
        item.filename = filename;
        this._queueCursor++;
    }
    
    _popQueue() {
        if (this._queueCursor === 0) {
            throw new Error('Cannot pop from empty queue');
        }
        
        return this._queue[--this._queueCursor];
    }
    
    get() {
        this._flush();
        const map = this._map;
        const result = {
            code: (this._buf + this._str).trimRight(),
            decodedMap: map?.getDecoded(),
            get __mergedMap() {
                return this.map;
            },
            get map() {
                const resultMap = map ? map.get() : null;
                
                result.map = resultMap;
                return resultMap;
            },
            set map(value) {
                Object.defineProperty(result, 'map', {
                    value,
                    writable: true,
                });
            },
            get rawMappings() {
                const mappings = map?.getRawMappings();
                
                result.rawMappings = mappings;
                return mappings;
            },
            set rawMappings(value) {
                Object.defineProperty(result, 'rawMappings', {
                    value,
                    writable: true,
                });
            },
        };
        
        return result;
    }
    
    append(str, maybeNewline) {
        this._flush();
        this._append(str, this._sourcePosition, maybeNewline);
    }
    
    appendChar(char) {
        this._flush();
        this._appendChar(char, 1, this._sourcePosition);
    }
    
    queue(char) {
        if (char === 10) {
            while (this._queueCursor !== 0) {
                const char2 = this._queue[this._queueCursor - 1].char;
                
                if (char2 !== 32 && char2 !== 9) {
                    break;
                }
                
                this._queueCursor--;
            }
        }
        
        const sourcePosition = this._sourcePosition;
        this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);
    }
    
    queueIndentation(repeat) {
        if (repeat === 0)
            return;
        
        this._pushQueue(-1, repeat, void 0, void 0, void 0);
    }
    
    _flush() {
        const queueCursor = this._queueCursor;
        const queue = this._queue;
        
        for (let i = 0; i < queueCursor; i++) {
            const item = queue[i];
            this._appendChar(item.char, item.repeat, item);
        }
        
        this._queueCursor = 0;
    }
    
    _appendChar(char, repeat, sourcePos) {
        this._last = char;
        
        if (char === -1) {
            const fastIndentation = this._fastIndentations[repeat];
            
            if (fastIndentation !== void 0) {
                this._str += fastIndentation;
            } else {
                this._str += repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;
            }
        } else {
            this._str += repeat > 1 ? String
                .fromCharCode(char)
                .repeat(repeat) : String.fromCharCode(char);
        }
        
        if (char !== 10) {
            this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename);
            this._position.column += repeat;
        } else {
            this._position.line++;
            this._position.column = 0;
        }
        
        if (this._canMarkIdName) {
            sourcePos.identifierName = void 0;
            sourcePos.identifierNamePos = void 0;
        }
    }
    
    _append(str, sourcePos, maybeNewline) {
        const len = str.length;
        const position = this._position;
        
        this._last = str.charCodeAt(len - 1);
        
        if (++this._appendCount > 4096) {
            +this._str;
            this._buf += this._str;
            this._str = str;
            this._appendCount = 0;
        } else {
            this._str += str;
        }
        
        if (!maybeNewline && !this._map) {
            position.column += len;
            return;
        }
        
        const {
            column,
            identifierName,
            identifierNamePos,
            filename,
        } = sourcePos;
        
        let line = sourcePos.line;
        
        if ((identifierName != null || identifierNamePos != null) && this._canMarkIdName) {
            sourcePos.identifierName = void 0;
            sourcePos.identifierNamePos = void 0;
        }
        
        let i = str.indexOf('\n');
        let last2 = 0;
        
        if (i !== 0) {
            this._mark(line, column, identifierName, identifierNamePos, filename);
        }
        
        while (i !== -1) {
            position.line++;
            position.column = 0;
            last2 = i + 1;
            
            if (last2 < len && line !== void 0) {
                this._mark(++line, 0, null, null, filename);
            }
            
            i = str.indexOf('\n', last2);
        }
        
        position.column += len - last2;
    }
    
    _mark(line, column, identifierName, identifierNamePos, filename) {
        this._map?.mark(this._position, line, column, identifierName, identifierNamePos, filename);
    }
    
    removeTrailingNewline() {
        const queueCursor = this._queueCursor;
        
        if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {
            this._queueCursor--;
        }
    }
    
    removeLastSemicolon() {
        const queueCursor = this._queueCursor;
        
        if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {
            this._queueCursor--;
        }
    }
    
    getLastChar() {
        const queueCursor = this._queueCursor;
        return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;
    }
    
    getNewlineCount() {
        const queueCursor = this._queueCursor;
        let count = 0;
        
        if (queueCursor === 0)
            return this._last === 10 ? 1 : 0;
        
        for (let i = queueCursor - 1; i >= 0; i--) {
            if (this._queue[i].char !== 10) {
                break;
            }
            
            count++;
        }
        
        return count === queueCursor && this._last === 10 ? count + 1 : count;
    }
    
    endsWithCharAndNewline() {
        const queue = this._queue;
        const queueCursor = this._queueCursor;
        
        if (queueCursor !== 0) {
            const lastCp = queue[queueCursor - 1].char;
            
            if (lastCp !== 10)
                return;
            
            if (queueCursor > 1) {
                return queue[queueCursor - 2].char;
            } else {
                return this._last;
            }
        }
    }
    
    hasContent() {
        return this._queueCursor !== 0 || !!this._last;
    }
    
    exactSource(loc, cb) {
        if (!this._map) {
            cb();
            return;
        }
        
        this.source('start', loc);
        const identifierName = loc.identifierName;
        const sourcePos = this._sourcePosition;
        
        if (identifierName) {
            this._canMarkIdName = false;
            sourcePos.identifierName = identifierName;
        }
        
        cb();
        
        if (identifierName) {
            this._canMarkIdName = true;
            sourcePos.identifierName = void 0;
            sourcePos.identifierNamePos = void 0;
        }
        
        this.source('end', loc);
    }
    
    source(prop, loc) {
        if (!this._map)
            return;
        
        this._normalizePosition(prop, loc, 0);
    }
    
    sourceWithOffset(prop, loc, columnOffset) {
        if (!this._map)
            return;
        
        this._normalizePosition(prop, loc, columnOffset);
    }
    
    _normalizePosition(prop, loc, columnOffset) {
        const pos = loc[prop];
        const target = this._sourcePosition;
        
        if (pos) {
            target.line = pos.line;
            target.column = Math.max(pos.column + columnOffset, 0);
            target.filename = loc.filename;
        }
    }
    
    getCurrentColumn() {
        const queue = this._queue;
        const queueCursor = this._queueCursor;
        let lastIndex = -1;
        let len = 0;
        
        for (let i = 0; i < queueCursor; i++) {
            const item = queue[i];
            
            if (item.char === 10) {
                lastIndex = len;
            }
            
            len += item.repeat;
        }
        
        return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;
    }
    
    getCurrentLine() {
        let count = 0;
        const queue = this._queue;
        
        for (let i = 0; i < this._queueCursor; i++) {
            if (queue[i].char === 10) {
                count++;
            }
        }
        
        return this._position.line + count;
    }
};

var {
    FLIPPED_ALIAS_KEYS: FLIPPED_ALIAS_KEYS$1,
    isArrayExpression: isArrayExpression2,
    isAssignmentExpression: isAssignmentExpression2,
    isBinary: isBinary2,
    isBlockStatement: isBlockStatement2,
    isCallExpression: isCallExpression$3$1,
    isFunction: isFunction$1$1,
    isIdentifier: isIdentifier$2$1,
    isLiteral: isLiteral$1$1,
    isMemberExpression: isMemberExpression$3$1,
    isObjectExpression: isObjectExpression2,
    isOptionalCallExpression: isOptionalCallExpression2,
    isOptionalMemberExpression: isOptionalMemberExpression$1$1,
    isStringLiteral: isStringLiteral3,
} = lib_exports;

function crawlInternal(node, state) {
    if (!node)
        return state;
    
    if (isMemberExpression$3$1(node) || isOptionalMemberExpression$1$1(node)) {
        crawlInternal(node.object, state);
        
        if (node.computed)
            crawlInternal(node.property, state);
    } else if (isBinary2(node) || isAssignmentExpression2(node)) {
        crawlInternal(node.left, state);
        crawlInternal(node.right, state);
    } else if (isCallExpression$3$1(node) || isOptionalCallExpression2(node)) {
        state.hasCall = true;
        crawlInternal(node.callee, state);
    } else if (isFunction$1$1(node)) {
        state.hasFunction = true;
    } else if (isIdentifier$2$1(node)) {
        state.hasHelper = state.hasHelper || node.callee && isHelper(node.callee);
    }


    
    return state;
}

function crawl(node) {
    return crawlInternal(node, {
        hasCall: false,
        hasFunction: false,
        hasHelper: false,
    });
}

function isHelper(node) {
    if (!node)
        return false;
    
    if (isMemberExpression$3$1(node)) {
        return isHelper(node.object) || isHelper(node.property);
    } else if (isIdentifier$2$1(node)) {
        return node.name === 'require' || node.name.charCodeAt(0) === 95;
    } else if (isCallExpression$3$1(node)) {
        return isHelper(node.callee);
    } else if (isBinary2(node) || isAssignmentExpression2(node)) {
        return isIdentifier$2$1(node.left) && isHelper(node.left) || isHelper(node.right);
    } else {
        return false;
    }


}

function isType2(node) {
    return isLiteral$1$1(node)
        || isObjectExpression2(node)
        || isArrayExpression2(node)
        || isIdentifier$2$1(node)
        || isMemberExpression$3$1(node);
}

var nodes = {
    AssignmentExpression(node) {
        const state = crawl(node.right);
        
        if (state.hasCall && state.hasHelper || state.hasFunction) {
            return state.hasFunction ? 1 | 2 : 2;
        }
    },
    SwitchCase(node, parent) {
        return (!!node.consequent.length || parent.cases[0] === node ? 1 : 0) | (!node.consequent.length && parent.cases[parent.cases.length - 1] === node ? 2 : 0);
    },
    LogicalExpression(node) {
        if (isFunction$1$1(node.left) || isFunction$1$1(node.right)) {
            return 2;
        }
    },
    Literal(node) {
        if (isStringLiteral3(node) && node.value === 'use strict') {
            return 2;
        }
    },
    CallExpression(node) {
        if (isFunction$1$1(node.callee) || isHelper(node)) {
            return 1 | 2;
        }
    },
    OptionalCallExpression(node) {
        if (isFunction$1$1(node.callee)) {
            return 1 | 2;
        }
    },
    VariableDeclaration(node) {
        for (let i = 0; i < node.declarations.length; i++) {
            const declar = node.declarations[i];
            let enabled = isHelper(declar.id) && !isType2(declar.init);
            
            if (!enabled && declar.init) {
                const state = crawl(declar.init);
                enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
            }
            
            if (enabled) {
                return 1 | 2;
            }
        }
    },
    IfStatement(node) {
        if (isBlockStatement2(node.consequent)) {
            return 1 | 2;
        }
    },
};

nodes.ObjectProperty =
nodes.ObjectTypeProperty =
nodes.ObjectMethod = function(node, parent) {
    if (parent.properties[0] === node) {
        return 1;
    }
};
nodes.ObjectTypeCallProperty = function(node, parent) {
    if (parent.callProperties[0] === node && !parent.properties?.length) {
        return 1;
    }
};
nodes.ObjectTypeIndexer = function(node, parent) {
    if (parent.indexers[0] === node && !parent.properties?.length && !parent.callProperties?.length) {
        return 1;
    }
};
nodes.ObjectTypeInternalSlot = function(node, parent) {
    if (parent.internalSlots[0] === node && !parent.properties?.length && !parent.callProperties?.length && !parent.indexers?.length) {
        return 1;
    }
};
[
    ['Function', true],
    ['Class', true],
    ['Loop', true],
    ['LabeledStatement', true],
    ['SwitchStatement', true],
    ['TryStatement', true],
].forEach(function([type, amounts]) {
    [type]
        .concat(FLIPPED_ALIAS_KEYS$1[type] || [])
        .forEach(function(type2) {
            const ret = amounts ? 1 | 2 : 0;
            nodes[type2] = () => ret;
        });
});
var {
    isArrayTypeAnnotation: isArrayTypeAnnotation2,
    isBinaryExpression: isBinaryExpression2,
    isCallExpression: isCallExpression$2$1,
    isForOfStatement: isForOfStatement2,
    isIndexedAccessType: isIndexedAccessType2,
    isMemberExpression: isMemberExpression$2$1,
    isObjectPattern: isObjectPattern2,
    isOptionalMemberExpression: isOptionalMemberExpression2,
    isYieldExpression: isYieldExpression2,
    isStatement: isStatement$4$1,
} = lib_exports;

var PRECEDENCE = /* @__PURE__ */new Map([
    ['||', 0],
    ['??', 0],
    ['|>', 0],
    ['&&', 1],
    ['|', 2],
    ['^', 3],
    ['&', 4],
    ['==', 5],
    ['===', 5],
    ['!=', 5],
    ['!==', 5],
    ['<', 6],
    ['>', 6],
    ['<=', 6],
    ['>=', 6],
    ['in', 6],
    ['instanceof', 6],
    ['>>', 7],
    ['<<', 7],
    ['>>>', 7],
    ['+', 8],
    ['-', 8],
    ['*', 9],
    ['/', 9],
    ['%', 9],
    ['**', 10],
]);

function getBinaryPrecedence(node, nodeType) {
    if (nodeType === 'BinaryExpression' || nodeType === 'LogicalExpression') {
        return PRECEDENCE.get(node.operator);
    }
    
    if (nodeType === 'TSAsExpression' || nodeType === 'TSSatisfiesExpression') {
        return PRECEDENCE.get('in');
    }
}

function isTSTypeExpression(nodeType) {
    return nodeType === 'TSAsExpression' || nodeType === 'TSSatisfiesExpression' || nodeType === 'TSTypeAssertion';
}

var isClassExtendsClause = (node, parent) => {
    const parentType = parent.type;
    return (parentType === 'ClassDeclaration' || parentType === 'ClassExpression') && parent.superClass === node;
};

var hasPostfixPart = (node, parent) => {
    const parentType = parent.type;
    return (parentType === 'MemberExpression'
        || parentType === 'OptionalMemberExpression')
        && parent.object === node
        || (parentType === 'CallExpression'
        || parentType === 'OptionalCallExpression'
        || parentType === 'NewExpression')
        && parent.callee === node
        || parentType === 'TaggedTemplateExpression'
        && parent.tag === node
        || parentType === 'TSNonNullExpression';
};

function NullableTypeAnnotation$1(node, parent) {
    return isArrayTypeAnnotation2(parent);
}

function FunctionTypeAnnotation$1(node, parent, tokenContext) {
    const parentType = parent.type;
    return parentType === 'UnionTypeAnnotation'
        || parentType === 'IntersectionTypeAnnotation'
        || parentType === 'ArrayTypeAnnotation'
        || Boolean(tokenContext & TokenContext.arrowFlowReturnType);
}

function UpdateExpression$1(node, parent) {
    return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
}

function needsParenBeforeExpressionBrace(tokenContext) {
    return Boolean(tokenContext & (TokenContext.expressionStatement | TokenContext.arrowBody));
}

function ObjectExpression$1$1(node, parent, tokenContext) {
    return needsParenBeforeExpressionBrace(tokenContext);
}

function DoExpression$1(node, parent, tokenContext) {
    return !node.async && Boolean(tokenContext & TokenContext.expressionStatement);
}

function Binary(node, parent) {
    const parentType = parent.type;
    
    if (node.type === 'BinaryExpression' && node.operator === '**' && parentType === 'BinaryExpression' && parent.operator === '**') {
        return parent.left === node;
    }
    
    if (isClassExtendsClause(node, parent)) {
        return true;
    }
    
    if (hasPostfixPart(node, parent) || parentType === 'UnaryExpression' || parentType === 'SpreadElement' || parentType === 'AwaitExpression') {
        return true;
    }
    
    const parentPos = getBinaryPrecedence(parent, parentType);
    
    if (parentPos != null) {
        const nodePos = getBinaryPrecedence(node, node.type);
        
        if (parentPos === nodePos && parentType === 'BinaryExpression' && parent.right === node || parentPos > nodePos) {
            return true;
        }
    }
    
    return void 0;
}

function UnionTypeAnnotation$1(node, parent) {
    const parentType = parent.type;
    return parentType === 'ArrayTypeAnnotation'
        || parentType === 'NullableTypeAnnotation'
        || parentType === 'IntersectionTypeAnnotation'
        || parentType === 'UnionTypeAnnotation';
}

function OptionalIndexedAccessType$1(node, parent) {
    return isIndexedAccessType2(parent) && parent.objectType === node;
}

function TSAsExpression2(node, parent) {
    if ((parent.type === 'AssignmentExpression' || parent.type === 'AssignmentPattern') && parent.left === node) {
        return true;
    }
    
    if (parent.type === 'BinaryExpression' && (parent.operator === '|' || parent.operator === '&') && node === parent.left) {
        return true;
    }
    
    return Binary(node, parent);
}

function TSConditionalType$1$1(node, parent) {
    const parentType = parent.type;
    
    if (parentType === 'TSArrayType' || parentType === 'TSIndexedAccessType' && parent.objectType === node || parentType === 'TSOptionalType' || parentType === 'TSTypeOperator' || parentType === 'TSTypeParameter') {
        return true;
    }
    
    if ((parentType === 'TSIntersectionType' || parentType === 'TSUnionType') && parent.types[0] === node) {
        return true;
    }
    
    if (parentType === 'TSConditionalType' && (parent.checkType === node || parent.extendsType === node)) {
        return true;
    }
    
    return false;
}

function TSUnionType$1$1(node, parent) {
    const parentType = parent.type;
    return parentType === 'TSIntersectionType'
        || parentType === 'TSTypeOperator'
        || parentType === 'TSArrayType'
        || parentType === 'TSIndexedAccessType'
        && parent.objectType === node
        || parentType === 'TSOptionalType';
}

function TSIntersectionType$1$1(node, parent) {
    const parentType = parent.type;
    return parentType === 'TSTypeOperator'
        || parentType === 'TSArrayType'
        || parentType === 'TSIndexedAccessType'
        && parent.objectType === node
        || parentType === 'TSOptionalType';
}

function TSInferType$1$1(node, parent) {
    const parentType = parent.type;
    
    if (parentType === 'TSArrayType' || parentType === 'TSIndexedAccessType' && parent.objectType === node || parentType === 'TSOptionalType') {
        return true;
    }
    
    if (node.typeParameter.constraint) {
        if ((parentType === 'TSIntersectionType' || parentType === 'TSUnionType') && parent.types[0] === node) {
            return true;
        }
    }
    
    return false;
}

function TSTypeOperator$1(node, parent) {
    const parentType = parent.type;
    return parentType === 'TSArrayType'
        || parentType === 'TSIndexedAccessType'
        && parent.objectType === node
        || parentType === 'TSOptionalType';
}

function TSInstantiationExpression$1(node, parent) {
    const parentType = parent.type;
    return (parentType === 'CallExpression'
        || parentType === 'OptionalCallExpression'
        || parentType === 'NewExpression'
        || parentType === 'TSInstantiationExpression')
        && !!parent.typeArguments;
}

function TSFunctionType$1$1(node, parent) {
    const parentType = parent.type;
    return parentType === 'TSIntersectionType'
        || parentType === 'TSUnionType'
        || parentType === 'TSTypeOperator'
        || parentType === 'TSOptionalType'
        || parentType === 'TSArrayType'
        || parentType === 'TSIndexedAccessType'
        && parent.objectType === node
        || parentType === 'TSConditionalType'
        && (parent.checkType === node
        || parent.extendsType === node);
}

function BinaryExpression2(node, parent, tokenContext) {
    return node.operator === 'in' && Boolean(tokenContext & TokenContext.forInOrInitHeadAccumulate);
}

function SequenceExpression$1$1(node, parent) {
    const parentType = parent.type;
    
    if (parentType === 'SequenceExpression' || parentType === 'ParenthesizedExpression' || parentType === 'MemberExpression' && parent.property === node || parentType === 'OptionalMemberExpression' && parent.property === node || parentType === 'TemplateLiteral') {
        return false;
    }
    
    if (parentType === 'ClassDeclaration') {
        return true;
    }
    
    if (parentType === 'ForOfStatement') {
        return parent.right === node;
    }
    
    if (parentType === 'ExportDefaultDeclaration') {
        return true;
    }
    
    return !isStatement$4$1(parent);
}

function YieldExpression$1(node, parent) {
    const parentType = parent.type;
    return parentType === 'BinaryExpression'
        || parentType === 'LogicalExpression'
        || parentType === 'UnaryExpression'
        || parentType === 'SpreadElement'
        || hasPostfixPart(node, parent)
        || parentType === 'AwaitExpression'
        && isYieldExpression2(node)
        || parentType === 'ConditionalExpression'
        && node === parent.test
        || isClassExtendsClause(node, parent)
        || isTSTypeExpression(parentType);
}

function ClassExpression2(node, parent, tokenContext) {
    return Boolean(tokenContext & (TokenContext.expressionStatement | TokenContext.exportDefault));
}

function UnaryLike(node, parent) {
    return hasPostfixPart(node, parent)
        || isBinaryExpression2(parent)
        && parent.operator === '**'
        && parent.left === node
        || isClassExtendsClause(node, parent);
}

function FunctionExpression$1$1(node, parent, tokenContext) {
    return Boolean(tokenContext & (TokenContext.expressionStatement | TokenContext.exportDefault));
}

function ConditionalExpression$1$1(node, parent) {
    const parentType = parent.type;
    
    if (parentType === 'UnaryExpression' || parentType === 'SpreadElement' || parentType === 'BinaryExpression' || parentType === 'LogicalExpression' || parentType === 'ConditionalExpression' && parent.test === node || parentType === 'AwaitExpression' || isTSTypeExpression(parentType)) {
        return true;
    }
    
    return UnaryLike(node, parent);
}

function OptionalMemberExpression$1(node, parent) {
    return isCallExpression$2$1(parent) && parent.callee === node
        || isMemberExpression$2$1(parent) && parent.object === node;
}

function AssignmentExpression$1$1(node, parent, tokenContext) {
    if (needsParenBeforeExpressionBrace(tokenContext) && isObjectPattern2(node.left)) {
        return true;
    } else {
        return ConditionalExpression$1$1(node, parent);
    }
}

function LogicalExpression2(node, parent) {
    const parentType = parent.type;
    
    if (isTSTypeExpression(parentType))
        return true;
    
    if (parentType !== 'LogicalExpression')
        return false;
    
    switch(node.operator) {
    case '||':
        return parent.operator === '??' || parent.operator === '&&';
    
    case '&&':
        return parent.operator === '??';
    
    case '??':
        return parent.operator !== '??';
    }
}

function Identifier$1$1(node, parent, tokenContext, getRawIdentifier) {
    const parentType = parent.type;
    
    if (node.extra?.parenthesized && parentType === 'AssignmentExpression' && parent.left === node) {
        const rightType = parent.right.type;
        
        if ((rightType === 'FunctionExpression' || rightType === 'ClassExpression') && parent.right.id == null) {
            return true;
        }
    }
    
    if (getRawIdentifier && getRawIdentifier(node) !== node.name) {
        return false;
    }
    
    if (node.name === 'let') {
        const isFollowedByBracket = isMemberExpression$2$1(parent, {
            object: node,
            computed: true,
        }) || isOptionalMemberExpression2(parent, {
            object: node,
            computed: true,
            optional: false,
        });
        
        if (isFollowedByBracket && tokenContext & (TokenContext.expressionStatement | TokenContext.forInitHead | TokenContext.forInHead)) {
            return true;
        }
        
        return Boolean(tokenContext & TokenContext.forOfHead);
    }
    
    return node.name === 'async' && isForOfStatement2(parent, {
        left: node,
        await: false,
    });
}

var parens$1 = /* @__PURE__ */Object.freeze({
    __proto__: null,
    ArrowFunctionExpression: ConditionalExpression$1$1,
    AssignmentExpression: AssignmentExpression$1$1,
    AwaitExpression: YieldExpression$1,
    Binary,
    BinaryExpression: BinaryExpression2,
    ClassExpression: ClassExpression2,
    ConditionalExpression: ConditionalExpression$1$1,
    DoExpression: DoExpression$1,
    FunctionExpression: FunctionExpression$1$1,
    FunctionTypeAnnotation: FunctionTypeAnnotation$1,
    Identifier: Identifier$1$1,
    IntersectionTypeAnnotation: UnionTypeAnnotation$1,
    LogicalExpression: LogicalExpression2,
    NullableTypeAnnotation: NullableTypeAnnotation$1,
    ObjectExpression: ObjectExpression$1$1,
    OptionalCallExpression: OptionalMemberExpression$1,
    OptionalIndexedAccessType: OptionalIndexedAccessType$1,
    OptionalMemberExpression: OptionalMemberExpression$1,
    SequenceExpression: SequenceExpression$1$1,
    TSAsExpression: TSAsExpression2,
    TSConditionalType: TSConditionalType$1$1,
    TSConstructorType: TSFunctionType$1$1,
    TSFunctionType: TSFunctionType$1$1,
    TSInferType: TSInferType$1$1,
    TSInstantiationExpression: TSInstantiationExpression$1,
    TSIntersectionType: TSIntersectionType$1$1,
    TSSatisfiesExpression: TSAsExpression2,
    TSTypeAssertion: UnaryLike,
    TSTypeOperator: TSTypeOperator$1,
    TSUnionType: TSUnionType$1$1,
    UnaryLike,
    UnionTypeAnnotation: UnionTypeAnnotation$1,
    UpdateExpression: UpdateExpression$1,
    YieldExpression: YieldExpression$1,
});

var {
    FLIPPED_ALIAS_KEYS: FLIPPED_ALIAS_KEYS2,
    VISITOR_KEYS: VISITOR_KEYS$1,
    isCallExpression: isCallExpression$1$1,
    isDecorator: isDecorator2,
    isExpressionStatement: isExpressionStatement3,
    isMemberExpression: isMemberExpression$1$1,
    isNewExpression: isNewExpression$1,
    isParenthesizedExpression: isParenthesizedExpression2,
} = lib_exports;

var TokenContext = {
    normal: 0,
    expressionStatement: 1,
    arrowBody: 2,
    exportDefault: 4,
    arrowFlowReturnType: 8,
    forInitHead: 16,
    forInHead: 32,
    forOfHead: 64,
    forInOrInitHeadAccumulate: 128,
    forInOrInitHeadAccumulatePassThroughMask: 128,
};

function expandAliases(obj) {
    const map =     /* @__PURE__ */new Map();
    
    function add(type, func) {
        const fn = map.get(type);
        
        map.set(type, fn ? function(node, parent, stack, getRawIdentifier) {
            return fn(node, parent, stack, getRawIdentifier) ?? func(node, parent, stack, getRawIdentifier);
        } : func);
    }
    
    for (const type of Object.keys(obj)) {
        const aliases = FLIPPED_ALIAS_KEYS2[type];
        
        if (aliases) {
            for (const alias2 of aliases) {
                add(alias2, obj[type]);
            }
        } else {
            add(type, obj[type]);
        }
    }
    
    return map;
}

var expandedParens = expandAliases(parens$1);
var expandedWhitespaceNodes = expandAliases(nodes);

function isOrHasCallExpression(node) {
    if (isCallExpression$1$1(node)) {
        return true;
    }
    
    return isMemberExpression$1$1(node) && isOrHasCallExpression(node.object);
}

function needsWhitespace(node, parent, type) {
    if (!node)
        return false;
    
    if (isExpressionStatement3(node)) {
        node = node.expression;
    }
    
    const flag = expandedWhitespaceNodes.get(node.type)?.(node, parent);
    
    if (typeof flag === 'number') {
        return (flag & type) !== 0;
    }
    
    return false;
}

function needsWhitespaceBefore(node, parent) {
    return needsWhitespace(node, parent, 1);
}

function needsWhitespaceAfter(node, parent) {
    return needsWhitespace(node, parent, 2);
}

function needsParens$1(node, parent, tokenContext, getRawIdentifier) {
    if (!parent)
        return false;
    
    if (isNewExpression$1(parent) && parent.callee === node) {
        if (isOrHasCallExpression(node))
            return true;
    }
    
    if (isDecorator2(parent)) {
        return !isDecoratorMemberExpression(node) && !(isCallExpression$1$1(node) && isDecoratorMemberExpression(node.callee)) && !isParenthesizedExpression2(node);
    }
    
    return expandedParens.get(node.type)?.(node, parent, tokenContext, getRawIdentifier);
}

function isDecoratorMemberExpression(node) {
    switch(node.type) {
    case 'Identifier':
        return true;
    
    case 'MemberExpression':
        return !node.computed && node.property.type === 'Identifier' && isDecoratorMemberExpression(node.object);
    
    default:
        return false;
    }
}

function isLastChild(parent, child) {
    const visitorKeys = VISITOR_KEYS$1[parent.type];
    
    for (let i = visitorKeys.length - 1; i >= 0; i--) {
        const val = parent[visitorKeys[i]];
        
        if (val === child) {
            return true;
        } else if (Array.isArray(val)) {
            let j = val.length - 1;
            while (j >= 0 && val[j] === null)
                j--;
            
            return j >= 0 && val[j] === child;
        } else if (val) {
            return false;
        }

    }
    
    return false;
}

var n = /* @__PURE__ */Object.freeze({
    __proto__: null,
    TokenContext,
    isLastChild,
    needsParens: needsParens$1,
    needsWhitespace,
    needsWhitespaceAfter,
    needsWhitespaceBefore,
});

var {traverseFast: traverseFast2, VISITOR_KEYS: VISITOR_KEYS2} = lib_exports;

var TokenMap = class {
    constructor(ast, tokens, source) {
        __publicField(this, '_tokens');
        __publicField(this, '_source');
        __publicField(this, '_nodesToTokenIndexes',         /* @__PURE__ */new Map());
        __publicField(this, '_nodesOccurrencesCountCache',         /* @__PURE__ */new Map());
        __publicField(this, '_tokensCache',         /* @__PURE__ */new Map());
        this._tokens = tokens;
        this._source = source;
        traverseFast2(ast, (node) => {
            const indexes = this._getTokensIndexesOfNode(node);
            
            if (indexes.length > 0)
                this._nodesToTokenIndexes.set(node, indexes);
        });
        this._tokensCache = null;
    }
    
    has(node) {
        return this._nodesToTokenIndexes.has(node);
    }
    
    getIndexes(node) {
        return this._nodesToTokenIndexes.get(node);
    }
    
    find(node, condition) {
        const indexes = this._nodesToTokenIndexes.get(node);
        
        if (indexes) {
            for (let k = 0; k < indexes.length; k++) {
                const index2 = indexes[k];
                const tok = this._tokens[index2];
                
                if (condition(tok, index2))
                    return tok;
            }
        }
        
        return null;
    }
    
    findLastIndex(node, condition) {
        const indexes = this._nodesToTokenIndexes.get(node);
        
        if (indexes) {
            for (let k = indexes.length - 1; k >= 0; k--) {
                const index2 = indexes[k];
                const tok = this._tokens[index2];
                
                if (condition(tok, index2))
                    return index2;
            }
        }
        
        return -1;
    }
    
    findMatching(node, test, occurrenceCount = 0) {
        const indexes = this._nodesToTokenIndexes.get(node);
        
        if (indexes) {
            let i = 0;
            const count = occurrenceCount;
            
            if (count > 1) {
                const cache2 = this._nodesOccurrencesCountCache.get(node);
                
                if (cache2 && cache2.test === test && cache2.count < count) {
                    i = cache2.i + 1;
                    occurrenceCount -= cache2.count + 1;
                }
            }
            
            for (; i < indexes.length; i++) {
                const tok = this._tokens[indexes[i]];
                
                if (this.matchesOriginal(tok, test)) {
                    if (occurrenceCount === 0) {
                        if (count > 0) {
                            this._nodesOccurrencesCountCache.set(node, {
                                test,
                                count,
                                i,
                            });
                        }
                        
                        return tok;
                    }
                    
                    occurrenceCount--;
                }
            }
        }
        
        return null;
    }
    
    matchesOriginal(token, test) {
        if (token.end - token.start !== test.length)
            return false;
        
        if (token.value != null)
            return token.value === test;
        
        return this._source.startsWith(test, token.start);
    }
    
    startMatches(node, test) {
        const indexes = this._nodesToTokenIndexes.get(node);
        
        if (!indexes)
            return false;
        
        const tok = this._tokens[indexes[0]];
        
        if (tok.start !== node.start)
            return false;
        
        return this.matchesOriginal(tok, test);
    }
    
    endMatches(node, test) {
        const indexes = this._nodesToTokenIndexes.get(node);
        
        if (!indexes)
            return false;
        
        const tok = this._tokens[indexes[indexes.length - 1]];
        
        if (tok.end !== node.end)
            return false;
        
        return this.matchesOriginal(tok, test);
    }
    
    _getTokensIndexesOfNode(node) {
        if (node.start == null || node.end == null)
            return [];
        
        const {first, last: last2} = this._findTokensOfNode(node, 0, this._tokens.length - 1);
        
        let low = first;
        const children = childrenIterator(node);
        
        if ((node.type === 'ExportNamedDeclaration' || node.type === 'ExportDefaultDeclaration') && node.declaration && node.declaration.type === 'ClassDeclaration') {
            children.next();
        }
        
        const indexes = [];
        
        for (const child of children) {
            if (child == null)
                continue;
            
            if (child.start == null || child.end == null)
                continue;
            
            const childTok = this._findTokensOfNode(child, low, last2);
            const high = childTok.first;
            
            for (let k = low; k < high; k++)
                indexes.push(k);
            
            low = childTok.last + 1;
        }
        
        for (let k = low; k <= last2; k++)
            indexes.push(k);
        
        return indexes;
    }
    
    _findTokensOfNode(node, low, high) {
        const cached = this._tokensCache.get(node);
        
        if (cached)
            return cached;
        
        const first = this._findFirstTokenOfNode(node.start, low, high);
        const last2 = this._findLastTokenOfNode(node.end, first, high);
        
        this._tokensCache.set(node, {
            first,
            last: last2,
        });
        return {
            first,
            last: last2,
        };
    }
    
    _findFirstTokenOfNode(start, low, high) {
        while (low <= high) {
            const mid = high + low >> 1;
            
            if (start < this._tokens[mid].start) {
                high = mid - 1;
            } else if (start > this._tokens[mid].start) {
                low = mid + 1;
            } else {
                return mid;
            }
        }
        
        return low;
    }
    
    _findLastTokenOfNode(end, low, high) {
        while (low <= high) {
            const mid = high + low >> 1;
            
            if (end < this._tokens[mid].end) {
                high = mid - 1;
            } else if (end > this._tokens[mid].end) {
                low = mid + 1;
            } else {
                return mid;
            }
        }
        
        return high;
    }
};

function* childrenIterator(node) {
    if (node.type === 'TemplateLiteral') {
        yield node.quasis[0];
        for (let i = 1; i < node.quasis.length; i++) {
            yield node.expressions[i - 1];
            yield node.quasis[i];
        }
        
        return;
    }
    
    const keys2 = VISITOR_KEYS2[node.type];
    
    for (const key of keys2) {
        const child = node[key];
        
        if (!child)
            continue;
        
        if (Array.isArray(child)) {
            yield* child;
        } else {
            yield child;
        }
    }
}

function TaggedTemplateExpression2(node) {
    this.print(node.tag);
    {
        this.print(node.typeArguments);
    }
    this.print(node.quasi);
}

function TemplateElement2() {
    throw new Error('TemplateElement printing is handled in TemplateLiteral');
}

function _printTemplate(node, substitutions) {
    const quasis = node.quasis;
    let partRaw = '`';
    
    for (let i = 0; i < quasis.length - 1; i++) {
        partRaw += quasis[i].value.raw;
        this.token(partRaw + '${', true);
        this.print(substitutions[i]);
        partRaw = '}';
    }
    
    partRaw += quasis[quasis.length - 1].value.raw;
    this.token(partRaw + '`', true);
}

function TemplateLiteral2(node) {
    this._printTemplate(node, node.expressions);
}

var {
    isCallExpression: isCallExpression3,
    isLiteral: isLiteral2,
    isMemberExpression: isMemberExpression2,
    isNewExpression: isNewExpression3,
    isPattern: isPattern2,
} = lib_exports;

function UnaryExpression2(node) {
    const {operator} = node;
    
    if (operator === 'void' || operator === 'delete' || operator === 'typeof' || operator === 'throw') {
        this.word(operator);
        this.space();
    } else {
        this.token(operator);
    }
    
    this.print(node.argument);
}

function DoExpression2(node) {
    if (node.async) {
        this.word('async', true);
        this.space();
    }
    
    this.word('do');
    this.space();
    this.print(node.body);
}

function ParenthesizedExpression2(node) {
    this.tokenChar(40);
    const exit = this.enterDelimited();
    this.print(node.expression);
    exit();
    this.rightParens(node);
}

function UpdateExpression2(node) {
    if (node.prefix) {
        this.token(node.operator);
        this.print(node.argument);
    } else {
        this.print(node.argument, true);
        this.token(node.operator);
    }
}

function ConditionalExpression2(node) {
    this.print(node.test);
    this.space();
    this.tokenChar(63);
    this.space();
    this.print(node.consequent);
    this.space();
    this.tokenChar(58);
    this.space();
    this.print(node.alternate);
}

function NewExpression2(node, parent) {
    this.word('new');
    this.space();
    this.print(node.callee);
    
    if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression3(parent, {callee: node}) && !isMemberExpression2(parent) && !isNewExpression3(parent)) {
        return;
    }
    
    this.print(node.typeArguments);
    
    if (node.arguments.length === 0 && this.tokenMap && !this.tokenMap.endMatches(node, ')')) {
        return;
    }
    
    this.tokenChar(40);
    const exit = this.enterDelimited();
    this.printList(node.arguments, this.shouldPrintTrailingComma(')'));
    exit();
    this.rightParens(node);
}

function SequenceExpression2(node) {
    this.printList(node.expressions);
}

function ThisExpression2() {
    this.word('this');
}

function Super2() {
    this.word('super');
}

function _shouldPrintDecoratorsBeforeExport(node) {
    if (typeof this.format.decoratorsBeforeExport === 'boolean') {
        return this.format.decoratorsBeforeExport;
    }
    
    return typeof node.start === 'number' && node.start === node.declaration.start;
}

function Decorator2(node) {
    this.tokenChar(64);
    this.print(node.expression);
    this.newline();
}

function OptionalMemberExpression2(node) {
    let {computed} = node;
    
    const {optional, property} = node;
    
    this.print(node.object);
    
    if (!computed && isMemberExpression2(property)) {
        throw new TypeError('Got a MemberExpression for MemberExpression property');
    }
    
    if (isLiteral2(property) && typeof property.value === 'number') {
        computed = true;
    }
    
    if (optional) {
        this.token('?.');
    }
    
    if (computed) {
        this.tokenChar(91);
        this.print(property);
        this.tokenChar(93);
    } else {
        if (!optional) {
            this.tokenChar(46);
        }
        
        this.print(property);
    }
}

function OptionalCallExpression2(node) {
    this.print(node.callee);
    
    if (node.optional) {
        this.token('?.');
    }
    
    this.print(node.typeArguments);
    this.tokenChar(40);
    const exit = this.enterDelimited();
    this.printList(node.arguments);
    exit();
    this.rightParens(node);
}

function CallExpression2(node) {
    this.print(node.callee);
    this.print(node.typeArguments);
    this.tokenChar(40);
    const exit = this.enterDelimited();
    this.printList(node.arguments, this.shouldPrintTrailingComma(')'));
    exit();
    this.rightParens(node);
}

function Import2() {
    this.word('import');
}

function AwaitExpression2(node) {
    this.word('await');
    this.space();
    this.print(node.argument);
}

function YieldExpression2(node) {
    if (node.delegate) {
        this.word('yield', true);
        this.tokenChar(42);
        
        if (node.argument) {
            this.space();
            this.print(node.argument);
        }
    } else if (node.argument) {
        this.word('yield', true);
        this.space();
        this.print(node.argument);
    } else {
        this.word('yield');
    }
}

function EmptyStatement2() {
    this.semicolon(true);
}

function ExpressionStatement2(node) {
    this.tokenContext |= TokenContext.expressionStatement;
    this.print(node.expression);
    this.semicolon();
}

function AssignmentPattern2(node) {
    this.print(node.left);
    
    if (node.left.type === 'Identifier' || isPattern2(node.left)) {
        if (node.left.optional)
            this.tokenChar(63);
        
        this.print(node.left.typeAnnotation);
    }
    
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node.right);
}

function AssignmentExpression2(node) {
    this.print(node.left);
    this.space();
    
    if (node.operator === 'in' || node.operator === 'instanceof') {
        this.word(node.operator);
    } else {
        this.token(node.operator);
        this._endsWithDiv = node.operator === '/';
    }
    
    this.space();
    this.print(node.right);
}

function BindExpression2(node) {
    this.print(node.object);
    this.token('::');
    this.print(node.callee);
}

function MemberExpression2(node) {
    this.print(node.object);
    
    if (!node.computed && isMemberExpression2(node.property)) {
        throw new TypeError('Got a MemberExpression for MemberExpression property');
    }
    
    let computed = node.computed;
    
    if (isLiteral2(node.property) && typeof node.property.value === 'number') {
        computed = true;
    }
    
    if (computed) {
        const exit = this.enterDelimited();
        this.tokenChar(91);
        this.print(node.property);
        this.tokenChar(93);
        exit();
    } else {
        this.tokenChar(46);
        this.print(node.property);
    }
}

function MetaProperty2(node) {
    this.print(node.meta);
    this.tokenChar(46);
    this.print(node.property);
}

function PrivateName2(node) {
    this.tokenChar(35);
    this.print(node.id);
}

function V8IntrinsicIdentifier2(node) {
    this.tokenChar(37);
    this.word(node.name);
}

function ModuleExpression2(node) {
    this.word('module', true);
    this.space();
    this.tokenChar(123);
    this.indent();
    const {body} = node;
    
    if (body.body.length || body.directives.length) {
        this.newline();
    }
    
    this.print(body);
    this.dedent();
    this.rightBrace(node);
}

var {
    isFor: isFor2,
    isForStatement: isForStatement2,
    isIfStatement: isIfStatement2,
    isStatement: isStatement$3$1,
} = lib_exports;

function WithStatement2(node) {
    this.word('with');
    this.space();
    this.tokenChar(40);
    this.print(node.object);
    this.tokenChar(41);
    this.printBlock(node);
}

function IfStatement2(node) {
    this.word('if');
    this.space();
    this.tokenChar(40);
    this.print(node.test);
    this.tokenChar(41);
    this.space();
    const needsBlock = node.alternate && isIfStatement2(getLastStatement(node.consequent));
    
    if (needsBlock) {
        this.tokenChar(123);
        this.newline();
        this.indent();
    }
    
    this.printAndIndentOnComments(node.consequent);
    
    if (needsBlock) {
        this.dedent();
        this.newline();
        this.tokenChar(125);
    }
    
    if (node.alternate) {
        if (this.endsWith(125))
            this.space();
        
        this.word('else');
        this.space();
        this.printAndIndentOnComments(node.alternate);
    }
}

function getLastStatement(statement2) {
    const {body} = statement2;
    
    if (isStatement$3$1(body) === false) {
        return statement2;
    }
    
    return getLastStatement(body);
}

function ForStatement2(node) {
    this.word('for');
    this.space();
    this.tokenChar(40);
    {
        const exit = this.enterForStatementInit();
        this.print(node.init);
        exit();
    }
    this.tokenChar(59);
    
    if (node.test) {
        this.space();
        this.print(node.test);
    }
    
    this.token(';', false, 1);
    
    if (node.update) {
        this.space();
        this.print(node.update);
    }
    
    this.tokenChar(41);
    this.printBlock(node);
}

function WhileStatement2(node) {
    this.word('while');
    this.space();
    this.tokenChar(40);
    this.print(node.test);
    this.tokenChar(41);
    this.printBlock(node);
}

function ForXStatement(node) {
    this.word('for');
    this.space();
    const isForOf = node.type === 'ForOfStatement';
    
    if (isForOf && node.await) {
        this.word('await');
        this.space();
    }
    
    this.noIndentInnerCommentsHere();
    this.tokenChar(40);
    {
        const exit = this.enterForXStatementInit(isForOf);
        this.print(node.left);
        exit?.();
    }
    this.space();
    this.word(isForOf ? 'of' : 'in');
    this.space();
    this.print(node.right);
    this.tokenChar(41);
    this.printBlock(node);
}

var ForInStatement2 = ForXStatement;
var ForOfStatement2 = ForXStatement;

function DoWhileStatement2(node) {
    this.word('do');
    this.space();
    this.print(node.body);
    this.space();
    this.word('while');
    this.space();
    this.tokenChar(40);
    this.print(node.test);
    this.tokenChar(41);
    this.semicolon();
}

function printStatementAfterKeyword(printer, node) {
    if (node) {
        printer.space();
        printer.printTerminatorless(node);
    }
    
    printer.semicolon();
}

function BreakStatement2(node) {
    this.word('break');
    printStatementAfterKeyword(this, node.label);
}

function ContinueStatement2(node) {
    this.word('continue');
    printStatementAfterKeyword(this, node.label);
}

function ReturnStatement2(node) {
    this.word('return');
    printStatementAfterKeyword(this, node.argument);
}

function ThrowStatement2(node) {
    this.word('throw');
    printStatementAfterKeyword(this, node.argument);
}

function LabeledStatement2(node) {
    this.print(node.label);
    this.tokenChar(58);
    this.space();
    this.print(node.body);
}

function TryStatement2(node) {
    this.word('try');
    this.space();
    this.print(node.block);
    this.space();
    
    if (node.handlers) {
        this.print(node.handlers[0]);
    } else {
        this.print(node.handler);
    }
    
    if (node.finalizer) {
        this.space();
        this.word('finally');
        this.space();
        this.print(node.finalizer);
    }
}

function CatchClause2(node) {
    this.word('catch');
    this.space();
    
    if (node.param) {
        this.tokenChar(40);
        this.print(node.param);
        this.print(node.param.typeAnnotation);
        this.tokenChar(41);
        this.space();
    }
    
    this.print(node.body);
}

function SwitchStatement2(node) {
    this.word('switch');
    this.space();
    this.tokenChar(40);
    this.print(node.discriminant);
    this.tokenChar(41);
    this.space();
    this.tokenChar(123);
    this.printSequence(node.cases, true, void 0, function addNewlines(leading, cas) {
        if (!leading && node.cases[node.cases.length - 1] === cas)
            return -1;
    });
    this.rightBrace(node);
}

function SwitchCase2(node) {
    if (node.test) {
        this.word('case');
        this.space();
        this.print(node.test);
        this.tokenChar(58);
    } else {
        this.word('default');
        this.tokenChar(58);
    }
    
    if (node.consequent.length) {
        this.newline();
        this.printSequence(node.consequent, true);
    }
}

function DebuggerStatement2() {
    this.word('debugger');
    this.semicolon();
}

function VariableDeclaration2(node, parent) {
    if (node.declare) {
        this.word('declare');
        this.space();
    }
    
    const {kind} = node;
    
    if (kind === 'await using') {
        this.word('await');
        this.space();
        this.word('using', true);
    } else {
        this.word(kind, kind === 'using');
    }
    
    this.space();
    let hasInits = false;
    
    if (!isFor2(parent)) {
        for (const declar of node.declarations) {
            if (declar.init) {
                hasInits = true;
            }
        }
    }
    
    this.printList(node.declarations, void 0, void 0, node.declarations.length > 1, hasInits ? function(occurrenceCount) {
        this.token(',', false, occurrenceCount);
        this.newline();
    } : void 0);
    
    if (isFor2(parent)) {
        if (isForStatement2(parent)) {
            if (parent.init === node)
                return;
        } else {
            if (parent.left === node)
                return;
        }
    }
    
    this.semicolon();
}

function VariableDeclarator2(node) {
    this.print(node.id);
    
    if (node.definite)
        this.tokenChar(33);
    
    this.print(node.id.typeAnnotation);
    
    if (node.init) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.init);
    }
}

var {
    isExportDefaultDeclaration: isExportDefaultDeclaration2,
    isExportNamedDeclaration: isExportNamedDeclaration2,
} = lib_exports;

function ClassDeclaration2(node, parent) {
    const inExport = isExportDefaultDeclaration2(parent) || isExportNamedDeclaration2(parent);
    
    if (!inExport || !this._shouldPrintDecoratorsBeforeExport(parent)) {
        this.printJoin(node.decorators);
    }
    
    if (node.declare) {
        this.word('declare');
        this.space();
    }
    
    if (node.abstract) {
        this.word('abstract');
        this.space();
    }
    
    this.word('class');
    
    if (node.id) {
        this.space();
        this.print(node.id);
    }
    
    this.print(node.typeParameters);
    
    if (node.superClass) {
        this.space();
        this.word('extends');
        this.space();
        this.print(node.superClass);
        this.print(node.superTypeArguments);
    }
    
    if (node.implements) {
        this.space();
        this.word('implements');
        this.space();
        this.printList(node.implements);
    }
    
    this.space();
    this.print(node.body);
}

function ClassBody2(node) {
    this.tokenChar(123);
    
    if (node.body.length === 0) {
        this.tokenChar(125);
    } else {
        this.newline();
        const separator = classBodyEmptySemicolonsPrinter(this, node);
        separator?.(-1);
        const exit = this.enterDelimited();
        this.printJoin(node.body, true, true, separator, true);
        exit();
        
        if (!this.endsWith(10))
            this.newline();
        
        this.rightBrace(node);
    }
}

function classBodyEmptySemicolonsPrinter(printer, node) {
    if (!printer.tokenMap || node.start == null || node.end == null) {
        return null;
    }
    
    const indexes = printer.tokenMap.getIndexes(node);
    
    if (!indexes)
        return null;
    
    let k = 1;
    let occurrenceCount = 0;
    let nextLocIndex = 0;
    
    const advanceNextLocIndex = () => {
        while (nextLocIndex < node.body.length && node.body[nextLocIndex].start == null) {
            nextLocIndex++;
        }
    };
    
    advanceNextLocIndex();
    return (i) => {
        if (nextLocIndex <= i) {
            nextLocIndex = i + 1;
            advanceNextLocIndex();
        }
        
        const end = nextLocIndex === node.body.length ? node.end : node.body[nextLocIndex].start;
        let tok;
        
        while (k < indexes.length && printer.tokenMap.matchesOriginal(tok = printer._tokens[indexes[k]], ';') && tok.start < end) {
            printer.token(';', void 0, occurrenceCount++);
            k++;
        }
    };
}

function ClassProperty2(node) {
    this.printJoin(node.decorators);
    
    if (!node.static && !this.format.preserveFormat) {
        const endLine = node.key.loc?.end?.line;
        
        if (endLine)
            this.catchUp(endLine);
    }
    
    this.tsPrintClassMemberModifiers(node);
    
    if (node.computed) {
        this.tokenChar(91);
        this.print(node.key);
        this.tokenChar(93);
    } else {
        this._variance(node);
        this.print(node.key);
    }
    
    if (node.optional) {
        this.tokenChar(63);
    }
    
    if (node.definite) {
        this.tokenChar(33);
    }
    
    this.print(node.typeAnnotation);
    
    if (node.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.value);
    }
    
    this.semicolon();
}

function ClassAccessorProperty2(node) {
    this.printJoin(node.decorators);
    const endLine = node.key.loc?.end?.line;
    
    if (endLine)
        this.catchUp(endLine);
    
    this.tsPrintClassMemberModifiers(node);
    this.word('accessor', true);
    this.space();
    
    if (node.computed) {
        this.tokenChar(91);
        this.print(node.key);
        this.tokenChar(93);
    } else {
        this._variance(node);
        this.print(node.key);
    }
    
    if (node.optional) {
        this.tokenChar(63);
    }
    
    if (node.definite) {
        this.tokenChar(33);
    }
    
    this.print(node.typeAnnotation);
    
    if (node.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.value);
    }
    
    this.semicolon();
}

function ClassPrivateProperty2(node) {
    this.printJoin(node.decorators);
    this.tsPrintClassMemberModifiers(node);
    this.print(node.key);
    
    if (node.optional) {
        this.tokenChar(63);
    }
    
    if (node.definite) {
        this.tokenChar(33);
    }
    
    this.print(node.typeAnnotation);
    
    if (node.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.value);
    }
    
    this.semicolon();
}

function ClassMethod2(node) {
    this._classMethodHead(node);
    this.space();
    this.print(node.body);
}

function ClassPrivateMethod2(node) {
    this._classMethodHead(node);
    this.space();
    this.print(node.body);
}

function _classMethodHead(node) {
    this.printJoin(node.decorators);
    
    if (!this.format.preserveFormat) {
        const endLine = node.key.loc?.end?.line;
        
        if (endLine)
            this.catchUp(endLine);
    }
    
    this.tsPrintClassMemberModifiers(node);
    this._methodHead(node);
}

function StaticBlock2(node) {
    this.word('static');
    this.space();
    this.tokenChar(123);
    
    if (node.body.length === 0) {
        this.tokenChar(125);
    } else {
        this.newline();
        this.printSequence(node.body, true);
        this.rightBrace(node);
    }
}

var {isIdentifier: isIdentifier$1$1} = lib_exports;

function _params(node, idNode, parentNode) {
    this.print(node.typeParameters);
    const nameInfo = _getFuncIdName.call(this, idNode, parentNode);
    
    if (nameInfo) {
        this.sourceIdentifierName(nameInfo.name, nameInfo.pos);
    }
    
    this.tokenChar(40);
    this._parameters(node.params, ')');
    const noLineTerminator = node.type === 'ArrowFunctionExpression';
    this.print(node.returnType, noLineTerminator);
    this._noLineTerminator = noLineTerminator;
}

function _parameters(parameters, endToken) {
    const exit = this.enterDelimited();
    const trailingComma = this.shouldPrintTrailingComma(endToken);
    const paramLength = parameters.length;
    
    for (let i = 0; i < paramLength; i++) {
        this._param(parameters[i]);
        
        if (trailingComma || i < paramLength - 1) {
            this.token(',', null, i);
            this.space();
        }
    }
    
    this.token(endToken);
    exit();
}

function _param(parameter) {
    this.printJoin(parameter.decorators);
    this.print(parameter);
    
    if (parameter.optional) {
        this.tokenChar(63);
    }
    
    this.print(parameter.typeAnnotation);
}

function _methodHead(node) {
    const kind = node.kind;
    const key = node.key;
    
    if (kind === 'get' || kind === 'set') {
        this.word(kind);
        this.space();
    }
    
    if (node.async) {
        this.word('async', true);
        this.space();
    }
    
    if (kind === 'method' || kind === 'init') {
        if (node.generator) {
            this.tokenChar(42);
        }
    }
    
    if (node.computed) {
        this.tokenChar(91);
        this.print(key);
        this.tokenChar(93);
    } else {
        this.print(key);
    }
    
    if (node.optional) {
        this.tokenChar(63);
    }
    
    this._params(node, node.computed && node.key.type !== 'StringLiteral' ? void 0 : node.key, void 0);
}

function _predicate(node, noLineTerminatorAfter) {
    if (node.predicate) {
        if (!node.returnType) {
            this.tokenChar(58);
        }
        
        this.space();
        this.print(node.predicate, noLineTerminatorAfter);
    }
}

function _functionHead(node, parent) {
    if (node.async) {
        this.word('async');
        
        if (!this.format.preserveFormat) {
            this._endsWithInnerRaw = false;
        }
        
        this.space();
    }
    
    this.word('function');
    
    if (node.generator) {
        if (!this.format.preserveFormat) {
            this._endsWithInnerRaw = false;
        }
        
        this.tokenChar(42);
    }
    
    this.space();
    
    if (node.id) {
        this.print(node.id);
    }
    
    this._params(node, node.id, parent);
    
    if (node.type !== 'TSDeclareFunction') {
        this._predicate(node);
    }
}

function FunctionExpression2(node, parent) {
    this._functionHead(node, parent);
    this.space();
    this.print(node.body);
}

function ArrowFunctionExpression2(node, parent) {
    if (node.async) {
        this.word('async', true);
        this.space();
    }
    
    if (this._shouldPrintArrowParamsParens(node)) {
        this._params(node, void 0, parent);
    } else {
        this.print(node.params[0], true);
    }
    
    this._predicate(node, true);
    this.space();
    this.printInnerComments();
    this.token('=>');
    this.space();
    this.tokenContext |= TokenContext.arrowBody;
    this.print(node.body);
}

function _shouldPrintArrowParamsParens(node) {
    if (node.params.length !== 1)
        return true;
    
    if (node.typeParameters || node.returnType || node.predicate) {
        return true;
    }
    
    const firstParam = node.params[0];
    
    if (!isIdentifier$1$1(firstParam) || firstParam.typeAnnotation || firstParam.optional || firstParam.leadingComments?.length || firstParam.trailingComments?.length) {
        return true;
    }
    
    if (this.tokenMap) {
        if (node.loc == null)
            return true;
        
        if (this.tokenMap.findMatching(node, '(') !== null)
            return true;
        
        const arrowToken = this.tokenMap.findMatching(node, '=>');
        
        if (arrowToken?.loc == null)
            return true;
        
        return arrowToken.loc.start.line !== node.loc.start.line;
    }
    
    if (this.format.retainLines)
        return true;
    
    return false;
}

function _getFuncIdName(idNode, parent) {
    let id = idNode;
    
    if (!id && parent) {
        const parentType = parent.type;
        
        if (parentType === 'VariableDeclarator') {
            id = parent.id;
        } else if (parentType === 'AssignmentExpression' || parentType === 'AssignmentPattern') {
            id = parent.left;
        } else if (parentType === 'ObjectProperty' || parentType === 'ClassProperty') {
            if (!parent.computed || parent.key.type === 'StringLiteral') {
                id = parent.key;
            }
        } else if (parentType === 'ClassPrivateProperty' || parentType === 'ClassAccessorProperty') {
            id = parent.key;
        }


    }
    
    if (!id)
        return;
    
    let nameInfo;
    
    if (id.type === 'Identifier') {
        nameInfo = {
            pos: id.loc?.start,
            name: id.loc?.identifierName || id.name,
        };
    } else if (id.type === 'PrivateName') {
        nameInfo = {
            pos: id.loc?.start,
            name: '#' + id.id.name,
        };
    } else if (id.type === 'StringLiteral') {
        nameInfo = {
            pos: id.loc?.start,
            name: id.value,
        };
    }
    
    return nameInfo;
}

var {
    isClassDeclaration: isClassDeclaration2,
    isExportDefaultSpecifier: isExportDefaultSpecifier2,
    isExportNamespaceSpecifier: isExportNamespaceSpecifier2,
    isImportDefaultSpecifier: isImportDefaultSpecifier2,
    isImportNamespaceSpecifier: isImportNamespaceSpecifier2,
    isStatement: isStatement$2$1,
} = lib_exports;

function ImportSpecifier2(node) {
    if (node.importKind === 'type' || node.importKind === 'typeof') {
        this.word(node.importKind);
        this.space();
    }
    
    this.print(node.imported);
    
    if (node.local && node.local.name !== node.imported.name) {
        this.space();
        this.word('as');
        this.space();
        this.print(node.local);
    }
}

function ImportDefaultSpecifier2(node) {
    this.print(node.local);
}

function ExportDefaultSpecifier2(node) {
    this.print(node.exported);
}

function ExportSpecifier2(node) {
    if (node.exportKind === 'type') {
        this.word('type');
        this.space();
    }
    
    this.print(node.local);
    
    if (node.exported && node.local.name !== node.exported.name) {
        this.space();
        this.word('as');
        this.space();
        this.print(node.exported);
    }
}

function ExportNamespaceSpecifier2(node) {
    this.tokenChar(42);
    this.space();
    this.word('as');
    this.space();
    this.print(node.exported);
}

function _printAttributes(node, hasPreviousBrace) {
    const {importAttributesKeyword} = this.format;
    
    const {attributes, assertions} = node;
    
    const useAssertKeyword = importAttributesKeyword === 'assert' || !importAttributesKeyword && assertions;
    
    this.word(useAssertKeyword ? 'assert' : 'with');
    this.space();
    const occurrenceCount = hasPreviousBrace ? 1 : 0;
    this.token('{', null, occurrenceCount);
    this.space();
    this.printList(attributes || assertions, this.shouldPrintTrailingComma('}'));
    this.space();
    this.token('}', null, occurrenceCount);
}

function ExportAllDeclaration2(node) {
    this.word('export');
    this.space();
    
    if (node.exportKind === 'type') {
        this.word('type');
        this.space();
    }
    
    this.tokenChar(42);
    this.space();
    this.word('from');
    this.space();
    
    if (node.attributes?.length || node.assertions?.length) {
        this.print(node.source, true);
        this.space();
        this._printAttributes(node, false);
    } else {
        this.print(node.source);
    }
    
    this.semicolon();
}

function maybePrintDecoratorsBeforeExport(printer, node) {
    if (isClassDeclaration2(node.declaration) && printer._shouldPrintDecoratorsBeforeExport(node)) {
        printer.printJoin(node.declaration.decorators);
    }
}

function ExportNamedDeclaration2(node) {
    maybePrintDecoratorsBeforeExport(this, node);
    this.word('export');
    this.space();
    
    if (node.declaration) {
        const declar = node.declaration;
        this.print(declar);
        
        if (!isStatement$2$1(declar))
            this.semicolon();
    } else {
        if (node.exportKind === 'type') {
            this.word('type');
            this.space();
        }
        
        const specifiers = node.specifiers.slice(0);
        let hasSpecial = false;
        
        for (;;) {
            const first = specifiers[0];
            
            if (isExportDefaultSpecifier2(first) || isExportNamespaceSpecifier2(first)) {
                hasSpecial = true;
                this.print(specifiers.shift());
                
                if (specifiers.length) {
                    this.tokenChar(44);
                    this.space();
                }
            } else {
                break;
            }
        }
        
        let hasBrace = false;
        
        if (specifiers.length || !specifiers.length && !hasSpecial) {
            hasBrace = true;
            this.tokenChar(123);
            
            if (specifiers.length) {
                this.space();
                this.printList(specifiers, this.shouldPrintTrailingComma('}'));
                this.space();
            }
            
            this.tokenChar(125);
        }
        
        if (node.source) {
            this.space();
            this.word('from');
            this.space();
            
            if (node.attributes?.length || node.assertions?.length) {
                this.print(node.source, true);
                this.space();
                this._printAttributes(node, hasBrace);
            } else {
                this.print(node.source);
            }
        }
        
        this.semicolon();
    }
}

function ExportDefaultDeclaration2(node) {
    maybePrintDecoratorsBeforeExport(this, node);
    this.word('export');
    this.noIndentInnerCommentsHere();
    this.space();
    this.word('default');
    this.space();
    this.tokenContext |= TokenContext.exportDefault;
    const declar = node.declaration;
    this.print(declar);
    
    if (!isStatement$2$1(declar))
        this.semicolon();
}

function ImportDeclaration2(node) {
    this.word('import');
    this.space();
    const isTypeKind = node.importKind === 'type' || node.importKind === 'typeof';
    
    if (isTypeKind) {
        this.noIndentInnerCommentsHere();
        this.word(node.importKind);
        this.space();
    } else if (node.module) {
        this.noIndentInnerCommentsHere();
        this.word('module');
        this.space();
    } else if (node.phase) {
        this.noIndentInnerCommentsHere();
        this.word(node.phase);
        this.space();
    }
    
    const specifiers = node.specifiers.slice(0);
    const hasSpecifiers = !!specifiers.length;
    
    while (hasSpecifiers) {
        const first = specifiers[0];
        
        if (isImportDefaultSpecifier2(first) || isImportNamespaceSpecifier2(first)) {
            this.print(specifiers.shift());
            
            if (specifiers.length) {
                this.tokenChar(44);
                this.space();
            }
        } else {
            break;
        }
    }
    
    let hasBrace = false;
    
    if (specifiers.length) {
        hasBrace = true;
        this.tokenChar(123);
        this.space();
        this.printList(specifiers, this.shouldPrintTrailingComma('}'));
        this.space();
        this.tokenChar(125);
    } else if (isTypeKind && !hasSpecifiers) {
        hasBrace = true;
        this.tokenChar(123);
        this.tokenChar(125);
    }
    
    if (hasSpecifiers || isTypeKind) {
        this.space();
        this.word('from');
        this.space();
    }
    
    if (node.attributes?.length || node.assertions?.length) {
        this.print(node.source, true);
        this.space();
        this._printAttributes(node, hasBrace);
    } else {
        this.print(node.source);
    }
    
    this.semicolon();
}

function ImportAttribute2(node) {
    this.print(node.key);
    this.tokenChar(58);
    this.space();
    this.print(node.value);
}

function ImportNamespaceSpecifier2(node) {
    this.tokenChar(42);
    this.space();
    this.word('as');
    this.space();
    this.print(node.local);
}

function ImportExpression2(node) {
    this.word('import');
    
    if (node.phase) {
        this.tokenChar(46);
        this.word(node.phase);
    }
    
    this.tokenChar(40);
    const shouldPrintTrailingComma = this.shouldPrintTrailingComma(')');
    this.print(node.source);
    
    if (node.options != null) {
        this.tokenChar(44);
        this.space();
        this.print(node.options);
    }
    
    if (shouldPrintTrailingComma) {
        this.tokenChar(44);
    }
    
    this.rightParens(node);
}

var {
    isAssignmentPattern: isAssignmentPattern2,
    isIdentifier: isIdentifier3,
} = lib_exports;

var lastRawIdentNode = null;
var lastRawIdentResult = '';

function _getRawIdentifier(node) {
    if (node === lastRawIdentNode)
        return lastRawIdentResult;
    
    lastRawIdentNode = node;
    const {name} = node;
    
    const token = this.tokenMap.find(node, (tok) => tok.value === name);
    
    if (token) {
        lastRawIdentResult = this._originalCode.slice(token.start, token.end);
        return lastRawIdentResult;
    }
    
    return lastRawIdentResult = node.name;
}

function Identifier2(node) {
    this.sourceIdentifierName(node.loc?.identifierName || node.name);
    this.word(this.tokenMap ? this._getRawIdentifier(node) : node.name);
}

function ArgumentPlaceholder2() {
    this.tokenChar(63);
}

function RestElement2(node) {
    this.token('...');
    this.print(node.argument);
}

function ObjectExpression2(node) {
    const props = node.properties;
    this.tokenChar(123);
    
    if (props.length) {
        const exit = this.enterDelimited();
        this.space();
        this.printList(props, this.shouldPrintTrailingComma('}'), true, true);
        this.space();
        exit();
    }
    
    this.sourceWithOffset('end', node.loc, -1);
    this.tokenChar(125);
}

function ObjectMethod2(node) {
    this.printJoin(node.decorators);
    this._methodHead(node);
    this.space();
    this.print(node.body);
}

function ObjectProperty2(node) {
    this.printJoin(node.decorators);
    
    if (node.computed) {
        this.tokenChar(91);
        this.print(node.key);
        this.tokenChar(93);
    } else {
        if (isAssignmentPattern2(node.value) && isIdentifier3(node.key) && node.key.name === node.value.left.name) {
            this.print(node.value);
            return;
        }
        
        this.print(node.key);
        
        if (node.shorthand && isIdentifier3(node.key) && isIdentifier3(node.value) && node.key.name === node.value.name) {
            return;
        }
    }
    
    this.tokenChar(58);
    this.space();
    this.print(node.value);
}

function ArrayExpression2(node) {
    const elems = node.elements;
    const len = elems.length;
    this.tokenChar(91);
    const exit = this.enterDelimited();
    
    for (let i = 0; i < elems.length; i++) {
        const elem = elems[i];
        
        if (elem) {
            if (i > 0)
                this.space();
            
            this.print(elem);
            
            if (i < len - 1 || this.shouldPrintTrailingComma(']')) {
                this.token(',', false, i);
            }
        } else {
            this.token(',', false, i);
        }
    }
    
    exit();
    this.tokenChar(93);
}

function RecordExpression2(node) {
    const props = node.properties;
    let startToken;
    let endToken;
    
    {
        startToken = '#{';
        endToken = '}';
    }
    this.token(startToken);
    
    if (props.length) {
        this.space();
        this.printList(props, this.shouldPrintTrailingComma(endToken), true, true);
        this.space();
    }
    
    this.token(endToken);
}

function TupleExpression2(node) {
    const elems = node.elements;
    const len = elems.length;
    let startToken;
    let endToken;
    
    {
        startToken = '#[';
        endToken = ']';
    }
    this.token(startToken);
    for (let i = 0; i < elems.length; i++) {
        const elem = elems[i];
        
        if (elem) {
            if (i > 0)
                this.space();
            
            this.print(elem);
            
            if (i < len - 1 || this.shouldPrintTrailingComma(endToken)) {
                this.token(',', false, i);
            }
        }
    }
    
    this.token(endToken);
}

function RegExpLiteral2(node) {
    this.word(`/${node.pattern}/${node.flags}`);
}

function BooleanLiteral2(node) {
    this.word(node.value ? 'true' : 'false');
}

function NullLiteral2() {
    this.word('null');
}

function NumericLiteral2(node) {
    const raw = this.getPossibleRaw(node);
    const opts = this.format.jsescOption;
    const value = node.value;
    const str = value + '';
    
    if (opts.numbers) {
        this.number((0, import_jsesc.default)(value, opts), value);
    } else if (raw == null) {
        this.number(str, value);
    } else if (this.format.minified) {
        this.number(raw.length < str.length ? raw : str, value);
    } else {
        this.number(raw, value);
    }

}

function StringLiteral2(node) {
    const raw = this.getPossibleRaw(node);
    
    if (!this.format.minified && raw !== void 0) {
        this.token(raw);
        return;
    }
    
    const val = (0, import_jsesc.default)(node.value, this.format.jsescOption);
    this.token(val);
}

function BigIntLiteral2(node) {
    const raw = this.getPossibleRaw(node);
    
    if (!this.format.minified && raw !== void 0) {
        this.word(raw);
        return;
    }
    
    this.word(node.value + 'n');
}

var validTopicTokenSet = /* @__PURE__ */new Set([
    '^^',
    '@@',
    '^',
    '%',
    '#',
]);

function TopicReference2() {
    const {topicToken} = this.format;
    
    if (validTopicTokenSet.has(topicToken)) {
        this.token(topicToken);
    } else {
        const givenTopicTokenJSON = JSON.stringify(topicToken);
        const validTopics = Array.from(validTopicTokenSet, (v) => JSON.stringify(v));
        throw new Error(`The "topicToken" generator option must be one of ${validTopics.join(', ')} (${givenTopicTokenJSON} received instead).`);
    }
}

function PipelineTopicExpression2(node) {
    this.print(node.expression);
}

function PipelineBareFunction2(node) {
    this.print(node.callee);
}

function PipelinePrimaryTopicReference2() {
    this.tokenChar(35);
}

function VoidPattern2() {
    this.word('void');
}

var {
    isDeclareExportDeclaration: isDeclareExportDeclaration2,
    isStatement: isStatement$12,
} = lib_exports;

function AnyTypeAnnotation2() {
    this.word('any');
}

function ArrayTypeAnnotation2(node) {
    this.print(node.elementType, true);
    this.tokenChar(91);
    this.tokenChar(93);
}

function BooleanTypeAnnotation2() {
    this.word('boolean');
}

function BooleanLiteralTypeAnnotation2(node) {
    this.word(node.value ? 'true' : 'false');
}

function NullLiteralTypeAnnotation2() {
    this.word('null');
}

function DeclareClass2(node, parent) {
    if (!isDeclareExportDeclaration2(parent)) {
        this.word('declare');
        this.space();
    }
    
    this.word('class');
    this.space();
    this._interfaceish(node);
}

function DeclareFunction2(node, parent) {
    if (!isDeclareExportDeclaration2(parent)) {
        this.word('declare');
        this.space();
    }
    
    this.word('function');
    this.space();
    this.print(node.id);
    this.print(node.id.typeAnnotation.typeAnnotation);
    
    if (node.predicate) {
        this.space();
        this.print(node.predicate);
    }
    
    this.semicolon();
}

function InferredPredicate2() {
    this.tokenChar(37);
    this.word('checks');
}

function DeclaredPredicate2(node) {
    this.tokenChar(37);
    this.word('checks');
    this.tokenChar(40);
    this.print(node.value);
    this.tokenChar(41);
}

function DeclareInterface2(node) {
    this.word('declare');
    this.space();
    this.InterfaceDeclaration(node);
}

function DeclareModule2(node) {
    this.word('declare');
    this.space();
    this.word('module');
    this.space();
    this.print(node.id);
    this.space();
    this.print(node.body);
}

function DeclareModuleExports2(node) {
    this.word('declare');
    this.space();
    this.word('module');
    this.tokenChar(46);
    this.word('exports');
    this.print(node.typeAnnotation);
}

function DeclareTypeAlias2(node) {
    this.word('declare');
    this.space();
    this.TypeAlias(node);
}

function DeclareOpaqueType2(node, parent) {
    if (!isDeclareExportDeclaration2(parent)) {
        this.word('declare');
        this.space();
    }
    
    this.OpaqueType(node);
}

function DeclareVariable2(node, parent) {
    if (!isDeclareExportDeclaration2(parent)) {
        this.word('declare');
        this.space();
    }
    
    this.word('var');
    this.space();
    this.print(node.id);
    this.print(node.id.typeAnnotation);
    this.semicolon();
}

function DeclareExportDeclaration2(node) {
    this.word('declare');
    this.space();
    this.word('export');
    this.space();
    
    if (node.default) {
        this.word('default');
        this.space();
    }
    
    FlowExportDeclaration.call(this, node);
}

function DeclareExportAllDeclaration2(node) {
    this.word('declare');
    this.space();
    ExportAllDeclaration2.call(this, node);
}

function EnumDeclaration2(node) {
    const {id, body} = node;
    
    this.word('enum');
    this.space();
    this.print(id);
    this.print(body);
}

function enumExplicitType(context, name, hasExplicitType) {
    if (hasExplicitType) {
        context.space();
        context.word('of');
        context.space();
        context.word(name);
    }
    
    context.space();
}

function enumBody(context, node) {
    const {members} = node;
    
    context.token('{');
    context.indent();
    context.newline();
    for (const member of members) {
        context.print(member);
        context.newline();
    }
    
    if (node.hasUnknownMembers) {
        context.token('...');
        context.newline();
    }
    
    context.dedent();
    context.token('}');
}

function EnumBooleanBody2(node) {
    const {explicitType} = node;
    
    enumExplicitType(this, 'boolean', explicitType);
    enumBody(this, node);
}

function EnumNumberBody2(node) {
    const {explicitType} = node;
    
    enumExplicitType(this, 'number', explicitType);
    enumBody(this, node);
}

function EnumStringBody2(node) {
    const {explicitType} = node;
    
    enumExplicitType(this, 'string', explicitType);
    enumBody(this, node);
}

function EnumSymbolBody2(node) {
    enumExplicitType(this, 'symbol', true);
    enumBody(this, node);
}

function EnumDefaultedMember2(node) {
    const {id} = node;
    
    this.print(id);
    this.tokenChar(44);
}

function enumInitializedMember(context, node) {
    context.print(node.id);
    context.space();
    context.token('=');
    context.space();
    context.print(node.init);
    context.token(',');
}

function EnumBooleanMember2(node) {
    enumInitializedMember(this, node);
}

function EnumNumberMember2(node) {
    enumInitializedMember(this, node);
}

function EnumStringMember2(node) {
    enumInitializedMember(this, node);
}

function FlowExportDeclaration(node) {
    if (node.declaration) {
        const declar = node.declaration;
        this.print(declar);
        
        if (!isStatement$12(declar))
            this.semicolon();
    } else {
        this.tokenChar(123);
        
        if (node.specifiers.length) {
            this.space();
            this.printList(node.specifiers);
            this.space();
        }
        
        this.tokenChar(125);
        
        if (node.source) {
            this.space();
            this.word('from');
            this.space();
            this.print(node.source);
        }
        
        this.semicolon();
    }
}

function ExistsTypeAnnotation2() {
    this.tokenChar(42);
}

function FunctionTypeAnnotation2(node, parent) {
    this.print(node.typeParameters);
    this.tokenChar(40);
    
    if (node.this) {
        this.word('this');
        this.tokenChar(58);
        this.space();
        this.print(node.this.typeAnnotation);
        
        if (node.params.length || node.rest) {
            this.tokenChar(44);
            this.space();
        }
    }
    
    this.printList(node.params);
    
    if (node.rest) {
        if (node.params.length) {
            this.tokenChar(44);
            this.space();
        }
        
        this.token('...');
        this.print(node.rest);
    }
    
    this.tokenChar(41);
    const type = parent?.type;
    
    if (type != null && (type === 'ObjectTypeCallProperty' || type === 'ObjectTypeInternalSlot' || type === 'DeclareFunction' || type === 'ObjectTypeProperty' && parent.method)) {
        this.tokenChar(58);
    } else {
        this.space();
        this.token('=>');
    }
    
    this.space();
    this.print(node.returnType);
}

function FunctionTypeParam2(node) {
    this.print(node.name);
    
    if (node.optional)
        this.tokenChar(63);
    
    if (node.name) {
        this.tokenChar(58);
        this.space();
    }
    
    this.print(node.typeAnnotation);
}

function InterfaceExtends2(node) {
    this.print(node.id);
    this.print(node.typeParameters, true);
}

function _interfaceish(node) {
    this.print(node.id);
    this.print(node.typeParameters);
    
    if (node.extends?.length) {
        this.space();
        this.word('extends');
        this.space();
        this.printList(node.extends);
    }
    
    if (node.type === 'DeclareClass') {
        if (node.mixins?.length) {
            this.space();
            this.word('mixins');
            this.space();
            this.printList(node.mixins);
        }
        
        if (node.implements?.length) {
            this.space();
            this.word('implements');
            this.space();
            this.printList(node.implements);
        }
    }
    
    this.space();
    this.print(node.body);
}

function _variance(node) {
    const kind = node.variance?.kind;
    
    if (kind != null) {
        if (kind === 'plus') {
            this.tokenChar(43);
        } else if (kind === 'minus') {
            this.tokenChar(45);
        }
    }
}

function InterfaceDeclaration2(node) {
    this.word('interface');
    this.space();
    this._interfaceish(node);
}

function andSeparator(occurrenceCount) {
    this.space();
    this.token('&', false, occurrenceCount);
    this.space();
}

function InterfaceTypeAnnotation2(node) {
    this.word('interface');
    
    if (node.extends?.length) {
        this.space();
        this.word('extends');
        this.space();
        this.printList(node.extends);
    }
    
    this.space();
    this.print(node.body);
}

function IntersectionTypeAnnotation2(node) {
    this.printJoin(node.types, void 0, void 0, andSeparator);
}

function MixedTypeAnnotation2() {
    this.word('mixed');
}

function EmptyTypeAnnotation2() {
    this.word('empty');
}

function NullableTypeAnnotation2(node) {
    this.tokenChar(63);
    this.print(node.typeAnnotation);
}

function NumberTypeAnnotation2() {
    this.word('number');
}

function StringTypeAnnotation2() {
    this.word('string');
}

function ThisTypeAnnotation2() {
    this.word('this');
}

function TupleTypeAnnotation2(node) {
    this.tokenChar(91);
    this.printList(node.types);
    this.tokenChar(93);
}

function TypeofTypeAnnotation2(node) {
    this.word('typeof');
    this.space();
    this.print(node.argument);
}

function TypeAlias2(node) {
    this.word('type');
    this.space();
    this.print(node.id);
    this.print(node.typeParameters);
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node.right);
    this.semicolon();
}

function TypeAnnotation2(node, parent) {
    this.tokenChar(58);
    this.space();
    
    if (parent.type === 'ArrowFunctionExpression') {
        this.tokenContext |= TokenContext.arrowFlowReturnType;
    } else if (node.optional) {
        this.tokenChar(63);
    }
    
    this.print(node.typeAnnotation);
}

function TypeParameterInstantiation2(node) {
    this.tokenChar(60);
    this.printList(node.params);
    this.tokenChar(62);
}

function TypeParameter2(node) {
    this._variance(node);
    this.word(node.name);
    
    if (node.bound) {
        this.print(node.bound);
    }
    
    if (node.default) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.default);
    }
}

function OpaqueType2(node) {
    this.word('opaque');
    this.space();
    this.word('type');
    this.space();
    this.print(node.id);
    this.print(node.typeParameters);
    
    if (node.supertype) {
        this.tokenChar(58);
        this.space();
        this.print(node.supertype);
    }
    
    if (node.impltype) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.impltype);
    }
    
    this.semicolon();
}

function ObjectTypeAnnotation2(node) {
    if (node.exact) {
        this.token('{|');
    } else {
        this.tokenChar(123);
    }
    
    const props = [
        ...node.properties,
        ...node.callProperties || [],
        ...node.indexers || [],
        ...node.internalSlots || [],
    ];
    
    if (props.length) {
        this.newline();
        this.space();
        this.printJoin(props, true, true, void 0, void 0, function addNewlines(leading) {
            if (leading && !props[0])
                return 1;
        }, () => {
            if (props.length !== 1 || node.inexact) {
                this.tokenChar(44);
                this.space();
            }
        });
        this.space();
    }
    
    if (node.inexact) {
        this.indent();
        this.token('...');
        
        if (props.length) {
            this.newline();
        }
        
        this.dedent();
    }
    
    if (node.exact) {
        this.token('|}');
    } else {
        this.tokenChar(125);
    }
}

function ObjectTypeInternalSlot2(node) {
    if (node.static) {
        this.word('static');
        this.space();
    }
    
    this.tokenChar(91);
    this.tokenChar(91);
    this.print(node.id);
    this.tokenChar(93);
    this.tokenChar(93);
    
    if (node.optional)
        this.tokenChar(63);
    
    if (!node.method) {
        this.tokenChar(58);
        this.space();
    }
    
    this.print(node.value);
}

function ObjectTypeCallProperty2(node) {
    if (node.static) {
        this.word('static');
        this.space();
    }
    
    this.print(node.value);
}

function ObjectTypeIndexer2(node) {
    if (node.static) {
        this.word('static');
        this.space();
    }
    
    this._variance(node);
    this.tokenChar(91);
    
    if (node.id) {
        this.print(node.id);
        this.tokenChar(58);
        this.space();
    }
    
    this.print(node.key);
    this.tokenChar(93);
    this.tokenChar(58);
    this.space();
    this.print(node.value);
}

function ObjectTypeProperty2(node) {
    if (node.proto) {
        this.word('proto');
        this.space();
    }
    
    if (node.static) {
        this.word('static');
        this.space();
    }
    
    if (node.kind === 'get' || node.kind === 'set') {
        this.word(node.kind);
        this.space();
    }
    
    this._variance(node);
    this.print(node.key);
    
    if (node.optional)
        this.tokenChar(63);
    
    if (!node.method) {
        this.tokenChar(58);
        this.space();
    }
    
    this.print(node.value);
}

function ObjectTypeSpreadProperty2(node) {
    this.token('...');
    this.print(node.argument);
}

function QualifiedTypeIdentifier2(node) {
    this.print(node.qualification);
    this.tokenChar(46);
    this.print(node.id);
}

function SymbolTypeAnnotation2() {
    this.word('symbol');
}

function orSeparator(occurrenceCount) {
    this.space();
    this.token('|', false, occurrenceCount);
    this.space();
}

function UnionTypeAnnotation2(node) {
    this.printJoin(node.types, void 0, void 0, orSeparator);
}

function TypeCastExpression2(node) {
    this.tokenChar(40);
    this.print(node.expression);
    this.print(node.typeAnnotation);
    this.tokenChar(41);
}

function Variance2(node) {
    if (node.kind === 'plus') {
        this.tokenChar(43);
    } else {
        this.tokenChar(45);
    }
}

function VoidTypeAnnotation2() {
    this.word('void');
}

function IndexedAccessType2(node) {
    this.print(node.objectType, true);
    this.tokenChar(91);
    this.print(node.indexType);
    this.tokenChar(93);
}

function OptionalIndexedAccessType2(node) {
    this.print(node.objectType);
    
    if (node.optional) {
        this.token('?.');
    }
    
    this.tokenChar(91);
    this.print(node.indexType);
    this.tokenChar(93);
}

function File2(node) {
    if (node.program) {
        this.print(node.program.interpreter);
    }
    
    this.print(node.program);
}

function Program2(node) {
    this.noIndentInnerCommentsHere();
    this.printInnerComments();
    const directivesLen = node.directives?.length;
    
    if (directivesLen) {
        const newline = node.body.length ? 2 : 1;
        this.printSequence(node.directives, void 0, newline);
        
        if (!node.directives[directivesLen - 1].trailingComments?.length) {
            this.newline(newline);
        }
    }
    
    this.printSequence(node.body);
}

function BlockStatement2(node) {
    this.tokenChar(123);
    const exit = this.enterDelimited();
    const directivesLen = node.directives?.length;
    
    if (directivesLen) {
        const newline = node.body.length ? 2 : 1;
        this.printSequence(node.directives, true, newline);
        
        if (!node.directives[directivesLen - 1].trailingComments?.length) {
            this.newline(newline);
        }
    }
    
    this.printSequence(node.body, true);
    exit();
    this.rightBrace(node);
}

function Directive2(node) {
    this.print(node.value);
    this.semicolon();
}

var unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
var unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;

function DirectiveLiteral2(node) {
    const raw = this.getPossibleRaw(node);
    
    if (!this.format.minified && raw !== void 0) {
        this.token(raw);
        return;
    }
    
    const {value} = node;
    
    if (!unescapedDoubleQuoteRE.test(value)) {
        this.token(`"${value}"`);
    } else if (!unescapedSingleQuoteRE.test(value)) {
        this.token(`'${value}'`);
    } else {
        throw new Error('Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.');
    }
}

function InterpreterDirective2(node) {
    this.token(`#!${node.value}`);
    this.newline(1, true);
}

function Placeholder2(node) {
    this.token('%%');
    this.print(node.name);
    this.token('%%');
    
    if (node.expectedNode === 'Statement') {
        this.semicolon();
    }
}

function JSXAttribute2(node) {
    this.print(node.name);
    
    if (node.value) {
        this.tokenChar(61);
        this.print(node.value);
    }
}

function JSXIdentifier2(node) {
    this.word(node.name);
}

function JSXNamespacedName2(node) {
    this.print(node.namespace);
    this.tokenChar(58);
    this.print(node.name);
}

function JSXMemberExpression2(node) {
    this.print(node.object);
    this.tokenChar(46);
    this.print(node.property);
}

function JSXSpreadAttribute2(node) {
    this.tokenChar(123);
    this.token('...');
    this.print(node.argument);
    this.rightBrace(node);
}

function JSXExpressionContainer2(node) {
    this.tokenChar(123);
    this.print(node.expression);
    this.rightBrace(node);
}

function JSXSpreadChild2(node) {
    this.tokenChar(123);
    this.token('...');
    this.print(node.expression);
    this.rightBrace(node);
}

function JSXText2(node) {
    const raw = this.getPossibleRaw(node);
    
    if (raw !== void 0) {
        this.token(raw, true);
    } else {
        this.token(node.value, true);
    }
}

function JSXElement2(node) {
    const open = node.openingElement;
    this.print(open);
    
    if (open.selfClosing)
        return;
    
    this.indent();
    for (const child of node.children) {
        this.print(child);
    }
    
    this.dedent();
    this.print(node.closingElement);
}

function spaceSeparator() {
    this.space();
}

function JSXOpeningElement2(node) {
    this.tokenChar(60);
    this.print(node.name);
    {
        this.print(node.typeArguments);
    }
    if (node.attributes.length > 0) {
        this.space();
        this.printJoin(node.attributes, void 0, void 0, spaceSeparator);
    }
    
    if (node.selfClosing) {
        this.space();
        this.tokenChar(47);
    }
    
    this.tokenChar(62);
}

function JSXClosingElement2(node) {
    this.tokenChar(60);
    this.tokenChar(47);
    this.print(node.name);
    this.tokenChar(62);
}

function JSXEmptyExpression2() {
    this.printInnerComments();
}

function JSXFragment2(node) {
    this.print(node.openingFragment);
    this.indent();
    
    for (const child of node.children) {
        this.print(child);
    }
    
    this.dedent();
    this.print(node.closingFragment);
}

function JSXOpeningFragment2() {
    this.tokenChar(60);
    this.tokenChar(62);
}

function JSXClosingFragment2() {
    this.token('</');
    this.tokenChar(62);
}

function TSTypeAnnotation2(node, parent) {
    this.token((parent.type === 'TSFunctionType' || parent.type === 'TSConstructorType') && parent.returnType === node ? '=>' : ':');
    this.space();
    
    if (node.optional)
        this.tokenChar(63);
    
    this.print(node.typeAnnotation);
}

function TSTypeParameterInstantiation2(node, parent) {
    this.tokenChar(60);
    let printTrailingSeparator = parent.type === 'ArrowFunctionExpression' && node.params.length === 1;
    
    if (this.tokenMap && node.start != null && node.end != null) {
        printTrailingSeparator && (printTrailingSeparator = !!this.tokenMap.find(node, (t) => this.tokenMap.matchesOriginal(t, ',')));
        printTrailingSeparator || (printTrailingSeparator = this.shouldPrintTrailingComma('>'));
    }
    
    this.printList(node.params, printTrailingSeparator);
    this.tokenChar(62);
}

function TSTypeParameter2(node) {
    if (node.const) {
        this.word('const');
        this.space();
    }
    
    if (node.in) {
        this.word('in');
        this.space();
    }
    
    if (node.out) {
        this.word('out');
        this.space();
    }
    
    this.word(node.name.name);
    
    if (node.constraint) {
        this.space();
        this.word('extends');
        this.space();
        this.print(node.constraint);
    }
    
    if (node.default) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.default);
    }
}

function TSParameterProperty2(node) {
    if (node.accessibility) {
        this.word(node.accessibility);
        this.space();
    }
    
    if (node.readonly) {
        this.word('readonly');
        this.space();
    }
    
    this._param(node.parameter);
}

function TSDeclareFunction2(node, parent) {
    if (node.declare) {
        this.word('declare');
        this.space();
    }
    
    this._functionHead(node, parent);
    this.semicolon();
}

function TSDeclareMethod2(node) {
    this._classMethodHead(node);
    this.semicolon();
}

function TSQualifiedName2(node) {
    this.print(node.left);
    this.tokenChar(46);
    this.print(node.right);
}

function TSCallSignatureDeclaration2(node) {
    this.tsPrintSignatureDeclarationBase(node);
    maybePrintTrailingCommaOrSemicolon(this, node);
}

function maybePrintTrailingCommaOrSemicolon(printer, node) {
    if (!printer.tokenMap || !node.start || !node.end) {
        printer.semicolon();
        return;
    }
    
    if (printer.tokenMap.endMatches(node, ',')) {
        printer.token(',');
    } else if (printer.tokenMap.endMatches(node, ';')) {
        printer.semicolon();
    }
}

function TSConstructSignatureDeclaration2(node) {
    this.word('new');
    this.space();
    this.tsPrintSignatureDeclarationBase(node);
    maybePrintTrailingCommaOrSemicolon(this, node);
}

function TSPropertySignature2(node) {
    const {readonly} = node;
    
    if (readonly) {
        this.word('readonly');
        this.space();
    }
    
    this.tsPrintPropertyOrMethodName(node);
    this.print(node.typeAnnotation);
    maybePrintTrailingCommaOrSemicolon(this, node);
}

function tsPrintPropertyOrMethodName(node) {
    if (node.computed) {
        this.tokenChar(91);
    }
    
    this.print(node.key);
    
    if (node.computed) {
        this.tokenChar(93);
    }
    
    if (node.optional) {
        this.tokenChar(63);
    }
}

function TSMethodSignature2(node) {
    const {kind} = node;
    
    if (kind === 'set' || kind === 'get') {
        this.word(kind);
        this.space();
    }
    
    this.tsPrintPropertyOrMethodName(node);
    this.tsPrintSignatureDeclarationBase(node);
    maybePrintTrailingCommaOrSemicolon(this, node);
}

function TSIndexSignature2(node) {
    const {readonly, static: isStatic2} = node;
    
    if (isStatic2) {
        this.word('static');
        this.space();
    }
    
    if (readonly) {
        this.word('readonly');
        this.space();
    }
    
    this.tokenChar(91);
    this._parameters(node.parameters, ']');
    this.print(node.typeAnnotation);
    maybePrintTrailingCommaOrSemicolon(this, node);
}

function TSAnyKeyword2() {
    this.word('any');
}

function TSBigIntKeyword2() {
    this.word('bigint');
}

function TSUnknownKeyword2() {
    this.word('unknown');
}

function TSNumberKeyword2() {
    this.word('number');
}

function TSObjectKeyword2() {
    this.word('object');
}

function TSBooleanKeyword2() {
    this.word('boolean');
}

function TSStringKeyword2() {
    this.word('string');
}

function TSSymbolKeyword2() {
    this.word('symbol');
}

function TSVoidKeyword2() {
    this.word('void');
}

function TSUndefinedKeyword2() {
    this.word('undefined');
}

function TSNullKeyword2() {
    this.word('null');
}

function TSNeverKeyword2() {
    this.word('never');
}

function TSIntrinsicKeyword2() {
    this.word('intrinsic');
}

function TSThisType2() {
    this.word('this');
}

function TSFunctionType2(node) {
    this.tsPrintFunctionOrConstructorType(node);
}

function TSConstructorType2(node) {
    if (node.abstract) {
        this.word('abstract');
        this.space();
    }
    
    this.word('new');
    this.space();
    this.tsPrintFunctionOrConstructorType(node);
}

function tsPrintFunctionOrConstructorType(node) {
    const {typeParameters} = node;
    
    const parameters = node.params;
    this.print(typeParameters);
    this.tokenChar(40);
    this._parameters(parameters, ')');
    this.space();
    const returnType = node.returnType;
    this.print(returnType);
}

function TSTypeReference2(node) {
    const typeArguments = node.typeArguments;
    this.print(node.typeName, !!typeArguments);
    this.print(typeArguments);
}

function TSTypePredicate2(node) {
    if (node.asserts) {
        this.word('asserts');
        this.space();
    }
    
    this.print(node.parameterName);
    
    if (node.typeAnnotation) {
        this.space();
        this.word('is');
        this.space();
        this.print(node.typeAnnotation.typeAnnotation);
    }
}

function TSTypeQuery2(node) {
    this.word('typeof');
    this.space();
    this.print(node.exprName);
    const typeArguments = node.typeArguments;
    
    if (typeArguments) {
        this.print(typeArguments);
    }
}

function TSTypeLiteral2(node) {
    printBraced(this, node, () => this.printJoin(node.members, true, true));
}

function TSArrayType2(node) {
    this.print(node.elementType, true);
    this.tokenChar(91);
    this.tokenChar(93);
}

function TSTupleType2(node) {
    this.tokenChar(91);
    this.printList(node.elementTypes, this.shouldPrintTrailingComma(']'));
    this.tokenChar(93);
}

function TSOptionalType2(node) {
    this.print(node.typeAnnotation);
    this.tokenChar(63);
}

function TSRestType2(node) {
    this.token('...');
    this.print(node.typeAnnotation);
}

function TSNamedTupleMember2(node) {
    this.print(node.label);
    
    if (node.optional)
        this.tokenChar(63);
    
    this.tokenChar(58);
    this.space();
    this.print(node.elementType);
}

function TSUnionType2(node) {
    tsPrintUnionOrIntersectionType(this, node, '|');
}

function TSIntersectionType2(node) {
    tsPrintUnionOrIntersectionType(this, node, '&');
}

function tsPrintUnionOrIntersectionType(printer, node, sep) {
    let hasLeadingToken = 0;
    
    if (printer.tokenMap?.startMatches(node, sep)) {
        hasLeadingToken = 1;
        printer.token(sep);
    }
    
    printer.printJoin(node.types, void 0, void 0, function(i) {
        this.space();
        this.token(sep, null, i + hasLeadingToken);
        this.space();
    });
}

function TSConditionalType2(node) {
    this.print(node.checkType);
    this.space();
    this.word('extends');
    this.space();
    this.print(node.extendsType);
    this.space();
    this.tokenChar(63);
    this.space();
    this.print(node.trueType);
    this.space();
    this.tokenChar(58);
    this.space();
    this.print(node.falseType);
}

function TSInferType2(node) {
    this.word('infer');
    this.print(node.typeParameter);
}

function TSParenthesizedType2(node) {
    this.tokenChar(40);
    this.print(node.typeAnnotation);
    this.tokenChar(41);
}

function TSTypeOperator2(node) {
    this.word(node.operator);
    this.space();
    this.print(node.typeAnnotation);
}

function TSIndexedAccessType2(node) {
    this.print(node.objectType, true);
    this.tokenChar(91);
    this.print(node.indexType);
    this.tokenChar(93);
}

function TSMappedType2(node) {
    const {
        nameType,
        optional,
        readonly,
        typeAnnotation: typeAnnotation2,
    } = node;
    
    this.tokenChar(123);
    const exit = this.enterDelimited();
    this.space();
    
    if (readonly) {
        tokenIfPlusMinus(this, readonly);
        this.word('readonly');
        this.space();
    }
    
    this.tokenChar(91);
    {
        this.word(node.key.name);
    }
    this.space();
    this.word('in');
    this.space();
    {
        this.print(node.constraint);
    }
    if (nameType) {
        this.space();
        this.word('as');
        this.space();
        this.print(nameType);
    }
    
    this.tokenChar(93);
    
    if (optional) {
        tokenIfPlusMinus(this, optional);
        this.tokenChar(63);
    }
    
    if (typeAnnotation2) {
        this.tokenChar(58);
        this.space();
        this.print(typeAnnotation2);
    }
    
    this.space();
    exit();
    this.tokenChar(125);
}

function tokenIfPlusMinus(self, tok) {
    if (tok !== true) {
        self.token(tok);
    }
}

function TSTemplateLiteralType2(node) {
    this._printTemplate(node, node.types);
}

function TSLiteralType2(node) {
    this.print(node.literal);
}

function TSClassImplements2(node) {
    this.print(node.expression);
    this.print(node.typeArguments);
}

function TSInterfaceDeclaration2(node) {
    const {
        declare,
        id,
        typeParameters,
        extends: extendz,
        body,
    } = node;
    
    if (declare) {
        this.word('declare');
        this.space();
    }
    
    this.word('interface');
    this.space();
    this.print(id);
    this.print(typeParameters);
    
    if (extendz?.length) {
        this.space();
        this.word('extends');
        this.space();
        this.printList(extendz);
    }
    
    this.space();
    this.print(body);
}

function TSInterfaceBody2(node) {
    printBraced(this, node, () => this.printJoin(node.body, true, true));
}

function TSTypeAliasDeclaration2(node) {
    const {
        declare,
        id,
        typeParameters,
        typeAnnotation: typeAnnotation2,
    } = node;
    
    if (declare) {
        this.word('declare');
        this.space();
    }
    
    this.word('type');
    this.space();
    this.print(id);
    this.print(typeParameters);
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(typeAnnotation2);
    this.semicolon();
}

function TSTypeExpression2(node) {
    const {
        type,
        expression: expression2,
        typeAnnotation: typeAnnotation2,
    } = node;
    
    this.print(expression2, true);
    this.space();
    this.word(type === 'TSAsExpression' ? 'as' : 'satisfies');
    this.space();
    this.print(typeAnnotation2);
}

function TSTypeAssertion2(node) {
    const {typeAnnotation: typeAnnotation2, expression: expression2} = node;
    
    this.tokenChar(60);
    this.print(typeAnnotation2);
    this.tokenChar(62);
    this.space();
    this.print(expression2);
}

function TSInstantiationExpression2(node) {
    this.print(node.expression);
    {
        this.print(node.typeArguments);
    }
}

function TSEnumDeclaration2(node) {
    const {
        declare,
        const: isConst,
        id,
    } = node;
    
    if (declare) {
        this.word('declare');
        this.space();
    }
    
    if (isConst) {
        this.word('const');
        this.space();
    }
    
    this.word('enum');
    this.space();
    this.print(id);
    this.space();
    {
        this.print(node.body);
    }
}

function TSEnumBody2(node) {
    printBraced(this, node, () => this.printList(node.members, this.shouldPrintTrailingComma('}') ?? false, true, true));
}

function TSEnumMember2(node) {
    const {id, initializer} = node;
    
    this.print(id);
    
    if (initializer) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(initializer);
    }
}

function TSModuleDeclaration2(node) {
    const {
        declare,
        id,
        kind,
    } = node;
    
    if (declare) {
        this.word('declare');
        this.space();
    }
    
    {
        if (kind !== 'global') {
            this.word(kind);
            this.space();
        }
        
        this.print(node.id);
        
        if (!node.body) {
            this.semicolon();
            return;
        }
        
        this.space();
        this.print(node.body);
    }
}

function TSModuleBlock2(node) {
    printBraced(this, node, () => this.printSequence(node.body, true));
}

function TSImportType2(node) {
    const {
        argument,
        qualifier,
        options,
    } = node;
    
    this.word('import');
    this.tokenChar(40);
    this.print(argument);
    
    if (options) {
        this.tokenChar(44);
        this.print(options);
    }
    
    this.tokenChar(41);
    
    if (qualifier) {
        this.tokenChar(46);
        this.print(qualifier);
    }
    
    const typeArguments = node.typeArguments;
    
    if (typeArguments) {
        this.print(typeArguments);
    }
}

function TSImportEqualsDeclaration2(node) {
    const {
        id,
        moduleReference,
    } = node;
    
    this.word('import');
    this.space();
    this.print(id);
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(moduleReference);
    this.semicolon();
}

function TSExternalModuleReference2(node) {
    this.token('require(');
    this.print(node.expression);
    this.tokenChar(41);
}

function TSNonNullExpression2(node) {
    this.print(node.expression);
    this.tokenChar(33);
}

function TSExportAssignment2(node) {
    this.word('export');
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node.expression);
    this.semicolon();
}

function TSNamespaceExportDeclaration2(node) {
    this.word('export');
    this.space();
    this.word('as');
    this.space();
    this.word('namespace');
    this.space();
    this.print(node.id);
    this.semicolon();
}

function tsPrintSignatureDeclarationBase(node) {
    const {typeParameters} = node;
    
    const parameters = node.params;
    this.print(typeParameters);
    this.tokenChar(40);
    this._parameters(parameters, ')');
    const returnType = node.returnType;
    this.print(returnType);
}

function tsPrintClassMemberModifiers(node) {
    const isPrivateField = node.type === 'ClassPrivateProperty';
    const isPublicField = node.type === 'ClassAccessorProperty' || node.type === 'ClassProperty';
    printModifiersList(this, node, [isPublicField && node.declare && 'declare', !isPrivateField && node.accessibility]);
    
    if (node.static) {
        this.word('static');
        this.space();
    }
    
    printModifiersList(this, node, [!isPrivateField && node.abstract && 'abstract', !isPrivateField && node.override && 'override', (isPublicField || isPrivateField) && node.readonly && 'readonly']);
}

function printBraced(printer, node, cb) {
    printer.token('{');
    const exit = printer.enterDelimited();
    cb();
    exit();
    printer.rightBrace(node);
}

function printModifiersList(printer, node, modifiers) {
    const modifiersSet =     /* @__PURE__ */new Set();
    
    for (const modifier of modifiers) {
        if (modifier)
            modifiersSet.add(modifier);
    }
    
    printer.tokenMap?.find(node, (tok) => {
        if (modifiersSet.has(tok.value)) {
            printer.token(tok.value);
            printer.space();
            modifiersSet.delete(tok.value);
            
            return modifiersSet.size === 0;
        }
    });
    
    for (const modifier of modifiersSet) {
        printer.word(modifier);
        printer.space();
    }
}

var generatorFunctions = /* @__PURE__ */Object.freeze({
    __proto__: null,
    AnyTypeAnnotation: AnyTypeAnnotation2,
    ArgumentPlaceholder: ArgumentPlaceholder2,
    ArrayExpression: ArrayExpression2,
    ArrayPattern: ArrayExpression2,
    ArrayTypeAnnotation: ArrayTypeAnnotation2,
    ArrowFunctionExpression: ArrowFunctionExpression2,
    AssignmentExpression: AssignmentExpression2,
    AssignmentPattern: AssignmentPattern2,
    AwaitExpression: AwaitExpression2,
    BigIntLiteral: BigIntLiteral2,
    BinaryExpression: AssignmentExpression2,
    BindExpression: BindExpression2,
    BlockStatement: BlockStatement2,
    BooleanLiteral: BooleanLiteral2,
    BooleanLiteralTypeAnnotation: BooleanLiteralTypeAnnotation2,
    BooleanTypeAnnotation: BooleanTypeAnnotation2,
    BreakStatement: BreakStatement2,
    CallExpression: CallExpression2,
    CatchClause: CatchClause2,
    ClassAccessorProperty: ClassAccessorProperty2,
    ClassBody: ClassBody2,
    ClassDeclaration: ClassDeclaration2,
    ClassExpression: ClassDeclaration2,
    ClassImplements: InterfaceExtends2,
    ClassMethod: ClassMethod2,
    ClassPrivateMethod: ClassPrivateMethod2,
    ClassPrivateProperty: ClassPrivateProperty2,
    ClassProperty: ClassProperty2,
    ConditionalExpression: ConditionalExpression2,
    ContinueStatement: ContinueStatement2,
    DebuggerStatement: DebuggerStatement2,
    DeclareClass: DeclareClass2,
    DeclareExportAllDeclaration: DeclareExportAllDeclaration2,
    DeclareExportDeclaration: DeclareExportDeclaration2,
    DeclareFunction: DeclareFunction2,
    DeclareInterface: DeclareInterface2,
    DeclareModule: DeclareModule2,
    DeclareModuleExports: DeclareModuleExports2,
    DeclareOpaqueType: DeclareOpaqueType2,
    DeclareTypeAlias: DeclareTypeAlias2,
    DeclareVariable: DeclareVariable2,
    DeclaredPredicate: DeclaredPredicate2,
    Decorator: Decorator2,
    Directive: Directive2,
    DirectiveLiteral: DirectiveLiteral2,
    DoExpression: DoExpression2,
    DoWhileStatement: DoWhileStatement2,
    EmptyStatement: EmptyStatement2,
    EmptyTypeAnnotation: EmptyTypeAnnotation2,
    EnumBooleanBody: EnumBooleanBody2,
    EnumBooleanMember: EnumBooleanMember2,
    EnumDeclaration: EnumDeclaration2,
    EnumDefaultedMember: EnumDefaultedMember2,
    EnumNumberBody: EnumNumberBody2,
    EnumNumberMember: EnumNumberMember2,
    EnumStringBody: EnumStringBody2,
    EnumStringMember: EnumStringMember2,
    EnumSymbolBody: EnumSymbolBody2,
    ExistsTypeAnnotation: ExistsTypeAnnotation2,
    ExportAllDeclaration: ExportAllDeclaration2,
    ExportDefaultDeclaration: ExportDefaultDeclaration2,
    ExportDefaultSpecifier: ExportDefaultSpecifier2,
    ExportNamedDeclaration: ExportNamedDeclaration2,
    ExportNamespaceSpecifier: ExportNamespaceSpecifier2,
    ExportSpecifier: ExportSpecifier2,
    ExpressionStatement: ExpressionStatement2,
    File: File2,
    ForInStatement: ForInStatement2,
    ForOfStatement: ForOfStatement2,
    ForStatement: ForStatement2,
    FunctionDeclaration: FunctionExpression2,
    FunctionExpression: FunctionExpression2,
    FunctionTypeAnnotation: FunctionTypeAnnotation2,
    FunctionTypeParam: FunctionTypeParam2,
    GenericTypeAnnotation: InterfaceExtends2,
    Identifier: Identifier2,
    IfStatement: IfStatement2,
    Import: Import2,
    ImportAttribute: ImportAttribute2,
    ImportDeclaration: ImportDeclaration2,
    ImportDefaultSpecifier: ImportDefaultSpecifier2,
    ImportExpression: ImportExpression2,
    ImportNamespaceSpecifier: ImportNamespaceSpecifier2,
    ImportSpecifier: ImportSpecifier2,
    IndexedAccessType: IndexedAccessType2,
    InferredPredicate: InferredPredicate2,
    InterfaceDeclaration: InterfaceDeclaration2,
    InterfaceExtends: InterfaceExtends2,
    InterfaceTypeAnnotation: InterfaceTypeAnnotation2,
    InterpreterDirective: InterpreterDirective2,
    IntersectionTypeAnnotation: IntersectionTypeAnnotation2,
    JSXAttribute: JSXAttribute2,
    JSXClosingElement: JSXClosingElement2,
    JSXClosingFragment: JSXClosingFragment2,
    JSXElement: JSXElement2,
    JSXEmptyExpression: JSXEmptyExpression2,
    JSXExpressionContainer: JSXExpressionContainer2,
    JSXFragment: JSXFragment2,
    JSXIdentifier: JSXIdentifier2,
    JSXMemberExpression: JSXMemberExpression2,
    JSXNamespacedName: JSXNamespacedName2,
    JSXOpeningElement: JSXOpeningElement2,
    JSXOpeningFragment: JSXOpeningFragment2,
    JSXSpreadAttribute: JSXSpreadAttribute2,
    JSXSpreadChild: JSXSpreadChild2,
    JSXText: JSXText2,
    LabeledStatement: LabeledStatement2,
    LogicalExpression: AssignmentExpression2,
    MemberExpression: MemberExpression2,
    MetaProperty: MetaProperty2,
    MixedTypeAnnotation: MixedTypeAnnotation2,
    ModuleExpression: ModuleExpression2,
    NewExpression: NewExpression2,
    NullLiteral: NullLiteral2,
    NullLiteralTypeAnnotation: NullLiteralTypeAnnotation2,
    NullableTypeAnnotation: NullableTypeAnnotation2,
    NumberLiteralTypeAnnotation: NumericLiteral2,
    NumberTypeAnnotation: NumberTypeAnnotation2,
    NumericLiteral: NumericLiteral2,
    ObjectExpression: ObjectExpression2,
    ObjectMethod: ObjectMethod2,
    ObjectPattern: ObjectExpression2,
    ObjectProperty: ObjectProperty2,
    ObjectTypeAnnotation: ObjectTypeAnnotation2,
    ObjectTypeCallProperty: ObjectTypeCallProperty2,
    ObjectTypeIndexer: ObjectTypeIndexer2,
    ObjectTypeInternalSlot: ObjectTypeInternalSlot2,
    ObjectTypeProperty: ObjectTypeProperty2,
    ObjectTypeSpreadProperty: ObjectTypeSpreadProperty2,
    OpaqueType: OpaqueType2,
    OptionalCallExpression: OptionalCallExpression2,
    OptionalIndexedAccessType: OptionalIndexedAccessType2,
    OptionalMemberExpression: OptionalMemberExpression2,
    ParenthesizedExpression: ParenthesizedExpression2,
    PipelineBareFunction: PipelineBareFunction2,
    PipelinePrimaryTopicReference: PipelinePrimaryTopicReference2,
    PipelineTopicExpression: PipelineTopicExpression2,
    Placeholder: Placeholder2,
    PrivateName: PrivateName2,
    Program: Program2,
    QualifiedTypeIdentifier: QualifiedTypeIdentifier2,
    RecordExpression: RecordExpression2,
    RegExpLiteral: RegExpLiteral2,
    RestElement: RestElement2,
    ReturnStatement: ReturnStatement2,
    SequenceExpression: SequenceExpression2,
    SpreadElement: RestElement2,
    StaticBlock: StaticBlock2,
    StringLiteral: StringLiteral2,
    StringLiteralTypeAnnotation: StringLiteral2,
    StringTypeAnnotation: StringTypeAnnotation2,
    Super: Super2,
    SwitchCase: SwitchCase2,
    SwitchStatement: SwitchStatement2,
    SymbolTypeAnnotation: SymbolTypeAnnotation2,
    TSAnyKeyword: TSAnyKeyword2,
    TSArrayType: TSArrayType2,
    TSAsExpression: TSTypeExpression2,
    TSBigIntKeyword: TSBigIntKeyword2,
    TSBooleanKeyword: TSBooleanKeyword2,
    TSCallSignatureDeclaration: TSCallSignatureDeclaration2,
    TSClassImplements: TSClassImplements2,
    TSConditionalType: TSConditionalType2,
    TSConstructSignatureDeclaration: TSConstructSignatureDeclaration2,
    TSConstructorType: TSConstructorType2,
    TSDeclareFunction: TSDeclareFunction2,
    TSDeclareMethod: TSDeclareMethod2,
    TSEnumBody: TSEnumBody2,
    TSEnumDeclaration: TSEnumDeclaration2,
    TSEnumMember: TSEnumMember2,
    TSExportAssignment: TSExportAssignment2,
    TSExternalModuleReference: TSExternalModuleReference2,
    TSFunctionType: TSFunctionType2,
    TSImportEqualsDeclaration: TSImportEqualsDeclaration2,
    TSImportType: TSImportType2,
    TSIndexSignature: TSIndexSignature2,
    TSIndexedAccessType: TSIndexedAccessType2,
    TSInferType: TSInferType2,
    TSInstantiationExpression: TSInstantiationExpression2,
    TSInterfaceBody: TSInterfaceBody2,
    TSInterfaceDeclaration: TSInterfaceDeclaration2,
    TSInterfaceHeritage: TSClassImplements2,
    TSIntersectionType: TSIntersectionType2,
    TSIntrinsicKeyword: TSIntrinsicKeyword2,
    TSLiteralType: TSLiteralType2,
    TSMappedType: TSMappedType2,
    TSMethodSignature: TSMethodSignature2,
    TSModuleBlock: TSModuleBlock2,
    TSModuleDeclaration: TSModuleDeclaration2,
    TSNamedTupleMember: TSNamedTupleMember2,
    TSNamespaceExportDeclaration: TSNamespaceExportDeclaration2,
    TSNeverKeyword: TSNeverKeyword2,
    TSNonNullExpression: TSNonNullExpression2,
    TSNullKeyword: TSNullKeyword2,
    TSNumberKeyword: TSNumberKeyword2,
    TSObjectKeyword: TSObjectKeyword2,
    TSOptionalType: TSOptionalType2,
    TSParameterProperty: TSParameterProperty2,
    TSParenthesizedType: TSParenthesizedType2,
    TSPropertySignature: TSPropertySignature2,
    TSQualifiedName: TSQualifiedName2,
    TSRestType: TSRestType2,
    TSSatisfiesExpression: TSTypeExpression2,
    TSStringKeyword: TSStringKeyword2,
    TSSymbolKeyword: TSSymbolKeyword2,
    TSTemplateLiteralType: TSTemplateLiteralType2,
    TSThisType: TSThisType2,
    TSTupleType: TSTupleType2,
    TSTypeAliasDeclaration: TSTypeAliasDeclaration2,
    TSTypeAnnotation: TSTypeAnnotation2,
    TSTypeAssertion: TSTypeAssertion2,
    TSTypeLiteral: TSTypeLiteral2,
    TSTypeOperator: TSTypeOperator2,
    TSTypeParameter: TSTypeParameter2,
    TSTypeParameterDeclaration: TSTypeParameterInstantiation2,
    TSTypeParameterInstantiation: TSTypeParameterInstantiation2,
    TSTypePredicate: TSTypePredicate2,
    TSTypeQuery: TSTypeQuery2,
    TSTypeReference: TSTypeReference2,
    TSUndefinedKeyword: TSUndefinedKeyword2,
    TSUnionType: TSUnionType2,
    TSUnknownKeyword: TSUnknownKeyword2,
    TSVoidKeyword: TSVoidKeyword2,
    TaggedTemplateExpression: TaggedTemplateExpression2,
    TemplateElement: TemplateElement2,
    TemplateLiteral: TemplateLiteral2,
    ThisExpression: ThisExpression2,
    ThisTypeAnnotation: ThisTypeAnnotation2,
    ThrowStatement: ThrowStatement2,
    TopicReference: TopicReference2,
    TryStatement: TryStatement2,
    TupleExpression: TupleExpression2,
    TupleTypeAnnotation: TupleTypeAnnotation2,
    TypeAlias: TypeAlias2,
    TypeAnnotation: TypeAnnotation2,
    TypeCastExpression: TypeCastExpression2,
    TypeParameter: TypeParameter2,
    TypeParameterDeclaration: TypeParameterInstantiation2,
    TypeParameterInstantiation: TypeParameterInstantiation2,
    TypeofTypeAnnotation: TypeofTypeAnnotation2,
    UnaryExpression: UnaryExpression2,
    UnionTypeAnnotation: UnionTypeAnnotation2,
    UpdateExpression: UpdateExpression2,
    V8IntrinsicIdentifier: V8IntrinsicIdentifier2,
    VariableDeclaration: VariableDeclaration2,
    VariableDeclarator: VariableDeclarator2,
    Variance: Variance2,
    VoidPattern: VoidPattern2,
    VoidTypeAnnotation: VoidTypeAnnotation2,
    WhileStatement: WhileStatement2,
    WithStatement: WithStatement2,
    YieldExpression: YieldExpression2,
    _classMethodHead,
    _functionHead,
    _getRawIdentifier,
    _interfaceish,
    _methodHead,
    _param,
    _parameters,
    _params,
    _predicate,
    _printAttributes,
    _printTemplate,
    _shouldPrintArrowParamsParens,
    _shouldPrintDecoratorsBeforeExport,
    _variance,
    tsPrintClassMemberModifiers,
    tsPrintFunctionOrConstructorType,
    tsPrintPropertyOrMethodName,
    tsPrintSignatureDeclarationBase,
});

var {
    isExpression: isExpression2,
    isFunction: isFunction3,
    isStatement: isStatement3,
    isClassBody: isClassBody2,
    isTSInterfaceBody: isTSInterfaceBody2,
    isTSEnumMember: isTSEnumMember2,
} = lib_exports;

var SCIENTIFIC_NOTATION = /e/i;
var ZERO_DECIMAL_INTEGER = /\.0+$/;
var HAS_NEWLINE = /[\n\r\u2028\u2029]/;
var HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\n\r\u2028\u2029]|\*\//;

function commentIsNewline(c) {
    return c.type === 'CommentLine' || HAS_NEWLINE.test(c.value);
}

var {needsParens} = n;

var Printer = class {
    constructor(format, map, tokens, originalCode) {
        __publicField(this, 'tokenContext', TokenContext.normal);
        __publicField(this, '_tokens', null);
        __publicField(this, '_originalCode', null);
        __publicField(this, '_currentNode', null);
        __publicField(this, '_indent', 0);
        __publicField(this, '_indentRepeat', 0);
        __publicField(this, '_insideAux', false);
        __publicField(this, '_noLineTerminator', false);
        __publicField(this, '_noLineTerminatorAfterNode', null);
        __publicField(this, '_printAuxAfterOnNextUserNode', false);
        __publicField(this, '_printedComments',         /* @__PURE__ */new Set());
        __publicField(this, '_endsWithInteger', false);
        __publicField(this, '_endsWithWord', false);
        __publicField(this, '_endsWithDiv', false);
        __publicField(this, '_lastCommentLine', 0);
        __publicField(this, '_endsWithInnerRaw', false);
        __publicField(this, '_indentInnerComments', true);
        __publicField(this, 'tokenMap', null);
        __publicField(this, '_boundGetRawIdentifier', this._getRawIdentifier.bind(this));
        __publicField(this, '_printSemicolonBeforeNextNode', -1);
        __publicField(this, '_printSemicolonBeforeNextToken', -1);
        this.format = format;
        this._tokens = tokens;
        this._originalCode = originalCode;
        this._indentRepeat = format.indent.style.length;
        this._inputMap = map?._inputMap;
        this._buf = new Buffer2(map, format.indent.style[0]);
    }
    
    enterForStatementInit() {
        this.tokenContext |= TokenContext.forInitHead | TokenContext.forInOrInitHeadAccumulate;
        return () => this.tokenContext = TokenContext.normal;
    }
    
    enterForXStatementInit(isForOf) {
        if (isForOf) {
            this.tokenContext |= TokenContext.forOfHead;
            return null;
        } else {
            this.tokenContext |= TokenContext.forInHead | TokenContext.forInOrInitHeadAccumulate;
            return () => this.tokenContext = TokenContext.normal;
        }
    }
    
    enterDelimited() {
        const oldTokenContext = this.tokenContext;
        const oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
        
        if (!(oldTokenContext & TokenContext.forInOrInitHeadAccumulate) && oldNoLineTerminatorAfterNode === null) {
            return () => {};
        }
        
        this._noLineTerminatorAfterNode = null;
        this.tokenContext = TokenContext.normal;
        return () => {
            this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
            this.tokenContext = oldTokenContext;
        };
    }
    
    generate(ast) {
        if (this.format.preserveFormat) {
            this.tokenMap = new TokenMap(ast, this._tokens, this._originalCode);
        }
        
        this.print(ast);
        this._maybeAddAuxComment();
        return this._buf.get();
    }
    
    indent() {
        const {format} = this;
        
        if (format.preserveFormat || format.compact || format.concise) {
            return;
        }
        
        this._indent++;
    }
    
    dedent() {
        const {format} = this;
        
        if (format.preserveFormat || format.compact || format.concise) {
            return;
        }
        
        this._indent--;
    }
    
    semicolon(force = false) {
        this._maybeAddAuxComment();
        
        if (force) {
            this._appendChar(59);
            this._noLineTerminator = false;
            return;
        }
        
        if (this.tokenMap) {
            const node = this._currentNode;
            
            if (node.start != null && node.end != null) {
                if (!this.tokenMap.endMatches(node, ';')) {
                    this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();
                    return;
                }
                
                const indexes = this.tokenMap.getIndexes(this._currentNode);
                this._catchUpTo(this._tokens[indexes[indexes.length - 1]].loc.start);
            }
        }
        
        this._queue(59);
        this._noLineTerminator = false;
    }
    
    rightBrace(node) {
        if (this.format.minified) {
            this._buf.removeLastSemicolon();
        }
        
        this.sourceWithOffset('end', node.loc, -1);
        this.tokenChar(125);
    }
    
    rightParens(node) {
        this.sourceWithOffset('end', node.loc, -1);
        this.tokenChar(41);
    }
    
    space(force = false) {
        const {format} = this;
        
        if (format.compact || format.preserveFormat)
            return;
        
        if (force) {
            this._space();
        } else if (this._buf.hasContent()) {
            const lastCp = this.getLastChar();
            
            if (lastCp !== 32 && lastCp !== 10) {
                this._space();
            }
        }
    }
    
    word(str, noLineTerminatorAfter = false) {
        this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;
        this._maybePrintInnerComments(str);
        this._maybeAddAuxComment();
        
        if (this.tokenMap)
            this._catchUpToCurrentToken(str);
        
        if (this._endsWithWord || this._endsWithDiv && str.charCodeAt(0) === 47) {
            this._space();
        }
        
        this._append(str, false);
        this._endsWithWord = true;
        this._noLineTerminator = noLineTerminatorAfter;
    }
    
    number(str, number) {
        function isNonDecimalLiteral(str2) {
            if (str2.length > 2 && str2.charCodeAt(0) === 48) {
                const secondChar = str2.charCodeAt(1);
                return secondChar === 98 || secondChar === 111 || secondChar === 120;
            }
            
            return false;
        }
        
        this.word(str);
        this._endsWithInteger = Number.isInteger(number) && !isNonDecimalLiteral(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;
    }
    
    token(str, maybeNewline = false, occurrenceCount = 0) {
        this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;
        this._maybePrintInnerComments(str, occurrenceCount);
        this._maybeAddAuxComment();
        
        if (this.tokenMap)
            this._catchUpToCurrentToken(str, occurrenceCount);
        
        const lastChar = this.getLastChar();
        const strFirst = str.charCodeAt(0);
        
        if (lastChar === 33 && (str === '--' || strFirst === 61) || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {
            this._space();
        }
        
        this._append(str, maybeNewline);
        this._noLineTerminator = false;
    }
    
    tokenChar(char) {
        this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;
        const str = String.fromCharCode(char);
        this._maybePrintInnerComments(str);
        this._maybeAddAuxComment();
        
        if (this.tokenMap)
            this._catchUpToCurrentToken(str);
        
        const lastChar = this.getLastChar();
        
        if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {
            this._space();
        }
        
        this._appendChar(char);
        this._noLineTerminator = false;
    }
    
    newline(i = 1, force) {
        if (i <= 0)
            return;
        
        if (!force) {
            if (this.format.retainLines || this.format.compact)
                return;
            
            if (this.format.concise) {
                this.space();
                return;
            }
        }
        
        if (i > 2)
            i = 2;
        
        i -= this._buf.getNewlineCount();
        for (let j = 0; j < i; j++) {
            this._newline();
        }
        
        return;
    }
    
    endsWith(char) {
        return this.getLastChar() === char;
    }
    
    getLastChar() {
        return this._buf.getLastChar();
    }
    
    endsWithCharAndNewline() {
        return this._buf.endsWithCharAndNewline();
    }
    
    removeTrailingNewline() {
        this._buf.removeTrailingNewline();
    }
    
    exactSource(loc, cb) {
        if (!loc) {
            cb();
            return;
        }
        
        this._catchUp('start', loc);
        this._buf.exactSource(loc, cb);
    }
    
    source(prop, loc) {
        if (!loc)
            return;
        
        this._catchUp(prop, loc);
        this._buf.source(prop, loc);
    }
    
    sourceWithOffset(prop, loc, columnOffset) {
        if (!loc || this.format.preserveFormat)
            return;
        
        this._catchUp(prop, loc);
        this._buf.sourceWithOffset(prop, loc, columnOffset);
    }
    
    sourceIdentifierName(identifierName, pos) {
        if (!this._buf._canMarkIdName)
            return;
        
        const sourcePosition = this._buf._sourcePosition;
        
        sourcePosition.identifierNamePos = pos;
        sourcePosition.identifierName = identifierName;
    }
    
    _space() {
        this._queue(32);
    }
    
    _newline() {
        this._queue(10);
    }
    
    _catchUpToCurrentToken(str, occurrenceCount = 0) {
        const token = this.tokenMap.findMatching(this._currentNode, str, occurrenceCount);
        
        if (token)
            this._catchUpTo(token.loc.start);
        
        if (this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine()) {
            this._buf.appendChar(59);
            this._endsWithWord = false;
            this._endsWithInteger = false;
            this._endsWithDiv = false;
        }
        
        this._printSemicolonBeforeNextToken = -1;
        this._printSemicolonBeforeNextNode = -1;
    }
    
    _append(str, maybeNewline) {
        this._maybeIndent(str.charCodeAt(0));
        this._buf.append(str, maybeNewline);
        this._endsWithWord = false;
        this._endsWithInteger = false;
        this._endsWithDiv = false;
    }
    
    _appendChar(char) {
        this._maybeIndent(char);
        this._buf.appendChar(char);
        this._endsWithWord = false;
        this._endsWithInteger = false;
        this._endsWithDiv = false;
    }
    
    _queue(char) {
        this._maybeIndent(char);
        this._buf.queue(char);
        this._endsWithWord = false;
        this._endsWithInteger = false;
    }
    
    _maybeIndent(firstChar) {
        if (this._indent && firstChar !== 10 && this.endsWith(10)) {
            this._buf.queueIndentation(this._getIndent());
        }
    }
    
    _shouldIndent(firstChar) {
        if (this._indent && firstChar !== 10 && this.endsWith(10)) {
            return true;
        }
    }
    
    catchUp(line) {
        if (!this.format.retainLines)
            return;
        
        const count = line - this._buf.getCurrentLine();
        
        for (let i = 0; i < count; i++) {
            this._newline();
        }
    }
    
    _catchUp(prop, loc) {
        const {format} = this;
        
        if (!format.preserveFormat) {
            if (format.retainLines && loc?.[prop]) {
                this.catchUp(loc[prop].line);
            }
            
            return;
        }
        
        const pos = loc?.[prop];
        
        if (pos != null)
            this._catchUpTo(pos);
    }
    
    _catchUpTo({line, column, index: index2}) {
        const count = line - this._buf.getCurrentLine();
        
        if (count > 0 && this._noLineTerminator) {
            return;
        }
        
        for (let i = 0; i < count; i++) {
            this._newline();
        }
        
        const spacesCount = count > 0 ? column : column - this._buf.getCurrentColumn();
        
        if (spacesCount > 0) {
            const spaces = this._originalCode ? this
                ._originalCode
                .slice(index2 - spacesCount, index2)
                .replace(/[^\t\v\f\uFEFF\p{Space_Separator}]/gu, ' ') : ' '.repeat(spacesCount);
            this._append(spaces, false);
        }
    }
    
    _getIndent() {
        return this._indentRepeat * this._indent;
    }
    
    printTerminatorless(node) {
        this._noLineTerminator = true;
        this.print(node);
    }
    
    print(node, noLineTerminatorAfter, trailingCommentsLineOffset) {
        if (!node)
            return;
        
        this._endsWithInnerRaw = false;
        const nodeType = node.type;
        const format = this.format;
        const oldConcise = format.concise;
        
        if (node._compact) {
            format.concise = true;
        }
        
        const printMethod = this[nodeType];
        
        if (printMethod === void 0) {
            throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node.constructor.name)}`);
        }
        
        const parent = this._currentNode;
        
        this._currentNode = node;
        
        if (this.tokenMap) {
            this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode;
        }
        
        const oldInAux = this._insideAux;
        
        this._insideAux = node.loc == null;
        this._maybeAddAuxComment(this._insideAux && !oldInAux);
        const parenthesized = node.extra?.parenthesized;
        let shouldPrintParens = parenthesized
            && format.preserveFormat
            || parenthesized
            && format.retainFunctionParens
            && nodeType === 'FunctionExpression'
            || needsParens(node, parent, this.tokenContext, format.preserveFormat ? this._boundGetRawIdentifier : void 0);
        
        if (!shouldPrintParens && parenthesized && node.leadingComments?.length && node.leadingComments[0].type === 'CommentBlock') {
            const parentType = parent?.type;
            
            switch(parentType) {
            case 'ExpressionStatement':            
            case 'VariableDeclarator':            
            case 'AssignmentExpression':            
            case 'ReturnStatement':
                break;
            
            case 'CallExpression':            
            case 'OptionalCallExpression':            
            case 'NewExpression':
                if (parent.callee !== node)
                    break;
            
            default:
                shouldPrintParens = true;
            }
        }
        
        let indentParenthesized = false;
        
        if (!shouldPrintParens && this._noLineTerminator && (node.leadingComments?.some(commentIsNewline) || this.format.retainLines && node.loc && node.loc.start.line > this._buf.getCurrentLine())) {
            shouldPrintParens = true;
            indentParenthesized = true;
        }
        
        let oldNoLineTerminatorAfterNode;
        let oldTokenContext;
        
        if (!shouldPrintParens) {
            noLineTerminatorAfter || (noLineTerminatorAfter = parent && this._noLineTerminatorAfterNode === parent && isLastChild(parent, node));
            
            if (noLineTerminatorAfter) {
                if (node.trailingComments?.some(commentIsNewline)) {
                    if (isExpression2(node))
                        shouldPrintParens = true;
                } else {
                    oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
                    this._noLineTerminatorAfterNode = node;
                }
            }
        }
        
        if (shouldPrintParens) {
            this.tokenChar(40);
            
            if (indentParenthesized)
                this.indent();
            
            this._endsWithInnerRaw = false;
            
            if (this.tokenContext & TokenContext.forInOrInitHeadAccumulate) {
                oldTokenContext = this.tokenContext;
                this.tokenContext = TokenContext.normal;
            }
            
            oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
            this._noLineTerminatorAfterNode = null;
        }
        
        this._lastCommentLine = 0;
        this._printLeadingComments(node, parent);
        const loc = nodeType === 'Program' || nodeType === 'File' ? null : node.loc;
        this.exactSource(loc, printMethod.bind(this, node, parent));
        
        if (shouldPrintParens) {
            this._printTrailingComments(node, parent);
            
            if (indentParenthesized) {
                this.dedent();
                this.newline();
            }
            
            this.tokenChar(41);
            this._noLineTerminator = noLineTerminatorAfter;
            
            if (oldTokenContext)
                this.tokenContext = oldTokenContext;
        } else if (noLineTerminatorAfter && !this._noLineTerminator) {
            this._noLineTerminator = true;
            this._printTrailingComments(node, parent);
        } else {
            this._printTrailingComments(node, parent, trailingCommentsLineOffset);
        }
        
        this._currentNode = parent;
        format.concise = oldConcise;
        this._insideAux = oldInAux;
        
        if (oldNoLineTerminatorAfterNode !== void 0) {
            this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
        }
        
        this._endsWithInnerRaw = false;
    }
    
    _maybeAddAuxComment(enteredPositionlessNode) {
        if (enteredPositionlessNode)
            this._printAuxBeforeComment();
        
        if (!this._insideAux)
            this._printAuxAfterComment();
    }
    
    _printAuxBeforeComment() {
        if (this._printAuxAfterOnNextUserNode)
            return;
        
        this._printAuxAfterOnNextUserNode = true;
        const comment = this.format.auxiliaryCommentBefore;
        
        if (comment) {
            this._printComment({
                type: 'CommentBlock',
                value: comment,
            }, 0);
        }
    }
    
    _printAuxAfterComment() {
        if (!this._printAuxAfterOnNextUserNode)
            return;
        
        this._printAuxAfterOnNextUserNode = false;
        const comment = this.format.auxiliaryCommentAfter;
        
        if (comment) {
            this._printComment({
                type: 'CommentBlock',
                value: comment,
            }, 0);
        }
    }
    
    getPossibleRaw(node) {
        const extra = node.extra;
        
        if (extra?.raw != null && extra.rawValue != null && node.value === extra.rawValue) {
            return extra.raw;
        }
    }
    
    printJoin(nodes2, statement2, indent, separator, printTrailingSeparator, addNewlines, iterator, trailingCommentsLineOffset) {
        if (!nodes2?.length)
            return;
        
        if (indent == null && this.format.retainLines) {
            const startLine = nodes2[0].loc?.start.line;
            
            if (startLine != null && startLine !== this._buf.getCurrentLine()) {
                indent = true;
            }
        }
        
        if (indent)
            this.indent();
        
        const newlineOpts = {
            addNewlines,
            nextNodeStartLine: 0,
        };
        
        const boundSeparator = separator?.bind(this);
        const len = nodes2.length;
        
        for (let i = 0; i < len; i++) {
            const node = nodes2[i];
            
            if (!node)
                continue;
            
            if (statement2)
                this._printNewline(i === 0, newlineOpts);
            
            this.print(node, void 0, trailingCommentsLineOffset || 0);
            iterator?.(node, i);
            
            if (boundSeparator != null) {
                if (i < len - 1)
                    boundSeparator(i, false);
                else if (printTrailingSeparator)
                    boundSeparator(i, true);
            }
            
            if (statement2) {
                if (!node.trailingComments?.length) {
                    this._lastCommentLine = 0;
                }
                
                if (i + 1 === len) {
                    this.newline(1);
                } else {
                    const nextNode = nodes2[i + 1];
                    
                    newlineOpts.nextNodeStartLine = nextNode.loc?.start.line || 0;
                    this._printNewline(true, newlineOpts);
                }
            }
        }
        
        if (indent)
            this.dedent();
    }
    
    printAndIndentOnComments(node) {
        const indent = node.leadingComments && node.leadingComments.length > 0;
        
        if (indent)
            this.indent();
        
        this.print(node);
        
        if (indent)
            this.dedent();
    }
    
    printBlock(parent) {
        const node = parent.body;
        
        if (node.type !== 'EmptyStatement') {
            this.space();
        }
        
        this.print(node);
    }
    
    _printTrailingComments(node, parent, lineOffset) {
        const {
            innerComments,
            trailingComments,
        } = node;
        
        if (innerComments?.length) {
            this._printComments(2, innerComments, node, parent, lineOffset);
        }
        
        if (trailingComments?.length) {
            this._printComments(2, trailingComments, node, parent, lineOffset);
        }
    }
    
    _printLeadingComments(node, parent) {
        const comments = node.leadingComments;
        
        if (!comments?.length)
            return;
        
        this._printComments(0, comments, node, parent);
    }
    
    _maybePrintInnerComments(nextTokenStr, nextTokenOccurrenceCount) {
        if (this._endsWithInnerRaw) {
            this.printInnerComments(this.tokenMap?.findMatching(
                this._currentNode,
                nextTokenStr,
                nextTokenOccurrenceCount,
            ));
        }
        
        this._endsWithInnerRaw = true;
        this._indentInnerComments = true;
    }
    
    printInnerComments(nextToken) {
        const node = this._currentNode;
        const comments = node.innerComments;
        
        if (!comments?.length)
            return;
        
        const hasSpace = this.endsWith(32);
        const indent = this._indentInnerComments;
        const printedCommentsCount = this._printedComments.size;
        
        if (indent)
            this.indent();
        
        this._printComments(1, comments, node, void 0, void 0, nextToken);
        
        if (hasSpace && printedCommentsCount !== this._printedComments.size) {
            this.space();
        }
        
        if (indent)
            this.dedent();
    }
    
    noIndentInnerCommentsHere() {
        this._indentInnerComments = false;
    }
    
    printSequence(nodes2, indent, trailingCommentsLineOffset, addNewlines) {
        this.printJoin(nodes2, true, indent ?? false, void 0, void 0, addNewlines, void 0, trailingCommentsLineOffset);
    }
    
    printList(items, printTrailingSeparator, statement2, indent, separator, iterator) {
        this.printJoin(items, statement2, indent, separator ?? commaSeparator, printTrailingSeparator, void 0, iterator);
    }
    
    shouldPrintTrailingComma(listEnd) {
        if (!this.tokenMap)
            return null;
        
        const listEndIndex = this.tokenMap.findLastIndex(this._currentNode, (token) => this.tokenMap.matchesOriginal(token, listEnd));
        
        if (listEndIndex <= 0)
            return null;
        
        return this.tokenMap.matchesOriginal(this._tokens[listEndIndex - 1], ',');
    }
    
    _printNewline(newLine, opts) {
        const format = this.format;
        
        if (format.retainLines || format.compact)
            return;
        
        if (format.concise) {
            this.space();
            return;
        }
        
        if (!newLine) {
            return;
        }
        
        const startLine = opts.nextNodeStartLine;
        const lastCommentLine = this._lastCommentLine;
        
        if (startLine > 0 && lastCommentLine > 0) {
            const offset = startLine - lastCommentLine;
            
            if (offset >= 0) {
                this.newline(offset || 1);
                return;
            }
        }
        
        if (this._buf.hasContent()) {
            this.newline(1);
        }
    }
    
    _shouldPrintComment(comment, nextToken) {
        if (comment.ignore)
            return 0;
        
        if (this._printedComments.has(comment))
            return 0;
        
        if (this._noLineTerminator && HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)) {
            return 2;
        }
        
        if (nextToken && this.tokenMap) {
            const commentTok = this.tokenMap.find(this._currentNode, (token) => token.value === comment.value);
            
            if (commentTok && commentTok.start > nextToken.start) {
                return 2;
            }
        }
        
        this._printedComments.add(comment);
        
        if (!this.format.shouldPrintComment(comment.value)) {
            return 0;
        }
        
        return 1;
    }
    
    _printComment(comment, skipNewLines) {
        const noLineTerminator = this._noLineTerminator;
        const isBlockComment = comment.type === 'CommentBlock';
        const printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;
        
        if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {
            this.newline(1);
        }
        
        const lastCharCode = this.getLastChar();
        
        if (lastCharCode !== 91 && lastCharCode !== 123 && lastCharCode !== 40) {
            this.space();
        }
        
        let val;
        
        if (isBlockComment) {
            val = `/*${comment.value}*/`;
            
            if (this.format.indent.adjustMultilineComment) {
                const offset = comment.loc?.start.column;
                
                if (offset) {
                    const newlineRegex = new RegExp('\\n\\s{1,' + offset + '}', 'g');
                    val = val.replace(newlineRegex, '\n');
                }
                
                if (this.format.concise) {
                    val = val.replace(/\n(?!$)/g, `
`);
                } else {
                    let indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
                    
                    if (this._shouldIndent(47) || this.format.retainLines) {
                        indentSize += this._getIndent();
                    }
                    
                    val = val.replace(/\n(?!$)/g, `
${' '.repeat(indentSize)}`);
                }
            }
        } else if (!noLineTerminator) {
            val = `//${comment.value}`;
        } else {
            val = `/*${comment.value}*/`;
        }
        
        if (this._endsWithDiv)
            this._space();
        
        if (this.tokenMap) {
            const {
                _printSemicolonBeforeNextToken,
                _printSemicolonBeforeNextNode,
            } = this;
            
            this._printSemicolonBeforeNextToken = -1;
            this._printSemicolonBeforeNextNode = -1;
            this.source('start', comment.loc);
            this._append(val, isBlockComment);
            this._printSemicolonBeforeNextNode = _printSemicolonBeforeNextNode;
            this._printSemicolonBeforeNextToken = _printSemicolonBeforeNextToken;
        } else {
            this.source('start', comment.loc);
            this._append(val, isBlockComment);
        }
        
        if (!isBlockComment && !noLineTerminator) {
            this.newline(1, true);
        }
        
        if (printNewLines && skipNewLines !== 3) {
            this.newline(1);
        }
    }
    
    _printComments(type, comments, node, parent, lineOffset = 0, nextToken) {
        const nodeLoc = node.loc;
        const len = comments.length;
        let hasLoc = !!nodeLoc;
        const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;
        const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;
        let lastLine = 0;
        let leadingCommentNewline = 0;
        
        const maybeNewline = this._noLineTerminator ? function() {} : this.newline.bind(this);
        
        for (let i = 0; i < len; i++) {
            const comment = comments[i];
            const shouldPrint = this._shouldPrintComment(comment, nextToken);
            
            if (shouldPrint === 2) {
                hasLoc = false;
                break;
            }
            
            if (hasLoc && comment.loc && shouldPrint === 1) {
                const commentStartLine = comment.loc.start.line;
                const commentEndLine = comment.loc.end.line;
                
                if (type === 0) {
                    let offset = 0;
                    
                    if (i === 0) {
                        if (this._buf.hasContent() && (comment.type === 'CommentLine' || commentStartLine !== commentEndLine)) {
                            offset =
                            leadingCommentNewline = 1;
                        }
                    } else {
                        offset = commentStartLine - lastLine;
                    }
                    
                    lastLine = commentEndLine;
                    maybeNewline(offset);
                    this._printComment(comment, 1);
                    
                    if (i + 1 === len) {
                        maybeNewline(Math.max(
                            nodeStartLine - lastLine,
                            leadingCommentNewline,
                        ));
                        lastLine = nodeStartLine;
                    }
                } else if (type === 1) {
                    const offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);
                    
                    lastLine = commentEndLine;
                    maybeNewline(offset);
                    this._printComment(comment, 1);
                    
                    if (i + 1 === len) {
                        maybeNewline(Math.min(1, nodeEndLine - lastLine));
                        lastLine = nodeEndLine;
                    }
                } else {
                    const offset = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);
                    
                    lastLine = commentEndLine;
                    maybeNewline(offset);
                    this._printComment(comment, 1);
                }
            } else {
                hasLoc = false;
                
                if (shouldPrint !== 1) {
                    continue;
                }
                
                if (len === 1) {
                    const singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value);
                    const shouldSkipNewline = singleLine
                        && !isStatement3(node)
                        && !isClassBody2(parent)
                        && !isTSInterfaceBody2(parent)
                        && !isTSEnumMember2(node);
                    
                    if (type === 0) {
                        this._printComment(comment, shouldSkipNewline && node.type !== 'ObjectExpression' || singleLine && isFunction3(parent, {
                            body: node,
                        }) ? 1 : 0);
                    } else if (shouldSkipNewline && type === 2) {
                        this._printComment(comment, 1);
                    } else {
                        this._printComment(comment, 0);
                    }
                } else if (type === 1 && !(node.type === 'ObjectExpression' && node.properties.length > 1) && node.type !== 'ClassBody' && node.type !== 'TSInterfaceBody') {
                    this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0);
                } else {
                    this._printComment(comment, 0);
                }
            }
        }
        
        if (type === 2 && hasLoc && lastLine) {
            this._lastCommentLine = lastLine;
        }
    }
};

Object.assign(Printer.prototype, generatorFunctions);
function commaSeparator(occurrenceCount, last2) {
    this.token(',', false, occurrenceCount);
    
    if (!last2)
        this.space();
}

function normalizeOptions(code2, opts, ast) {
    if (opts.experimental_preserveFormat) {
        if (typeof code2 !== 'string') {
            throw new Error('`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string');
        }
        
        if (!opts.retainLines) {
            throw new Error('`experimental_preserveFormat` requires `retainLines` to be set to `true`');
        }
        
        if (opts.compact && opts.compact !== 'auto') {
            throw new Error('`experimental_preserveFormat` is not compatible with the `compact` option');
        }
        
        if (opts.minified) {
            throw new Error('`experimental_preserveFormat` is not compatible with the `minified` option');
        }
        
        if (opts.jsescOption) {
            throw new Error('`experimental_preserveFormat` is not compatible with the `jsescOption` option');
        }
        
        if (!Array.isArray(ast.tokens)) {
            throw new Error('`experimental_preserveFormat` requires the AST to have attached the token of the input code. Make sure to enable the `tokens: true` parser option.');
        }
    }
    
    const format = {
        auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
        auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
        shouldPrintComment: opts.shouldPrintComment,
        preserveFormat: opts.experimental_preserveFormat,
        retainLines: opts.retainLines,
        retainFunctionParens: opts.retainFunctionParens,
        comments: opts.comments == null || opts.comments,
        compact: opts.compact,
        minified: opts.minified,
        concise: opts.concise,
        indent: {
            adjustMultilineComment: true,
            style: '  ',
        },
        jsescOption: Object.assign({
            quotes: 'double',
            wrap: true,
            minimal: true,
        }, opts.jsescOption),
        topicToken: opts.topicToken,
        importAttributesKeyword: opts.importAttributesKeyword,
    };
    
    if (format.minified) {
        format.compact = true;
        format.shouldPrintComment = format.shouldPrintComment || (() => format.comments);
    } else {
        format.shouldPrintComment = format.shouldPrintComment || ((value) => format.comments || value.includes('@license') || value.includes('@preserve'));
    }
    
    if (format.compact === 'auto') {
        format.compact = typeof code2 === 'string' && code2.length > 5e5;
        
        if (format.compact) {
            console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${opts.filename} as it exceeds the max of ${'500KB'}.`);
        }
    }
    
    if (format.compact || format.preserveFormat) {
        format.indent.adjustMultilineComment = false;
    }
    
    const {
        auxiliaryCommentBefore,
        auxiliaryCommentAfter,
        shouldPrintComment,
    } = format;
    
    if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {
        format.auxiliaryCommentBefore = void 0;
    }
    
    if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {
        format.auxiliaryCommentAfter = void 0;
    }
    
    return format;
}

function generate$6(ast, opts = {}, code2) {
    const format = normalizeOptions(code2, opts, ast);
    const map = opts.sourceMaps ? new SourceMap(opts, code2) : null;
    const printer = new Printer(format, map, ast.tokens, typeof code2 === 'string' ? code2 : null);
    
    return printer.generate(ast);
}

// node_modules/@babel/traverse/lib/index.js
var import_debug = __toESM(require_src());

// node_modules/@babel/helper-globals/data/builtin-lower.json
var builtin_lower_default = [
    'decodeURI',
    'decodeURIComponent',
    'encodeURI',
    'encodeURIComponent',
    'escape',
    'eval',
    'globalThis',
    'isFinite',
    'isNaN',
    'parseFloat',
    'parseInt',
    'undefined',
    'unescape',
];

// node_modules/@babel/helper-globals/data/builtin-upper.json
var builtin_upper_default = [
    'AggregateError',
    'Array',
    'ArrayBuffer',
    'Atomics',
    'BigInt',
    'BigInt64Array',
    'BigUint64Array',
    'Boolean',
    'DataView',
    'Date',
    'Error',
    'EvalError',
    'FinalizationRegistry',
    'Float16Array',
    'Float32Array',
    'Float64Array',
    'Function',
    'Infinity',
    'Int16Array',
    'Int32Array',
    'Int8Array',
    'Intl',
    'Iterator',
    'JSON',
    'Map',
    'Math',
    'NaN',
    'Number',
    'Object',
    'Promise',
    'Proxy',
    'RangeError',
    'ReferenceError',
    'Reflect',
    'RegExp',
    'Set',
    'SharedArrayBuffer',
    'String',
    'Symbol',
    'SyntaxError',
    'TypeError',
    'Uint16Array',
    'Uint32Array',
    'Uint8Array',
    'Uint8ClampedArray',
    'URIError',
    'WeakMap',
    'WeakRef',
    'WeakSet',
];

// node_modules/@babel/traverse/lib/index.js
var ReferencedIdentifier = [
    'Identifier',
    'JSXIdentifier',
];
var ReferencedMemberExpression = [
    'MemberExpression',
];
var BindingIdentifier = ['Identifier'];
var Statement = ['Statement'];
var Expression = ['Expression'];
var Scope$1 = [
    'Scopable',
    'Pattern',
];
var Referenced = null;
var BlockScoped = null;
var Var = [
    'VariableDeclaration',
];
var User = null;
var Generated = null;
var Pure = null;
var Flow = [
    'Flow',
    'ImportDeclaration',
    'ExportDeclaration',
    'ImportSpecifier',
];
var RestProperty2 = [
    'RestElement',
];
var SpreadProperty2 = [
    'RestElement',
];
var ExistentialTypeParam = [
    'ExistsTypeAnnotation',
];
var NumericLiteralTypeAnnotation = [
    'NumberLiteralTypeAnnotation',
];
var ForAwaitStatement = [
    'ForOfStatement',
];

var virtualTypes = /* @__PURE__ */Object.freeze({
    __proto__: null,
    BindingIdentifier,
    BlockScoped,
    ExistentialTypeParam,
    Expression,
    Flow,
    ForAwaitStatement,
    Generated,
    NumericLiteralTypeAnnotation,
    Pure,
    Referenced,
    ReferencedIdentifier,
    ReferencedMemberExpression,
    RestProperty: RestProperty2,
    Scope: Scope$1,
    SpreadProperty: SpreadProperty2,
    Statement,
    User,
    Var,
});

var {
    isBinding: isBinding2,
    isBlockScoped: nodeIsBlockScoped,
    isExportDeclaration: isExportDeclaration$1$1,
    isExpression: nodeIsExpression,
    isFlow: nodeIsFlow,
    isForStatement: isForStatement3,
    isForXStatement: isForXStatement2,
    isIdentifier: isIdentifier$6$1,
    isImportDeclaration: isImportDeclaration$1$1,
    isImportSpecifier: isImportSpecifier2,
    isJSXIdentifier: isJSXIdentifier3,
    isJSXMemberExpression: isJSXMemberExpression2,
    isMemberExpression: isMemberExpression$12,
    isRestElement: nodeIsRestElement,
    isReferenced: nodeIsReferenced,
    isScope: nodeIsScope,
    isStatement: nodeIsStatement,
    isVar: nodeIsVar,
    isVariableDeclaration: isVariableDeclaration$2$1,
    react: react2,
    isForOfStatement: isForOfStatement3,
} = lib_exports;

var {isCompatTag: isCompatTag2} = react2;

function isReferencedIdentifier(opts) {
    const {node, parent} = this;
    
    if (!isIdentifier$6$1(node, opts) && !isJSXMemberExpression2(parent, opts)) {
        if (isJSXIdentifier3(node, opts)) {
            if (isCompatTag2(node.name))
                return false;
        } else {
            return false;
        }
    }
    
    return nodeIsReferenced(node, parent, this.parentPath.parent);
}

function isReferencedMemberExpression() {
    const {node, parent} = this;
    
    return isMemberExpression$12(node) && nodeIsReferenced(node, parent);
}

function isBindingIdentifier() {
    const {node, parent} = this;
    
    const grandparent = this.parentPath.parent;
    
    return isIdentifier$6$1(node) && isBinding2(node, parent, grandparent);
}

function isStatement$13() {
    const {node, parent} = this;
    
    if (nodeIsStatement(node)) {
        if (isVariableDeclaration$2$1(node)) {
            if (isForXStatement2(parent, {left: node}))
                return false;
            
            if (isForStatement3(parent, {init: node}))
                return false;
        }
        
        return true;
    } else {
        return false;
    }
}

function isExpression$3() {
    if (this.isIdentifier()) {
        return this.isReferencedIdentifier();
    } else {
        return nodeIsExpression(this.node);
    }
}

function isScope2() {
    return nodeIsScope(this.node, this.parent);
}

function isReferenced2() {
    return nodeIsReferenced(this.node, this.parent);
}

function isBlockScoped2() {
    return nodeIsBlockScoped(this.node);
}

function isVar2() {
    return nodeIsVar(this.node);
}

function isUser() {
    return this.node && !!this.node.loc;
}

function isGenerated() {
    return !this.isUser();
}

function isPure(constantsOnly) {
    return this.scope.isPure(this.node, constantsOnly);
}

function isFlow2() {
    const {node} = this;
    
    if (nodeIsFlow(node)) {
        return true;
    } else if (isImportDeclaration$1$1(node)) {
        return node.importKind === 'type' || node.importKind === 'typeof';
    } else if (isExportDeclaration$1$1(node)) {
        return node.exportKind === 'type';
    } else if (isImportSpecifier2(node)) {
        return node.importKind === 'type' || node.importKind === 'typeof';
    } else {
        return false;
    }


}

function isRestProperty2() {
    return nodeIsRestElement(this.node) && this.parentPath?.isObjectPattern();
}

function isSpreadProperty2() {
    return nodeIsRestElement(this.node) && this.parentPath?.isObjectExpression();
}

function isForAwaitStatement() {
    return isForOfStatement3(this.node, {
        await: true,
    });
}

var NodePath_virtual_types_validator = /* @__PURE__ */Object.freeze({
    __proto__: null,
    isBindingIdentifier,
    isBlockScoped: isBlockScoped2,
    isExpression: isExpression$3,
    isFlow: isFlow2,
    isForAwaitStatement,
    isGenerated,
    isPure,
    isReferenced: isReferenced2,
    isReferencedIdentifier,
    isReferencedMemberExpression,
    isRestProperty: isRestProperty2,
    isScope: isScope2,
    isSpreadProperty: isSpreadProperty2,
    isStatement: isStatement$13,
    isUser,
    isVar: isVar2,
});

var {
    DEPRECATED_KEYS: DEPRECATED_KEYS2,
    DEPRECATED_ALIASES: DEPRECATED_ALIASES2,
    FLIPPED_ALIAS_KEYS: FLIPPED_ALIAS_KEYS3,
    TYPES: TYPES2,
    __internal__deprecationWarning: deprecationWarning2,
} = lib_exports;

function isVirtualType(type) {
    return type in virtualTypes;
}

function isExplodedVisitor(visitor) {
    return visitor?._exploded;
}

function explode$1(visitor) {
    if (isExplodedVisitor(visitor))
        return visitor;
    
    visitor._exploded = true;
    for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType))
            continue;
        
        const parts = nodeType.split('|');
        
        if (parts.length === 1)
            continue;
        
        const fns = visitor[nodeType];
        delete visitor[nodeType];
        for (const part of parts) {
            visitor[part] = fns;
        }
    }
    
    verify$1(visitor);
    delete visitor.__esModule;
    ensureEntranceObjects(visitor);
    ensureCallbackArrays(visitor);
    
    for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType))
            continue;
        
        if (!isVirtualType(nodeType))
            continue;
        
        const fns = visitor[nodeType];
        
        for (const type of Object.keys(fns)) {
            fns[type] = wrapCheck(nodeType, fns[type]);
        }
        
        delete visitor[nodeType];
        const types2 = virtualTypes[nodeType];
        
        if (types2 !== null) {
            for (const type of types2) {
                if (visitor[type]) {
                    mergePair(visitor[type], fns);
                } else {
                    visitor[type] = fns;
                }
            }
        } else {
            mergePair(visitor, fns);
        }
    }
    
    for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType))
            continue;
        
        let aliases = FLIPPED_ALIAS_KEYS3[nodeType];
        
        if (nodeType in DEPRECATED_KEYS2) {
            const deprecatedKey = DEPRECATED_KEYS2[nodeType];
            deprecationWarning2(nodeType, deprecatedKey, 'Visitor ');
            aliases = [deprecatedKey];
        } else if (nodeType in DEPRECATED_ALIASES2) {
            const deprecatedAlias = DEPRECATED_ALIASES2[nodeType];
            deprecationWarning2(nodeType, deprecatedAlias, 'Visitor ');
            aliases = FLIPPED_ALIAS_KEYS3[deprecatedAlias];
        }
        
        if (!aliases)
            continue;
        
        const fns = visitor[nodeType];
        delete visitor[nodeType];
        for (const alias2 of aliases) {
            const existing = visitor[alias2];
            
            if (existing) {
                mergePair(existing, fns);
            } else {
                visitor[alias2] = Object.assign({}, fns);
            }
        }
    }
    
    for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType))
            continue;
        
        ensureCallbackArrays(visitor[nodeType]);
    }
    
    return visitor;
}

function verify$1(visitor) {
    if (visitor._verified)
        return;
    
    if (typeof visitor === 'function') {
        throw new Error('You passed `traverse()` a function when it expected a visitor object, are you sure you didn\'t mean `{ enter: Function }`?');
    }
    
    for (const nodeType of Object.keys(visitor)) {
        if (nodeType === 'enter' || nodeType === 'exit') {
            validateVisitorMethods(nodeType, visitor[nodeType]);
        }
        
        if (shouldIgnoreKey(nodeType))
            continue;
        
        if (!TYPES2.includes(nodeType)) {
            throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type in @babel/traverse ${'8.0.0-beta.2'}`);
        }
        
        const visitors2 = visitor[nodeType];
        
        if (typeof visitors2 === 'object') {
            for (const visitorKey of Object.keys(visitors2)) {
                if (visitorKey === 'enter' || visitorKey === 'exit') {
                    validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors2[visitorKey]);
                } else {
                    throw new Error(`You passed \`traverse()\` a visitor object with the property ${nodeType} that has the invalid property ${visitorKey}`);
                }
            }
        }
    }
    
    visitor._verified = true;
}

function validateVisitorMethods(path, val) {
    const fns = [].concat(val);
    
    for (const fn of fns) {
        if (typeof fn !== 'function') {
            throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);
        }
    }
}

function merge2(visitors2, states = [], wrapper) {
    const mergedVisitor = {
        _verified: true,
        _exploded: true,
    };
    
    for (let i = 0; i < visitors2.length; i++) {
        const visitor = explode$1(visitors2[i]);
        const state = states[i];
        let topVisitor = visitor;
        
        if (state || wrapper) {
            topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper);
        }
        
        mergePair(mergedVisitor, topVisitor);
        for (const key of Object.keys(visitor)) {
            if (shouldIgnoreKey(key))
                continue;
            
            let typeVisitor = visitor[key];
            
            if (state || wrapper) {
                typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper);
            }
            
            const nodeVisitor = mergedVisitor[key] || (mergedVisitor[key] = {});
            mergePair(nodeVisitor, typeVisitor);
        }
    }
    
    return mergedVisitor;
}

function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
    const newVisitor = {};
    
    for (const phase of ['enter', 'exit']) {
        let fns = oldVisitor[phase];
        
        if (!Array.isArray(fns))
            continue;
        
        fns = fns.map(function(fn) {
            let newFn = fn;
            
            if (state) {
                newFn = function(path) {
                    fn.call(state, path, state);
                };
            }
            
            if (wrapper) {
                newFn = wrapper(state?.key, phase, newFn);
            }
            
            if (newFn !== fn) {
                newFn.toString = () => fn.toString();
            }
            
            return newFn;
        });
        newVisitor[phase] = fns;
    }
    
    return newVisitor;
}

function ensureEntranceObjects(obj) {
    for (const key of Object.keys(obj)) {
        if (shouldIgnoreKey(key))
            continue;
        
        const fns = obj[key];
        
        if (typeof fns === 'function') {
            obj[key] = {
                enter: fns,
            };
        }
    }
}

function ensureCallbackArrays(obj) {
    if (obj.enter && !Array.isArray(obj.enter))
        obj.enter = [obj.enter];
    
    if (obj.exit && !Array.isArray(obj.exit))
        obj.exit = [obj.exit];
}

function wrapCheck(nodeType, fn) {
    const fnKey = `is${nodeType}`;
    const validator = NodePath_virtual_types_validator[fnKey];
    const newFn = function(path) {
        if (validator.call(path)) {
            return fn.apply(this, arguments);
        }
    };
    
    newFn.toString = () => fn.toString();
    return newFn;
}

function shouldIgnoreKey(key) {
    if (key[0] === '_')
        return true;
    
    if (key === 'enter' || key === 'exit' || key === 'shouldSkip')
        return true;
    
    if (key === 'denylist' || key === 'noScope' || key === 'skipKeys') {
        return true;
    }
    
    return false;
}

function mergePair(dest, src) {
    for (const phase of ['enter', 'exit']) {
        if (!src[phase])
            continue;
        
        dest[phase] = [].concat(dest[phase] || [], src[phase]);
    }
}

var _environmentVisitor = {
    FunctionParent(path) {
        if (path.isArrowFunctionExpression())
            return;
        
        path.skip();
        
        if (path.isMethod()) {
            {
                path.requeueComputedKeyAndDecorators();
            }
        }
    },
    Property(path) {
        if (path.isObjectProperty())
            return;
        
        path.skip();
        {
            path.requeueComputedKeyAndDecorators();
        }
    },
};

function environmentVisitor(visitor) {
    return merge2([_environmentVisitor, visitor]);
}

var visitors$2 = /* @__PURE__ */Object.freeze({
    __proto__: null,
    environmentVisitor,
    explode: explode$1,
    isExplodedVisitor,
    merge: merge2,
    verify: verify$1,
});

var {getAssignmentIdentifiers: getAssignmentIdentifiers$1} = lib_exports;

var renameVisitor = {
    ReferencedIdentifier({node}, state) {
        if (node.name === state.oldName) {
            node.name = state.newName;
        }
    },
    Scope(path, state) {
        if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
            path.skip();
            
            if (path.isMethod()) {
                {
                    path.requeueComputedKeyAndDecorators();
                }
            }
        }
    },
    ObjectProperty({node, scope: scope2}, state) {
        const {name} = node.key;
        
        if (node.shorthand && (name === state.oldName || name === state.newName) && scope2.getBindingIdentifier(name) === state.binding.identifier) {
            node.shorthand = false;
        }
    },
    'AssignmentExpression|Declaration|VariableDeclarator'(path, state) {
        if (path.isVariableDeclaration())
            return;
        
        const ids = path.isAssignmentExpression() ? getAssignmentIdentifiers$1(path.node) : path.getOuterBindingIdentifiers();
        
        for (const name in ids) {
            if (name === state.oldName)
                ids[name].name = state.newName;
        }
    },
};

var Renamer = class {
    constructor(binding, oldName, newName) {
        this.newName = newName;
        this.oldName = oldName;
        this.binding = binding;
    }
    
    maybeConvertFromExportDeclaration(parentDeclar) {
        const maybeExportDeclar = parentDeclar.parentPath;
        
        if (!maybeExportDeclar.isExportDeclaration()) {
            return;
        }
        
        if (maybeExportDeclar.isExportDefaultDeclaration()) {
            const {declaration} = maybeExportDeclar.node;
            
            if (isDeclaration(declaration) && !declaration.id) {
                return;
            }
        }
        
        if (maybeExportDeclar.isExportAllDeclaration()) {
            return;
        }
        
        maybeExportDeclar.splitExportDeclaration();
    }
    
    maybeConvertFromClassFunctionDeclaration(path) {
        return path;
    }
    
    maybeConvertFromClassFunctionExpression(path) {
        return path;
    }
    
    rename() {
        const {
            binding,
            oldName,
            newName,
        } = this;
        
        const {scope: scope2, path} = binding;
        
        const parentDeclar = path.find((path2) => path2.isDeclaration() || path2.isFunctionExpression() || path2.isClassExpression());
        
        if (parentDeclar) {
            const bindingIds = parentDeclar.getOuterBindingIdentifiers();
            
            if (bindingIds[oldName] === binding.identifier) {
                this.maybeConvertFromExportDeclaration(parentDeclar);
            }
        }
        
        const blockToTraverse = scope2.block;
        
        const skipKeys = {
            discriminant: true,
        };
        
        if (isMethod(blockToTraverse)) {
            if (blockToTraverse.computed) {
                skipKeys.key = true;
            }
            
            if (!isObjectMethod$1(blockToTraverse)) {
                skipKeys.decorators = true;
            }
        }
        
        traverseNode(blockToTraverse, explode$1(renameVisitor), scope2, this, scope2.path, skipKeys);
        {
            scope2.removeOwnBinding(oldName);
            scope2.bindings[newName] = binding;
            this.binding.identifier.name = newName;
        }
        if (parentDeclar) {
            this.maybeConvertFromClassFunctionDeclaration(path);
            this.maybeConvertFromClassFunctionExpression(path);
        }
    }
};

var Binding = class {
    constructor({identifier: identifier4, scope: scope2, path, kind}) {
        __publicField(this, 'identifier');
        __publicField(this, 'scope');
        __publicField(this, 'path');
        __publicField(this, 'kind');
        __publicField(this, 'constantViolations', []);
        __publicField(this, 'constant', true);
        __publicField(this, 'referencePaths', []);
        __publicField(this, 'referenced', false);
        __publicField(this, 'references', 0);
        this.identifier = identifier4;
        this.scope = scope2;
        this.path = path;
        this.kind = kind;
        
        if ((kind === 'var' || kind === 'hoisted') && isInitInLoop(path)) {
            this.reassign(path);
        }
        
        this.clearValue();
    }
    
    deoptValue() {
        this.clearValue();
        this.hasDeoptedValue = true;
    }
    
    setValue(value) {
        if (this.hasDeoptedValue)
            return;
        
        this.hasValue = true;
        this.value = value;
    }
    
    clearValue() {
        this.hasDeoptedValue = false;
        this.hasValue = false;
        this.value = null;
    }
    
    reassign(path) {
        this.constant = false;
        
        if (this.constantViolations.includes(path)) {
            return;
        }
        
        this.constantViolations.push(path);
    }
    
    reference(path) {
        if (this.referencePaths.includes(path)) {
            return;
        }
        
        this.referenced = true;
        this.references++;
        this.referencePaths.push(path);
    }
    
    dereference() {
        this.references--;
        this.referenced = !!this.references;
    }
};

function isInitInLoop(path) {
    const isFunctionDeclarationOrHasInit = !path.isVariableDeclarator() || path.node.init;
    
    for (let {parentPath, key} = path; parentPath; ({
        parentPath,
        key,
    } = parentPath)) {
        if (parentPath.isFunctionParent())
            return false;
        
        if (key === 'left' && parentPath.isForXStatement() || isFunctionDeclarationOrHasInit && key === 'body' && parentPath.isLoop()) {
            return true;
        }
    }
    
    return false;
}

var pathsCache = /* @__PURE__ */new WeakMap();
var scope = /* @__PURE__ */new WeakMap();

function clear() {
    clearPath();
    clearScope();
}

function clearPath() {
    pathsCache =     /* @__PURE__ */new WeakMap();
}

function clearScope() {
    scope =     /* @__PURE__ */new WeakMap();
}

function getCachedPaths(path) {
    const {parent, parentPath} = path;
    
    return parentPath ? parentPath._store : pathsCache.get(parent);
}

function getOrCreateCachedPaths(node, parentPath) {
    if (parentPath) {
        return parentPath._store || (parentPath._store =         /* @__PURE__ */new Map());
    }
    
    let paths = pathsCache.get(node);
    
    if (!paths)
        pathsCache.set(node, paths =         /* @__PURE__ */new Map());
    
    return paths;
}

var cache = /* @__PURE__ */Object.freeze({
    __proto__: null,
    clear,
    clearPath,
    clearScope,
    getCachedPaths,
    getOrCreateCachedPaths,
    get path() {
        return pathsCache;
    },
    get scope() {
        return scope;
    },
});

var {
    assignmentExpression: assignmentExpression$3,
    callExpression: callExpression$3,
    cloneNode: cloneNode$3,
    getBindingIdentifiers: getBindingIdentifiers$3,
    identifier: identifier$3$1,
    isArrayExpression: isArrayExpression3,
    isBinary: isBinary3,
    isCallExpression: isCallExpression$12,
    isClass: isClass2,
    isClassBody: isClassBody3,
    isClassDeclaration: isClassDeclaration3,
    isExportAllDeclaration: isExportAllDeclaration2,
    isExportDefaultDeclaration: isExportDefaultDeclaration3,
    isExportNamedDeclaration: isExportNamedDeclaration$1$1,
    isFunctionDeclaration: isFunctionDeclaration2,
    isIdentifier: isIdentifier$5$1,
    isImportDeclaration: isImportDeclaration2,
    isLiteral: isLiteral$12,
    isMemberExpression: isMemberExpression3,
    isMethod: isMethod2,
    isModuleSpecifier: isModuleSpecifier2,
    isNullLiteral: isNullLiteral2,
    isObjectExpression: isObjectExpression3,
    isProperty: isProperty2,
    isPureish: isPureish2,
    isRegExpLiteral: isRegExpLiteral2,
    isSuper: isSuper$1,
    isTaggedTemplateExpression: isTaggedTemplateExpression2,
    isTemplateLiteral: isTemplateLiteral2,
    isThisExpression: isThisExpression2,
    isUnaryExpression: isUnaryExpression2,
    isVariableDeclaration: isVariableDeclaration$1$1,
    expressionStatement: expressionStatement$3$1,
    matchesPattern: matchesPattern$1$1,
    memberExpression: memberExpression$1,
    numericLiteral: numericLiteral$2,
    toIdentifier: toIdentifier2,
    variableDeclaration: variableDeclaration$1$1,
    variableDeclarator: variableDeclarator$1,
    isRecordExpression: isRecordExpression2,
    isTupleExpression: isTupleExpression2,
    isObjectProperty: isObjectProperty2,
    isTopicReference: isTopicReference2,
    isMetaProperty: isMetaProperty2,
    isPrivateName: isPrivateName2,
    isExportDeclaration: isExportDeclaration2,
    buildUndefinedNode: buildUndefinedNode$1,
    sequenceExpression: sequenceExpression$2,
} = lib_exports;

function gatherNodeParts(node, parts) {
    switch(node?.type) {
    default:
        if (isImportDeclaration2(node) || isExportDeclaration2(node)) {
            if ((isExportAllDeclaration2(node) || isExportNamedDeclaration$1$1(node) || isImportDeclaration2(node)) && node.source) {
                gatherNodeParts(node.source, parts);
            } else if ((isExportNamedDeclaration$1$1(node) || isImportDeclaration2(node)) && node.specifiers?.length) {
                for (const e of node.specifiers)
                    gatherNodeParts(e, parts);
            } else if ((isExportDefaultDeclaration3(node) || isExportNamedDeclaration$1$1(node)) && node.declaration) {
                gatherNodeParts(node.declaration, parts);
            }

        } else if (isModuleSpecifier2(node)) {
            gatherNodeParts(node.local, parts);
        } else if (isLiteral$12(node) && !isNullLiteral2(node) && !isRegExpLiteral2(node) && !isTemplateLiteral2(node)) {
            parts.push(node.value);
        }
        
        break;
    
    case 'MemberExpression':    
    case 'OptionalMemberExpression':    
    case 'JSXMemberExpression':
        gatherNodeParts(node.object, parts);
        gatherNodeParts(node.property, parts);
        break;
    
    case 'Identifier':    
    case 'JSXIdentifier':
        parts.push(node.name);
        break;
    
    case 'CallExpression':    
    case 'OptionalCallExpression':    
    case 'NewExpression':
        gatherNodeParts(node.callee, parts);
        break;
    
    case 'ObjectExpression':    
    case 'ObjectPattern':
        
        for (const e of node.properties) {
            gatherNodeParts(e, parts);
        }
        
        break;
    
    case 'SpreadElement':    
    case 'RestElement':
        gatherNodeParts(node.argument, parts);
        break;
    
    case 'ObjectProperty':    
    case 'ObjectMethod':    
    case 'ClassProperty':    
    case 'ClassMethod':    
    case 'ClassPrivateProperty':    
    case 'ClassPrivateMethod':
        gatherNodeParts(node.key, parts);
        break;
    
    case 'ThisExpression':
        parts.push('this');
        break;
    
    case 'Super':
        parts.push('super');
        break;
    
    case 'Import':    
    case 'ImportExpression':
        parts.push('import');
        break;
    
    case 'DoExpression':
        parts.push('do');
        break;
    
    case 'YieldExpression':
        parts.push('yield');
        gatherNodeParts(node.argument, parts);
        break;
    
    case 'AwaitExpression':
        parts.push('await');
        gatherNodeParts(node.argument, parts);
        break;
    
    case 'AssignmentExpression':
        gatherNodeParts(node.left, parts);
        break;
    
    case 'VariableDeclarator':
        gatherNodeParts(node.id, parts);
        break;
    
    case 'FunctionExpression':    
    case 'FunctionDeclaration':    
    case 'ClassExpression':    
    case 'ClassDeclaration':
        gatherNodeParts(node.id, parts);
        break;
    
    case 'PrivateName':
        gatherNodeParts(node.id, parts);
        break;
    
    case 'ParenthesizedExpression':
        gatherNodeParts(node.expression, parts);
        break;
    
    case 'UnaryExpression':    
    case 'UpdateExpression':
        gatherNodeParts(node.argument, parts);
        break;
    
    case 'MetaProperty':
        gatherNodeParts(node.meta, parts);
        gatherNodeParts(node.property, parts);
        break;
    
    case 'JSXElement':
        gatherNodeParts(node.openingElement, parts);
        break;
    
    case 'JSXOpeningElement':
        gatherNodeParts(node.name, parts);
        break;
    
    case 'JSXFragment':
        gatherNodeParts(node.openingFragment, parts);
        break;
    
    case 'JSXOpeningFragment':
        parts.push('Fragment');
        break;
    
    case 'JSXNamespacedName':
        gatherNodeParts(node.namespace, parts);
        gatherNodeParts(node.name, parts);
        break;
    }
}

function resetScope(scope2) {
    if (scope2.path.type === 'Program') {
        scope2.referencesSet =         /* @__PURE__ */new Set();
        scope2.uidsSet =         /* @__PURE__ */new Set();
    }
    
    scope2.bindings =     /* @__PURE__ */Object.create(null);
    scope2.globals =     /* @__PURE__ */Object.create(null);
}

var collectorVisitor = {
    ForStatement(path) {
        const declar = path.get('init');
        
        if (declar.isVar()) {
            const {scope: scope2} = path;
            
            const parentScope = scope2.getFunctionParent() || scope2.getProgramParent();
            parentScope.registerBinding('var', declar);
        }
    },
    Declaration(path) {
        if (path.isBlockScoped())
            return;
        
        if (path.isImportDeclaration())
            return;
        
        if (path.isExportDeclaration())
            return;
        
        const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();
        parent.registerDeclaration(path);
    },
    ImportDeclaration(path) {
        const parent = path.scope.getBlockParent();
        parent.registerDeclaration(path);
    },
    TSImportEqualsDeclaration(path) {
        const parent = path.scope.getBlockParent();
        parent.registerDeclaration(path);
    },
    ReferencedIdentifier(path, state) {
        if (isTSQualifiedName(path.parent) && path.parent.right === path.node) {
            return;
        }
        
        if (path.parentPath.isTSImportEqualsDeclaration())
            return;
        
        state.references.push(path);
    },
    ForXStatement(path, state) {
        const left = path.get('left');
        
        if (left.isPattern() || left.isIdentifier()) {
            state.constantViolations.push(path);
        } else if (left.isVar()) {
            const {scope: scope2} = path;
            
            const parentScope = scope2.getFunctionParent() || scope2.getProgramParent();
            parentScope.registerBinding('var', left);
        }
    },
    ExportDeclaration: {
        exit(path) {
            const {node, scope: scope2} = path;
            
            if (isExportAllDeclaration2(node))
                return;
            
            const declar = node.declaration;
            
            if (isClassDeclaration3(declar) || isFunctionDeclaration2(declar)) {
                const id = declar.id;
                
                if (!id)
                    return;
                
                const binding = scope2.getBinding(id.name);
                binding?.reference(path);
            } else if (isVariableDeclaration$1$1(declar)) {
                for (const decl of declar.declarations) {
                    for (const name of Object.keys(getBindingIdentifiers$3(decl))) {
                        const binding = scope2.getBinding(name);
                        binding?.reference(path);
                    }
                }
            }
        },
    },
    LabeledStatement(path) {
        path.scope
            .getBlockParent()
            .registerDeclaration(path);
    },
    AssignmentExpression(path, state) {
        state.assignments.push(path);
    },
    UpdateExpression(path, state) {
        state.constantViolations.push(path);
    },
    UnaryExpression(path, state) {
        if (path.node.operator === 'delete') {
            state.constantViolations.push(path);
        }
    },
    BlockScoped(path) {
        let scope2 = path.scope;
        
        if (scope2.path === path)
            scope2 = scope2.parent;
        
        const parent = scope2.getBlockParent();
        parent.registerDeclaration(path);
        
        if (path.isClassDeclaration() && path.node.id) {
            const id = path.node.id;
            const name = id.name;
            
            path.scope.bindings[name] = path.scope.parent.getBinding(name);
        }
    },
    CatchClause(path) {
        path.scope.registerBinding('let', path);
    },
    Function(path) {
        const params = path.get('params');
        
        for (const param of params) {
            path.scope.registerBinding('param', param);
        }
        
        if (path.isFunctionExpression() && path.node.id) {
            path.scope.registerBinding('local', path.get('id'), path);
        }
    },
    ClassExpression(path) {
        if (path.node.id) {
            path.scope.registerBinding('local', path.get('id'), path);
        }
    },
    TSTypeAnnotation(path) {
        path.skip();
    },
};

var scopeVisitor;
var uid = 0;

var _Scope = class _Scope {
    constructor(path) {
        __publicField(this, 'uid');
        __publicField(this, 'path');
        __publicField(this, 'block');
        __publicField(this, 'inited');
        __publicField(this, 'labels');
        __publicField(this, 'bindings');
        __publicField(this, 'referencesSet');
        __publicField(this, 'globals');
        __publicField(this, 'uidsSet');
        __publicField(this, 'data');
        __publicField(this, 'crawling');
        const {node} = path;
        
        const cached = scope.get(node);
        
        if (cached?.path === path) {
            return cached;
        }
        
        scope.set(node, this);
        this.uid = uid++;
        this.block = node;
        this.path = path;
        this.labels =         /* @__PURE__ */new Map();
        this.inited = false;
    }
    
    get parent() {
        let parent, path = this.path;
        
        do {
            const shouldSkip = path.key === 'key' || path.listKey === 'decorators';
            
            path = path.parentPath;
            
            if (shouldSkip && path.isMethod())
                path = path.parentPath;
            
            if (path?.isScope())
                parent = path;
        } while (path && !parent)
        
        return parent?.scope;
    }
    
    get references() {
        throw new Error('Scope#references is not available in Babel 8. Use Scope#referencesSet instead.');
    }
    
    get uids() {
        throw new Error('Scope#uids is not available in Babel 8. Use Scope#uidsSet instead.');
    }
    
    generateDeclaredUidIdentifier(name) {
        const id = this.generateUidIdentifier(name);
        
        this.push({
            id,
        });
        return cloneNode$3(id);
    }
    
    generateUidIdentifier(name) {
        return identifier$3$1(this.generateUid(name));
    }
    
    generateUid(name = 'temp') {
        name = toIdentifier2(name)
            .replace(/^_+/, '')
            .replace(/\d+$/g, '');
        let uid2;
        let i = 0;
        
        do {
            uid2 = `_${name}`;
            
            if (i >= 11)
                uid2 += i - 1;
            else if (i >= 9)
                uid2 += i - 9;
            else if (i >= 1)
                uid2 += i + 1;
            
            i++;
        } while (this.hasLabel(uid2) || this.hasBinding(uid2) || this.hasGlobal(uid2) || this.hasReference(uid2))
        const program3 = this.getProgramParent();
        
        {
            program3.referencesSet.add(uid2);
            program3.uidsSet.add(uid2);
        }
        
        return uid2;
    }
    
    generateUidBasedOnNode(node, defaultName) {
        const parts = [];
        gatherNodeParts(node, parts);
        let id = parts.join('$');
        
        id = id.replace(/^_/, '') || defaultName || 'ref';
        return this.generateUid(id.slice(0, 20));
    }
    
    generateUidIdentifierBasedOnNode(node, defaultName) {
        return identifier$3$1(this.generateUidBasedOnNode(
            node,
            defaultName,
        ));
    }
    
    isStatic(node) {
        if (isThisExpression2(node) || isSuper$1(node) || isTopicReference2(node)) {
            return true;
        }
        
        if (isIdentifier$5$1(node)) {
            const binding = this.getBinding(node.name);
            
            if (binding) {
                return binding.constant;
            } else {
                return this.hasBinding(node.name);
            }
        }
        
        return false;
    }
    
    maybeGenerateMemoised(node, dontPush) {
        if (this.isStatic(node)) {
            return null;
        } else {
            const id = this.generateUidIdentifierBasedOnNode(node);
            
            if (!dontPush) {
                this.push({
                    id,
                });
                return cloneNode$3(id);
            }
            
            return id;
        }
    }
    
    checkBlockScopedCollisions(local, kind, name, id) {
        if (kind === 'param')
            return;
        
        if (local.kind === 'local')
            return;
        
        const duplicate = kind === 'let'
            || local.kind === 'let'
            || local.kind === 'const'
            || local.kind === 'module'
            || local.kind === 'param' && kind === 'const';
        
        if (duplicate) {
            throw this.path.hub.buildError(id, `Duplicate declaration "${name}"`, TypeError);
        }
    }
    
    rename(oldName, newName) {
        const binding = this.getBinding(oldName);
        
        if (binding) {
            newName || (newName = this.generateUidIdentifier(oldName).name);
            const renamer = new Renamer(binding, oldName, newName);
            
            {
                renamer.rename();
            }
        }
    }
    
    dump() {
        const sep = '-'.repeat(60);
        console.log(sep);
        let scope2 = this;
        
        do {
            console.log('#', scope2.block.type);
            for (const name of Object.keys(scope2.bindings)) {
                const binding = scope2.bindings[name];
                
                console.log(' -', name, {
                    constant: binding.constant,
                    references: binding.references,
                    violations: binding.constantViolations.length,
                    kind: binding.kind,
                });
            }
        } while (scope2 = scope2.parent)
        console.log(sep);
    }
    
    hasLabel(name) {
        return !!this.getLabel(name);
    }
    
    getLabel(name) {
        return this.labels.get(name);
    }
    
    registerLabel(path) {
        this.labels.set(path.node.label.name, path);
    }
    
    registerDeclaration(path) {
        if (path.isLabeledStatement()) {
            this.registerLabel(path);
        } else if (path.isFunctionDeclaration()) {
            this.registerBinding('hoisted', path.get('id'), path);
        } else if (path.isVariableDeclaration()) {
            const declarations = path.get('declarations');
            const {kind} = path.node;
            
            for (const declar of declarations) {
                this.registerBinding(kind === 'using' || kind === 'await using' ? 'const' : kind, declar);
            }
        } else if (path.isClassDeclaration()) {
            if (path.node.declare)
                return;
            
            this.registerBinding('let', path);
        } else if (path.isImportDeclaration()) {
            const isTypeDeclaration = path.node.importKind === 'type' || path.node.importKind === 'typeof';
            const specifiers = path.get('specifiers');
            
            for (const specifier of specifiers) {
                const isTypeSpecifier = isTypeDeclaration
                    || specifier.isImportSpecifier()
                    && (specifier.node.importKind === 'type'
                    || specifier.node.importKind === 'typeof');
                this.registerBinding(isTypeSpecifier ? 'unknown' : 'module', specifier);
            }
        } else if (path.isExportDeclaration()) {
            const declar = path.get('declaration');
            
            if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {
                this.registerDeclaration(declar);
            }
        } else {
            this.registerBinding('unknown', path);
        }




    }
    
    buildUndefinedNode() {
        return buildUndefinedNode$1();
    }
    
    registerConstantViolation(path) {
        const ids = path.getAssignmentIdentifiers();
        
        for (const name of Object.keys(ids)) {
            this.getBinding(name)?.reassign(path);
        }
    }
    
    registerBinding(kind, path, bindingPath = path) {
        if (!kind)
            throw new ReferenceError('no `kind`');
        
        if (path.isVariableDeclaration()) {
            const declarators = path.get('declarations');
            
            for (const declar of declarators) {
                this.registerBinding(kind, declar);
            }
            
            return;
        }
        
        const parent = this.getProgramParent();
        const ids = path.getOuterBindingIdentifiers(true);
        
        for (const name of Object.keys(ids)) {
            {
                parent.referencesSet.add(name);
            }
            
            for (const id of ids[name]) {
                const local = this.getOwnBinding(name);
                
                if (local) {
                    if (local.identifier === id)
                        continue;
                    
                    this.checkBlockScopedCollisions(local, kind, name, id);
                }
                
                if (local) {
                    local.reassign(bindingPath);
                } else {
                    this.bindings[name] = new Binding({
                        identifier: id,
                        scope: this,
                        path: bindingPath,
                        kind,
                    });
                }
            }
        }
    }
    
    addGlobal(node) {
        this.globals[node.name] = node;
    }
    
    hasUid(name) {
        {
            return this
                .getProgramParent()
                .uidsSet
                .has(name);
        }
    }
    
    hasGlobal(name) {
        let scope2 = this;
        
        do {
            if (scope2.globals[name])
                return true;
        } while (scope2 = scope2.parent)
        
        return false;
    }
    
    hasReference(name) {
        {
            return this
                .getProgramParent()
                .referencesSet
                .has(name);
        }
    }
    
    isPure(node, constantsOnly) {
        if (isIdentifier$5$1(node)) {
            const binding = this.getBinding(node.name);
            
            if (!binding)
                return false;
            
            if (constantsOnly)
                return binding.constant;
            
            return true;
        } else if (isThisExpression2(node) || isMetaProperty2(node) || isTopicReference2(node) || isPrivateName2(node)) {
            return true;
        } else if (isClass2(node)) {
            if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
                return false;
            }
            
            if (node.decorators?.length > 0) {
                return false;
            }
            
            return this.isPure(node.body, constantsOnly);
        } else if (isClassBody3(node)) {
            for (const method of node.body) {
                if (!this.isPure(method, constantsOnly))
                    return false;
            }
            
            return true;
        } else if (isBinary3(node)) {
            return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
        } else if (isArrayExpression3(node) || isTupleExpression2(node)) {
            for (const elem of node.elements) {
                if (elem !== null && !this.isPure(elem, constantsOnly))
                    return false;
            }
            
            return true;
        } else if (isObjectExpression3(node) || isRecordExpression2(node)) {
            for (const prop of node.properties) {
                if (!this.isPure(prop, constantsOnly))
                    return false;
            }
            
            return true;
        } else if (isMethod2(node)) {
            if (node.computed && !this.isPure(node.key, constantsOnly))
                return false;
            
            if (node.decorators?.length > 0) {
                return false;
            }
            
            return true;
        } else if (isProperty2(node)) {
            if (node.computed && !this.isPure(node.key, constantsOnly))
                return false;
            
            if (node.decorators?.length > 0) {
                return false;
            }
            
            if (isObjectProperty2(node) || node.static) {
                if (node.value !== null && !this.isPure(node.value, constantsOnly)) {
                    return false;
                }
            }
            
            return true;
        } else if (isUnaryExpression2(node)) {
            return this.isPure(node.argument, constantsOnly);
        } else if (isTemplateLiteral2(node)) {
            for (const expression2 of node.expressions) {
                if (!this.isPure(expression2, constantsOnly))
                    return false;
            }
            
            return true;
        } else if (isTaggedTemplateExpression2(node)) {
            return matchesPattern$1$1(node.tag, 'String.raw') && !this.hasBinding('String', {
                noGlobals: true,
            }) && this.isPure(node.quasi, constantsOnly);
        } else if (isMemberExpression3(node)) {
            return !node.computed
                && isIdentifier$5$1(node.object)
                && node.object.name === 'Symbol'
                && isIdentifier$5$1(node.property)
                && node.property.name !== 'for'
                && !this.hasBinding('Symbol', {
                noGlobals: true,
            });
        } else if (isCallExpression$12(node)) {
            return matchesPattern$1$1(node.callee, 'Symbol.for')
                && !this.hasBinding('Symbol', {
                noGlobals: true,
            })
                && node.arguments.length === 1
                && isStringLiteral$a(node.arguments[0]);
        } else {
            return isPureish2(node);
        }












    }
    
    setData(key, val) {
        return this.data[key] = val;
    }
    
    getData(key) {
        let scope2 = this;
        
        do {
            const data = scope2.data[key];
            
            if (data != null)
                return data;
        } while (scope2 = scope2.parent)
    }
    
    removeData(key) {
        let scope2 = this;
        
        do {
            const data = scope2.data[key];
            
            if (data != null)
                scope2.data[key] = null;
        } while (scope2 = scope2.parent)
    }
    
    init() {
        if (!this.inited) {
            this.inited = true;
            this.crawl();
        }
    }
    
    crawl() {
        const path = this.path;
        resetScope(this);
        this.data =         /* @__PURE__ */Object.create(null);
        let scope2 = this;
        
        do {
            if (scope2.crawling)
                return;
            
            if (scope2.path.isProgram()) {
                break;
            }
        } while (scope2 = scope2.parent)
        const programParent = scope2;
        
        const state = {
            references: [],
            constantViolations: [],
            assignments: [],
        };
        
        this.crawling = true;
        scopeVisitor || (scopeVisitor = traverse3.visitors.merge([{
            Scope(path2) {
                resetScope(path2.scope);
            },
        },
collectorVisitor]));
        
        if (path.type !== 'Program') {
            for (const visit2 of scopeVisitor.enter) {
                visit2.call(state, path, state);
            }
            
            const typeVisitors = scopeVisitor[path.type];
            
            if (typeVisitors) {
                for (const visit2 of typeVisitors.enter) {
                    visit2.call(state, path, state);
                }
            }
        }
        
        path.traverse(scopeVisitor, state);
        this.crawling = false;
        
        for (const path2 of state.assignments) {
            const ids = path2.getAssignmentIdentifiers();
            
            for (const name of Object.keys(ids)) {
                if (path2.scope.getBinding(name))
                    continue;
                
                programParent.addGlobal(ids[name]);
            }
            
            path2.scope.registerConstantViolation(path2);
        }
        
        for (const ref of state.references) {
            const binding = ref.scope.getBinding(ref.node.name);
            
            if (binding) {
                binding.reference(ref);
            } else {
                programParent.addGlobal(ref.node);
            }
        }
        
        for (const path2 of state.constantViolations) {
            path2.scope.registerConstantViolation(path2);
        }
    }
    
    push(opts) {
        let path = this.path;
        
        if (path.isPattern()) {
            path = this.getPatternParent().path;
        } else if (!path.isBlockStatement() && !path.isProgram()) {
            path = this.getBlockParent().path;
        }
        
        if (path.isSwitchStatement()) {
            path = (this.getFunctionParent() || this.getProgramParent()).path;
        }
        
        const {
            init,
            unique,
            kind = 'var',
            id,
        } = opts;
        
        if (!init && !unique && (kind === 'var' || kind === 'let') && path.isFunction() && !path.node.name && isCallExpression$12(path.parent, {callee: path.node}) && path.parent.arguments.length <= path.node.params.length && isIdentifier$5$1(id)) {
            path.pushContainer('params', id);
            path.scope.registerBinding('param', path.get('params')[path.node.params.length - 1]);
            return;
        }
        
        if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
            path.ensureBlock();
            path = path.get('body');
        }
        
        const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
        const dataKey = `declaration:${kind}:${blockHoist}`;
        let declarPath = !unique && path.getData(dataKey);
        
        if (!declarPath) {
            const declar = variableDeclaration$1$1(kind, []);
            
            declar._blockHoist = blockHoist;
            [declarPath] = path.unshiftContainer('body', [declar]);
            
            if (!unique)
                path.setData(dataKey, declarPath);
        }
        
        const declarator = variableDeclarator$1(id, init);
        const len = declarPath.node.declarations.push(declarator);
        
        path.scope.registerBinding(kind, declarPath.get('declarations')[len - 1]);
    }
    
    getProgramParent() {
        let scope2 = this;
        
        do {
            if (scope2.path.isProgram()) {
                return scope2;
            }
        } while (scope2 = scope2.parent)
        throw new Error('Couldn\'t find a Program');
    }
    
    getFunctionParent() {
        let scope2 = this;
        
        do {
            if (scope2.path.isFunctionParent()) {
                return scope2;
            }
        } while (scope2 = scope2.parent)
        
        return null;
    }
    
    getBlockParent() {
        let scope2 = this;
        
        do {
            if (scope2.path.isBlockParent()) {
                return scope2;
            }
        } while (scope2 = scope2.parent)
        throw new Error('We couldn\'t find a BlockStatement, For, Switch, Function, Loop or Program...');
    }
    
    getPatternParent() {
        let scope2 = this;
        
        do {
            if (!scope2.path.isPattern()) {
                return scope2.getBlockParent();
            }
        } while (scope2 = scope2.parent.parent)
        throw new Error('We couldn\'t find a BlockStatement, For, Switch, Function, Loop or Program...');
    }
    
    getAllBindings() {
        const ids =         /* @__PURE__ */Object.create(null);
        let scope2 = this;
        
        do {
            for (const key of Object.keys(scope2.bindings)) {
                if (key in ids === false) {
                    ids[key] = scope2.bindings[key];
                }
            }
            
            scope2 = scope2.parent;
        } while (scope2)
        
        return ids;
    }
    
    bindingIdentifierEquals(name, node) {
        return this.getBindingIdentifier(name) === node;
    }
    
    getBinding(name) {
        let scope2 = this;
        let previousPath;
        
        do {
            const binding = scope2.getOwnBinding(name);
            
            if (binding) {
                if (previousPath?.isPattern() && binding.kind !== 'param' && binding.kind !== 'local');
 else {
                    return binding;
                }
            } else if (!binding && name === 'arguments' && scope2.path.isFunction() && !scope2.path.isArrowFunctionExpression()) {
                break;
            }
            
            previousPath = scope2.path;
        } while (scope2 = scope2.parent)
    }
    
    getOwnBinding(name) {
        return this.bindings[name];
    }
    
    getBindingIdentifier(name) {
        return this.getBinding(name)?.identifier;
    }
    
    getOwnBindingIdentifier(name) {
        const binding = this.bindings[name];
        return binding?.identifier;
    }
    
    hasOwnBinding(name) {
        return !!this.getOwnBinding(name);
    }
    
    hasBinding(name, opts) {
        if (!name)
            return false;
        
        let noGlobals;
        let noUids;
        let upToScope;
        
        if (typeof opts === 'object') {
            noGlobals = opts.noGlobals;
            noUids = opts.noUids;
            upToScope = opts.upToScope;
        } else if (typeof opts === 'boolean') {
            noGlobals = opts;
        }
        
        let scope2 = this;
        
        do {
            if (upToScope === scope2) {
                break;
            }
            
            if (scope2.hasOwnBinding(name)) {
                return true;
            }
        } while (scope2 = scope2.parent)
        if (!noUids && this.hasUid(name))
            return true;
        
        if (!noGlobals && _Scope.globals.includes(name))
            return true;
        
        if (!noGlobals && _Scope.contextVariables.includes(name))
            return true;
        
        return false;
    }
    
    parentHasBinding(name, opts) {
        return this.parent?.hasBinding(name, opts);
    }
    
    moveBindingTo(name, scope2) {
        const info = this.getBinding(name);
        
        if (info) {
            info.scope.removeOwnBinding(name);
            info.scope = scope2;
            scope2.bindings[name] = info;
        }
    }
    
    removeOwnBinding(name) {
        delete this.bindings[name];
    }
    
    removeBinding(name) {
        this.getBinding(name)?.scope.removeOwnBinding(name);
        {
            this
                .getProgramParent()
                .uidsSet
                .delete(name);
        }
    }
    
    hoistVariables(emit = (id) => this.push({
        id,
    })) {
        this.crawl();
        const seen =         /* @__PURE__ */new Set();
        
        for (const name of Object.keys(this.bindings)) {
            const binding = this.bindings[name];
            
            if (!binding)
                continue;
            
            const {path} = binding;
            
            if (!path.isVariableDeclarator())
                continue;
            
            const {parent, parentPath} = path;
            
            if (parent.kind !== 'var' || seen.has(parent))
                continue;
            
            seen.add(path.parent);
            let firstId;
            const init = [];
            
            for (const decl of parent.declarations) {
                firstId ?? (firstId = decl.id);
                
                if (decl.init) {
                    init.push(assignmentExpression$3('=', decl.id, decl.init));
                }
                
                const ids = Object.keys(getBindingIdentifiers$3(decl, false, true, true));
                
                for (const name2 of ids) {
                    emit(identifier$3$1(name2), decl.init != null);
                }
            }
            
            if (parentPath.parentPath.isFor({left: parent})) {
                parentPath.replaceWith(firstId);
            } else if (init.length === 0) {
                parentPath.remove();
            } else {
                const expr = init.length === 1 ? init[0] : sequenceExpression$2(init);
                
                if (parentPath.parentPath.isForStatement({init: parent})) {
                    parentPath.replaceWith(expr);
                } else {
                    parentPath.replaceWith(expressionStatement$3$1(expr));
                }
            }
        }
    }
};

__publicField(_Scope, 'globals', [...builtin_lower_default, ...builtin_upper_default]);
__publicField(_Scope, 'contextVariables', [
    'arguments',
    'undefined',
    'Infinity',
    'NaN',
]);
var Scope2 = _Scope;

var {VISITOR_KEYS: VISITOR_KEYS$4} = lib_exports;

function findParent$1(callback) {
    let path = this;
    
    while (path = path.parentPath) {
        if (callback(path))
            return path;
    }
    
    return null;
}

function find(callback) {
    let path = this;
    
    do {
        if (callback(path))
            return path;
    } while (path = path.parentPath)
    
    return null;
}

function getFunctionParent() {
    return this.findParent((p) => p.isFunction());
}

function getStatementParent() {
    let path = this;
    
    do {
        if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
            break;
        } else {
            path = path.parentPath;
        }
    } while (path)
    if (path && (path.isProgram() || path.isFile())) {
        throw new Error('File/Program node, we can\'t possibly find a statement parent to this');
    }
    
    return path;
}

function getEarliestCommonAncestorFrom(paths) {
    return this.getDeepestCommonAncestorFrom(paths, function(deepest, i, ancestries) {
        let earliest;
        const keys2 = VISITOR_KEYS$4[deepest.type];
        
        for (const ancestry of ancestries) {
            const path = ancestry[i + 1];
            
            if (!earliest) {
                earliest = path;
                continue;
            }
            
            if (path.listKey && earliest.listKey === path.listKey) {
                if (path.key < earliest.key) {
                    earliest = path;
                    continue;
                }
            }
            
            const earliestKeyIndex = keys2.indexOf(earliest.parentKey);
            const currentKeyIndex = keys2.indexOf(path.parentKey);
            
            if (earliestKeyIndex > currentKeyIndex) {
                earliest = path;
            }
        }
        
        return earliest;
    });
}

function getDeepestCommonAncestorFrom(paths, filter) {
    if (!paths.length) {
        return this;
    }
    
    if (paths.length === 1) {
        return paths[0];
    }
    
    let minDepth = Infinity;
    let lastCommonIndex, lastCommon;
    
    const ancestries = paths.map((path) => {
        const ancestry = [];
        
        do {
            ancestry.unshift(path);
        } while ((path = path.parentPath) && path !== this)
        if (ancestry.length < minDepth) {
            minDepth = ancestry.length;
        }
        
        return ancestry;
    });
    
    const first = ancestries[0];
    
    depthLoop:     for (let i = 0; i < minDepth; i++) {
        const shouldMatch = first[i];
        
        for (const ancestry of ancestries) {
            if (ancestry[i] !== shouldMatch) {
                break depthLoop;
            }
        }
        
        lastCommonIndex = i;
        lastCommon = shouldMatch;
    }
    if (lastCommon) {
        if (filter) {
            return filter(lastCommon, lastCommonIndex, ancestries);
        } else {
            return lastCommon;
        }
    } else {
        throw new Error('Couldn\'t find intersection');
    }
}

function getAncestry() {
    let path = this;
    const paths = [];
    
    do {
        paths.push(path);
    } while (path = path.parentPath)
    
    return paths;
}

function isAncestor(maybeDescendant) {
    return maybeDescendant.isDescendant(this);
}

function isDescendant(maybeAncestor) {
    return !!this.findParent((parent) => parent === maybeAncestor);
}

function inType(...candidateTypes) {
    let path = this;
    
    while (path) {
        if (candidateTypes.includes(path.node.type))
            return true;
        
        path = path.parentPath;
    }
    
    return false;
}

var {
    createFlowUnionType: createFlowUnionType2,
    createTSUnionType: createTSUnionType2,
    createUnionTypeAnnotation,
    isFlowType: isFlowType2,
    isTSType: isTSType2,
} = lib_exports;

function createUnionType(types2) {
    {
        if (types2.every((v) => isFlowType2(v))) {
            return createFlowUnionType2(types2);
        }
        
        if (types2.every((v) => isTSType2(v))) {
            return createTSUnionType2(types2);
        }
    }
}

var {
    BOOLEAN_NUMBER_BINARY_OPERATORS: BOOLEAN_NUMBER_BINARY_OPERATORS2,
    createTypeAnnotationBasedOnTypeof: createTypeAnnotationBasedOnTypeof2,
    numberTypeAnnotation: numberTypeAnnotation$1,
    voidTypeAnnotation: voidTypeAnnotation$2,
} = lib_exports;

function infererReference(node) {
    if (!this.isReferenced())
        return;
    
    const binding = this.scope.getBinding(node.name);
    
    if (binding) {
        if (binding.identifier.typeAnnotation) {
            return binding.identifier.typeAnnotation;
        } else {
            return getTypeAnnotationBindingConstantViolations(binding, this, node.name);
        }
    }
    
    if (node.name === 'undefined') {
        return voidTypeAnnotation$2();
    } else if (node.name === 'NaN' || node.name === 'Infinity') {
        return numberTypeAnnotation$1();
    }    else if (node.name === 'arguments');

}

function getTypeAnnotationBindingConstantViolations(binding, path, name) {
    const types2 = [];
    const functionConstantViolations = [];
    let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
    const testType = getConditionalAnnotation(binding, path, name);
    
    if (testType) {
        const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
        
        constantViolations = constantViolations.filter((path2) => !testConstantViolations.includes(path2));
        types2.push(testType.typeAnnotation);
    }
    
    if (constantViolations.length) {
        constantViolations.push(...functionConstantViolations);
        for (const violation of constantViolations) {
            types2.push(violation.getTypeAnnotation());
        }
    }
    
    if (!types2.length) {
        return;
    }
    
    return createUnionType(types2);
}

function getConstantViolationsBefore(binding, path, functions) {
    const violations = binding.constantViolations.slice();
    violations.unshift(binding.path);
    return violations.filter((violation) => {
        violation = violation.resolve();
        const status = violation._guessExecutionStatusRelativeTo(path);
        
        if (functions && status === 'unknown')
            functions.push(violation);
        
        return status === 'before';
    });
}

function inferAnnotationFromBinaryExpression(name, path) {
    const operator = path.node.operator;
    const right = path.get('right').resolve();
    const left = path.get('left').resolve();
    let target;
    
    if (left.isIdentifier({name})) {
        target = right;
    } else if (right.isIdentifier({name})) {
        target = left;
    }
    
    if (target) {
        if (operator === '===') {
            return target.getTypeAnnotation();
        }
        
        if (BOOLEAN_NUMBER_BINARY_OPERATORS2.includes(operator)) {
            return numberTypeAnnotation$1();
        }
        
        return;
    }
    
    if (operator !== '===' && operator !== '==')
        return;
    
    let typeofPath;
    let typePath;
    
    if (left.isUnaryExpression({operator: 'typeof'})) {
        typeofPath = left;
        typePath = right;
    } else if (right.isUnaryExpression({operator: 'typeof'})) {
        typeofPath = right;
        typePath = left;
    }
    
    if (!typeofPath)
        return;
    
    if (!typeofPath.get('argument').isIdentifier({name}))
        return;
    
    typePath = typePath.resolve();
    
    if (!typePath.isLiteral())
        return;
    
    const typeValue = typePath.node.value;
    
    if (typeof typeValue !== 'string')
        return;
    
    return createTypeAnnotationBasedOnTypeof2(typeValue);
}

function getParentConditionalPath(binding, path, name) {
    let parentPath;
    
    while (parentPath = path.parentPath) {
        if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
            if (path.key === 'test') {
                return;
            }
            
            return parentPath;
        }
        
        if (parentPath.isFunction()) {
            if (parentPath.parentPath.scope.getBinding(name) !== binding)
                return;
        }
        
        path = parentPath;
    }
}

function getConditionalAnnotation(binding, path, name) {
    const ifStatement2 = getParentConditionalPath(binding, path, name);
    
    if (!ifStatement2)
        return;
    
    const test = ifStatement2.get('test');
    const paths = [test];
    const types2 = [];
    
    for (let i = 0; i < paths.length; i++) {
        const path2 = paths[i];
        
        if (path2.isLogicalExpression()) {
            if (path2.node.operator === '&&') {
                paths.push(path2.get('left'));
                paths.push(path2.get('right'));
            }
        } else if (path2.isBinaryExpression()) {
            const type = inferAnnotationFromBinaryExpression(name, path2);
            
            if (type)
                types2.push(type);
        }
    }
    
    if (types2.length) {
        return {
            typeAnnotation: createUnionType(types2),
            ifStatement: ifStatement2,
        };
    }
    
    return getConditionalAnnotation(binding, ifStatement2, name);
}

var {
    BOOLEAN_BINARY_OPERATORS: BOOLEAN_BINARY_OPERATORS2,
    BOOLEAN_UNARY_OPERATORS: BOOLEAN_UNARY_OPERATORS2,
    NUMBER_BINARY_OPERATORS: NUMBER_BINARY_OPERATORS2,
    NUMBER_UNARY_OPERATORS: NUMBER_UNARY_OPERATORS2,
    STRING_UNARY_OPERATORS: STRING_UNARY_OPERATORS2,
    anyTypeAnnotation: anyTypeAnnotation$1,
    arrayTypeAnnotation: arrayTypeAnnotation2,
    booleanTypeAnnotation: booleanTypeAnnotation2,
    buildMatchMemberExpression: buildMatchMemberExpression2,
    genericTypeAnnotation: genericTypeAnnotation2,
    identifier: identifier$2$1,
    nullLiteralTypeAnnotation: nullLiteralTypeAnnotation2,
    numberTypeAnnotation: numberTypeAnnotation2,
    stringTypeAnnotation: stringTypeAnnotation$1,
    tupleTypeAnnotation: tupleTypeAnnotation2,
    unionTypeAnnotation: unionTypeAnnotation2,
    voidTypeAnnotation: voidTypeAnnotation$1,
    isIdentifier: isIdentifier$4$1,
} = lib_exports;

function VariableDeclarator3() {
    if (!this.get('id').isIdentifier())
        return;
    
    return this
        .get('init')
        .getTypeAnnotation();
}

function TypeCastExpression3(node) {
    return node.typeAnnotation;
}

TypeCastExpression3.validParent = true;
function TSAsExpression3(node) {
    return node.typeAnnotation;
}

TSAsExpression3.validParent = true;
function TSNonNullExpression3() {
    return this
        .get('expression')
        .getTypeAnnotation();
}

function NewExpression3(node) {
    if (node.callee.type === 'Identifier') {
        return genericTypeAnnotation2(node.callee);
    }
}

function TemplateLiteral3() {
    return stringTypeAnnotation$1();
}

function UnaryExpression3(node) {
    const operator = node.operator;
    
    if (operator === 'void') {
        return voidTypeAnnotation$1();
    } else if (NUMBER_UNARY_OPERATORS2.includes(operator)) {
        return numberTypeAnnotation2();
    } else if (STRING_UNARY_OPERATORS2.includes(operator)) {
        return stringTypeAnnotation$1();
    } else if (BOOLEAN_UNARY_OPERATORS2.includes(operator)) {
        return booleanTypeAnnotation2();
    }


}

function BinaryExpression3(node) {
    const operator = node.operator;
    
    if (NUMBER_BINARY_OPERATORS2.includes(operator)) {
        return numberTypeAnnotation2();
    } else if (BOOLEAN_BINARY_OPERATORS2.includes(operator)) {
        return booleanTypeAnnotation2();
    } else if (operator === '+') {
        const right = this.get('right');
        const left = this.get('left');
        
        if (left.isBaseType('number') && right.isBaseType('number')) {
            return numberTypeAnnotation2();
        } else if (left.isBaseType('string') || right.isBaseType('string')) {
            return stringTypeAnnotation$1();
        }
        
        return unionTypeAnnotation2([stringTypeAnnotation$1(), numberTypeAnnotation2()]);
    }

}

function LogicalExpression3() {
    const argumentTypes = [
        this
            .get('left')
            .getTypeAnnotation(),
        this
            .get('right')
            .getTypeAnnotation(),
    ];
    return createUnionType(argumentTypes);
}

function ConditionalExpression3() {
    const argumentTypes = [
        this
            .get('consequent')
            .getTypeAnnotation(),
        this
            .get('alternate')
            .getTypeAnnotation(),
    ];
    return createUnionType(argumentTypes);
}

function SequenceExpression3() {
    return this
        .get('expressions')
        .pop()
        .getTypeAnnotation();
}

function ParenthesizedExpression3() {
    return this
        .get('expression')
        .getTypeAnnotation();
}

function AssignmentExpression3() {
    return this
        .get('right')
        .getTypeAnnotation();
}

function UpdateExpression3(node) {
    const operator = node.operator;
    
    if (operator === '++' || operator === '--') {
        return numberTypeAnnotation2();
    }
}

function StringLiteral3() {
    return stringTypeAnnotation$1();
}

function NumericLiteral3() {
    return numberTypeAnnotation2();
}

function BooleanLiteral3() {
    return booleanTypeAnnotation2();
}

function NullLiteral3() {
    return nullLiteralTypeAnnotation2();
}

function RegExpLiteral3() {
    return genericTypeAnnotation2(identifier$2$1('RegExp'));
}

function ObjectExpression3() {
    return genericTypeAnnotation2(identifier$2$1('Object'));
}

function ArrayExpression3() {
    return genericTypeAnnotation2(identifier$2$1('Array'));
}

function RestElement3() {
    return ArrayExpression3();
}

RestElement3.validParent = true;
function Func() {
    return genericTypeAnnotation2(identifier$2$1('Function'));
}

var isArrayFrom = buildMatchMemberExpression2('Array.from');
var isObjectKeys = buildMatchMemberExpression2('Object.keys');
var isObjectValues = buildMatchMemberExpression2('Object.values');
var isObjectEntries = buildMatchMemberExpression2('Object.entries');

function CallExpression3() {
    const {callee} = this.node;
    
    if (isObjectKeys(callee)) {
        return arrayTypeAnnotation2(stringTypeAnnotation$1());
    } else if (isArrayFrom(callee) || isObjectValues(callee) || isIdentifier$4$1(callee, {name: 'Array'})) {
        return arrayTypeAnnotation2(anyTypeAnnotation$1());
    } else if (isObjectEntries(callee)) {
        return arrayTypeAnnotation2(tupleTypeAnnotation2([stringTypeAnnotation$1(), anyTypeAnnotation$1()]));
    }
    
    return resolveCall(this.get('callee'));
}

function TaggedTemplateExpression3() {
    return resolveCall(this.get('tag'));
}

function resolveCall(callee) {
    callee = callee.resolve();
    
    if (callee.isFunction()) {
        const {node} = callee;
        
        if (node.async) {
            if (node.generator) {
                return genericTypeAnnotation2(identifier$2$1('AsyncIterator'));
            } else {
                return genericTypeAnnotation2(identifier$2$1('Promise'));
            }
        } else {
            if (node.generator) {
                return genericTypeAnnotation2(identifier$2$1('Iterator'));
            } else if (callee.node.returnType) {
                return callee.node.returnType;
            } else
;

        }
    }
}

var inferers = /* @__PURE__ */Object.freeze({
    __proto__: null,
    ArrayExpression: ArrayExpression3,
    ArrowFunctionExpression: Func,
    AssignmentExpression: AssignmentExpression3,
    BinaryExpression: BinaryExpression3,
    BooleanLiteral: BooleanLiteral3,
    CallExpression: CallExpression3,
    ClassDeclaration: Func,
    ClassExpression: Func,
    ConditionalExpression: ConditionalExpression3,
    FunctionDeclaration: Func,
    FunctionExpression: Func,
    Identifier: infererReference,
    LogicalExpression: LogicalExpression3,
    NewExpression: NewExpression3,
    NullLiteral: NullLiteral3,
    NumericLiteral: NumericLiteral3,
    ObjectExpression: ObjectExpression3,
    ParenthesizedExpression: ParenthesizedExpression3,
    RegExpLiteral: RegExpLiteral3,
    RestElement: RestElement3,
    SequenceExpression: SequenceExpression3,
    StringLiteral: StringLiteral3,
    TSAsExpression: TSAsExpression3,
    TSNonNullExpression: TSNonNullExpression3,
    TaggedTemplateExpression: TaggedTemplateExpression3,
    TemplateLiteral: TemplateLiteral3,
    TypeCastExpression: TypeCastExpression3,
    UnaryExpression: UnaryExpression3,
    UpdateExpression: UpdateExpression3,
    VariableDeclarator: VariableDeclarator3,
});

var {
    anyTypeAnnotation: anyTypeAnnotation2,
    isAnyTypeAnnotation: isAnyTypeAnnotation2,
    isArrayTypeAnnotation: isArrayTypeAnnotation3,
    isBooleanTypeAnnotation: isBooleanTypeAnnotation2,
    isEmptyTypeAnnotation: isEmptyTypeAnnotation2,
    isFlowBaseAnnotation: isFlowBaseAnnotation2,
    isGenericTypeAnnotation: isGenericTypeAnnotation2,
    isIdentifier: isIdentifier$3$1,
    isMixedTypeAnnotation: isMixedTypeAnnotation2,
    isNumberTypeAnnotation: isNumberTypeAnnotation2,
    isStringTypeAnnotation: isStringTypeAnnotation2,
    isTSArrayType: isTSArrayType2,
    isTSTypeAnnotation: isTSTypeAnnotation2,
    isTSTypeReference: isTSTypeReference2,
    isTupleTypeAnnotation: isTupleTypeAnnotation2,
    isTypeAnnotation: isTypeAnnotation2,
    isUnionTypeAnnotation: isUnionTypeAnnotation2,
    isVoidTypeAnnotation: isVoidTypeAnnotation2,
    stringTypeAnnotation: stringTypeAnnotation2,
    voidTypeAnnotation: voidTypeAnnotation2,
} = lib_exports;

function getTypeAnnotation() {
    let type = this.getData('typeAnnotation');
    
    if (type != null) {
        return type;
    }
    
    type = _getTypeAnnotation.call(this) || anyTypeAnnotation2();
    
    if (isTypeAnnotation2(type) || isTSTypeAnnotation2(type)) {
        type = type.typeAnnotation;
    }
    
    this.setData('typeAnnotation', type);
    return type;
}

var typeAnnotationInferringNodes = /* @__PURE__ */new WeakSet();

function _getTypeAnnotation() {
    const node = this.node;
    
    if (!node) {
        if (this.key === 'init' && this.parentPath.isVariableDeclarator()) {
            const declar = this.parentPath.parentPath;
            const declarParent = declar.parentPath;
            
            if (declar.key === 'left' && declarParent.isForInStatement()) {
                return stringTypeAnnotation2();
            }
            
            if (declar.key === 'left' && declarParent.isForOfStatement()) {
                return anyTypeAnnotation2();
            }
            
            return voidTypeAnnotation2();
        } else {
            return;
        }
    }
    
    if (node.typeAnnotation) {
        return node.typeAnnotation;
    }
    
    if (typeAnnotationInferringNodes.has(node)) {
        return;
    }
    
    typeAnnotationInferringNodes.add(node);
    try {
        let inferer = inferers[node.type];
        
        if (inferer) {
            return inferer.call(this, node);
        }
        
        inferer = inferers[this.parentPath.type];
        
        if (inferer?.validParent) {
            return this.parentPath.getTypeAnnotation();
        }
    } finally {
        typeAnnotationInferringNodes.delete(node);
    }
}

function isBaseType(baseName, soft) {
    return _isBaseType(baseName, this.getTypeAnnotation(), soft);
}

function _isBaseType(baseName, type, soft) {
    if (baseName === 'string') {
        return isStringTypeAnnotation2(type);
    } else if (baseName === 'number') {
        return isNumberTypeAnnotation2(type);
    } else if (baseName === 'boolean') {
        return isBooleanTypeAnnotation2(type);
    } else if (baseName === 'any') {
        return isAnyTypeAnnotation2(type);
    } else if (baseName === 'mixed') {
        return isMixedTypeAnnotation2(type);
    } else if (baseName === 'empty') {
        return isEmptyTypeAnnotation2(type);
    } else if (baseName === 'void') {
        return isVoidTypeAnnotation2(type);
    } else {
        if (soft) {
            return false;
        } else {
            throw new Error(`Unknown base type ${baseName}`);
        }
    }





}

function couldBeBaseType(name) {
    const type = this.getTypeAnnotation();
    
    if (isAnyTypeAnnotation2(type))
        return true;
    
    if (isUnionTypeAnnotation2(type)) {
        for (const type2 of type.types) {
            if (isAnyTypeAnnotation2(type2) || _isBaseType(name, type2, true)) {
                return true;
            }
        }
        
        return false;
    } else {
        return _isBaseType(name, type, true);
    }
}

function baseTypeStrictlyMatches(rightArg) {
    const left = this.getTypeAnnotation();
    const right = rightArg.getTypeAnnotation();
    
    if (!isAnyTypeAnnotation2(left) && isFlowBaseAnnotation2(left)) {
        return right.type === left.type;
    }
    
    return false;
}

function isGenericType(genericName) {
    const type = this.getTypeAnnotation();
    
    if (genericName === 'Array') {
        if (isTSArrayType2(type) || isArrayTypeAnnotation3(type) || isTupleTypeAnnotation2(type)) {
            return true;
        }
    }
    
    return isGenericTypeAnnotation2(type) && isIdentifier$3$1(type.id, {
        name: genericName,
    })
        || isTSTypeReference2(type) && isIdentifier$3$1(type.typeName, {
        name: genericName,
    });
}

var hooks = [
    function(self, parent) {
        const removeParent = self.key === 'test'
            && (parent.isWhile()
            || parent.isSwitchCase())
            || self.key === 'declaration'
            && parent.isExportDeclaration()
            || self.key === 'body'
            && parent.isLabeledStatement()
            || self.listKey === 'declarations'
            && parent.isVariableDeclaration()
            && parent.node.declarations.length === 1
            || self.key === 'expression' && parent.isExpressionStatement();
        
        if (removeParent) {
            parent.remove();
            return true;
        }
    },
    function(self, parent) {
        if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
            parent.replaceWith(parent.node.expressions[0]);
            return true;
        }
    },
    function(self, parent) {
        if (parent.isBinary()) {
            if (self.key === 'left') {
                parent.replaceWith(parent.node.right);
            } else {
                parent.replaceWith(parent.node.left);
            }
            
            return true;
        }
    },
    function(self, parent) {
        if (parent.isIfStatement() && self.key === 'consequent' || self.key === 'body' && (parent.isLoop() || parent.isArrowFunctionExpression())) {
            self.replaceWith({
                type: 'BlockStatement',
                body: [],
            });
            return true;
        }
    },
];

var {getBindingIdentifiers: getBindingIdentifiers$2} = lib_exports;

function remove$3() {
    _assertUnremoved.call(this);
    resync.call(this);
    
    if (_callRemovalHooks.call(this)) {
        _markRemoved.call(this);
        return;
    }
    
    if (!this.opts?.noScope) {
        _removeFromScope.call(this);
    }
    
    this.shareCommentsWithSiblings();
    _remove.call(this);
    _markRemoved.call(this);
}

function _removeFromScope() {
    const bindings = getBindingIdentifiers$2(this.node, false, false, true);
    Object
        .keys(bindings)
        .forEach((name) => this.scope.removeBinding(name));
}

function _callRemovalHooks() {
    if (this.parentPath) {
        for (const fn of hooks) {
            if (fn(this, this.parentPath))
                return true;
        }
    }
}

function _remove() {
    if (Array.isArray(this.container)) {
        this.container.splice(this.key, 1);
        updateSiblingKeys.call(this, this.key, -1);
    } else {
        _replaceWith.call(this, null);
    }
}

function _markRemoved() {
    this._traverseFlags |= SHOULD_SKIP | REMOVED;
    
    if (this.parent) {
        getCachedPaths(this)?.delete(this.node);
    }
    
    this.node = null;
}

function _assertUnremoved() {
    if (this.removed) {
        throw this.buildCodeFrameError('NodePath has been removed so is read-only.');
    }
}

var {
    arrowFunctionExpression: arrowFunctionExpression$2,
    assertExpression: assertExpression2,
    assignmentExpression: assignmentExpression$2,
    blockStatement: blockStatement$2$1,
    callExpression: callExpression$2,
    cloneNode: cloneNode$2,
    expressionStatement: expressionStatement$2$1,
    isAssignmentExpression: isAssignmentExpression3,
    isCallExpression: isCallExpression4,
    isExportNamedDeclaration: isExportNamedDeclaration3,
    isExpression: isExpression$2$1,
    isIdentifier: isIdentifier$22,
    isSequenceExpression: isSequenceExpression2,
    isSuper: isSuper2,
    thisExpression: thisExpression$1,
} = lib_exports;

function insertBefore(nodes_) {
    _assertUnremoved.call(this);
    const nodes2 = _verifyNodeList.call(this, nodes_);
    const {parentPath, parent} = this;
    
    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration3(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
        return parentPath.insertBefore(nodes2);
    } else if (this.isNodeType('Expression') && !this.isJSXElement() || parentPath.isForStatement() && this.key === 'init') {
        if (this.node)
            nodes2.push(this.node);
        
        return this.replaceExpressionWithStatements(nodes2);
    } else if (Array.isArray(this.container)) {
        return _containerInsertBefore.call(this, nodes2);
    } else if (this.isStatementOrBlock()) {
        const node = this.node;
        const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
        const [blockPath] = this.replaceWith(blockStatement$2$1(shouldInsertCurrentNode ? [node] : []));
        
        return blockPath.unshiftContainer('body', nodes2);
    } else {
        throw new Error('We don\'t know what to do with this node type. We were previously a Statement but we can\'t fit in here?');
    }


}

function _containerInsert(from, nodes2) {
    updateSiblingKeys.call(this, from, nodes2.length);
    const paths = [];
    this.container.splice(from, 0, ...nodes2);
    for (let i = 0; i < nodes2.length; i++) {
        const to = from + i;
        const path = this.getSibling(to);
        paths.push(path);
        
        if (this.context?.queue) {
            pushContext.call(path, this.context);
        }
    }
    
    const contexts = _getQueueContexts.call(this);
    
    for (const path of paths) {
        setScope.call(path);
        path.debug('Inserted.');
        
        for (const context of contexts) {
            context.maybeQueue(path, true);
        }
    }
    
    return paths;
}

function _containerInsertBefore(nodes2) {
    return _containerInsert.call(this, this.key, nodes2);
}

function _containerInsertAfter(nodes2) {
    return _containerInsert.call(this, this.key + 1, nodes2);
}

var last = (arr) => arr[arr.length - 1];

function isHiddenInSequenceExpression(path) {
    return isSequenceExpression2(path.parent) && (last(path.parent.expressions) !== path.node || isHiddenInSequenceExpression(path.parentPath));
}

function isAlmostConstantAssignment(node, scope2) {
    if (!isAssignmentExpression3(node) || !isIdentifier$22(node.left)) {
        return false;
    }
    
    const blockScope = scope2.getBlockParent();
    
    return blockScope.hasOwnBinding(node.left.name) && blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1;
}

function insertAfter$1(nodes_) {
    _assertUnremoved.call(this);
    
    if (this.isSequenceExpression()) {
        return last(this.get('expressions')).insertAfter(nodes_);
    }
    
    const nodes2 = _verifyNodeList.call(this, nodes_);
    
    const {parentPath, parent} = this;
    
    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration3(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
        return parentPath.insertAfter(nodes2.map((node) => {
            return isExpression$2$1(node) ? expressionStatement$2$1(node) : node;
        }));
    } else if (this.isNodeType('Expression') && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === 'init') {
        const self = this;
        
        if (self.node) {
            const node = self.node;
            let {scope: scope2} = this;
            
            if (scope2.path.isPattern()) {
                assertExpression2(node);
                self.replaceWith(callExpression$2(arrowFunctionExpression$2([], node), []));
                self.get('callee.body').insertAfter(nodes2);
                return [self];
            }
            
            if (isHiddenInSequenceExpression(self)) {
                nodes2.unshift(node);
            } else if (isCallExpression4(node) && isSuper2(node.callee)) {
                nodes2.unshift(node);
                nodes2.push(thisExpression$1());
            } else if (isAlmostConstantAssignment(node, scope2)) {
                nodes2.unshift(node);
                nodes2.push(cloneNode$2(node.left));
            } else if (scope2.isPure(node, true)) {
                nodes2.push(node);
            } else {
                if (parentPath.isMethod({computed: true, key: node})) {
                    scope2 = scope2.parent;
                }
                
                const temp = scope2.generateDeclaredUidIdentifier();
                nodes2.unshift(expressionStatement$2$1(assignmentExpression$2('=', cloneNode$2(temp), node)));
                nodes2.push(expressionStatement$2$1(cloneNode$2(temp)));
            }


        }
        
        return this.replaceExpressionWithStatements(nodes2);
    } else if (Array.isArray(this.container)) {
        return _containerInsertAfter.call(this, nodes2);
    } else if (this.isStatementOrBlock()) {
        const node = this.node;
        const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
        const [blockPath] = this.replaceWith(blockStatement$2$1(shouldInsertCurrentNode ? [node] : []));
        
        return blockPath.pushContainer('body', nodes2);
    } else {
        throw new Error('We don\'t know what to do with this node type. We were previously a Statement but we can\'t fit in here?');
    }


}

function updateSiblingKeys(fromIndex, incrementBy) {
    if (!this.parent)
        return;
    
    const paths = getCachedPaths(this);
    
    if (!paths)
        return;
    
    for (const [, path] of paths) {
        if (typeof path.key === 'number' && path.container === this.container && path.key >= fromIndex) {
            path.key += incrementBy;
        }
    }
}

function _verifyNodeList(nodes2) {
    if (!nodes2) {
        return [];
    }
    
    if (!Array.isArray(nodes2)) {
        nodes2 = [nodes2];
    }
    
    for (let i = 0; i < nodes2.length; i++) {
        const node = nodes2[i];
        let msg;
        
        if (!node) {
            msg = 'has falsy node';
        } else if (typeof node !== 'object') {
            msg = 'contains a non-object node';
        } else if (!node.type) {
            msg = 'without a type';
        } else if (node instanceof NodePath_Final) {
            msg = 'has a NodePath when it expected a raw object';
        }

        
        if (msg) {
            const type = Array.isArray(node) ? 'array' : typeof node;
            throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);
        }
    }
    
    return nodes2;
}

function unshiftContainer(listKey, nodes2) {
    _assertUnremoved.call(this);
    const verifiedNodes = _verifyNodeList.call(this, nodes2);
    const container = this.node[listKey];
    
    const path = NodePath_Final.get({
        parentPath: this,
        parent: this.node,
        container,
        listKey,
        key: 0,
    }).setContext(this.context);
    
    return _containerInsertBefore.call(path, verifiedNodes);
}

function pushContainer(listKey, nodes2) {
    _assertUnremoved.call(this);
    const verifiedNodes = _verifyNodeList.call(this, nodes2);
    const container = this.node[listKey];
    
    const path = NodePath_Final.get({
        parentPath: this,
        parent: this.node,
        container,
        listKey,
        key: container.length,
    }).setContext(this.context);
    
    return path.replaceWithMultiple(verifiedNodes);
}

var {
    FUNCTION_TYPES: FUNCTION_TYPES2,
    arrowFunctionExpression: arrowFunctionExpression$1$1,
    assignmentExpression: assignmentExpression$1$1,
    awaitExpression: awaitExpression2,
    blockStatement: blockStatement$1$1,
    buildUndefinedNode: buildUndefinedNode2,
    callExpression: callExpression$1$1,
    cloneNode: cloneNode$1,
    conditionalExpression: conditionalExpression$1$1,
    expressionStatement: expressionStatement$1$1,
    getBindingIdentifiers: getBindingIdentifiers$1,
    identifier: identifier$1$1,
    inheritLeadingComments: inheritLeadingComments2,
    inheritTrailingComments: inheritTrailingComments2,
    inheritsComments: inheritsComments2,
    isBlockStatement: isBlockStatement$1$1,
    isEmptyStatement: isEmptyStatement2,
    isExpression: isExpression$1$1,
    isExpressionStatement: isExpressionStatement4,
    isIfStatement: isIfStatement3,
    isProgram: isProgram2,
    isStatement: isStatement4,
    isVariableDeclaration: isVariableDeclaration2,
    removeComments: removeComments2,
    returnStatement: returnStatement$1$1,
    sequenceExpression: sequenceExpression$1$1,
    validate: validate$13,
    yieldExpression: yieldExpression2,
} = lib_exports;

function replaceWithMultiple$3(nodes2) {
    resync.call(this);
    const verifiedNodes = _verifyNodeList.call(this, nodes2);
    inheritLeadingComments2(verifiedNodes[0], this.node);
    inheritTrailingComments2(verifiedNodes[verifiedNodes.length - 1], this.node);
    getCachedPaths(this)?.delete(this.node);
    this.node =
    this.container[this.key] = null;
    const paths = this.insertAfter(nodes2);
    
    if (this.node) {
        this.requeue();
    } else {
        this.remove();
    }
    
    return paths;
}

function replaceWithSourceString(replacement) {
    resync.call(this);
    let ast;
    
    try {
        replacement = `(${replacement})`;
        ast = parse$6(replacement);
    } catch(err) {
        const loc = err.loc;
        
        if (loc) {
            err.message += ' - make sure this is an expression.\n' + codeFrameColumns$2(replacement, {
                start: {
                    line: loc.line,
                    column: loc.column + 1,
                },
            });
            err.code = 'BABEL_REPLACE_SOURCE_ERROR';
        }
        
        throw err;
    }


        const expressionAST = ast.program.body[0].expression;
    traverse3.removeProperties(expressionAST);
    return this.replaceWith(expressionAST);
}

function replaceWith$8(replacementPath) {
    resync.call(this);
    
    if (this.removed) {
        throw new Error('You can\'t replace this node, we\'ve already removed it');
    }
    
    let replacement = replacementPath instanceof NodePath_Final ? replacementPath.node : replacementPath;
    
    if (!replacement) {
        throw new Error('You passed `path.replaceWith()` a falsy node, use `path.remove()` instead');
    }
    
    if (this.node === replacement) {
        return [
            this,
        ];
    }
    
    if (this.isProgram() && !isProgram2(replacement)) {
        throw new Error('You can only replace a Program root node with another Program node');
    }
    
    if (Array.isArray(replacement)) {
        throw new Error('Don\'t use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`');
    }
    
    if (typeof replacement === 'string') {
        throw new Error('Don\'t use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`');
    }
    
    let nodePath = '';
    
    if (this.isNodeType('Statement') && isExpression$1$1(replacement)) {
        if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
            replacement = expressionStatement$1$1(replacement);
            nodePath = 'expression';
        }
    }
    
    if (this.isNodeType('Expression') && isStatement4(replacement)) {
        if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
            return this.replaceExpressionWithStatements([replacement]);
        }
    }
    
    const oldNode = this.node;
    
    if (oldNode) {
        inheritsComments2(replacement, oldNode);
        removeComments2(oldNode);
    }
    
    _replaceWith.call(this, replacement);
    this.type = replacement.type;
    setScope.call(this);
    this.requeue();
    return [
        nodePath ? this.get(nodePath) : this,
    ];
}

function _replaceWith(node) {
    if (!this.container) {
        throw new ReferenceError('Container is falsy');
    }
    
    if (this.inList) {
        validate$13(this.parent, this.key, [node]);
    } else {
        validate$13(this.parent, this.key, node);
    }
    
    this.debug(`Replace with ${node?.type}`);
    getCachedPaths(this)?.set(node, this).delete(this.node);
    this.node =
    this.container[this.key] = node;
}

function replaceExpressionWithStatements(nodes2) {
    resync.call(this);
    const declars = [];
    const nodesAsSingleExpression = gatherSequenceExpressions(nodes2, declars);
    
    if (nodesAsSingleExpression) {
        for (const id of declars)
            this.scope.push({
                id,
            });
        
        return this
            .replaceWith(nodesAsSingleExpression)[0]
            .get('expressions');
    }
    
    const functionParent = this.getFunctionParent();
    const isParentAsync = functionParent?.node.async;
    const isParentGenerator = functionParent?.node.generator;
    const container = arrowFunctionExpression$1$1([], blockStatement$1$1(nodes2));
    
    this.replaceWith(callExpression$1$1(container, []));
    const callee = this.get('callee');
    
    callee.get('body').scope.hoistVariables((id) => this.scope.push({
        id,
    }));
    const completionRecords = callee.getCompletionRecords();
    
    for (const path of completionRecords) {
        if (!path.isExpressionStatement())
            continue;
        
        const loop = path.findParent((path2) => path2.isLoop());
        
        if (loop) {
            let uid2 = loop.getData('expressionReplacementReturnUid');
            
            if (!uid2) {
                uid2 = callee.scope.generateDeclaredUidIdentifier('ret');
                callee.get('body').pushContainer('body', returnStatement$1$1(cloneNode$1(uid2)));
                loop.setData('expressionReplacementReturnUid', uid2);
            } else {
                uid2 = identifier$1$1(uid2.name);
            }
            
            path.get('expression').replaceWith(assignmentExpression$1$1('=', cloneNode$1(uid2), path.node.expression));
        } else {
            path.replaceWith(returnStatement$1$1(path.node.expression));
        }
    }
    
    callee.arrowFunctionToExpression();
    const newCallee = callee;
    const needToAwaitFunction = isParentAsync && traverse3.hasType(this
        .get('callee.body').node, 'AwaitExpression', FUNCTION_TYPES2);
    const needToYieldFunction = isParentGenerator && traverse3.hasType(this
        .get('callee.body').node, 'YieldExpression', FUNCTION_TYPES2);
    
    if (needToAwaitFunction) {
        newCallee.set('async', true);
        
        if (!needToYieldFunction) {
            this.replaceWith(awaitExpression2(this.node));
        }
    }
    
    if (needToYieldFunction) {
        newCallee.set('generator', true);
        this.replaceWith(yieldExpression2(this.node, true));
    }
    
    return newCallee.get('body.body');
}

function gatherSequenceExpressions(nodes2, declars) {
    const exprs = [];
    let ensureLastUndefined = true;
    
    for (const node of nodes2) {
        if (!isEmptyStatement2(node)) {
            ensureLastUndefined = false;
        }
        
        if (isExpression$1$1(node)) {
            exprs.push(node);
        } else if (isExpressionStatement4(node)) {
            exprs.push(node.expression);
        } else if (isVariableDeclaration2(node)) {
            if (node.kind !== 'var')
                return;
            
            for (const declar of node.declarations) {
                const bindings = getBindingIdentifiers$1(declar);
                
                for (const key of Object.keys(bindings)) {
                    declars.push(cloneNode$1(bindings[key]));
                }
                
                if (declar.init) {
                    exprs.push(assignmentExpression$1$1('=', declar.id, declar.init));
                }
            }
            
            ensureLastUndefined = true;
        } else if (isIfStatement3(node)) {
            const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], declars) : buildUndefinedNode2();
            const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], declars) : buildUndefinedNode2();
            
            if (!consequent || !alternate)
                return;
            
            exprs.push(conditionalExpression$1$1(node.test, consequent, alternate));
        } else if (isBlockStatement$1$1(node)) {
            const body = gatherSequenceExpressions(node.body, declars);
            
            if (!body)
                return;
            
            exprs.push(body);
        } else if (isEmptyStatement2(node)) {
            if (nodes2.indexOf(node) === 0) {
                ensureLastUndefined = true;
            }
        } else {
            return;
        }




    }
    
    if (ensureLastUndefined)
        exprs.push(buildUndefinedNode2());
    
    if (exprs.length === 1) {
        return exprs[0];
    } else {
        return sequenceExpression$1$1(exprs);
    }
}

function replaceInline(nodes2) {
    resync.call(this);
    
    if (Array.isArray(nodes2)) {
        if (Array.isArray(this.container)) {
            nodes2 = _verifyNodeList.call(this, nodes2);
            const paths = _containerInsertAfter.call(this, nodes2);
            this.remove();
            return paths;
        } else {
            return this.replaceWithMultiple(nodes2);
        }
    } else {
        return this.replaceWith(nodes2);
    }
}

var VALID_OBJECT_CALLEES = [
    'Number',
    'String',
    'Math',
];
var VALID_IDENTIFIER_CALLEES = [
    'isFinite',
    'isNaN',
    'parseFloat',
    'parseInt',
    'decodeURI',
    'decodeURIComponent',
    'encodeURI',
    'encodeURIComponent',
    'btoa',
    'atob',
];
var INVALID_METHODS = ['random'];

function isValidObjectCallee(val) {
    return VALID_OBJECT_CALLEES.includes(val);
}

function isValidIdentifierCallee(val) {
    return VALID_IDENTIFIER_CALLEES.includes(val);
}

function isInvalidMethod(val) {
    return INVALID_METHODS.includes(val);
}

function evaluateTruthy() {
    const res = this.evaluate();
    
    if (res.confident)
        return !!res.value;
}

function deopt(path, state) {
    if (!state.confident)
        return;
    
    state.deoptPath = path;
    state.confident = false;
}

var Globals = /* @__PURE__ */new Map([
    ['undefined', void 0],
    ['Infinity', Infinity],
    ['NaN', NaN],
]);

function evaluateCached(path, state) {
    const {node} = path;
    
    const {seen} = state;
    
    if (seen.has(node)) {
        const existing = seen.get(node);
        
        if (existing.resolved) {
            return existing.value;
        } else {
            deopt(path, state);
            return;
        }
    } else {
        const item = {
            resolved: false,
        };
        
        seen.set(node, item);
        const val = _evaluate(path, state);
        
        if (state.confident) {
            item.resolved = true;
            item.value = val;
        }
        
        return val;
    }
}

function _evaluate(path, state) {
    if (!state.confident)
        return;
    
    if (path.isSequenceExpression()) {
        const exprs = path.get('expressions');
        return evaluateCached(exprs[exprs.length - 1], state);
    }
    
    if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
        return path.node.value;
    }
    
    if (path.isNullLiteral()) {
        return null;
    }
    
    if (path.isTemplateLiteral()) {
        return evaluateQuasis(path, path.node.quasis, state);
    }
    
    if (path.isTaggedTemplateExpression() && path.get('tag').isMemberExpression()) {
        const object = path.get('tag.object');
        const {
            node: {
                name,
            },
        } = object;
        
        const property = path.get('tag.property');
        
        if (object.isIdentifier() && name === 'String' && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === 'raw') {
            return evaluateQuasis(path, path.node.quasi.quasis, state, true);
        }
    }
    
    if (path.isConditionalExpression()) {
        const testResult = evaluateCached(path.get('test'), state);
        
        if (!state.confident)
            return;
        
        if (testResult) {
            return evaluateCached(path.get('consequent'), state);
        } else {
            return evaluateCached(path.get('alternate'), state);
        }
    }
    
    if (path.isExpressionWrapper()) {
        return evaluateCached(path.get('expression'), state);
    }
    
    if (path.isMemberExpression() && !path.parentPath.isCallExpression({callee: path.node})) {
        const property = path.get('property');
        const object = path.get('object');
        
        if (object.isLiteral()) {
            const value = object.node.value;
            const type = typeof value;
            let key = null;
            
            if (path.node.computed) {
                key = evaluateCached(property, state);
                
                if (!state.confident)
                    return;
            } else if (property.isIdentifier()) {
                key = property.node.name;
            }
            
            if ((type === 'number' || type === 'string') && key != null && (typeof key === 'number' || typeof key === 'string')) {
                return value[key];
            }
        }
    }
    
    if (path.isReferencedIdentifier()) {
        const binding = path.scope.getBinding(path.node.name);
        
        if (binding) {
            if (binding.constantViolations.length > 0 || path.node.start < binding.path.node.end) {
                deopt(binding.path, state);
                return;
            }
            
            const bindingPathScope = binding.path.scope;
            
            if (binding.kind === 'var' && bindingPathScope !== binding.scope) {
                let hasUnsafeBlock = !bindingPathScope.path.parentPath.isBlockStatement();
                
                for (let scope2 = bindingPathScope.parent; scope2; scope2 = scope2.parent) {
                    if (scope2 === path.scope) {
                        if (hasUnsafeBlock) {
                            deopt(binding.path, state);
                            return;
                        }
                        
                        break;
                    }
                    
                    if (scope2.path.parentPath?.isBlockStatement()) {
                        hasUnsafeBlock = true;
                    }
                }
            }
            
            if (binding.hasValue) {
                return binding.value;
            }
        }
        
        const name = path.node.name;
        
        if (Globals.has(name)) {
            if (!binding) {
                return Globals.get(name);
            }
            
            deopt(binding.path, state);
            return;
        }
        
        const resolved = path.resolve();
        
        if (resolved === path) {
            deopt(path, state);
            return;
        }
        
        const value = evaluateCached(resolved, state);
        
        if (typeof value === 'object' && value !== null && binding.references > 1) {
            deopt(resolved, state);
            return;
        }
        
        return value;
    }
    
    if (path.isUnaryExpression({prefix: true})) {
        if (path.node.operator === 'void') {
            return void 0;
        }
        
        const argument = path.get('argument');
        
        if (path.node.operator === 'typeof' && (argument.isFunction() || argument.isClass())) {
            return 'function';
        }
        
        const arg = evaluateCached(argument, state);
        
        if (!state.confident)
            return;
        
        switch(path.node.operator) {
        case '!':
            return !arg;
        
        case '+':
            return +arg;
        
        case '-':
            return -arg;
        
        case '~':
            return ~arg;
        
        case 'typeof':
            return typeof arg;
        }
    }
    
    if (path.isArrayExpression()) {
        const arr = [];
        const elems = path.get('elements');
        
        for (const elem of elems) {
            const elemValue = elem.evaluate();
            
            if (elemValue.confident) {
                arr.push(elemValue.value);
            } else {
                deopt(elemValue.deopt, state);
                return;
            }
        }
        
        return arr;
    }
    
    if (path.isObjectExpression()) {
        const obj = {};
        const props = path.get('properties');
        
        for (const prop of props) {
            if (prop.isObjectMethod() || prop.isSpreadElement()) {
                deopt(prop, state);
                return;
            }
            
            const keyPath = prop.get('key');
            let key;
            
            if (prop.node.computed) {
                key = keyPath.evaluate();
                
                if (!key.confident) {
                    deopt(key.deopt, state);
                    return;
                }
                
                key = key.value;
            } else if (keyPath.isIdentifier()) {
                key = keyPath.node.name;
            } else {
                key = keyPath.node.value;
            }
            
            const valuePath = prop.get('value');
            let value = valuePath.evaluate();
            
            if (!value.confident) {
                deopt(value.deopt, state);
                return;
            }
            
            value = value.value;
            obj[key] = value;
        }
        
        return obj;
    }
    
    if (path.isLogicalExpression()) {
        const wasConfident = state.confident;
        const left = evaluateCached(path.get('left'), state);
        const leftConfident = state.confident;
        
        state.confident = wasConfident;
        const right = evaluateCached(path.get('right'), state);
        const rightConfident = state.confident;
        
        switch(path.node.operator) {
        case '||':
            state.confident = leftConfident && (!!left || rightConfident);
            
            if (!state.confident)
                return;
            
            return left || right;
        
        case '&&':
            state.confident = leftConfident && (!left || rightConfident);
            
            if (!state.confident)
                return;
            
            return left && right;
        
        case '??':
            state.confident = leftConfident && (left != null || rightConfident);
            
            if (!state.confident)
                return;
            
            return left ?? right;
        }
    }
    
    if (path.isBinaryExpression()) {
        const left = evaluateCached(path.get('left'), state);
        
        if (!state.confident)
            return;
        
        const right = evaluateCached(path.get('right'), state);
        
        if (!state.confident)
            return;
        
        switch(path.node.operator) {
        case '-':
            return left - right;
        
        case '+':
            return left + right;
        
        case '/':
            return left / right;
        
        case '*':
            return left * right;
        
        case '%':
            return left % right;
        
        case '**':
            return left ** right;
        
        case '<':
            return left < right;
        
        case '>':
            return left > right;
        
        case '<=':
            return left <= right;
        
        case '>=':
            return left >= right;
        
        case '==':
            return left == right;
        
        case '!=':
            return left != right;
        
        case '===':
            return left === right;
        
        case '!==':
            return left !== right;
        
        case '|':
            return left | right;
        
        case '&':
            return left & right;
        
        case '^':
            return left ^ right;
        
        case '<<':
            return left << right;
        
        case '>>':
            return left >> right;
        
        case '>>>':
            return left >>> right;
        }
    }
    
    if (path.isCallExpression()) {
        const callee = path.get('callee');
        let context;
        let func;
        
        if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && (isValidObjectCallee(callee.node.name) || isValidIdentifierCallee(callee.node.name))) {
            func = commonjsGlobal[callee.node.name];
        }
        
        if (callee.isMemberExpression()) {
            const object = callee.get('object');
            const property = callee.get('property');
            
            if (object.isIdentifier() && property.isIdentifier() && isValidObjectCallee(object.node.name) && !isInvalidMethod(property.node.name)) {
                context = commonjsGlobal[object.node.name];
                const key = property.node.name;
                
                if (Object.hasOwn(context, key)) {
                    func = context[key];
                }
            }
            
            if (object.isLiteral() && property.isIdentifier()) {
                const type = typeof object.node.value;
                
                if (type === 'string' || type === 'number') {
                    context = object.node.value;
                    func = context[property.node.name];
                }
            }
        }
        
        if (func) {
            const args = path.get('arguments').map((arg) => evaluateCached(arg, state));
            
            if (!state.confident)
                return;
            
            return func.apply(context, args);
        }
    }
    
    deopt(path, state);
}

function evaluateQuasis(path, quasis, state, raw = false) {
    let str = '';
    let i = 0;
    const exprs = path.isTemplateLiteral() ? path.get('expressions') : path.get('quasi.expressions');
    
    for (const elem of quasis) {
        if (!state.confident)
            break;
        
        str += raw ? elem.value.raw : elem.value.cooked;
        const expr = exprs[i++];
        
        if (expr)
            str += String(evaluateCached(expr, state));
    }
    
    if (!state.confident)
        return;
    
    return str;
}

function evaluate() {
    const state = {
        confident: true,
        deoptPath: null,
        seen:         /* @__PURE__ */new Map(),
    };
    
    let value = evaluateCached(this, state);
    
    if (!state.confident)
        value = void 0;
    
    return {
        confident: state.confident,
        deopt: state.deoptPath,
        value,
    };
}

var {
    arrowFunctionExpression: arrowFunctionExpression2,
    assignmentExpression: assignmentExpression2,
    binaryExpression: binaryExpression2,
    blockStatement: blockStatement3,
    callExpression: callExpression2,
    conditionalExpression: conditionalExpression2,
    expressionStatement: expressionStatement3,
    identifier: identifier3,
    isIdentifier: isIdentifier$12,
    jsxIdentifier: jsxIdentifier2,
    logicalExpression: logicalExpression2,
    LOGICAL_OPERATORS: LOGICAL_OPERATORS2,
    memberExpression: memberExpression2,
    metaProperty: metaProperty2,
    numericLiteral: numericLiteral$1,
    objectExpression: objectExpression2,
    restElement: restElement2,
    returnStatement: returnStatement2,
    sequenceExpression: sequenceExpression2,
    spreadElement: spreadElement2,
    stringLiteral: stringLiteral3,
    super: _super2,
    thisExpression: thisExpression2,
    toExpression: toExpression2,
    unaryExpression: unaryExpression$1$1,
    toBindingIdentifierName: toBindingIdentifierName2,
    isFunction: isFunction4,
    isAssignmentPattern: isAssignmentPattern3,
    isRestElement: isRestElement2,
    getFunctionName: getFunctionName2,
    cloneNode: cloneNode3,
    variableDeclaration: variableDeclaration2,
    variableDeclarator: variableDeclarator2,
    exportNamedDeclaration: exportNamedDeclaration2,
    exportSpecifier: exportSpecifier2,
    inherits: inherits2,
} = lib_exports;

function toComputedKey2() {
    let key;
    
    if (this.isMemberExpression()) {
        key = this.node.property;
    } else if (this.isProperty() || this.isMethod()) {
        key = this.node.key;
    } else {
        throw new ReferenceError('todo');
    }
    
    if (!this.node.computed) {
        if (isIdentifier$12(key))
            key = stringLiteral3(key.name);
    }
    
    return key;
}

function ensureBlock2() {
    const body = this.get('body');
    const bodyNode = body.node;
    
    if (Array.isArray(body)) {
        throw new Error('Can\'t convert array path to a block statement');
    }
    
    if (!bodyNode) {
        throw new Error('Can\'t convert node without a body');
    }
    
    if (body.isBlockStatement()) {
        return bodyNode;
    }
    
    const statements2 = [];
    let stringPath = 'body';
    let key;
    let listKey;
    
    if (body.isStatement()) {
        listKey = 'body';
        key = 0;
        statements2.push(body.node);
    } else {
        stringPath += '.body.0';
        
        if (this.isFunction()) {
            key = 'argument';
            statements2.push(returnStatement2(body.node));
        } else {
            key = 'expression';
            statements2.push(expressionStatement3(body.node));
        }
    }
    
    this.node.body = blockStatement3(statements2);
    const parentPath = this.get(stringPath);
    setup$1.call(body, parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
    return this.node;
}

function unwrapFunctionEnvironment() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
        throw this.buildCodeFrameError('Can only unwrap the environment of a function.');
    }
    
    hoistFunctionEnvironment(this);
}

function setType(path, type) {
    path.node.type = type;
}

function arrowFunctionToExpression({allowInsertArrow = true, allowInsertArrowWithRest = allowInsertArrow, noNewArrows = true} = {}) {
    if (!this.isArrowFunctionExpression()) {
        throw this.buildCodeFrameError('Cannot convert non-arrow function to a function expression.');
    }
    
    let self = this;
    
    if (!noNewArrows) {
        self = self.ensureFunctionName(false) ?? self;
    }
    
    const {thisBinding, fnPath: fn} = hoistFunctionEnvironment(self, noNewArrows, allowInsertArrow, allowInsertArrowWithRest);
    
    fn.ensureBlock();
    setType(fn, 'FunctionExpression');
    
    if (!noNewArrows) {
        const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier('arrowCheckId');
        
        if (checkBinding) {
            fn.parentPath.scope.push({
                id: checkBinding,
                init: objectExpression2([]),
            });
        }
        
        fn.get('body').unshiftContainer('body', expressionStatement3(callExpression2(this.hub.addHelper('newArrowCheck'), [thisExpression2(), checkBinding ? identifier3(checkBinding.name) : identifier3(thisBinding)])));
        fn.replaceWith(callExpression2(memberExpression2(fn.node, identifier3('bind')), [checkBinding ? identifier3(checkBinding.name) : thisExpression2()]));
        return fn.get('callee.object');
    }
    
    return fn;
}

var getSuperCallsVisitor = environmentVisitor({
    CallExpression(child, {allSuperCalls}) {
        if (!child.get('callee').isSuper())
            return;
        
        allSuperCalls.push(child);
    },
});

function hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true, allowInsertArrowWithRest = true) {
    let arrowParent;
    let thisEnvFn = fnPath.findParent((p) => {
        if (p.isArrowFunctionExpression()) {
            arrowParent ?? (arrowParent = p);
            return false;
        }
        
        return p.isFunction()
            || p.isProgram()
            || p.isClassProperty({
            static: false,
        })
            || p.isClassPrivateProperty({
            static: false,
        });
    });
    
    const inConstructor = thisEnvFn.isClassMethod({
        kind: 'constructor',
    });
    
    if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {
        if (arrowParent) {
            thisEnvFn = arrowParent;
        } else if (allowInsertArrow) {
            fnPath.replaceWith(callExpression2(arrowFunctionExpression2([], toExpression2(fnPath.node)), []));
            thisEnvFn = fnPath.get('callee');
            fnPath = thisEnvFn.get('body');
        } else {
            throw fnPath.buildCodeFrameError('Unable to transform arrow inside class property');
        }
    }
    
    const {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls,
    } = getScopeInformation(fnPath);
    
    if (inConstructor && superCalls.length > 0) {
        if (!allowInsertArrow) {
            throw superCalls[0].buildCodeFrameError('When using \'@babel/plugin-transform-arrow-functions\', it\'s not possible to compile `super()` in an arrow function without compiling classes.\nPlease add \'@babel/plugin-transform-classes\' to your Babel configuration.');
        }
        
        if (!allowInsertArrowWithRest) {
            throw superCalls[0].buildCodeFrameError('When using \'@babel/plugin-transform-parameters\', it\'s not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add \'@babel/plugin-transform-classes\' to your Babel configuration.');
        }
        
        const allSuperCalls = [];
        
        thisEnvFn.traverse(getSuperCallsVisitor, {
            allSuperCalls,
        });
        const superBinding = getSuperBinding(thisEnvFn);
        
        allSuperCalls.forEach((superCall) => {
            const callee = identifier3(superBinding);
            
            callee.loc = superCall.node.callee.loc;
            superCall.get('callee').replaceWith(callee);
        });
    }
    
    if (argumentsPaths.length > 0) {
        const argumentsBinding = getBinding$3(thisEnvFn, 'arguments', () => {
            const args = () => identifier3('arguments');
            
            if (thisEnvFn.scope.path.isProgram()) {
                return conditionalExpression2(binaryExpression2('===', unaryExpression$1$1('typeof', args()), stringLiteral3('undefined')), thisEnvFn.scope.buildUndefinedNode(), args());
            } else {
                return args();
            }
        });
        
        argumentsPaths.forEach((argumentsChild) => {
            const argsRef = identifier3(argumentsBinding);
            
            argsRef.loc = argumentsChild.node.loc;
            argumentsChild.replaceWith(argsRef);
        });
    }
    
    if (newTargetPaths.length > 0) {
        const newTargetBinding = getBinding$3(thisEnvFn, 'newtarget', () => metaProperty2(identifier3('new'), identifier3('target')));
        
        newTargetPaths.forEach((targetChild) => {
            const targetRef = identifier3(newTargetBinding);
            
            targetRef.loc = targetChild.node.loc;
            targetChild.replaceWith(targetRef);
        });
    }
    
    if (superProps.length > 0) {
        if (!allowInsertArrow) {
            throw superProps[0].buildCodeFrameError('When using \'@babel/plugin-transform-arrow-functions\', it\'s not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add \'@babel/plugin-transform-classes\' to your Babel configuration.');
        }
        
        const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);
        
        flatSuperProps.forEach((superProp) => {
            const key = superProp.node.computed ? '' : superProp.get('property').node.name;
            const superParentPath = superProp.parentPath;
            const isAssignment = superParentPath.isAssignmentExpression({
                left: superProp.node,
            });
            
            const isCall = superParentPath.isCallExpression({
                callee: superProp.node,
            });
            
            const isTaggedTemplate = superParentPath.isTaggedTemplateExpression({
                tag: superProp.node,
            });
            
            const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
            const args = [];
            
            if (superProp.node.computed) {
                args.push(superProp.get('property').node);
            }
            
            if (isAssignment) {
                const value = superParentPath.node.right;
                args.push(value);
            }
            
            const call2 = callExpression2(identifier3(superBinding), args);
            
            if (isCall) {
                superParentPath.unshiftContainer('arguments', thisExpression2());
                superProp.replaceWith(memberExpression2(call2, identifier3('call')));
                thisPaths.push(superParentPath.get('arguments.0'));
            } else if (isAssignment) {
                superParentPath.replaceWith(call2);
            } else if (isTaggedTemplate) {
                superProp.replaceWith(callExpression2(memberExpression2(call2, identifier3('bind'), false), [thisExpression2()]));
                thisPaths.push(superProp.get('arguments.0'));
            } else {
                superProp.replaceWith(call2);
            }

        });
    }
    
    let thisBinding;
    
    if (thisPaths.length > 0 || !noNewArrows) {
        thisBinding = getThisBinding(thisEnvFn, inConstructor);
        
        if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {
            thisPaths.forEach((thisChild) => {
                const thisRef = thisChild.isJSX() ? jsxIdentifier2(thisBinding) : identifier3(thisBinding);
                
                thisRef.loc = thisChild.node.loc;
                thisChild.replaceWith(thisRef);
            });
            
            if (!noNewArrows)
                thisBinding = null;
        }
    }
    
    return {
        thisBinding,
        fnPath,
    };
}

function isLogicalOp(op) {
    return LOGICAL_OPERATORS2.includes(op);
}

function standardizeSuperProperty(superProp) {
    if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== '=') {
        const assignmentPath = superProp.parentPath;
        const op = assignmentPath.node.operator.slice(0, -1);
        const value = assignmentPath.node.right;
        const isLogicalAssignment = isLogicalOp(op);
        
        if (superProp.node.computed) {
            const tmp = superProp.scope.generateDeclaredUidIdentifier('tmp');
            const object = superProp.node.object;
            const property = superProp.node.property;
            
            assignmentPath.get('left').replaceWith(memberExpression2(object, assignmentExpression2('=', tmp, property), true));
            assignmentPath.get('right').replaceWith(rightExpression(isLogicalAssignment ? '=' : op, memberExpression2(object, identifier3(tmp.name), true), value));
        } else {
            const object = superProp.node.object;
            const property = superProp.node.property;
            assignmentPath.get('left').replaceWith(memberExpression2(object, property));
            assignmentPath.get('right').replaceWith(rightExpression(isLogicalAssignment ? '=' : op, memberExpression2(object, identifier3(property.name)), value));
        }
        
        if (isLogicalAssignment) {
            assignmentPath.replaceWith(logicalExpression2(op, assignmentPath.node.left, assignmentPath.node.right));
        } else {
            assignmentPath.node.operator = '=';
        }
        
        return [
            assignmentPath.get('left'),
            assignmentPath.get('right').get('left'),
        ];
    } else if (superProp.parentPath.isUpdateExpression()) {
        const updateExpr = superProp.parentPath;
        const tmp = superProp.scope.generateDeclaredUidIdentifier('tmp');
        const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier('prop') : null;
        const parts = [
            assignmentExpression2('=', tmp, memberExpression2(superProp.node.object, computedKey ? assignmentExpression2('=', computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)),
            assignmentExpression2('=', memberExpression2(superProp.node.object, computedKey ? identifier3(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression2(superProp.parentPath.node.operator[0], identifier3(tmp.name), numericLiteral$1(1))),
        ];
        
        if (!superProp.parentPath.node.prefix) {
            parts.push(identifier3(tmp.name));
        }
        
        updateExpr.replaceWith(sequenceExpression2(parts));
        const left = updateExpr.get('expressions.0.right');
        const right = updateExpr.get('expressions.1.left');
        
        return [left, right];
    }
    
    return [superProp];
    function rightExpression(op, left, right) {
        if (op === '=') {
            return assignmentExpression2('=', left, right);
        } else {
            return binaryExpression2(op, left, right);
        }
    }
}

function hasSuperClass(thisEnvFn) {
    return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
}

var assignSuperThisVisitor = environmentVisitor({
    CallExpression(child, {supers, thisBinding}) {
        if (!child.get('callee').isSuper())
            return;
        
        if (supers.has(child.node))
            return;
        
        supers.add(child.node);
        child.replaceWithMultiple([child.node, assignmentExpression2('=', identifier3(thisBinding), identifier3('this'))]);
    },
});

function getThisBinding(thisEnvFn, inConstructor) {
    return getBinding$3(thisEnvFn, 'this', (thisBinding) => {
        if (!inConstructor || !hasSuperClass(thisEnvFn))
            return thisExpression2();
        
        thisEnvFn.traverse(assignSuperThisVisitor, {
            supers:             /* @__PURE__ */new WeakSet(),
            thisBinding,
        });
    });
}

function getSuperBinding(thisEnvFn) {
    return getBinding$3(thisEnvFn, 'supercall', () => {
        const argsBinding = thisEnvFn.scope.generateUidIdentifier('args');
        return arrowFunctionExpression2([restElement2(argsBinding)], callExpression2(_super2(), [spreadElement2(identifier3(argsBinding.name))]));
    });
}

function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
    const op = isAssignment ? 'set' : 'get';
    
    return getBinding$3(thisEnvFn, `superprop_${op}:${propName || ''}`, () => {
        const argsList = [];
        let fnBody;
        
        if (propName) {
            fnBody = memberExpression2(_super2(), identifier3(propName));
        } else {
            const method = thisEnvFn.scope.generateUidIdentifier('prop');
            argsList.unshift(method);
            fnBody = memberExpression2(_super2(), identifier3(method.name), true);
        }
        
        if (isAssignment) {
            const valueIdent = thisEnvFn.scope.generateUidIdentifier('value');
            argsList.push(valueIdent);
            fnBody = assignmentExpression2('=', fnBody, identifier3(valueIdent.name));
        }
        
        return arrowFunctionExpression2(argsList, fnBody);
    });
}

function getBinding$3(thisEnvFn, key, init) {
    const cacheKey = 'binding:' + key;
    let data = thisEnvFn.getData(cacheKey);
    
    if (!data) {
        const id = thisEnvFn.scope.generateUidIdentifier(key);
        
        data = id.name;
        thisEnvFn.setData(cacheKey, data);
        thisEnvFn.scope.push({
            id,
            init: init(data),
        });
    }
    
    return data;
}

var getScopeInformationVisitor = environmentVisitor({
    ThisExpression(child, {thisPaths}) {
        thisPaths.push(child);
    },
    JSXIdentifier(child, {thisPaths}) {
        if (child.node.name !== 'this')
            return;
        
        if (!child.parentPath.isJSXMemberExpression({object: child.node}) && !child.parentPath.isJSXOpeningElement({name: child.node})) {
            return;
        }
        
        thisPaths.push(child);
    },
    CallExpression(child, {superCalls}) {
        if (child.get('callee').isSuper())
            superCalls.push(child);
    },
    MemberExpression(child, {superProps}) {
        if (child.get('object').isSuper())
            superProps.push(child);
    },
    Identifier(child, {argumentsPaths}) {
        if (!child.isReferencedIdentifier({name: 'arguments'}))
            return;
        
        let curr = child.scope;
        
        do {
            if (curr.hasOwnBinding('arguments')) {
                curr.rename('arguments');
                return;
            }
            
            if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {
                break;
            }
        } while (curr = curr.parent)
        argumentsPaths.push(child);
    },
    MetaProperty(child, {newTargetPaths}) {
        if (!child.get('meta').isIdentifier({name: 'new'}))
            return;
        
        if (!child.get('property').isIdentifier({name: 'target'}))
            return;
        
        newTargetPaths.push(child);
    },
});

function getScopeInformation(fnPath) {
    const thisPaths = [];
    const argumentsPaths = [];
    const newTargetPaths = [];
    const superProps = [];
    const superCalls = [];
    
    fnPath.traverse(getScopeInformationVisitor, {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls,
    });
    return {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls,
    };
}

function splitExportDeclaration() {
    if (!this.isExportDeclaration() || this.isExportAllDeclaration()) {
        throw new Error('Only default and named export declarations can be split.');
    }
    
    if (this.isExportNamedDeclaration() && this.get('specifiers').length > 0) {
        throw new Error('It doesn\'t make sense to split exported specifiers.');
    }
    
    const declaration = this.get('declaration');
    
    if (this.isExportDefaultDeclaration()) {
        const standaloneDeclaration = declaration.isFunctionDeclaration() || declaration.isClassDeclaration();
        const exportExpr = declaration.isFunctionExpression() || declaration.isClassExpression();
        const scope2 = declaration.isScope() ? declaration.scope.parent : declaration.scope;
        let id = declaration.node.id;
        let needBindingRegistration = false;
        
        if (!id) {
            needBindingRegistration = true;
            id = scope2.generateUidIdentifier('default');
            
            if (standaloneDeclaration || exportExpr) {
                declaration.node.id = cloneNode3(id);
            }
        } else if (exportExpr && scope2.hasBinding(id.name)) {
            needBindingRegistration = true;
            id = scope2.generateUidIdentifier(id.name);
        }
        
        const updatedDeclaration = standaloneDeclaration ? declaration.node : variableDeclaration2('var', [variableDeclarator2(cloneNode3(id), declaration.node)]);
        const updatedExportDeclaration = exportNamedDeclaration2(null, [exportSpecifier2(cloneNode3(id), identifier3('default'))]);
        
        this.insertAfter(updatedExportDeclaration);
        this.replaceWith(updatedDeclaration);
        
        if (needBindingRegistration) {
            scope2.registerDeclaration(this);
        }
        
        return this;
    } else if (this.get('specifiers').length > 0) {
        throw new Error('It doesn\'t make sense to split exported specifiers.');
    }
    
    const bindingIdentifiers = declaration.getOuterBindingIdentifiers();
    
    const specifiers = Object
        .keys(bindingIdentifiers)
        .map((name) => {
        return exportSpecifier2(identifier3(name), identifier3(name));
    });
    
    const aliasDeclar = exportNamedDeclaration2(null, specifiers);
    
    this.insertAfter(aliasDeclar);
    this.replaceWith(declaration.node);
    return this;
}

var refersOuterBindingVisitor = {
    'ReferencedIdentifier|BindingIdentifier'(path, state) {
        if (path.node.name !== state.name)
            return;
        
        state.needsRename = true;
        path.stop();
    },
    Scope(path, state) {
        if (path.scope.hasOwnBinding(state.name)) {
            path.skip();
        }
    },
};

function ensureFunctionName(supportUnicodeId) {
    if (this.node.id)
        return this;
    
    const res = getFunctionName2(this.node, this.parent);
    
    if (res == null)
        return this;
    
    let {name} = res;
    
    if (!supportUnicodeId && /[\uD800-\uDFFF]/.test(name)) {
        return null;
    }
    
    if (name.startsWith('get ') || name.startsWith('set ')) {
        return null;
    }
    
    name = toBindingIdentifierName2(name.replace(/[/ ]/g, '_'));
    const id = identifier3(name);
    inherits2(id, res.originalNode);
    const state = {
        needsRename: false,
        name,
    };
    
    const {scope: scope2} = this;
    
    const binding = scope2.getOwnBinding(name);
    
    if (binding) {
        if (binding.kind === 'param') {
            state.needsRename = true;
        }
    } else if (scope2.parent.hasBinding(name) || scope2.hasGlobal(name)) {
        this.traverse(refersOuterBindingVisitor, state);
    }
    
    if (!state.needsRename) {
        this.node.id = id;
        {
            scope2
                .getProgramParent()
                .referencesSet
                .add(id.name);
        }
        
        return this;
    }
    
    if (scope2.hasBinding(id.name) && !scope2.hasGlobal(id.name)) {
        scope2.rename(id.name);
        this.node.id = id;
        {
            scope2
                .getProgramParent()
                .referencesSet
                .add(id.name);
        }
        
        return this;
    }
    
    if (!isFunction4(this.node))
        return null;
    
    const key = scope2.generateUidIdentifier(id.name);
    const params = [];
    
    for (let i = 0, len = getFunctionArity(this.node); i < len; i++) {
        params.push(scope2.generateUidIdentifier('x'));
    }
    
    const call2 = index$1.expression.ast`
    (function (${key}) {
      function ${id}(${params}) {
        return ${cloneNode3(key)}.apply(this, arguments);
      }

      ${cloneNode3(id)}.toString = function () {
        return ${cloneNode3(key)}.toString();
      }

      return ${cloneNode3(id)};
    })(${toExpression2(this.node)})
  `;
    
    return this
        .replaceWith(call2)[0]
        .get('arguments.0');
}

function getFunctionArity(node) {
    const count = node.params.findIndex((param) => isAssignmentPattern3(param) || isRestElement2(param));
    return count === -1 ? node.params.length : count;
}

var {
    STATEMENT_OR_BLOCK_KEYS: STATEMENT_OR_BLOCK_KEYS2,
    VISITOR_KEYS: VISITOR_KEYS$3,
    isBlockStatement: isBlockStatement3,
    isExpression: isExpression3,
    isIdentifier: isIdentifier4,
    isLiteral: isLiteral3,
    isStringLiteral: isStringLiteral4,
    isType: isType3,
    matchesPattern: _matchesPattern,
} = lib_exports;

function matchesPattern2(pattern, allowPartial) {
    return _matchesPattern(this.node, pattern, allowPartial);
}

function isStatic() {
    return this.scope.isStatic(this.node);
}

function isNodeType(type) {
    return isType3(this.type, type);
}

function canHaveVariableDeclarationOrExpression() {
    return (this.key === 'init' || this.key === 'left') && this.parentPath.isFor();
}

function canSwapBetweenExpressionAndStatement(replacement) {
    if (this.key !== 'body' || !this.parentPath.isArrowFunctionExpression()) {
        return false;
    }
    
    if (this.isExpression()) {
        return isBlockStatement3(replacement);
    } else if (this.isBlockStatement()) {
        return isExpression3(replacement);
    }
    
    return false;
}

function isCompletionRecord(allowInsideFunction) {
    let path = this;
    let first = true;
    
    do {
        const {type, container} = path;
        
        if (!first && (path.isFunction() || type === 'StaticBlock')) {
            return !!allowInsideFunction;
        }
        
        first = false;
        
        if (Array.isArray(container) && path.key !== container.length - 1) {
            return false;
        }
    } while ((path = path.parentPath) && !path.isProgram() && !path.isDoExpression())
    
    return true;
}

function isStatementOrBlock() {
    if (this.parentPath.isLabeledStatement() || isBlockStatement3(this.container)) {
        return false;
    } else {
        return STATEMENT_OR_BLOCK_KEYS2.includes(this.key);
    }
}

function referencesImport(moduleSource, importName) {
    if (!this.isReferencedIdentifier()) {
        if (this.isJSXMemberExpression() && this.node.property.name === importName || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral4(this.node.property, {value: importName}) : this.node.property.name === importName)) {
            const object = this.get('object');
            return object.isReferencedIdentifier() && object.referencesImport(moduleSource, '*');
        }
        
        return false;
    }
    
    const binding = this.scope.getBinding(this.node.name);
    
    if (!binding || binding.kind !== 'module')
        return false;
    
    const path = binding.path;
    const parent = path.parentPath;
    
    if (!parent.isImportDeclaration())
        return false;
    
    if (parent.node.source.value === moduleSource) {
        if (!importName)
            return true;
    } else {
        return false;
    }
    
    if (path.isImportDefaultSpecifier() && importName === 'default') {
        return true;
    }
    
    if (path.isImportNamespaceSpecifier() && importName === '*') {
        return true;
    }
    
    if (path.isImportSpecifier() && isIdentifier4(path.node.imported, {name: importName})) {
        return true;
    }
    
    return false;
}

function getSource() {
    const node = this.node;
    
    if (node.end) {
        const code2 = this.hub.getCode();
        
        if (code2)
            return code2.slice(node.start, node.end);
    }
    
    return '';
}

function willIMaybeExecuteBefore(target) {
    return this._guessExecutionStatusRelativeTo(target) !== 'after';
}

function getOuterFunction(path) {
    return path.isProgram() ? path : (path.parentPath.scope.getFunctionParent() || path.parentPath.scope.getProgramParent()).path;
}

function isExecutionUncertain(type, key) {
    switch(type) {
    case 'LogicalExpression':
        return key === 'right';
    
    case 'ConditionalExpression':    
    case 'IfStatement':
        return key === 'consequent' || key === 'alternate';
    
    case 'WhileStatement':    
    case 'DoWhileStatement':    
    case 'ForInStatement':    
    case 'ForOfStatement':
        return key === 'body';
    
    case 'ForStatement':
        return key === 'body' || key === 'update';
    
    case 'SwitchStatement':
        return key === 'cases';
    
    case 'TryStatement':
        return key === 'handler';
    
    case 'AssignmentPattern':
        return key === 'right';
    
    case 'OptionalMemberExpression':
        return key === 'property';
    
    case 'OptionalCallExpression':
        return key === 'arguments';
    
    default:
        return false;
    }
}

function isExecutionUncertainInList(paths, maxIndex) {
    for (let i = 0; i < maxIndex; i++) {
        const path = paths[i];
        
        if (isExecutionUncertain(path.parent.type, path.parentKey)) {
            return true;
        }
    }
    
    return false;
}

var SYMBOL_CHECKING = Symbol();

function _guessExecutionStatusRelativeTo(target) {
    return _guessExecutionStatusRelativeToCached(this, target,     /* @__PURE__ */new Map());
}

function _guessExecutionStatusRelativeToCached(base, target, cache2) {
    const funcParent = {
        this: getOuterFunction(base),
        target: getOuterFunction(target),
    };
    
    if (funcParent.target.node !== funcParent.this.node) {
        return _guessExecutionStatusRelativeToDifferentFunctionsCached(base, funcParent.target, cache2);
    }
    
    const paths = {
        target: target.getAncestry(),
        this: base.getAncestry(),
    };
    
    if (paths.target.includes(base))
        return 'after';
    
    if (paths.this.includes(target))
        return 'before';
    
    let commonPath;
    
    const commonIndex = {
        target: 0,
        this: 0,
    };
    
    while (!commonPath && commonIndex.this < paths.this.length) {
        const path = paths.this[commonIndex.this];
        
        commonIndex.target = paths.target.indexOf(path);
        
        if (commonIndex.target >= 0) {
            commonPath = path;
        } else {
            commonIndex.this++;
        }
    }
    
    if (!commonPath) {
        throw new Error('Internal Babel error - The two compared nodes don\'t appear to belong to the same program.');
    }
    
    if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {
        return 'unknown';
    }
    
    const divergence = {
        this: paths.this[commonIndex.this - 1],
        target: paths.target[commonIndex.target - 1],
    };
    
    if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {
        return divergence.target.key > divergence.this.key ? 'before' : 'after';
    }
    
    const keys2 = VISITOR_KEYS$3[commonPath.type];
    
    const keyPosition = {
        this: keys2.indexOf(divergence.this.parentKey),
        target: keys2.indexOf(divergence.target.parentKey),
    };
    
    return keyPosition.target > keyPosition.this ? 'before' : 'after';
}

function _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache2) {
    if (!target.isFunctionDeclaration()) {
        if (_guessExecutionStatusRelativeToCached(base, target, cache2) === 'before') {
            return 'before';
        }
        
        return 'unknown';
    } else if (target.parentPath.isExportDeclaration()) {
        return 'unknown';
    }
    
    const binding = target.scope.getBinding(target.node.id.name);
    
    if (!binding.references)
        return 'before';
    
    const referencePaths = binding.referencePaths;
    let allStatus;
    
    for (const path of referencePaths) {
        const childOfFunction = !!path.find((path2) => path2.node === target.node);
        
        if (childOfFunction)
            continue;
        
        if (path.key !== 'callee' || !path.parentPath.isCallExpression()) {
            return 'unknown';
        }
        
        const status = _guessExecutionStatusRelativeToCached(base, path, cache2);
        
        if (allStatus && allStatus !== status) {
            return 'unknown';
        } else {
            allStatus = status;
        }
    }
    
    return allStatus;
}

function _guessExecutionStatusRelativeToDifferentFunctionsCached(base, target, cache2) {
    let nodeMap = cache2.get(base.node);
    let cached;
    
    if (!nodeMap) {
        cache2.set(base.node, nodeMap =         /* @__PURE__ */new Map());
    } else if (cached = nodeMap.get(target.node)) {
        if (cached === SYMBOL_CHECKING) {
            return 'unknown';
        }
        
        return cached;
    }
    
    nodeMap.set(target.node, SYMBOL_CHECKING);
    const result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache2);
    nodeMap.set(target.node, result);
    return result;
}

function resolve2(dangerous, resolved) {
    return _resolve.call(this, dangerous, resolved) || this;
}

function _resolve(dangerous, resolved) {
    if (resolved?.includes(this))
        return;
    
    resolved = resolved || [];
    resolved.push(this);
    
    if (this.isVariableDeclarator()) {
        if (this.get('id').isIdentifier()) {
            return this
                .get('init')
                .resolve(dangerous, resolved);
        }
    } else if (this.isReferencedIdentifier()) {
        const binding = this.scope.getBinding(this.node.name);
        
        if (!binding)
            return;
        
        if (!binding.constant)
            return;
        
        if (binding.kind === 'module')
            return;
        
        if (binding.path !== this) {
            const ret = binding.path.resolve(dangerous, resolved);
            
            if (this.find((parent) => parent.node === ret.node))
                return;
            
            return ret;
        }
    } else if (this.isTypeCastExpression()) {
        return this
            .get('expression')
            .resolve(dangerous, resolved);
    } else if (dangerous && this.isMemberExpression()) {
        const targetKey = this.toComputedKey();
        
        if (!isLiteral3(targetKey))
            return;
        
        const targetName = targetKey.value;
        const target = this
            .get('object')
            .resolve(dangerous, resolved);
        
        if (target.isObjectExpression()) {
            const props = target.get('properties');
            
            for (const prop of props) {
                if (!prop.isProperty())
                    continue;
                
                const key = prop.get('key');
                let match = prop.isnt('computed') && key.isIdentifier({
                    name: targetName,
                });
                
                match = match || key.isLiteral({
                    value: targetName,
                });
                
                if (match)
                    return prop.get('value').resolve(dangerous, resolved);
            }
        } else if (target.isArrayExpression() && !isNaN(+targetName)) {
            const elems = target.get('elements');
            const elem = elems[targetName];
            
            if (elem)
                return elem.resolve(dangerous, resolved);
        }
    }


}

function isConstantExpression() {
    if (this.isIdentifier()) {
        const binding = this.scope.getBinding(this.node.name);
        
        if (!binding)
            return false;
        
        return binding.constant;
    }
    
    if (this.isLiteral()) {
        if (this.isRegExpLiteral()) {
            return false;
        }
        
        if (this.isTemplateLiteral()) {
            return this
                .get('expressions')
                .every((expression2) => expression2.isConstantExpression());
        }
        
        return true;
    }
    
    if (this.isUnaryExpression()) {
        if (this.node.operator !== 'void') {
            return false;
        }
        
        return this
            .get('argument')
            .isConstantExpression();
    }
    
    if (this.isBinaryExpression()) {
        const {operator} = this.node;
        
        return operator !== 'in'
            && operator !== 'instanceof'
            && this
            .get('left')
            .isConstantExpression()
            && this
            .get('right')
            .isConstantExpression();
    }
    
    if (this.isMemberExpression()) {
        return !this.node.computed && this
            .get('object')
            .isIdentifier({
                name: 'Symbol',
            }) && !this.scope.hasBinding('Symbol', {
            noGlobals: true,
        });
    }
    
    if (this.isCallExpression()) {
        return this.node.arguments.length === 1
            && this
            .get('callee')
            .matchesPattern('Symbol.for')
            && !this.scope.hasBinding('Symbol', {
            noGlobals: true,
        })
            && this
            .get('arguments')[0]
            .isStringLiteral();
    }
    
    return false;
}

function isInStrictMode() {
    const start = this.isProgram() ? this : this.parentPath;
    const strictParent = start.find((path) => {
        if (path.isProgram({sourceType: 'module'}))
            return true;
        
        if (path.isClass())
            return true;
        
        if (path.isArrowFunctionExpression() && !path.get('body').isBlockStatement()) {
            return false;
        }
        
        let body;
        
        if (path.isFunction()) {
            body = path.node.body;
        } else if (path.isProgram()) {
            body = path.node;
        } else {
            return false;
        }
        
        for (const directive2 of body.directives) {
            if (directive2.value.value === 'use strict') {
                return true;
            }
        }
    });
    
    return !!strictParent;
}

var {
    getAssignmentIdentifiers: _getAssignmentIdentifiers,
    getBindingIdentifiers: _getBindingIdentifiers,
    getOuterBindingIdentifiers: _getOuterBindingIdentifiers,
    numericLiteral: numericLiteral2,
    unaryExpression: unaryExpression2,
} = lib_exports;

var NORMAL_COMPLETION = 0;
var BREAK_COMPLETION = 1;

function NormalCompletion(path) {
    return {
        type: NORMAL_COMPLETION,
        path,
    };
}

function BreakCompletion(path) {
    return {
        type: BREAK_COMPLETION,
        path,
    };
}

function getOpposite() {
    if (this.key === 'left') {
        return this.getSibling('right');
    } else if (this.key === 'right') {
        return this.getSibling('left');
    }
    
    return null;
}

function addCompletionRecords(path, records, context) {
    if (path) {
        records.push(..._getCompletionRecords(path, context));
    }
    
    return records;
}

function completionRecordForSwitch(cases, records, context) {
    let lastNormalCompletions = [];
    
    for (let i = 0; i < cases.length; i++) {
        const casePath = cases[i];
        const caseCompletions = _getCompletionRecords(casePath, context);
        const normalCompletions = [];
        const breakCompletions = [];
        
        for (const c of caseCompletions) {
            if (c.type === NORMAL_COMPLETION) {
                normalCompletions.push(c);
            }
            
            if (c.type === BREAK_COMPLETION) {
                breakCompletions.push(c);
            }
        }
        
        if (normalCompletions.length) {
            lastNormalCompletions = normalCompletions;
        }
        
        records.push(...breakCompletions);
    }
    
    records.push(...lastNormalCompletions);
    
    return records;
}

function normalCompletionToBreak(completions) {
    completions.forEach((c) => {
        c.type = BREAK_COMPLETION;
    });
}

function replaceBreakStatementInBreakCompletion(completions, reachable) {
    completions.forEach((c) => {
        if (c.path.isBreakStatement({label: null})) {
            if (reachable) {
                c.path.replaceWith(unaryExpression2('void', numericLiteral2(0)));
            } else {
                c.path.remove();
            }
        }
    });
}

function getStatementListCompletion(paths, context) {
    const completions = [];
    
    if (context.canHaveBreak) {
        let lastNormalCompletions = [];
        
        for (let i = 0; i < paths.length; i++) {
            const path = paths[i];
            const newContext = Object.assign({}, context, {
                inCaseClause: false,
            });
            
            if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {
                newContext.shouldPopulateBreak = true;
            } else {
                newContext.shouldPopulateBreak = false;
            }
            
            const statementCompletions = _getCompletionRecords(path, newContext);
            
            if (statementCompletions.length > 0 && statementCompletions.every((c) => c.type === BREAK_COMPLETION)) {
                if (lastNormalCompletions.length > 0 && statementCompletions.every((c) => c.path.isBreakStatement({label: null}))) {
                    normalCompletionToBreak(lastNormalCompletions);
                    completions.push(...lastNormalCompletions);
                    
                    if (lastNormalCompletions.some((c) => c.path.isDeclaration())) {
                        completions.push(...statementCompletions);
                        
                        if (!context.shouldPreserveBreak) {
                            replaceBreakStatementInBreakCompletion(statementCompletions, true);
                        }
                    }
                    
                    if (!context.shouldPreserveBreak) {
                        replaceBreakStatementInBreakCompletion(statementCompletions, false);
                    }
                } else {
                    completions.push(...statementCompletions);
                    
                    if (!context.shouldPopulateBreak && !context.shouldPreserveBreak) {
                        replaceBreakStatementInBreakCompletion(statementCompletions, true);
                    }
                }
                
                break;
            }
            
            if (i === paths.length - 1) {
                completions.push(...statementCompletions);
            } else {
                lastNormalCompletions = [];
                for (let i2 = 0; i2 < statementCompletions.length; i2++) {
                    const c = statementCompletions[i2];
                    
                    if (c.type === BREAK_COMPLETION) {
                        completions.push(c);
                    }
                    
                    if (c.type === NORMAL_COMPLETION) {
                        lastNormalCompletions.push(c);
                    }
                }
            }
        }
    } else if (paths.length) {
        for (let i = paths.length - 1; i >= 0; i--) {
            const pathCompletions = _getCompletionRecords(paths[i], context);
            
            if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration() && !pathCompletions[0].path.isEmptyStatement()) {
                completions.push(...pathCompletions);
                break;
            }
        }
    }
    
    return completions;
}

function _getCompletionRecords(path, context) {
    let records = [];
    
    if (path.isIfStatement()) {
        records = addCompletionRecords(path.get('consequent'), records, context);
        records = addCompletionRecords(path.get('alternate'), records, context);
    } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {
        return addCompletionRecords(path.get('body'), records, context);
    } else if (path.isProgram() || path.isBlockStatement()) {
        return getStatementListCompletion(path.get('body'), context);
    } else if (path.isFunction()) {
        return _getCompletionRecords(path.get('body'), context);
    } else if (path.isTryStatement()) {
        records = addCompletionRecords(path.get('block'), records, context);
        records = addCompletionRecords(path.get('handler'), records, context);
    } else if (path.isCatchClause()) {
        return addCompletionRecords(path.get('body'), records, context);
    } else if (path.isSwitchStatement()) {
        return completionRecordForSwitch(path.get('cases'), records, context);
    } else if (path.isSwitchCase()) {
        return getStatementListCompletion(path.get('consequent'), {
            canHaveBreak: true,
            shouldPopulateBreak: false,
            inCaseClause: true,
            shouldPreserveBreak: context.shouldPreserveBreak,
        });
    } else if (path.isBreakStatement()) {
        records.push(BreakCompletion(path));
    } else {
        records.push(NormalCompletion(path));
    }






    
    return records;
}

function getCompletionRecords(shouldPreserveBreak = false) {
    const records = _getCompletionRecords(this, {
        canHaveBreak: false,
        shouldPopulateBreak: false,
        inCaseClause: false,
        shouldPreserveBreak,
    });
    
    return records.map((r) => r.path);
}

function getSibling(key) {
    return NodePath_Final.get({
        parentPath: this.parentPath,
        parent: this.parent,
        container: this.container,
        listKey: this.listKey,
        key,
    }).setContext(this.context);
}

function getPrevSibling$1() {
    return this.getSibling(this.key - 1);
}

function getNextSibling$1() {
    return this.getSibling(this.key + 1);
}

function getAllNextSiblings() {
    let _key = this.key;
    let sibling = this.getSibling(++_key);
    const siblings = [];
    
    while (sibling.node) {
        siblings.push(sibling);
        sibling = this.getSibling(++_key);
    }
    
    return siblings;
}

function getAllPrevSiblings() {
    let _key = this.key;
    let sibling = this.getSibling(--_key);
    const siblings = [];
    
    while (sibling.node) {
        siblings.push(sibling);
        sibling = this.getSibling(--_key);
    }
    
    return siblings;
}

function get2(key, context = true) {
    if (context === true)
        context = this.context;
    
    const parts = key.split('.');
    
    if (parts.length === 1) {
        return _getKey.call(this, key, context);
    } else {
        return _getPattern.call(this, parts, context);
    }
}

function _getKey(key, context) {
    const node = this.node;
    const container = node[key];
    
    if (Array.isArray(container)) {
        return container.map((_, i) => {
            return NodePath_Final.get({
                listKey: key,
                parentPath: this,
                parent: node,
                container,
                key: i,
            }).setContext(context);
        });
    } else {
        return NodePath_Final.get({
            parentPath: this,
            parent: node,
            container: node,
            key,
        }).setContext(context);
    }
}

function _getPattern(parts, context) {
    let path = this;
    
    for (const part of parts) {
        if (part === '.') {
            path = path.parentPath;
        } else {
            if (Array.isArray(path)) {
                path = path[part];
            } else {
                path = path.get(part, context);
            }
        }
    }
    
    return path;
}

function getAssignmentIdentifiers2() {
    return _getAssignmentIdentifiers(this.node);
}

function getBindingIdentifiers2(duplicates) {
    return _getBindingIdentifiers(this.node, duplicates);
}

function getOuterBindingIdentifiers2(duplicates) {
    return _getOuterBindingIdentifiers(this.node, duplicates);
}

function getBindingIdentifierPaths(duplicates = false, outerOnly = false) {
    const path = this;
    const search = [path];
    const ids =     /* @__PURE__ */Object.create(null);
    
    while (search.length) {
        const id = search.shift();
        
        if (!id)
            continue;
        
        if (!id.node)
            continue;
        
        const keys2 = _getBindingIdentifiers.keys[id.node.type];
        
        if (id.isIdentifier()) {
            if (duplicates) {
                const _ids = ids[id.node.name] = ids[id.node.name] || [];
                _ids.push(id);
            } else {
                ids[id.node.name] = id;
            }
            
            continue;
        }
        
        if (id.isExportDeclaration()) {
            const declaration = id.get('declaration');
            
            if (declaration.isDeclaration()) {
                search.push(declaration);
            }
            
            continue;
        }
        
        if (outerOnly) {
            if (id.isFunctionDeclaration()) {
                search.push(id.get('id'));
                continue;
            }
            
            if (id.isFunctionExpression()) {
                continue;
            }
        }
        
        if (keys2) {
            for (let i = 0; i < keys2.length; i++) {
                const key = keys2[i];
                const child = id.get(key);
                
                if (Array.isArray(child)) {
                    search.push(...child);
                } else if (child.node) {
                    search.push(child);
                }
            }
        }
    }
    
    return ids;
}

function getOuterBindingIdentifierPaths(duplicates = false) {
    return this.getBindingIdentifierPaths(duplicates, true);
}

var {addComment: _addComment, addComments: _addComments} = lib_exports;

function shareCommentsWithSiblings() {
    if (typeof this.key === 'string')
        return;
    
    const node = this.node;
    
    if (!node)
        return;
    
    const trailing = node.trailingComments;
    const leading = node.leadingComments;
    
    if (!trailing && !leading)
        return;
    
    const prev = this.getSibling(this.key - 1);
    const next = this.getSibling(this.key + 1);
    const hasPrev = Boolean(prev.node);
    const hasNext = Boolean(next.node);
    
    if (hasPrev) {
        if (leading) {
            prev.addComments('trailing', removeIfExisting(leading, prev.node.trailingComments));
        }
        
        if (trailing && !hasNext)
            prev.addComments('trailing', trailing);
    }
    
    if (hasNext) {
        if (trailing) {
            next.addComments('leading', removeIfExisting(trailing, next.node.leadingComments));
        }
        
        if (leading && !hasPrev)
            next.addComments('leading', leading);
    }
}

function removeIfExisting(list, toRemove) {
    if (!toRemove?.length)
        return list;
    
    const set = new Set(toRemove);
    
    return list.filter((el) => {
        return !set.has(el);
    });
}

function addComment2(type, content, line) {
    _addComment(this.node, type, content, line);
}

function addComments2(type, comments) {
    _addComments(this.node, type, comments);
}

var {validate: validate3} = lib_exports;

var debug$8 = (0, import_debug.default)('babel');
var REMOVED = 1 << 0;
var SHOULD_STOP = 1 << 1;
var SHOULD_SKIP = 1 << 2;

var NodePath_Final = class NodePath {
    constructor(hub, parent) {
        __publicField(this, 'contexts', []);
        __publicField(this, 'state', null);
        __publicField(this, 'opts', null);
        __publicField(this, '_traverseFlags', 0);
        __publicField(this, 'skipKeys', null);
        __publicField(this, 'parentPath', null);
        __publicField(this, 'container', null);
        __publicField(this, 'listKey', null);
        __publicField(this, 'key', null);
        __publicField(this, 'node', null);
        __publicField(this, 'type', null);
        __publicField(this, '_store', null);
        this.parent = parent;
        this.hub = hub;
        this.data = null;
        this.context = null;
        this.scope = null;
    }
    
    get removed() {
        return (this._traverseFlags & 1) > 0;
    }
    
    set removed(v) {
        if (v)
            this._traverseFlags |= 1;
        else
            this._traverseFlags &= -2;
    }
    
    get shouldStop() {
        return (this._traverseFlags & 2) > 0;
    }
    
    set shouldStop(v) {
        if (v)
            this._traverseFlags |= 2;
        else
            this._traverseFlags &= -3;
    }
    
    get shouldSkip() {
        return (this._traverseFlags & 4) > 0;
    }
    
    set shouldSkip(v) {
        if (v)
            this._traverseFlags |= 4;
        else
            this._traverseFlags &= -5;
    }
    
    static get({hub, parentPath, parent, container, listKey, key}) {
        if (!hub && parentPath) {
            hub = parentPath.hub;
        }
        
        if (!parent) {
            throw new Error('To get a node path the parent needs to exist');
        }
        
        const targetNode = container[key];
        const paths = getOrCreateCachedPaths(parent, parentPath);
        let path = paths.get(targetNode);
        
        if (!path) {
            path = new NodePath(hub, parent);
            
            if (targetNode)
                paths.set(targetNode, path);
        }
        
        setup$1.call(path, parentPath, container, listKey, key);
        return path;
    }
    
    getScope(scope2) {
        return this.isScope() ? new Scope2(this) : scope2;
    }
    
    setData(key, val) {
        if (this.data == null) {
            this.data =             /* @__PURE__ */Object.create(null);
        }
        
        return this.data[key] = val;
    }
    
    getData(key, def) {
        if (this.data == null) {
            this.data =             /* @__PURE__ */Object.create(null);
        }
        
        let val = this.data[key];
        
        if (val === void 0 && def !== void 0)
            val =
            this.data[key] = def;
        
        return val;
    }
    
    hasNode() {
        return this.node != null;
    }
    
    buildCodeFrameError(msg, Error2 = SyntaxError) {
        return this.hub.buildError(this.node, msg, Error2);
    }
    
    traverse(visitor, state) {
        traverse3(this.node, visitor, this.scope, state, this);
    }
    
    set(key, node) {
        validate3(this.node, key, node);
        this.node[key] = node;
    }
    
    getPathLocation() {
        const parts = [];
        let path = this;
        
        do {
            let key = path.key;
            
            if (path.inList)
                key = `${path.listKey}[${key}]`;
            
            parts.unshift(key);
        } while (path = path.parentPath)
        
        return parts.join('.');
    }
    
    debug(message) {
        if (!debug$8.enabled)
            return;
        
        debug$8(`${this.getPathLocation()} ${this.type}: ${message}`);
    }
    
    toString() {
        return generate$6(this.node).code;
    }
    
    get inList() {
        return !!this.listKey;
    }
    
    set inList(inList) {
        if (!inList) {
            this.listKey = null;
        }
    }
    
    get parentKey() {
        return this.listKey || this.key;
    }
};

var methods = {
    findParent: findParent$1,
    find,
    getFunctionParent,
    getStatementParent,
    getEarliestCommonAncestorFrom,
    getDeepestCommonAncestorFrom,
    getAncestry,
    isAncestor,
    isDescendant,
    inType,
    getTypeAnnotation,
    isBaseType,
    couldBeBaseType,
    baseTypeStrictlyMatches,
    isGenericType,
    replaceWithMultiple: replaceWithMultiple$3,
    replaceWithSourceString,
    replaceWith: replaceWith$8,
    replaceExpressionWithStatements,
    replaceInline,
    evaluateTruthy,
    evaluate,
    toComputedKey: toComputedKey2,
    ensureBlock: ensureBlock2,
    unwrapFunctionEnvironment,
    arrowFunctionToExpression,
    splitExportDeclaration,
    ensureFunctionName,
    matchesPattern: matchesPattern2,
    isStatic,
    isNodeType,
    canHaveVariableDeclarationOrExpression,
    canSwapBetweenExpressionAndStatement,
    isCompletionRecord,
    isStatementOrBlock,
    referencesImport,
    getSource,
    willIMaybeExecuteBefore,
    _guessExecutionStatusRelativeTo,
    resolve: resolve2,
    isConstantExpression,
    isInStrictMode,
    isDenylisted,
    visit,
    skip,
    skipKey,
    stop,
    setContext,
    requeue,
    requeueComputedKeyAndDecorators,
    remove: remove$3,
    insertBefore,
    insertAfter: insertAfter$1,
    unshiftContainer,
    pushContainer,
    getOpposite,
    getCompletionRecords,
    getSibling,
    getPrevSibling: getPrevSibling$1,
    getNextSibling: getNextSibling$1,
    getAllNextSiblings,
    getAllPrevSiblings,
    get: get2,
    getAssignmentIdentifiers: getAssignmentIdentifiers2,
    getBindingIdentifiers: getBindingIdentifiers2,
    getOuterBindingIdentifiers: getOuterBindingIdentifiers2,
    getBindingIdentifierPaths,
    getOuterBindingIdentifierPaths,
    shareCommentsWithSiblings,
    addComment: addComment2,
    addComments: addComments2,
};

Object.assign(NodePath_Final.prototype, methods);
for (const type of TYPES$4) {
    const typeKey = `is${type}`;
    const fn = lib_exports[typeKey];
    
    NodePath_Final.prototype[typeKey] = function(opts) {
        return fn(this.node, opts);
    };
    NodePath_Final.prototype[`assert${type}`] = function(opts) {
        if (!fn(this.node, opts)) {
            throw new TypeError(`Expected node path of type ${type}`);
        }
    };
}

Object.assign(NodePath_Final.prototype, NodePath_virtual_types_validator);
for (const type of Object.keys(virtualTypes)) {
    if (type[0] === '_')
        continue;
    
    if (!TYPES$4.includes(type))
        TYPES$4.push(type);
}

var {VISITOR_KEYS: VISITOR_KEYS$2} = lib_exports;

var TraversalContext = class {
    constructor(scope2, opts, state, parentPath) {
        __publicField(this, 'queue', null);
        __publicField(this, 'priorityQueue', null);
        this.parentPath = parentPath;
        this.scope = scope2;
        this.state = state;
        this.opts = opts;
    }
    
    shouldVisit(node) {
        const opts = this.opts;
        
        if (opts.enter || opts.exit)
            return true;
        
        if (opts[node.type])
            return true;
        
        const keys2 = VISITOR_KEYS$2[node.type];
        
        if (!keys2?.length)
            return false;
        
        for (const key of keys2) {
            if (node[key]) {
                return true;
            }
        }
        
        return false;
    }
    
    create(node, container, key, listKey) {
        return NodePath_Final.get({
            parentPath: this.parentPath,
            parent: node,
            container,
            key,
            listKey,
        });
    }
    
    maybeQueue(path, notPriority) {
        if (this.queue) {
            if (notPriority) {
                this.queue.push(path);
            } else {
                this.priorityQueue.push(path);
            }
        }
    }
    
    visitMultiple(container, parent, listKey) {
        if (container.length === 0)
            return false;
        
        const queue = [];
        
        for (let key = 0; key < container.length; key++) {
            const node = container[key];
            
            if (node && this.shouldVisit(node)) {
                queue.push(this.create(parent, container, key, listKey));
            }
        }
        
        return this.visitQueue(queue);
    }
    
    visitSingle(node, key) {
        if (this.shouldVisit(node[key])) {
            return this.visitQueue([this.create(node, node, key)]);
        } else {
            return false;
        }
    }
    
    visitQueue(queue) {
        this.queue = queue;
        this.priorityQueue = [];
        const visited =         /* @__PURE__ */new WeakSet();
        let stop2 = false;
        let visitIndex = 0;
        
        for (; visitIndex < queue.length;) {
            const path = queue[visitIndex];
            visitIndex++;
            resync.call(path);
            
            if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {
                pushContext.call(path, this);
            }
            
            if (path.key === null)
                continue;
            
            const {node} = path;
            
            if (visited.has(node))
                continue;
            
            if (node)
                visited.add(node);
            
            if (path.visit()) {
                stop2 = true;
                break;
            }
            
            if (this.priorityQueue.length) {
                stop2 = this.visitQueue(this.priorityQueue);
                this.priorityQueue = [];
                this.queue = queue;
                
                if (stop2)
                    break;
            }
        }
        
        for (let i = 0; i < visitIndex; i++) {
            popContext.call(queue[i]);
        }
        
        this.queue = null;
        
        return stop2;
    }
    
    visit(node, key) {
        const nodes2 = node[key];
        
        if (!nodes2)
            return false;
        
        if (Array.isArray(nodes2)) {
            return this.visitMultiple(nodes2, node, key);
        } else {
            return this.visitSingle(node, key);
        }
    }
};

var {VISITOR_KEYS: VISITOR_KEYS$12} = lib_exports;

function _visitPaths(ctx, paths) {
    ctx.queue = paths;
    ctx.priorityQueue = [];
    const visited =     /* @__PURE__ */new Set();
    let stop2 = false;
    let visitIndex = 0;
    
    for (; visitIndex < paths.length;) {
        const path = paths[visitIndex];
        visitIndex++;
        resync.call(path);
        
        if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== ctx) {
            pushContext.call(path, ctx);
        }
        
        if (path.key === null)
            continue;
        
        const {node} = path;
        
        if (visited.has(node))
            continue;
        
        if (node)
            visited.add(node);
        
        if (_visit(ctx, path)) {
            stop2 = true;
            break;
        }
        
        if (ctx.priorityQueue.length) {
            stop2 = _visitPaths(ctx, ctx.priorityQueue);
            ctx.priorityQueue = [];
            ctx.queue = paths;
            
            if (stop2)
                break;
        }
    }
    
    for (let i = 0; i < visitIndex; i++) {
        popContext.call(paths[i]);
    }
    
    ctx.queue = null;
    
    return stop2;
}

function _visit(ctx, path) {
    const node = path.node;
    
    if (!node) {
        return false;
    }
    
    const opts = ctx.opts;
    const denylist = opts.denylist ?? opts.blacklist;
    
    if (denylist?.includes(node.type)) {
        return false;
    }
    
    if (opts.shouldSkip?.(path)) {
        return false;
    }
    
    if (path.shouldSkip)
        return path.shouldStop;
    
    if (_call.call(path, opts.enter))
        return path.shouldStop;
    
    if (path.node) {
        if (_call.call(path, opts[node.type]?.enter))
            return path.shouldStop;
    }
    
    path.shouldStop = _traverse$1(path.node, opts, path.scope, ctx.state, path, path.skipKeys);
    
    if (path.node) {
        if (_call.call(path, opts.exit))
            return true;
    }
    
    if (path.node) {
        _call.call(path, opts[node.type]?.exit);
    }
    
    return path.shouldStop;
}

function _traverse$1(node, opts, scope2, state, path, skipKeys, visitSelf) {
    const keys2 = VISITOR_KEYS$12[node.type];
    
    if (!keys2?.length)
        return false;
    
    const ctx = new TraversalContext(scope2, opts, state, path);
    
    if (visitSelf) {
        if (skipKeys?.[path.parentKey])
            return false;
        
        return _visitPaths(ctx, [path]);
    }
    
    for (const key of keys2) {
        if (skipKeys?.[key])
            continue;
        
        const prop = node[key];
        
        if (!prop)
            continue;
        
        if (Array.isArray(prop)) {
            if (!prop.length)
                continue;
            
            const paths = [];
            
            for (let i = 0; i < prop.length; i++) {
                const childPath = NodePath_Final.get({
                    parentPath: path,
                    parent: node,
                    container: prop,
                    key: i,
                    listKey: key,
                });
                
                paths.push(childPath);
            }
            
            if (_visitPaths(ctx, paths))
                return true;
        } else {
            if (_visitPaths(ctx, [
                NodePath_Final.get({parentPath: path, parent: node, container: node, key, listKey: null}),
            ])) {
                return true;
            }
        }
    }
    
    return false;
}

function traverseNode(node, opts, scope2, state, path, skipKeys, visitSelf) {
    {
        return _traverse$1(node, opts, scope2, state, path, skipKeys, visitSelf);
    }
}

function call(key) {
    const opts = this.opts;
    this.debug(key);
    
    if (this.node) {
        if (_call.call(this, opts[key]))
            return true;
    }
    
    if (this.node) {
        return _call.call(this, opts[this.node.type]?.[key]);
    }
    
    return false;
}

function _call(fns) {
    if (!fns)
        return false;
    
    for (const fn of fns) {
        if (!fn)
            continue;
        
        const node = this.node;
        
        if (!node)
            return true;
        
        const ret = fn.call(this.state, this, this.state);
        
        if (ret && typeof ret === 'object' && typeof ret.then === 'function') {
            throw new Error(`You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.`);
        }
        
        if (ret) {
            throw new Error(`Unexpected return value from visitor method ${fn}`);
        }
        
        if (this.node !== node)
            return true;
        
        if (this._traverseFlags > 0)
            return true;
    }
    
    return false;
}

function isDenylisted() {
    const denylist = this.opts.denylist ?? this.opts.blacklist;
    return denylist?.includes(this.node.type);
}

function restoreContext(path, context) {
    if (path.context !== context) {
        path.context = context;
        path.state = context.state;
        path.opts = context.opts;
    }
}

function visit() {
    if (!this.node) {
        return false;
    }
    
    if (this.isDenylisted()) {
        return false;
    }
    
    if (this.opts.shouldSkip?.(this)) {
        return false;
    }
    
    const currentContext = this.context;
    
    if (this.shouldSkip || call.call(this, 'enter')) {
        this.debug('Skip...');
        return this.shouldStop;
    }
    
    restoreContext(this, currentContext);
    this.debug('Recursing into...');
    this.shouldStop = traverseNode(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
    restoreContext(this, currentContext);
    call.call(this, 'exit');
    return this.shouldStop;
}

function skip() {
    this.shouldSkip = true;
}

function skipKey(key) {
    if (this.skipKeys == null) {
        this.skipKeys = {};
    }
    
    this.skipKeys[key] = true;
}

function stop() {
    this._traverseFlags |= SHOULD_SKIP | SHOULD_STOP;
}

function setScope() {
    if (this.opts?.noScope)
        return;
    
    let path = this.parentPath;
    
    if ((this.key === 'key' || this.listKey === 'decorators') && path.isMethod() || this.key === 'discriminant' && path.isSwitchStatement()) {
        path = path.parentPath;
    }
    
    let target;
    
    while (path && !target) {
        if (path.opts?.noScope)
            return;
        
        target = path.scope;
        path = path.parentPath;
    }
    
    this.scope = this.getScope(target);
    this.scope?.init();
}

function setContext(context) {
    if (this.skipKeys != null) {
        this.skipKeys = {};
    }
    
    this._traverseFlags = 0;
    
    if (context) {
        this.context = context;
        this.state = context.state;
        this.opts = context.opts;
    }
    
    setScope.call(this);
    return this;
}

function resync() {
    if (this.removed)
        return;
    
    _resyncParent.call(this);
    _resyncList.call(this);
    _resyncKey.call(this);
}

function _resyncParent() {
    if (this.parentPath) {
        this.parent = this.parentPath.node;
    }
}

function _resyncKey() {
    if (!this.container)
        return;
    
    if (this.node === this.container[this.key]) {
        return;
    }
    
    if (Array.isArray(this.container)) {
        for (let i = 0; i < this.container.length; i++) {
            if (this.container[i] === this.node) {
                setKey.call(this, i);
                return;
            }
        }
    } else {
        for (const key of Object.keys(this.container)) {
            if (this.container[key] === this.node) {
                setKey.call(this, key);
                return;
            }
        }
    }
    
    this.key = null;
}

function _resyncList() {
    if (!this.parent || !this.inList)
        return;
    
    const newContainer = this.parent[this.listKey];
    
    if (this.container === newContainer)
        return;
    
    this.container = newContainer || null;
}

function popContext() {
    this.contexts.pop();
    
    if (this.contexts.length > 0) {
        this.setContext(this.contexts[this.contexts.length - 1]);
    } else {
        this.setContext(void 0);
    }
}

function pushContext(context) {
    this.contexts.push(context);
    this.setContext(context);
}

function setup$1(parentPath, container, listKey, key) {
    this.listKey = listKey;
    this.container = container;
    this.parentPath = parentPath || this.parentPath;
    setKey.call(this, key);
}

function setKey(key) {
    this.key = key;
    this.node = this.container[this.key];
    this.type = this.node?.type;
}

function requeue(pathToQueue = this) {
    if (pathToQueue.removed)
        return;
    
    {
        pathToQueue.shouldSkip = false;
    }
    const contexts = this.contexts;
    
    for (const context of contexts) {
        context.maybeQueue(pathToQueue);
    }
}

function requeueComputedKeyAndDecorators() {
    const {context, node} = this;
    
    if (!isPrivate(node) && node.computed) {
        context.maybeQueue(this.get('key'));
    }
    
    if (node.decorators) {
        for (const decorator2 of this.get('decorators')) {
            context.maybeQueue(decorator2);
        }
    }
}

function _getQueueContexts() {
    let path = this;
    let contexts = this.contexts;
    
    while (!contexts.length) {
        path = path.parentPath;
        
        if (!path)
            break;
        
        contexts = path.contexts;
    }
    
    return contexts;
}

var {
    VISITOR_KEYS: VISITOR_KEYS3,
    removeProperties: removeProperties2,
    traverseFast: traverseFast3,
} = lib_exports;

function traverse3(parent, opts = {}, scope2, state, parentPath, visitSelf) {
    if (!parent)
        return;
    
    if (!opts.noScope && !scope2) {
        if (parent.type !== 'Program' && parent.type !== 'File') {
            throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${parent.type} node without passing scope and parentPath.`);
        }
    }
    
    if (!parentPath && visitSelf) {
        throw new Error('visitSelf can only be used when providing a NodePath.');
    }
    
    if (!VISITOR_KEYS3[parent.type]) {
        return;
    }
    
    explode$1(opts);
    traverseNode(parent, opts, scope2, state, parentPath, null, visitSelf);
}

traverse3.visitors = visitors$2;
traverse3.verify = verify$1;
traverse3.explode = explode$1;
traverse3.cheap = function(node, enter) {
    traverseFast3(node, enter);
    return;
};
traverse3.node = function(node, opts, scope2, state, path, skipKeys) {
    traverseNode(node, opts, scope2, state, path, skipKeys);
};
traverse3.clearNode = function(node, opts) {
    removeProperties2(node, opts);
};
traverse3.removeProperties = function(tree, opts) {
    traverseFast3(tree, traverse3.clearNode, opts);
    return tree;
};
traverse3.hasType = function(tree, type, denylistTypes) {
    if (denylistTypes?.includes(tree.type))
        return false;
    
    if (tree.type === type)
        return true;
    
    return traverseFast3(tree, function(node) {
        if (denylistTypes?.includes(node.type)) {
            return traverseFast3.skip;
        }
        
        if (node.type === type) {
            return traverseFast3.stop;
        }
    });
};
traverse3.cache = cache;

bundle.default;

var parser$5 = {};

var printer = {};

var tokenize$1 = {};

var fullstore$3 = (value) => {
    const data = {
        value,
    };
    
    return (...args) => {
        const [value] = args;
        
        if (!args.length)
            return data.value;
        
        data.value = value;
        
        return value;
    };
};

var types$17 = {};

types$17.TYPES = {
    TOKEN: 'Token',
    NEWLINE: 'Newline',
    LINEBREAK: 'Linebreak',
    SPLITTER: 'Splitter',
    INDENT: 'Indent',
    DEBUG: 'Debug',
    SPACE: 'Space',
    ROUND_BRACE_OPEN: 'RoundBraceOpen',
    ROUND_BRACE_CLOSE: 'RoundBraceClose',
    QUOTE: 'Quote',
    END_OF_FILE: 'EndOfFile',
};

var functions$1 = {};

var arrowFunctionExpression = {};

var is$3 = {};

const {types: types$16} = bundle;
const {
    isStringLiteral: isStringLiteral$9,
    isIdentifier: isIdentifier$f,
    isIfStatement: isIfStatement$2,
    isStatement: isStatement$6,
    isForOfStatement: isForOfStatement$1,
    isVariableDeclaration: isVariableDeclaration$4,
    isMemberExpression: isMemberExpression$7,
    isArrayExpression: isArrayExpression$9,
    isObjectExpression: isObjectExpression$8,
    isLabeledStatement: isLabeledStatement$1,
} = types$16;

const isParentProgram$1 = (path) => path.parentPath?.isProgram();
const isParentBlock$3 = (path) => path.parentPath.isBlockStatement();

const isNext$p = (path) => {
    const next = path.getNextSibling();
    
    if (!next.node)
        return false;
    
    return !next.isEmptyStatement();
};

const isPrev$1 = (path) => {
    const next = path.getPrevSibling();
    return next.node;
};

const isNextParent$5 = (path) => isNext$p(path.parentPath);
const isLast$d = (path) => isParentProgram$1(path) && !isNext$p(path);

is$3.isNextObject = (a) => a
    .getNextSibling()
    .isObjectExpression();

is$3.isPrevObject = (a) => a
    .getPrevSibling()
    .isObjectExpression();

is$3.isFirst = (path) => path.node === path.parentPath.node.body?.[0];
is$3.isPrevBody = (path) => path
    .getPrevSibling()
    .isBlockStatement();
is$3.isNext = isNext$p;
is$3.isPrev = isPrev$1;
is$3.isNextParent = isNextParent$5;
is$3.isParentProgram = isParentProgram$1;
is$3.isParentBlock = isParentBlock$3;
is$3.isLast = isLast$d;
is$3.isParentLast = (path) => isLast$d(path.parentPath);

is$3.isIndented = (path = {}) => {
    const {parentPath, node} = path;
    
    if (!parentPath.node.loc)
        return true;
    
    return node.loc?.start.column !== parentPath.node.loc.start.column;
};

is$3.isCoupleLines = isCoupleLines$9;

function isCoupleLines$9(path) {
    const start = path.node?.loc?.start?.line;
    const end = path.node?.loc?.end?.line;
    
    return end !== start;
}

is$3.exists = (a) => a.node;
is$3.isStringAndIdentifier = isStringAndIdentifier$2;
function isStringAndIdentifier$2([a, b]) {
    return isStringLiteral$9(a) && isIdentifier$f(b);
}

const checkObject = (elements) => {
    let a = elements.at(-1);
    
    if (!isObjectExpression$8(a))
        a = elements.at(-2);
    
    if (!isObjectExpression$8(a))
        return false;
    
    return a.node.properties.length;
};

is$3.isSimpleAndNotEmptyObject = (elements) => {
    const [a] = elements;
    
    const simpleTypes = [
        'Identifier',
        'SpreadElement',
        'ArrayExpression',
        'CallExpression',
        'NewExpression',
    ];
    
    if (a && !simpleTypes.includes(a.type))
        return false;
    
    return checkObject(elements);
};

is$3.isIdentifierAndIdentifier = ([a, b]) => {
    return isIdentifier$f(a) && isIdentifier$f(b);
};

is$3.isStringAndMember = ([a, b]) => isStringLiteral$9(a) && isMemberExpression$7(b);
is$3.isIdentifierAndString = ([a, b]) => isIdentifier$f(a) && isStringLiteral$9(b);
is$3.isStringAndArray = ([a, b]) => {
    if (!isStringLiteral$9(a))
        return false;
    
    if (!isArrayExpression$9(b))
        return false;
    
    return !isStringAndIdentifier$2(b.node.elements);
};

const isIfOrStatement = (a) => isIfStatement$2(a) || isStatement$6(a);
const isForOfOrStatement = (a) => isForOfStatement$1(a) || isStatement$6(a);

is$3.isIf = (path) => isIfStatement$2(path.find(isIfOrStatement));

is$3.isForOf = (path) => {
    const current = path.find(isForOfOrStatement);
    
    if (isForOfStatement$1(current))
        return true;
    
    if (isVariableDeclaration$4(current))
        return isForOfStatement$1(current.parentPath);
    
    return false;
};

is$3.isInsideIf = (path) => path.parentPath?.isIfStatement();

is$3.isNewlineBetweenSiblings = (path) => {
    const endCurrent = path.node?.loc?.end?.line;
    const startNext = path.getNextSibling().node?.loc?.start?.line;
    
    if (!startNext)
        return false;
    
    return startNext - endCurrent > 1;
};

is$3.isInsideLabel = ({parentPath}) => isLabeledStatement$1(parentPath);

is$3.satisfy = (conditions) => (path) => {
    for (const condition of conditions)
        if (condition(path))
            return true;
    
    return false;
};

const parseNode$3 = (path) => path.node || path;

is$3.hasCoupleTrailingComments = (path) => {
    const node = parseNode$3(path);
    return node?.trailingComments?.length > 1;
};

is$3.hasTrailingComment = (path) => {
    const node = parseNode$3(path);
    return node.trailingComments?.length;
};

is$3.hasLeadingComment = (path) => path.node?.leadingComments?.length;

is$3.noTrailingComment = (path) => !path.node.trailingComments?.length;
is$3.noLeadingComment = (path) => !path.node.leadingComments?.length;

var params = {};

var comment = {};

var parseLeadingComments$4 = {};

var mark = {};

const WATER_MARK_BEFORE = '__putout_newline_before';
const WATER_MARK_AFTER = '__putout_newline_after';

mark.markBefore = markBefore$2;
mark.markAfter = markAfter$b;
mark.maybeMarkAfter = (a, path) => a && markAfter$b(path);

function markBefore$2(path) {
    path[WATER_MARK_BEFORE] = true;
}

function markAfter$b(path) {
    path[WATER_MARK_AFTER] = true;
}

mark.isMarkedAfter = isMarkedAfter$3;

function isMarkedAfter$3(path) {
    return path[WATER_MARK_AFTER];
}

mark.hasPrevNewline = (path) => {
    return isMarkedAfter$3(path.getPrevSibling());
};

var maybeInsideFn$1 = {};

maybeInsideFn$1.maybeInsideFn = (insideFn, {print, indent}) => {
    if (!insideFn)
        return;
    
    indent.inc();
    indent.inc();
    print.breakline();
    indent.dec();
    indent.dec();
};

var commentsPrinter = {};

const createPrintCommentLine = (fn, value) => () => fn(`//${value}`);
const createPrintCommentBlock = (fn, value) => () => fn(`/*${value}*/\n`);

commentsPrinter.hasTrailingCommentsPrinter = (currentTraverse) => {
    const {
        printTrailingCommentBlock,
        printTrailingCommentLine,
    } = currentTraverse;
    
    if (printTrailingCommentBlock)
        return true;
    
    return Boolean(printTrailingCommentLine);
};

commentsPrinter.hasLeadingCommentsPrinter = (currentTraverse) => {
    const {
        printLeadingCommentLine,
        printLeadingCommentBlock,
    } = currentTraverse;
    
    if (printLeadingCommentLine)
        return true;
    
    return Boolean(printLeadingCommentBlock);
};

commentsPrinter.printLeadingComments = (path, printer, semantics, {currentTraverse}) => {
    const {print} = printer;
    const {
        leadingComments = [],
    } = path.node;
    
    const {
        printLeadingCommentLine,
        printLeadingCommentBlock,
    } = currentTraverse;
    
    const n = leadingComments.length - 1;
    
    for (const [index, {type, value}] of leadingComments.entries()) {
        if (type === 'CommentLine') {
            printLeadingCommentLine?.(path, printer, semantics, {
                index,
                printComment: createPrintCommentLine(print, value),
                isLast: index === n,
            });
            continue;
        }
        
        if (type === 'CommentBlock')
            printLeadingCommentBlock?.(path, printer, semantics, {
                index,
                printComment: createPrintCommentBlock(print, value),
            });
    }
};

commentsPrinter.printTrailingComments = (path, printer, semantics, {currentTraverse}) => {
    const {print} = printer;
    const {
        trailingComments = []} = path.node;
    
    const {
        printTrailingCommentLine,
        printTrailingCommentBlock,
    } = currentTraverse;
    
    const n = trailingComments.length - 1;
    
    for (const [index, {type, value}] of trailingComments.entries()) {
        if (type === 'CommentLine') {
            printTrailingCommentLine?.(path, printer, semantics, {
                index,
                printComment: createPrintCommentLine(print, value),
                isLast: index === n,
            });
            continue;
        }
        
        if (type === 'CommentBlock')
            printTrailingCommentBlock?.(path, printer, semantics, {
                index,
                printComment: createPrintCommentBlock(print, value),
            });
    }
};

const {types: types$15} = bundle;
const {
    hasTrailingComment: hasTrailingComment$5,
    satisfy: satisfy$3,
    isPrev,
} = is$3;

const {markBefore: markBefore$1} = mark;
const {maybeInsideFn} = maybeInsideFn$1;

const {
    printLeadingComments,
    hasLeadingCommentsPrinter,
} = commentsPrinter;

const {
    isArrowFunctionExpression: isArrowFunctionExpression$1,
    isObjectProperty: isObjectProperty$2,
    isVariableDeclarator: isVariableDeclarator$3,
    isClassProperty,
    isTSPropertySignature,
    isSpreadElement: isSpreadElement$2,
    isClassBody: isClassBody$1,
    isBinaryExpression: isBinaryExpression$1,
    isClassMethod: isClassMethod$1,
    isDecorator: isDecorator$1,
} = types$15;

const isProperty = satisfy$3([
    isObjectProperty$2,
    isVariableDeclarator$3,
    isClassProperty,
    isTSPropertySignature,
    isSpreadElement$2,
]);

const isInsideVar = (path) => {
    const {parentPath} = path;
    
    if (isVariableDeclarator$3(parentPath) && path === parentPath.get('init'))
        return true;
    
    if (!isArrowFunctionExpression$1(parentPath))
        return false;
    
    return isVariableDeclarator$3(parentPath.parentPath);
};

const hasDecoratorsWithComments = (path) => path?.parentPath.node?.decorators;

function isCommentOfPrevious(path) {
    const [comment] = path.node.leadingComments;
    const {line} = comment.loc.start;
    
    return path.getPrevSibling().node?.loc.start.line === line;
}

function isCommentOnPreviousLine(path) {
    const {
        loc,
        leadingComments,
    } = path.node;
    
    if (!isProperty(path))
        return false;
    
    const [comment] = leadingComments;
    const {line} = comment.loc.start;
    
    if (isCommentOfPrevious(path))
        return false;
    
    return line <= loc.start.line - 1;
}

const isFirst$2 = (path) => {
    const {parentPath} = path;
    
    if (path === parentPath.get('properties')[0])
        return true;
    
    if (isClassBody$1(parentPath) && isClassProperty(path))
        return path === parentPath.get('body')[0];
    
    return false;
};

parseLeadingComments$4.parseLeadingComments = (path, printer, semantics, {currentTraverse = {}} = {}) => {
    const {
        print,
        maybe,
        indent,
    } = printer;
    
    if (!semantics.comments)
        return;
    
    const {leadingComments} = path.node;
    
    if (!leadingComments?.length)
        return;
    
    if (hasLeadingCommentsPrinter(currentTraverse))
        return printLeadingComments(path, printer, semantics, {
            currentTraverse,
        });
    
    if (hasDecoratorsWithComments(path))
        return;
    
    const looksLikeSwitchCase = path.isSwitchCase();
    
    if (!looksLikeSwitchCase && hasTrailingComment$5(path.getPrevSibling()))
        return;
    
    const insideFn = (path.parentPath.isFunction() || path.parentPath.isTSDeclareMethod()) && !path.isTSTypeParameterDeclaration();
    
    const propIs = isProperty(path);
    const isIndent = isFirst$2(path)
        || !looksLikeSwitchCase
        && !path.isClassMethod()
        && !insideFn
        && !propIs;
    
    const count = leadingComments.length - 1;
    
    for (const [index, {type, value}] of leadingComments.entries()) {
        if (type === 'CommentLine') {
            if (index || !path.isClassProperty() && !path.isBinaryExpression())
                maybe.indent(isIndent);
            
            maybeInsideFn(insideFn, {
                print,
                indent,
            });
            
            if (isCommentOnPreviousLine(path))
                maybe.print.breakline(!isFirst$2(path));
            else
                maybe.print.space(propIs && !path.isClassProperty());
            
            print(`//${value}`);
            
            if (index === count) {
                maybe.print.breakline(propIs);
                maybe.print.newline(!propIs);
                
                if (isClassMethod$1(path)) {
                    indent();
                } else if (isBinaryExpression$1(path) || isDecorator$1(path)) {
                    indent.inc();
                    indent();
                    indent.dec();
                }
            } else {
                print.newline();
            }
            
            if (isInsideVar(path)) {
                indent.inc();
                indent();
                indent.dec();
            }
            
            continue;
        }
        
        if (type === 'CommentBlock') {
            maybe.indent(isIndent);
            
            const looksLikeMethod = path.isClassMethod();
            const looksLikeDirective = path.isDirective();
            const looksLikeProp = path.isObjectProperty();
            
            if (looksLikeProp)
                print.breakline();
            
            print(`/*${value}*/`);
            
            if (isTSPropertySignature(path) && !isPrev(path))
                print.breakline();
            
            if (path.isStatement() || path.isTSEnumMember() || looksLikeDirective || looksLikeMethod || looksLikeProp || looksLikeSwitchCase) {
                print.newline();
                markBefore$1(path);
                maybe.indent(looksLikeMethod || looksLikeProp || looksLikeSwitchCase);
            }
            
            continue;
        }
    }
};

var parseTrailingComments$2 = {};

var isLooksLikeChain$4 = {};

var chain$3 = {};

const {hasTrailingComment: hasTrailingComment$4} = is$3;
const {assign: assign$b} = Object;

chain$3.chain = (path) => {
    const all = [
        ...down$1(path),
        ...up$1(path),
    ];
    
    const properties = all.slice(0, -1);
    const root = all.at(-1);
    
    return [root, properties];
};

function down$1(path) {
    const properties = [];
    
    let current = path.get('object');
    
    while (!current.isIdentifier()) {
        const isFn = current.isCallExpression();
        const prop = build(current);
        
        if (isFn)
            current = current.get('callee');
        
        properties.unshift(prop);
        
        if (!current.isMemberExpression())
            break;
        
        current = current.get('object');
    }
    
    return properties;
}

function up$1(current) {
    const properties = [];
    
    while (current.isMemberExpression()) {
        if (hasTrailingComment$4(current.get('object')))
            properties.push({
                type: 'CommentLine',
            });
        
        current = current.parentPath;
        
        if (current.isCallExpression()) {
            properties.push(build(current));
            current = current.parentPath;
        }
        
        if (!current.isMemberExpression())
            break;
    }
    
    properties.push({
        type: current.type,
    });
    
    return properties;
}

function build(path) {
    const prop = {
        type: path.type,
    };
    
    if (path.isCallExpression())
        assign$b(prop, {
            args: path.node.arguments.length,
            name: path.node.callee.property?.name || '',
        });
    
    return prop;
}

const {types: types$14} = bundle;
const {chain: chain$2} = chain$3;
const {satisfy: satisfy$2} = is$3;

const {
    isUnaryExpression,
    isIfStatement: isIfStatement$1,
    isCallExpression: isCallExpression$8,
    isIdentifier: isIdentifier$e,
} = types$14;

const isArgOfCall = (path) => path.parentPath?.isCallExpression() && path.parentPath.get('arguments.0') === path;
const isCall$1 = (a) => a.type === 'CallExpression';

const isExcludedFromChain = satisfy$2([isUnaryExpression, isIfStatement$1]);
const hasComment = ({type}) => type === 'CommentLine';

const isInsideMemberCall = (path) => {
    if (!isIdentifier$e(path.node.object))
        return false;
    
    if (!isIdentifier$e(path.node.property))
        return false;
    
    return isCallExpression$8(path.parentPath.parentPath);
};

isLooksLikeChain$4.isLooksLikeChain = (path) => {
    const [root, properties] = chain$2(path);
    
    if (isInsideMemberCall(path))
        return false;
    
    if (isExcludedFromChain(root))
        return false;
    
    if (isPathGet(properties))
        return false;
    
    if (properties.find(hasComment))
        return true;
    
    if (path.find(isIfUp))
        return false;
    
    const calls = properties.filter(isCall$1);
    const [firstCall] = calls;
    
    if (calls.length === 2 && !firstCall.name)
        return false;
    
    if (isArgOfCall(path))
        return false;
    
    return calls.length > 1;
};

const isPathGet = ([property]) => {
    return isCallExpression$8(property, {
        name: 'get',
    });
};

const isIfUp = (path) => {
    const ifPath = path.find(isIfStatement$1);
    let is = false;
    
    if (!ifPath)
        return is;
    
    ifPath.get('test').traverse({
        MemberExpression(currentPath) {
            if (path === currentPath) {
                is = true;
                path.stop();
            }
        },
    });
    
    return is;
};

const {types: types$13} = bundle;

const {
    isLast: isLast$c,
    isCoupleLines: isCoupleLines$8,
    isNext: isNext$o,
} = is$3;

const {isLooksLikeChain: isLooksLikeChain$3} = isLooksLikeChain$4;

const {
    printTrailingComments,
    hasTrailingCommentsPrinter,
} = commentsPrinter;

const {
    isDecorator,
    isMemberExpression: isMemberExpression$6,
    isExpressionStatement: isExpressionStatement$6,
    isCallExpression: isCallExpression$7,
} = types$13;

const hasBody$1 = (path) => {
    if (path.isTSModuleDeclaration())
        return true;
    
    return path.node.body?.length;
};

const isFnParam = (path) => {
    const {parentPath} = path;
    
    if (!parentPath.isFunction())
        return false;
    
    return parentPath.get('params').includes(path);
};

function isSameLine(path, loc) {
    return path.node.loc?.start.line === loc.start.line || path.node.loc?.end.line === loc.end.line;
}

const isTrailingIsLeading = (path) => path.node.trailingComments === path.getNextSibling().node?.leadingComments;

const isNewlineAfter = (path) => {
    const {parentPath} = path;
    
    if (isDecorator(path)) {
        const {loc} = path.node.trailingComments[0];
        return !isSameLine(path, loc);
    }
    
    if (isMemberExpression$6(parentPath))
        return false;
    
    return !isLast$c(path);
};

parseTrailingComments$2.isTrailingIsLeading = isTrailingIsLeading;

function isCommentOnNextLine(path) {
    const {node} = path;
    const {
        loc,
        trailingComments,
    } = node;
    
    if (path.isClassMethod())
        return false;
    
    if (isTrailingIsLeading(path))
        return false;
    
    if (path.isThrowStatement())
        return false;
    
    const [comment] = trailingComments;
    const {line} = comment.loc.start;
    
    const next = path.getNextSibling();
    
    if (next.node && line < next.node.loc?.start.line)
        return false;
    
    if (!loc)
        return true;
    
    const startLine = loc.start.line;
    const endLine = loc.end.line;
    const isNextLine = line === startLine + 1 && line === endLine + 1;
    const isNextLineAfterNewline = line === startLine + 2 && line === endLine + 2;
    
    return isNextLine || isNextLineAfterNewline;
}

parseTrailingComments$2.parseTrailingComments = (path, printer, semantics, {currentTraverse} = {}) => {
    const {parentPath} = path;
    const {
        write,
        maybe,
        indent,
    } = printer;
    
    if (!semantics.comments)
        return;
    
    const {trailingComments} = path.node;
    
    if (!trailingComments?.length)
        return;
    
    if (hasTrailingCommentsPrinter(currentTraverse))
        return printTrailingComments(path, printer, semantics, {
            currentTraverse,
        });
    
    if (path.isDirective())
        return;
    
    const n = trailingComments.length - 1;
    const likeChain = isLooksLikeChain$3(parentPath);
    
    for (const {type, value, loc} of trailingComments) {
        const sameLine = isSameLine(path, loc);
        const commentOnNextLine = isCommentOnNextLine(path);
        
        if (type === 'CommentLine') {
            const nextLineInChain = commentOnNextLine && likeChain;
            const shouldIndent = !sameLine && !commentOnNextLine;
            
            maybe.write.breakline(commentOnNextLine);
            maybe.write.space(sameLine);
            
            if (shouldIndent || nextLineInChain) {
                maybe.indent.inc(nextLineInChain);
                indent();
                maybe.indent.dec(nextLineInChain);
            }
            
            if (hasBody$1(path)) {
                maybe.write.breakline(!isNext$o(path));
                maybe.write.breakline(!n);
            }
            
            write(`//${value}`);
            maybe.write.newline(isNewlineAfter(path));
            
            continue;
        }
        
        if (type === 'CommentBlock') {
            maybe.write.space(sameLine);
            maybe.indent(!sameLine);
            maybe.print.breakline(isPrevCall(path));
            write(`/*${value}*/`);
            maybe.write.newline(!sameLine || !isFnParam(path) && isCoupleLines$8(path.parentPath));
        }
    }
};

function isPrevCall(path) {
    const prev = path.getPrevSibling();
    
    if (isExpressionStatement$6(prev))
        return false;
    
    const {expression} = path.node;
    
    if (!isCallExpression$7(expression))
        return false;
    
    return !isCallExpression$7(expression.arguments[0]);
}

var parseComments$8 = {};

const {isNext: isNext$n} = is$3;

parseComments$8.parseComments = (path, {write, maybe}, semantics) => {
    if (!semantics.comments)
        return;
    
    const comments = path.node.comments || path.node.innerComments;
    
    if (!comments)
        return;
    
    const n = comments.length - 1;
    const program = path.isProgram();
    
    for (const [i, {type, value}] of comments.entries()) {
        if (type === 'CommentLine') {
            maybe.write.breakline(isNext$n(path) || !program);
            write('//');
            write(value);
            
            if (program) {
                maybe.write.newline(i < n);
                continue;
            }
            
            write.newline();
            continue;
        }
        
        if (type === 'CommentBlock') {
            write('/*');
            write(value);
            write('*/');
        }
    }
};

const {parseLeadingComments: parseLeadingComments$3} = parseLeadingComments$4;
const {parseTrailingComments: parseTrailingComments$1} = parseTrailingComments$2;
const {parseComments: parseComments$7} = parseComments$8;

comment.parseLeadingComments = parseLeadingComments$3;
comment.parseTrailingComments = parseTrailingComments$1;
comment.parseComments = parseComments$7;

const {parseComments: parseComments$6} = comment;

const noop$5 = () => {};
const parseParams = (path) => path.get('params');

params.printParams = (path, printer, semantics, customization = {}) => {
    const {extra, typeParameters} = path.node;
    const {
        print,
        maybe,
        traverse,
    } = printer;
    
    const {
        params = parseParams(path),
        braceOpen = '(',
        braceClose = ')',
        printSpace = print.space,
        printAfterOpen = noop$5,
        printBeforeClose = noop$5,
    } = customization;
    
    if (typeParameters)
        traverse(path.get('typeParameters'));
    
    printBraceOpen(path, {
        print,
        braceOpen,
    }, semantics);
    
    parseComments$6(path, printer, semantics);
    printAfterOpen();
    
    const n = params.length - 1;
    
    for (let i = 0; i <= n; i++) {
        const isLast = i === n;
        const current = params[i];
        
        traverse(current);
        
        if (!isLast) {
            print(',');
            printSpace();
        }
    }
    
    maybe.print(extra?.trailingComma, ',');
    
    printBeforeClose();
    printBraceClose(path, {
        print,
        braceClose,
    }, semantics);
};

function printBraceOpen(path, {print, braceOpen}, semantics) {
    if (isOneArgArrow(path) && !semantics.roundBraces.arrow)
        return;
    
    return print(braceOpen);
}

function printBraceClose(path, {print, braceClose}, semantics) {
    if (isOneArgArrow(path) && !semantics.roundBraces.arrow)
        return;
    
    print(braceClose);
}

function isOneArgArrow(path) {
    if (path.type !== 'ArrowFunctionExpression')
        return false;
    
    const {params} = path.node;
    const [param] = params;
    
    if (params.length !== 1)
        return false;
    
    return param.type === 'Identifier';
}

var maybeParens$e = {};

const isFn$6 = (a) => typeof a === 'function';
const isParens$3 = (path) => path.node.extra?.parenthesized;

maybeParens$e.isParens = isParens$3;
maybeParens$e.maybeParens = (print) => {
    if (isFn$6(print))
        return maybeParensPrint(print);
    
    return maybeParensCondition$1(print);
};

const maybeParensPrint = (print) => ({
    condition: isParens$3,
    before(path, {write}) {
        write('(');
    },
    print,
    after(path, {write}) {
        write(')');
    },
});

const maybeParensCondition$1 = ({print, condition, checkParens = true}) => ({
    ...maybeParensPrint(print),
    condition: (path, print, semantics) => {
        const is = condition?.(path, print, semantics);
        
        if (!checkParens)
            return is;
        
        return is || isParens$3(path);
    },
});

const {exists: exists$e} = is$3;
const {printParams: printParams$c} = params;
const {maybeParens: maybeParens$d} = maybeParens$e;

arrowFunctionExpression.ArrowFunctionExpression = maybeParens$d((path, printer, semantics) => {
    const {
        print,
        maybe,
        write,
        traverse,
    } = printer;
    
    const {async} = path.node;
    
    maybe.print(async, 'async ');
    printParams$c(path, printer, semantics);
    
    const returnType = path.get('returnType');
    
    if (exists$e(returnType)) {
        write(':');
        write.space();
        traverse(returnType);
    }
    
    print.space();
    print('=>');
    
    const body = path.get('body');
    
    const isJSX = body.isJSXElement();
    
    maybe.print.space(!isJSX);
    
    print('__body');
});

var functionDeclaration = {};

const {types: types$12} = bundle;
const {markAfter: markAfter$a} = mark;
const {isNext: isNext$m, isNextParent: isNextParent$4} = is$3;
const {printParams: printParams$b} = params;

const not = (fn) => (...a) => !fn(...a);
const notInsideExportDefaultWithBody = not(isInsideExportDefaultWithBody);

const {
    isAssignmentExpression: isAssignmentExpression$2,
    isTSModuleBlock: isTSModuleBlock$3,
    isBlockStatement: isBlockStatement$6,
    isExportNamedDeclaration: isExportNamedDeclaration$2,
    isExpressionStatement: isExpressionStatement$5,
    isFunctionDeclaration: isFunctionDeclaration$2,
    isExportDefaultDeclaration,
} = types$12;

const isInsideNamedExport$1 = ({parentPath}) => isExportNamedDeclaration$2(parentPath);

functionDeclaration.FunctionDeclaration = {
    print(path, printer, semantics) {
        const {print, maybe} = printer;
        
        const {
            async,
            generator,
            returnType,
        } = path.node;
        
        maybe.indent(!isInsideNamedExport$1(path));
        maybe.print(async, 'async ');
        
        print('function');
        
        if (!generator) {
            print(' ');
        } else {
            print('*');
            print.space();
        }
        
        print('__id');
        printParams$b(path, printer, semantics);
        
        if (returnType) {
            print(': ');
            print('__returnType');
        }
        
        print.space();
        print('__body');
    },
    afterSatisfy: () => [isNext$m, isNextParent$4, isInsideBlockStatement],
    after(path, {indent, maybe}) {
        if (isNextAssign$1(path) || isNextFunction(path) || isNext$m(path))
            indent();
        
        maybe.write.newline(notInsideExportDefaultWithBody(path));
        markAfter$a(path);
    },
};

const isNextFunction = (path) => {
    const next = path.getNextSibling();
    return isFunctionDeclaration$2(next);
};

const isNextAssign$1 = (path) => {
    const next = path.getNextSibling();
    
    if (!isExpressionStatement$5(next))
        return false;
    
    return isAssignmentExpression$2(next.node.expression);
};

function isInsideBlockStatement(path) {
    const {parentPath} = path;
    
    if (isTSModuleBlock$3(parentPath.parentPath))
        return true;
    
    if (!isBlockStatement$6(parentPath))
        return false;
    
    return !path.node.body.body.length;
}

function isInsideExportDefaultWithBody(path) {
    if (!isExportDefaultDeclaration(path.parentPath))
        return false;
    
    return path.node.body.body.length;
}

var classMethod$1 = {};

var maybeDecorators$4 = {};

const isPrevClassProperty = (path) => {
    const prev = path.getPrevSibling();
    
    if (!prev.node)
        return false;
    
    return prev.isClassProperty() || prev.isClassAccessorProperty();
};

maybeDecorators$4.maybeDecorators = (visitor) => (path, printer, semantics, options) => {
    const {
        write,
        traverse,
        maybe,
    } = printer;
    
    const {decorators} = path.node;
    
    if (decorators)
        for (const decorator of path.get('decorators')) {
            maybe.write.breakline(isPrevClassProperty(path));
            traverse(decorator);
            write.breakline();
        }
    
    visitor(path, printer, semantics, options);
};

var printKey$7 = {};

var maybePrintComputed$2 = {};

maybePrintComputed$2.maybePrintComputed = (path, key, {maybe, traverse}) => {
    const {computed} = path.node;
    
    maybe.write(computed, '[');
    traverse(key);
    maybe.write(computed, ']');
};

const {maybePrintComputed: maybePrintComputed$1} = maybePrintComputed$2;

printKey$7.printKey = (path, printer) => {
    const key = path.get('key');
    
    maybePrintComputed$1(path, key, printer);
};

var kind = {};

kind.printKind = (path, {write}) => {
    const {kind, generator} = path.node;
    
    const isGetter = kind === 'get' || kind === 'set';
    
    if (isGetter)
        write(`${kind} `);
    else if (generator)
        write('*');
};

var printFunctionParams$1 = {};

const {printParams: printParams$a} = params;
const {hasLeadingComment: hasLeadingComment$4} = is$3;

const isAllParamsHasLeadingComments = (path) => {
    const params = path.get('params');
    let commentsCount = 0;
    let decoratorsCount = 0;
    
    for (const param of params) {
        const decorators = param.get('decorators');
        
        if (!decorators.length)
            continue;
        
        const [firstDecorator] = decorators;
        ++decoratorsCount;
        
        if (hasLeadingComment$4(firstDecorator))
            ++commentsCount;
    }
    
    return commentsCount === decoratorsCount;
};

const hasDecorators = ({decorators}) => decorators?.length;

printFunctionParams$1.printFunctionParams = (path, printer, semantics) => {
    const {params} = path.node;
    const isNewline = params.filter(hasDecorators).length;
    const isAllHasComments = isAllParamsHasLeadingComments(path);
    
    const printSpace = createPrintSpace({
        isNewline,
        printer,
    });
    
    const printAfterOpen = createPrintAfterOpen({
        type: 'inc',
        printer,
        isNewline,
        isAllHasComments,
    });
    
    const printBeforeClose = createPrintBeforeClose({
        type: 'dec',
        printer,
        isNewline,
        isAllHasComments,
    });
    
    printParams$a(path, printer, semantics, {
        printAfterOpen,
        printSpace,
        printBeforeClose,
    });
};

const createPrintAfterOpen = ({isNewline, isAllHasComments, printer, type}) => () => {
    if (!isNewline)
        return;
    
    const {indent, print} = printer;
    
    if (!isAllHasComments)
        indent[type]();
    
    print.breakline();
};

const createPrintBeforeClose = ({isNewline, printer, isAllHasComments, type}) => () => {
    if (!isNewline)
        return;
    
    const {indent, print} = printer;
    
    if (!isAllHasComments)
        indent[type]();
    
    print.breakline();
};

const createPrintSpace = ({isNewline, printer}) => () => {
    const {print} = printer;
    
    if (!isNewline)
        return print.space();
    
    print.breakline();
};

const {
    isNext: isNext$l,
    hasTrailingComment: hasTrailingComment$3,
} = is$3;

const {maybeDecorators: maybeDecorators$3} = maybeDecorators$4;
const {printKey: printKey$6} = printKey$7;
const {printKind: printKind$3} = kind;
const {printFunctionParams} = printFunctionParams$1;

const noTrailingCommentAndNext = (path) => {
    if (hasTrailingComment$3(path))
        return false;
    
    return isNext$l(path);
};

const ClassMethod$1 = {
    print: maybeDecorators$3((path, printer, semantics) => {
        const {print} = printer;
        const {node} = path;
        const {accessibility, returnType} = node;
        
        if (accessibility) {
            print(accessibility);
            print(' ');
        }
        
        if (node.static) {
            print('static');
            print(' ');
        }
        
        if (node.override) {
            print('override');
            print(' ');
        }
        
        if (node.async) {
            print('async');
            print(' ');
        }
        
        printKind$3(path, printer);
        printKey$6(path, printer);
        printFunctionParams(path, printer, semantics);
        
        if (returnType) {
            print(':');
            print.space();
            print('__returnType');
        }
        
        print.space();
        print('__body');
    }),
    afterSatisfy: () => [noTrailingCommentAndNext],
    after(path, {print}) {
        print.linebreak();
    },
};

classMethod$1.ClassPrivateMethod = ClassMethod$1;
classMethod$1.ClassMethod = ClassMethod$1;

var objectMethod$1 = {};

const {isNewlineBetweenSiblings: isNewlineBetweenSiblings$3} = is$3;
const {printParams: printParams$9} = params;
const {printKey: printKey$5} = printKey$7;
const {printKind: printKind$2} = kind;

objectMethod$1.ObjectMethod = {
    beforeIf(path) {
        return path.node.async;
    },
    before(path, {write}) {
        write('async ');
    },
    print(path, printer, semantics) {
        const {print} = printer;
        
        printKind$2(path, printer);
        printKey$5(path, printer);
        printParams$9(path, printer, semantics);
        
        print.space();
        print('__body');
    },
    afterIf(path) {
        return isNewlineBetweenSiblings$3(path);
    },
    after(path, {print}) {
        print.linebreak();
    },
};

var functionExpression = {};

const {exists: exists$d} = is$3;
const {printParams: printParams$8} = params;
const {maybeParens: maybeParens$c} = maybeParens$e;

functionExpression.FunctionExpression = maybeParens$c((path, printer, semantics) => {
    const {
        print,
        maybe,
        write,
        traverse,
    } = printer;
    
    const {node} = path;
    const {generator, async} = node;
    
    maybe.write(async, 'async ');
    write('function');
    maybe.write(generator, '*');
    
    const id = path.get('id');
    
    if (exists$d(id)) {
        write(' ');
        traverse(id);
    }
    
    printParams$8(path, printer, semantics);
    
    print.space();
    print('__body');
});

const {ArrowFunctionExpression} = arrowFunctionExpression;
const {FunctionDeclaration} = functionDeclaration;

const {
    ClassMethod,
    ClassPrivateMethod,
} = classMethod$1;

const {ObjectMethod} = objectMethod$1;
const {FunctionExpression} = functionExpression;

functions$1.FunctionDeclaration = FunctionDeclaration;
functions$1.FunctionExpression = FunctionExpression;
functions$1.ArrowFunctionExpression = ArrowFunctionExpression;
functions$1.ClassMethod = ClassMethod;
functions$1.ClassPrivateMethod = ClassPrivateMethod;
functions$1.ObjectMethod = ObjectMethod;

var unaryExpressions$1 = {};

const {isLast: isLast$b, isNext: isNext$k} = is$3;
const {maybeParens: maybeParens$b} = maybeParens$e;

const isWord = (a) => /^(delete|typeof|void|throw)$/.test(a);

const unaryExpression = maybeParens$b((path, printer) => {
    const {maybe, traverse} = printer;
    const {prefix, operator} = path.node;
    const argPath = path.get('argument');
    
    maybe.print(prefix, operator);
    maybe.print(isWord(operator), ' ');
    traverse(argPath);
    maybe.print(!prefix, operator);
});

unaryExpressions$1.UnaryExpression = unaryExpression;
unaryExpressions$1.UpdateExpression = unaryExpression;

unaryExpressions$1.AwaitExpression = maybeParens$b((path, {print}) => {
    printUnary('await', {
        print,
    });
});

unaryExpressions$1.YieldExpression = maybeParens$b((path, {print, maybe}) => {
    const {delegate} = path.node;
    
    print(`yield`);
    maybe.print(delegate, '*');
    print(' ');
    print('__argument');
});

unaryExpressions$1.ThrowStatement = (path, {print, indent, maybe}) => {
    indent();
    
    printUnary('throw', {
        print,
    });
    
    print(';');
    maybe.print.newline(!isLast$b(path));
    maybe.print.breakline(isNext$k(path));
};

function printUnary(name, {print}) {
    print(`${name} `);
    print('__argument');
}

var memberExpressions$1 = {};

const {maybePrintComputed} = maybePrintComputed$2;
const {maybeParens: maybeParens$a} = maybeParens$e;
const {isLooksLikeChain: isLooksLikeChain$2} = isLooksLikeChain$4;

memberExpressions$1.MemberExpression = (path, printer) => {
    const {
        print,
        maybe,
        traverse,
    } = printer;
    
    const object = path.get('object');
    const property = path.get('property');
    const isParens = object.isAssignmentExpression();
    const {computed} = path.node;
    
    const isChain = isLooksLikeChain$2(path);
    
    maybe.print(isParens, '(');
    traverse(object);
    maybe.print(isParens, ')');
    
    if (computed)
        return maybePrintComputed(path, property, printer);
    
    maybe.indent.inc(isChain);
    maybe.print.breakline(isChain);
    
    print('.');
    print('__property');
    maybe.indent.dec(isChain);
};

memberExpressions$1.OptionalMemberExpression = maybeParens$a((path, {print, maybe}) => {
    const {computed, optional} = path.node;
    
    print('__object');
    
    maybe.print(optional, '?.');
    maybe.print(!optional && !computed, '.');
    
    if (computed) {
        print('[');
        print('__property');
        print(']');
        
        return;
    }
    
    print('__property');
});

var _class = {};

var maybeDeclare$6 = {};

maybeDeclare$6.maybeDeclare = (visit) => (path, printer, semantics) => {
    const {maybe} = printer;
    const {declare} = path.node;
    
    maybe.print(declare, 'declare ');
    visit(path, printer, semantics);
};

const {types: types$11} = bundle;

const {isNext: isNext$j} = is$3;
const {markAfter: markAfter$9} = mark;

const {maybeDeclare: maybeDeclare$5} = maybeDeclare$6;
const {parseComments: parseComments$5} = comment;
const {maybeDecorators: maybeDecorators$2} = maybeDecorators$4;

const isInsideTSModuleBlock = (path) => {
    return isTSModuleBlock$2(path.parentPath.parentPath);
};

const {
    isFunction: isFunction$6,
    isTSModuleBlock: isTSModuleBlock$2,
} = types$11;

const isInsideExport = ({parentPath}) => parentPath.isExportDeclaration();
const isFunctionLike = (path) => isFunction$6(path.parentPath.parentPath);
const hasBody = ({node}) => node.body.body.length;

const classVisitor = maybeDecorators$2((path, printer, semantics) => {
    const {
        id,
        abstract,
        superClass,
    } = path.node;
    
    const {
        print,
        indent,
        maybe,
        traverse,
    } = printer;
    
    maybe.print(abstract, 'abstract ');
    print('class');
    maybe.print(id || superClass, ' ');
    print('__id');
    print('__typeParameters');
    
    const {node} = path;
    
    if (node.superClass) {
        maybe.print(id, ' ');
        print('extends ');
        print('__superClass');
        print('__superTypeArguments');
    }
    
    if (node.implements) {
        print(' implements ');
        path.get('implements').forEach(print);
    }
    
    print.space();
    print('{');
    maybe.print.newline(path.node.body.body.length);
    indent.inc();
    
    const classBody = path.get('body');
    const body = classBody.get('body');
    
    for (const item of body) {
        indent();
        traverse(item);
    }
    
    if (!body.length)
        parseComments$5(classBody, printer, semantics);
    
    indent.dec();
    maybe.indent(body.length);
    print('}');
});

_class.ClassExpression = classVisitor;

_class.ClassDeclaration = {
    print: maybeDeclare$5((path, printer, semantics) => {
        const {maybe} = printer;
        maybe.indent(!isInsideExport(path));
        classVisitor(path, printer, semantics);
    }),
    afterIf(path) {
        if (isFunctionLike(path))
            return true;
        
        if (isNext$j(path))
            return true;
        
        return isInsideTSModuleBlock(path);
    },
    after(path, {write}) {
        write.newline();
        
        if (!isFunctionLike(path) && hasBody(path)) {
            write.newline();
            markAfter$9(path);
        }
    },
};

var callExpression = {};

const {exists: exists$c} = is$3;
const {maybeParens: maybeParens$9} = maybeParens$e;
const {isArray: isArray$e} = Array;

const parseArgs = (path) => {
    const argsPath = path.get('arguments');
    
    if (!isArray$e(argsPath))
        return [];
    
    return argsPath;
};

const CallExpression$1 = maybeParens$9((path, {indent, print, maybe, traverse}) => {
    const args = parseArgs(path);
    const isParentCall = tooLong$1(args) && path.parentPath.isCallExpression();
    
    const callee = path.get('callee');
    const typeParameters = path.get('typeArguments');
    
    traverse(callee);
    
    if (exists$c(typeParameters))
        traverse(typeParameters);
    
    if (path.node.optional)
        print('?.');
    
    print('(');
    
    const n = args.length - 1;
    
    maybe.indent.inc(isParentCall);
    
    for (const [i, arg] of args.entries()) {
        const isObject = arg.isObjectExpression();
        
        if (isParentCall && !isObject && n)
            print.breakline();
        
        print(arg);
        
        if (isParentCall && n) {
            print(',');
            continue;
        }
        
        if (i < n) {
            print(',');
            print.space();
        }
    }
    
    if (isParentCall) {
        indent.dec();
        maybe.print.breakline(n);
    }
    
    print(')');
});

callExpression.OptionalCallExpression = CallExpression$1;
callExpression.CallExpression = CallExpression$1;

function tooLong$1(args) {
    for (const arg of args) {
        if (arg.isIdentifier() && arg.node.name.length > 10)
            return true;
    }
    
    return false;
}

var newExpression = {};

const {types: types$10} = bundle;
const {exists: exists$b} = is$3;
const {isMarkedAfter: isMarkedAfter$2} = mark;

const {
    isExpressionStatement: isExpressionStatement$4,
    isMemberExpression: isMemberExpression$5,
} = types$10;

const isInsideExpressionStatement = ({parentPath}) => isExpressionStatement$4(parentPath);
const notFirst = ({parentPath}) => exists$b(parentPath.getPrevSibling());
const isInsideMember = ({parentPath}) => isMemberExpression$5(parentPath);

const getPrev = ({parentPath}) => {
    const prev = parentPath.getPrevSibling();
    
    return [
        prev.node,
        prev,
    ];
};

newExpression.NewExpression = {
    beforeIf(path) {
        if (!isInsideExpressionStatement(path))
            return false;
        
        const [exists, prev] = getPrev(path);
        
        if (!exists)
            return false;
        
        if (isMarkedAfter$2(prev))
            return false;
        
        if (prev.isExpressionStatement())
            return false;
        
        return notFirst(path);
    },
    before(path, {print}) {
        print.breakline();
    },
    print(path, printer, semantics) {
        const {print, maybe} = printer;
        print('new ');
        print('__callee');
        print('__typeArguments');
        
        const args = path.get('arguments');
        maybePrintOpenBrace(path, printer, semantics);
        
        const n = args.length - 1;
        
        for (const [i, arg] of args.entries()) {
            print(arg);
            maybe.print(i < n, ', ');
        }
        
        maybePrintCloseBrace(path, printer, semantics);
    },
};

function maybePrintOpenBrace(path, printer, semantics) {
    maybePrintBrace('(', path, printer, semantics);
}

function maybePrintCloseBrace(path, printer, semantics) {
    maybePrintBrace(')', path, printer, semantics);
}

function maybePrintBrace(brace, path, printer, semantics) {
    const {maybe, print} = printer;
    const {roundBraces} = semantics;
    const {length} = path.node.arguments;
    
    if (length || isInsideMember(path))
        return print(brace);
    
    maybe.print(roundBraces.new, brace);
}

var objectExpression$2 = {};

var isInsideTuple$1 = {};

const {types: types$$} = bundle;
const {isArrayExpression: isArrayExpression$8} = types$$;

const TYPES$3 = [
    'NullLiteral',
    'NumericLiteral',
    'BigIntLiteral',
];

isInsideTuple$1.isInsideTuple = (path) => {
    const {parentPath} = path;
    
    if (!isArrayExpression$8(parentPath))
        return false;
    
    const [first, second] = parentPath.node.elements;
    
    if (second !== path.node)
        return false;
    
    return TYPES$3.includes(first.type);
};

var isThirdObjectInsideArray$1 = {};

const {types: types$_} = bundle;
const {
    isArrayExpression: isArrayExpression$7,
    isCallExpression: isCallExpression$6,
    isIdentifier: isIdentifier$d,
} = types$_;

isThirdObjectInsideArray$1.isThirdObjectInsideArray = ({parentPath}) => {
    if (!isArrayExpression$7(parentPath))
        return false;
    
    const [, second] = parentPath.node.elements;
    
    return isCallExpression$6(second) && !!isIdentifier$d(second);
};

const {types: types$Z} = bundle;
const {
    isCoupleLines: isCoupleLines$7,
    isForOf: isForOf$3,
    isIf,
    noTrailingComment: noTrailingComment$2,
    isNewlineBetweenSiblings: isNewlineBetweenSiblings$2,
    noLeadingComment,
    hasLeadingComment: hasLeadingComment$3,
    exists: exists$a,
} = is$3;

const {parseComments: parseComments$4} = comment;
const {isInsideTuple} = isInsideTuple$1;
const {isLooksLikeChain: isLooksLikeChain$1} = isLooksLikeChain$4;
const {isThirdObjectInsideArray} = isThirdObjectInsideArray$1;

const {
    isStringLiteral: isStringLiteral$8,
    isArrayExpression: isArrayExpression$6,
} = types$Z;

const isBodyOfArrow = (path) => path.parentPath.node.body === path.node;
const isLogical = (path) => path.get('argument').isLogicalExpression();
const isValue = (path) => path.get('properties.0.value').node;
const isParentExpression = (path) => path.parentPath.isExpressionStatement();

const isMemberExpressionCallee = ({parentPath}) => {
    if (!parentPath.isCallExpression())
        return false;
    
    const callee = parentPath.get('callee');
    
    if (!callee.isMemberExpression())
        return false;
    
    return isLooksLikeChain$1(callee);
};

const isInsideCall = ({parentPath}) => parentPath.isCallExpression();

function isInsideNestedArrayCall({parentPath}) {
    if (!isArrayExpression$6(parentPath))
        return false;
    
    if (!isArrayExpression$6(parentPath.parentPath))
        return false;
    
    return isInsideCall(parentPath.parentPath);
}

function isInsideNestedTuple({parentPath}) {
    const {elements} = parentPath.parentPath.node;
    const [first] = elements;
    
    return isStringLiteral$8(first);
}

objectExpression$2.ObjectExpression = (path, printer, semantics) => {
    const {trailingComma} = semantics;
    const {
        print,
        maybe,
        indent,
    } = printer;
    
    const insideNestedArrayCall = isInsideTuple(path) || isInsideNestedArrayCall(path) || isThirdObjectInsideArray(path);
    
    maybe.indent.inc(!insideNestedArrayCall);
    
    const properties = path.get('properties');
    const {length} = properties;
    const parens = isParens$2(path);
    const manyLines = !isOneLine$1(path);
    
    maybe.print(parens, '(');
    print('{');
    parseComments$4(path, printer, semantics);
    maybe.print.newline(manyLines);
    
    const n = properties.length - 1;
    
    const memberCallee = isMemberExpressionCallee(path);
    maybe.indent.inc(memberCallee);
    
    for (const [index, property] of properties.entries()) {
        if (property.isSpreadElement()) {
            const logical = isLogical(property);
            
            if (noLeadingComment(property))
                maybe.indent(length > 1 || logical || manyLines);
            
            print(property);
            
            if (noTrailingComment$2(property) && (length > 1 || manyLines)) {
                maybe.print(index !== n || trailingComma, ',');
                print.newline();
            }
            
            continue;
        }
        
        maybe.indent(manyLines && noLeadingComment(property));
        print(property);
        
        if (property.isObjectMethod())
            continue;
        
        if (noTrailingComment$2(property) && !hasNextLeadingComment(property)) {
            maybe.print.newline(manyLines);
            maybe.print.linebreak(isNewlineBetweenSiblings$2(property));
        }
    }
    
    if (!insideNestedArrayCall) {
        indent.dec();
        maybe.indent(manyLines);
    } else if (isInsideTuple(path) || isInsideNestedTuple(path)) {
        indent.dec();
        indent();
        indent.inc();
    }
    
    print('}');
    maybe.print(parens, ')');
    
    maybe.indent.dec(memberCallee);
};

const hasNextLeadingComment = (path) => {
    const next = path.getNextSibling();
    
    if (!exists$a(next))
        return false;
    
    return hasLeadingComment$3(next);
};

const notLastArgInsideCall = (path) => {
    const {parentPath} = path;
    
    if (!parentPath.isCallExpression())
        return false;
    
    if (isCoupleLines$7(path))
        return false;
    
    return path !== parentPath.get('arguments').at(-1);
};

const ONE_LINE$2 = true;
const MANY_LINES = false;

objectExpression$2.isOneLine = isOneLine$1;
function isOneLine$1(path) {
    const {length} = path.get('properties');
    
    if (!length)
        return ONE_LINE$2;
    
    if (notLastArgInsideCall(path))
        return ONE_LINE$2;
    
    if (isForOf$3(path))
        return ONE_LINE$2;
    
    if (isIf(path))
        return ONE_LINE$2;
    
    if (isCoupleLines$7(path))
        return MANY_LINES;
    
    return !isValue(path);
}

function isParens$2(path) {
    if (isBodyOfArrow(path))
        return true;
    
    return isParentExpression(path);
}

var objectProperty$3 = {};

var concatenate$1 = {};

const {types: types$Y} = bundle;
const {
    isStringLiteral: isStringLiteral$7,
    isTemplateLiteral: isTemplateLiteral$3,
    isBinaryExpression,
} = types$Y;

const isStringLike = (a) => {
    if (isStringLiteral$7(a))
        return true;
    
    return isTemplateLiteral$3(a);
};

concatenate$1.isConcatenation = (path) => {
    const {parentPath} = path;
    const {operator} = path.node;
    
    if (operator !== '+')
        return false;
    
    const startLine = path.node.loc?.start.line;
    const endLine = path.node.loc?.end.line;
    
    if (startLine === endLine)
        return false;
    
    const left = path.get('left');
    const right = path.get('right');
    
    if (isStringLike(left) && isStringLike(right) && isBinaryExpression(parentPath))
        return true;
    
    return isBinaryExpression(left) && isStringLike(right);
};

concatenate$1.concatenate = (path, {print, indent}) => {
    if (!path.parentPath.isBinaryExpression()) {
        indent.inc();
        print.breakline();
    }
    
    print('__left');
    print.space();
    print('+');
    print.breakline();
    print('__right');
    
    if (!path.parentPath.isBinaryExpression())
        indent.dec();
};

const {types: types$X} = bundle;
const {isConcatenation: isConcatenation$2} = concatenate$1;
const {isOneLine} = objectExpression$2;
const {printKey: printKey$4} = printKey$7;
const {isTSImportType} = types$X;
const isInsideTSImportType = ({parentPath}) => isTSImportType(parentPath.parentPath);

objectProperty$3.ObjectProperty = (path, printer, semantics) => {
    const {trailingComma} = semantics;
    const {shorthand} = path.node;
    const {
        maybe,
        traverse,
        write,
    } = printer;
    
    const value = path.get('value');
    const properties = path.parentPath.get('properties');
    const isLast = path === properties.at(-1);
    const manyLines = !isOneLine(path.parentPath);
    
    printKey$4(path, printer);
    
    if (!shorthand) {
        write(':');
        maybe.write.space(!isConcatenation$2(value));
        traverse(value);
    }
    
    if (manyLines && !isInsideTSImportType(path))
        maybe.write(!isLast || trailingComma, ',');
    else if (!isLast && properties.length)
        write(', ');
};

var objectPattern$1 = {};

var wrongShortand = {};

wrongShortand.wrongShorthand = ({computed, isAssign, keyPath, valuePath}) => {
    return !computed && !isAssign && keyPath.node.name !== valuePath.node.name;
};

var moreThenMaxPropertiesInOneLine$1 = {};

moreThenMaxPropertiesInOneLine$1.moreThenMaxPropertiesInOneLine = (path, {maxPropertiesInOneLine}) => {
    const {parentPath} = path;
    
    if (parentPath.isObjectProperty())
        return false;
    
    const n = path.node.properties.length;
    
    return maxPropertiesInOneLine >= n;
};

var maybeTypeAnnotation$4 = {};

const {types: types$W} = bundle;
const {
    isMemberExpression: isMemberExpression$4,
    isSequenceExpression: isSequenceExpression$1,
} = types$W;

maybeTypeAnnotation$4.maybePrintTypeAnnotation = maybePrintTypeAnnotation$3;

maybeTypeAnnotation$4.maybeTypeAnnotation = (visit) => (path, printer, semantics) => {
    visit(path, printer, semantics);
    
    maybePrintTypeAnnotation$3(path, printer);
};

function maybePrintTypeAnnotation$3(path, printer) {
    const {parentPath, node} = path;
    
    const {typeAnnotation} = node;
    const {write, traverse} = printer;
    
    if (isSequenceExpression$1(parentPath))
        return;
    
    if (isMemberExpression$4(parentPath))
        return;
    
    if (typeAnnotation) {
        write(':');
        write.space();
        traverse(path.get('typeAnnotation'));
    }
}

var moreThenMaxPropertiesLengthInOneLine$1 = {};

const {types: types$V} = bundle;
const {
    isAssignmentPattern: isAssignmentPattern$2,
    isIdentifier: isIdentifier$c,
} = types$V;

function getLength(left, right) {
    if (isIdentifier$c(left) && isIdentifier$c(right))
        return left.name.length + right.name.length;
    
    if (isIdentifier$c(left))
        return left.name.length;
    
    return 0;
}

moreThenMaxPropertiesLengthInOneLine$1.moreThenMaxPropertiesLengthInOneLine = (path, {maxPropertiesLengthInOneLine}) => {
    const {properties} = path.node;
    
    for (const {key, value} of properties) {
        if (isAssignmentPattern$2(value)) {
            const {left, right} = value;
            
            const length = getLength(left, right);
            
            if (length >= maxPropertiesLengthInOneLine)
                return true;
        }
        
        if (!isIdentifier$c(key))
            continue;
        
        const {name} = key;
        
        if (name.length >= maxPropertiesLengthInOneLine)
            return true;
    }
    
    return false;
};

var calculateLongAssignPattern = {};

const {types: types$U} = bundle;
const {
    isAssignmentPattern: isAssignmentPattern$1,
    isArrayExpression: isArrayExpression$5,
    isObjectExpression: isObjectExpression$7,
} = types$U;

calculateLongAssignPattern.calculateAssigns = (property, semantics) => {
    const currentAssign = isLongAssignPattern$1(property, semantics);
    
    const {right} = property.node.value;
    const isArrayOrObjectRight = isArrayExpression$5(right) || isComplexObject(right);
    const complexAssign = currentAssign && isArrayOrObjectRight;
    
    return {
        complexAssign,
    };
};

calculateLongAssignPattern.isLongAssignPattern = isLongAssignPattern$1;

function isLongAssignPattern$1(path, semantics) {
    if (!isAssignmentPattern$1(path.node.value))
        return false;
    
    const {maxPropertiesLengthInOneLine} = semantics;
    
    return path.node.key.name.length > maxPropertiesLengthInOneLine;
}

function isComplexObject(node) {
    if (!isObjectExpression$7(node))
        return false;
    
    return node.properties.length;
}

const {types: types$T} = bundle;
const {wrongShorthand} = wrongShortand;

const {
    isForOf: isForOf$2,
    isCoupleLines: isCoupleLines$6,
    exists: exists$9,
} = is$3;

const {moreThenMaxPropertiesInOneLine} = moreThenMaxPropertiesInOneLine$1;

const {maybeTypeAnnotation: maybeTypeAnnotation$3} = maybeTypeAnnotation$4;
const {moreThenMaxPropertiesLengthInOneLine} = moreThenMaxPropertiesLengthInOneLine$1;
const {printKey: printKey$3} = printKey$7;

const {
    calculateAssigns,
    isLongAssignPattern,
} = calculateLongAssignPattern;

const {
    isObjectExpression: isObjectExpression$6,
    isIdentifier: isIdentifier$b,
    isAssignmentPattern,
    isVariableDeclarator: isVariableDeclarator$2,
    isFunction: isFunction$5,
    isObjectPattern: isObjectPattern$2,
    isForOfStatement,
    isVariableDeclaration: isVariableDeclaration$3,
} = types$T;

const isInsideFn = (path) => {
    if (isFunction$5(path.parentPath))
        return true;
    
    return isFunction$5(path.parentPath.parentPath);
};

function isIndent(path) {
    return !path.parentPath.isArrayPattern();
}

const isCoupleProperties = ({path, valuePath, property}) => {
    if (!isCoupleLines$6(valuePath))
        return false;
    
    if (exists$9(property.getPrevSibling()))
        return false;
    
    const properties = path.get('properties');
    
    if (path.parentPath.isVariableDeclarator() && !hasAssign(properties))
        return false;
    
    return !path.parentPath.isObjectProperty();
};

function isInsideForOf({parentPath}) {
    return isForOfStatement(parentPath.parentPath.parentPath);
}

function isPrevAssign(path) {
    const prev = path.getPrevSibling();
    
    return isAssignmentPattern(prev.node.value);
}

function isPrevAssignObject(path) {
    const prev = path.getPrevSibling();
    
    if (!isAssignmentPattern(prev.node.value))
        return false;
    
    const {right} = prev.node.value;
    
    return isObjectExpression$6(right);
}

function isNextAssignObject(path) {
    const next = path.getNextSibling();
    
    if (!next.node)
        return false;
    
    if (!isAssignmentPattern(next.node.value))
        return false;
    
    const {right} = next.node.value;
    
    return isObjectExpression$6(right);
}

objectPattern$1.ObjectPattern = {
    print: maybeTypeAnnotation$3((path, printer, semantics) => {
        const shouldIndent = isIndent(path);
        const {
            maxPropertiesInOneLine,
            maxPropertiesLengthInOneLine,
        } = semantics;
        
        const {
            print,
            maybe,
            indent,
        } = printer;
        
        maybe.indent.inc(shouldIndent);
        print('{');
        
        const properties = path.get('properties');
        const n = properties.length - 1;
        
        const is = shouldAddNewline(path, {
            maxPropertiesInOneLine,
            maxPropertiesLengthInOneLine,
        });
        
        const hasObject = n && hasObjectPattern(properties);
        const notInsideFn = !isInsideFn(path);
        
        maybe.print.newline(is && notInsideFn);
        
        for (const [i, property] of properties.entries()) {
            if (property.isRestElement()) {
                const couple = is || hasObject;
                
                maybe.indent(couple);
                print(property);
                maybe.print.newline(couple);
                continue;
            }
            
            const prevAssignObject = i && isPrevAssignObject(property);
            const nextAssignObject = isNextAssignObject(property);
            
            const valuePath = property.get('value');
            const keyPath = property.get('key');
            const isAssign = valuePath.isAssignmentPattern();
            
            const {shorthand, computed} = property.node;
            const couple = isCoupleProperties({
                path,
                property,
                valuePath,
            });
            
            maybe.indent((prevAssignObject || is) && notInsideFn);
            maybe.print.breakline(couple && !isLongAssignPattern(property, semantics));
            
            if (!isAssign && nextAssignObject)
                print.breakline();
            
            printKey$3(property, printer);
            
            if (!shorthand || wrongShorthand({computed, isAssign, keyPath, valuePath})) {
                print(':');
                print.space();
                print(valuePath);
            } else if (isAssign) {
                print(valuePath);
                
                maybe.print(couple, ',');
                maybe.print.newline(couple);
                
                const {right} = valuePath.node;
                
                if (i && !isPrevAssign(property) && !isInsideForOf(path) && isObjectExpression$6(right)) {
                    print(',');
                    print.newline();
                    continue;
                }
            }
            
            if (!isAssign && nextAssignObject && notInsideFn) {
                print(',');
                print.breakline();
                continue;
            }
            
            const {complexAssign} = calculateAssigns(property, semantics);
            
            if (!complexAssign && (is || hasObject || prevAssignObject && notInsideFn)) {
                print(',');
                print.newline();
                
                continue;
            }
            
            if (i < n && !(isAssign && couple)) {
                print(',');
                print.space();
            }
        }
        
        indent.dec();
        
        maybe.indent(is || hasAssignObject(path, maxPropertiesLengthInOneLine));
        maybe.indent.inc(!shouldIndent);
        print('}');
    }),
};

function checkLength(properties) {
    for (const prop of properties) {
        const {value} = prop.node;
        
        if (!isIdentifier$b(value))
            continue;
        
        if (value.name.length > 4)
            return true;
    }
    
    return false;
}

function hasAssign(properties) {
    for (const prop of properties) {
        const {value} = prop.node;
        
        if (isAssignmentPattern(value))
            return true;
    }
    
    return false;
}

function hasAssignObject(path, maxPropertiesLengthInOneLine) {
    const {parentPath} = path;
    
    if (isVariableDeclaration$3(parentPath.parentPath)) {
        const {declarations} = parentPath.parentPath.node;
        
        if (declarations.length > 1)
            return false;
    }
    
    const properties = path.get('properties');
    const n = properties.length;
    
    for (const prop of properties) {
        const {value} = prop.node;
        
        if (isAssignmentPattern(value) && isObjectExpression$6(value.right))
            return n > 1 || maxPropertiesLengthInOneLine <= value.left;
    }
    
    return false;
}

function hasObjectPattern(properties) {
    for (const property of properties) {
        if (isObjectPattern$2(property.node.value))
            return true;
    }
    
    return false;
}

const ONE_LINE$1 = false;
const COUPLE_LINES = true;

function shouldAddNewline(path, semantics) {
    const {parentPath} = path;
    const properties = path.get('properties');
    const n = properties.length - 1;
    
    const {
        maxPropertiesInOneLine,
        maxPropertiesLengthInOneLine,
    } = semantics;
    
    const moreLength = moreThenMaxPropertiesLengthInOneLine(path, {
        maxPropertiesLengthInOneLine,
    });
    
    const moreCount = moreThenMaxPropertiesInOneLine(path, {
        maxPropertiesInOneLine,
    });
    
    const fnParam = isFunctionParam(path);
    
    if (hasObjectPattern(properties))
        return COUPLE_LINES;
    
    if (moreCount && !moreLength && isVariableDeclarator$2(path.parentPath))
        return ONE_LINE$1;
    
    if (!fnParam && n && !isForOf$2(path) && checkLength(properties))
        return COUPLE_LINES;
    
    if (!fnParam && hasAssign(properties))
        return COUPLE_LINES;
    
    return parentPath.isObjectProperty();
}

function isFunctionParam({parentPath}) {
    if (parentPath.isFunction())
        return true;
    
    if (!parentPath.isAssignmentPattern())
        return false;
    
    return parentPath.parentPath.isFunction();
}

var classProperty = {};

const {exists: exists$8} = is$3;
const {maybePrintTypeAnnotation: maybePrintTypeAnnotation$2} = maybeTypeAnnotation$4;
const {maybeDecorators: maybeDecorators$1} = maybeDecorators$4;
const {printKey: printKey$2} = printKey$7;
const {printKind: printKind$1} = kind;

const processClassProperty = maybeDecorators$1((path, printer, semantics, {accessor} = {}) => {
    const {node} = path;
    const {
        accessibility,
        declare,
        optional,
    } = node;
    
    const {print, maybe} = printer;
    
    maybe.print(accessor, 'accessor ');
    
    const value = path.get('value');
    
    maybe.print(declare, 'declare ');
    maybe.print(accessibility, `${accessibility} `);
    maybe.print(node.static, 'static ');
    maybe.print(node.readonly, 'readonly ');
    
    printKind$1(path, printer);
    printKey$2(path, printer);
    
    maybe.print(optional, '?');
    
    maybePrintTypeAnnotation$2(path, printer);
    
    if (exists$8(value)) {
        print.space();
        print('=');
        print.space();
        print('__value');
    }
    
    print(';');
    print.newline();
});

classProperty.ClassProperty = processClassProperty;
classProperty.ClassPrivateProperty = processClassProperty;

classProperty.PrivateName = (path, {print}) => {
    print('#');
    print('__id');
};

classProperty.ClassAccessorProperty = (path, printer, semantics) => {
    processClassProperty(path, printer, semantics, {
        accessor: true,
    });
};

var assignmentExpression = {exports: {}};

var maybeParensCondition = {};

const {hasLeadingComment: hasLeadingComment$2} = is$3;

const {isParens: isParens$1} = maybeParens$e;

maybeParensCondition.condition = (path, printer, semantics) => {
    const {parentPath} = path;
    const {type} = parentPath;
    const {roundBraces} = semantics;
    
    if (path.node.left.type === 'ObjectPattern')
        return true;
    
    if (type === 'LogicalExpression')
        return true;
    
    if (type === 'BinaryExpression')
        return true;
    
    if (type === 'UnaryExpression')
        return true;
    
    if (!roundBraces.assign && !hasLeadingComment$2(path))
        return false;
    
    return isParens$1(path);
};

var assignmentExpressionComments = {};

const {types: types$S} = bundle;
const {hasLeadingComment: hasLeadingComment$1} = is$3;
const {isReturnStatement: isReturnStatement$2} = types$S;

assignmentExpressionComments.printLeadingCommentLine = (path, printer, semantics, {printComment, isLast}) => {
    const {parentPath} = path;
    const {print, maybe} = printer;
    
    if (isReturnStatement$2(parentPath))
        return;
    
    maybe.print.breakline(!isLast);
    printComment();
    print.breakline();
};

assignmentExpressionComments.printLeadingCommentBlock = (path, printer, semantics, {printComment}) => {
    const {parentPath} = path;
    const {print} = printer;
    
    if (isReturnStatement$2(parentPath))
        return;
    
    printComment();
    print.indent();
};

assignmentExpressionComments.maybeInsideReturnWithCommentStart = (path, {print, indent}) => {
    const {parentPath} = path;
    const is = isReturnStatement$2(parentPath);
    
    if (is && hasLeadingComment$1(path)) {
        indent.inc();
        const {leadingComments} = path.node;
        
        print.breakline();
        for (const {type, value} of leadingComments) {
            if (type === 'CommentLine')
                print(`//${value}`);
            else
                print(`/*${value}*/`);
            
            print.breakline();
        }
    }
};

assignmentExpressionComments.maybeInsideReturnWithCommentEnd = (path, {print, indent}) => {
    const {parentPath} = path;
    const is = isReturnStatement$2(parentPath);
    
    if (!is || !hasLeadingComment$1(path))
        return;
    
    indent.dec();
    print.breakline();
};

var printSeparator = {};

const {types: types$R} = bundle;
const {
    isAssignmentExpression: isAssignmentExpression$1,
    isExpressionStatement: isExpressionStatement$3,
} = types$R;

printSeparator.printSeparator = (path, {print}) => {
    if (isMultiline(path))
        print.breakline();
    else
        print.space();
};

function isMultiline(path) {
    const {right} = path.node;
    
    if (!path.parentPath.find(isExpressionStatement$3))
        return false;
    
    return isAssignmentExpression$1(right);
}

(function (module) {

	const {condition} = maybeParensCondition;

	const {
	    printLeadingCommentLine,
	    maybeInsideReturnWithCommentEnd,
	    maybeInsideReturnWithCommentStart,
	    printLeadingCommentBlock,
	} = assignmentExpressionComments;

	const {maybeParens} = maybeParens$e;
	const {printSeparator: printSeparator$1} = printSeparator;

	const isInsideBlock = ({parentPath}) => /BlockStatement|Program/.test(parentPath.type);

	module.exports.AssignmentExpression = maybeParens({
	    checkParens: false,
	    condition,
	    print(path, printer) {
	        const {print} = printer;
	        const {operator} = path.node;
	        
	        maybeInsideReturnWithCommentStart(path, printer);
	        
	        print('__left');
	        print.space();
	        print(operator);
	        printSeparator$1(path, printer);
	        print('__right');
	        
	        if (isInsideBlock(path)) {
	            print(';');
	            print.breakline();
	        }
	        
	        maybeInsideReturnWithCommentEnd(path, printer);
	    },
	});

	module.exports.AssignmentExpression.printLeadingCommentLine = printLeadingCommentLine;
	module.exports.AssignmentExpression.printLeadingCommentBlock = printLeadingCommentBlock; 
} (assignmentExpression));

var assignmentExpressionExports = assignmentExpression.exports;
assignmentExpressionExports.default;

var arrayExpression$3 = {};

var newline = {};

var operate = {};

var getBinding$2 = {};

const {types: types$Q} = bundle;
const {
    isIdentifier: isIdentifier$a,
    isMemberExpression: isMemberExpression$3,
} = types$Q;

const isString$e = (a) => typeof a === 'string';

getBinding$2.getBinding = getBinding$1;
function getBinding$1(path, node) {
    const name = parseName$1(node);
    return path.scope.getAllBindings()[name];
}

getBinding$2.getBindingPath = (path, name) => getBinding$1(path, name)?.path;

const parseName$1 = (node) => {
    if (isString$e(node))
        return node;
    
    if (isIdentifier$a(node))
        return node.name;
    
    if (isMemberExpression$3(node))
        return parseName$1(node.object);
    
    return '';
};

var isSimple$2 = {};

const {types: types$P} = bundle;
const {
    isOptionalMemberExpression,
    isMemberExpression: isMemberExpression$2,
    isIdentifier: isIdentifier$9,
    isLiteral: isLiteral$3,
} = types$P;

isSimple$2.isSimple = (a) => {
    if (isLiteral$3(a))
        return true;
    
    if (isIdentifier$9(a))
        return true;
    
    if (isMemberExpression$2(a))
        return true;
    
    return isOptionalMemberExpression(a);
};

var extract$6 = {};

const {types: types$O} = bundle;
const {
    isArrayExpression: isArrayExpression$4,
    isLiteral: isLiteral$2,
    isIdentifier: isIdentifier$8,
    isMemberExpression: isMemberExpression$1,
    isTemplateElement: isTemplateElement$3,
    isRegExpLiteral: isRegExpLiteral$1,
    isClassMethod,
    isTemplateLiteral: isTemplateLiteral$2,
    isJSXText: isJSXText$3,
    isJSXAttribute: isJSXAttribute$2,
    isJSXIdentifier: isJSXIdentifier$2,
    isTSTypeReference: isTSTypeReference$2,
    isTSTypeParameter,
} = types$O;

extract$6.extract = extract$5;

function extract$5(node) {
    node = node.node || node;
    
    if (isIdentifier$8(node))
        return node.name;
    
    if (isJSXIdentifier$2(node))
        return node.name;
    
    if (isRegExpLiteral$1(node))
        return node.pattern;
    
    if (isTemplateLiteral$2(node))
        return extract$5(node.quasis[0]);
    
    if (isLiteral$2(node))
        return node.value;
    
    if (isTemplateElement$3(node))
        return node.value.raw;
    
    if (isMemberExpression$1(node))
        return `${extract$5(node.object)}.${extract$5(node.property)}`;
    
    if (isArrayExpression$4(node))
        return extractArrayExpression(node);
    
    if (isJSXText$3(node))
        return node.value;
    
    if (isJSXAttribute$2(node))
        return node.name.name;
    
    if (isClassMethod(node))
        return extract$5(node.key);
    
    if (isTSTypeReference$2(node))
        return extract$5(node.typeName);
    
    if (isTSTypeParameter(node))
        return extract$5(node.name);
    
    const nodeTypes = [
        'Literals',
        'Identifiers',
        'TemplateLiteral',
        'TemplateElement',
        'RegExpLiteral',
        'ArrayExpression',
        'MemberExpression',
        'JSXIdentifier',
        'JSXAttribute',
        'JSXText',
        'TSTypeParameter',
    ].join(', ');
    
    throw Error(`'operator.extract(node)' understands only ${nodeTypes} and TSTypeReference🤷, found: ${node.type}`);
}

function extractArrayExpression(node, collector = []) {
    for (const el of node.elements) {
        if (isArrayExpression$4(el)) {
            extractArrayExpression(el, collector);
            continue;
        }
        
        collector.push(extract$5(el));
    }
    
    return collector.join(',');
}

var compute$2 = {};

const {getBindingPath: getBindingPath$1} = getBinding$2;
const {extract: extract$4} = extract$6;

const NOT_COMPUTED = false;
const COMPUTED = true;

compute$2.compute = compute$1;
function compute$1(path) {
    const {node} = path;
    
    if (!path.evaluate)
        throw Error(`☝️ Looks like argument of 'compute' is not 'path'`);
    
    const {confident, value} = path.evaluate();
    
    if (confident)
        return [COMPUTED, value];
    
    if (path.isBinaryExpression())
        return parseBinaryExpression(path);
    
    if (isExtractable(path))
        return [COMPUTED, extract$4(node)];
    
    const bindingPath = parseBindingPath(path);
    
    if (!bindingPath)
        return [NOT_COMPUTED];
    
    const initPath = bindingPath.get('init');
    
    if (initPath.isObjectExpression() && path.isMemberExpression())
        return parseObjectExpression(path, initPath);
    
    return [NOT_COMPUTED];
}

function parseBindingPath(path) {
    const {node} = path;
    
    if (path.isIdentifier())
        return getBindingPath$1(path, extract$4(node));
    
    if (isSimpleMemberExpression(path))
        return getBindingPath$1(path, extract$4(node.object));
    
    return null;
}

function parseObjectExpression(path, initPath) {
    const keyPropertyValue = extract$4(path.node.property);
    
    for (const propertyPath of initPath.get('properties')) {
        const keyPath = propertyPath.get('key');
        
        if (!isExtractable(keyPath))
            return [NOT_COMPUTED];
        
        const keyValue = extract$4(keyPath);
        
        if (keyValue !== keyPropertyValue)
            continue;
        
        const [is, value] = compute$1(propertyPath.get('value'));
        
        if (!is)
            break;
        
        return [COMPUTED, value];
    }
    
    return [NOT_COMPUTED];
}

function isExtractable(path) {
    const computed = false;
    const {parentPath} = path;
    
    if (!path.isIdentifier() && !path.isLiteral())
        return false;
    
    if (parentPath.isObjectProperty({computed}))
        return !usedInAssignment(path);
    
    return false;
}

function isSimpleMemberExpression(path) {
    const objectPath = path.get('object');
    
    if (!path.isMemberExpression())
        return false;
    
    if (path.node.computed)
        return false;
    
    return objectPath.isIdentifier();
}

const binary = {
    init: (op, fn) => binary[op] = fn,
};

function parseBinaryExpression(path) {
    const {operator} = path.node;
    const leftPath = path.get('left');
    const rightPath = path.get('right');
    const [computedLeft, left] = compute$1(leftPath);
    
    if (!computedLeft)
        return [NOT_COMPUTED];
    
    const [computedRight, right] = compute$1(rightPath);
    
    if (!computedRight)
        return [NOT_COMPUTED];
    
    const line = `return a ${operator} b`;
    const fn = binary[operator] || binary.init(operator, Function('a', 'op', 'b', line));
    
    return [COMPUTED, fn(left, operator, right)];
}

function getReferences(path) {
    const {referencesSet} = path.scope;
    
    if (!referencesSet)
        return {};
    
    const entries = referencesSet.entries();
    
    return Object.fromEntries(entries);
}

function usedInAssignment(path) {
    const references = getReferences(path);
    
    const [name] = Object.keys(references);
    const binding = path.scope.bindings[name];
    
    if (!binding)
        return false;
    
    const {referencePaths} = binding;
    
    for (const ref of referencePaths) {
        if (ref.parentPath.parentPath?.isAssignmentExpression())
            return true;
    }
    
    return false;
}

var remove$2 = {};

const {entries: entries$a} = Object;
const isOneDeclaration = ({node}) => node.declarations.length === 1;

remove$2.remove = (path) => {
    if (!path.node)
        return;
    
    const {scope} = path;
    const prev = getPrevSibling(path);
    const next = getNextSibling(path);
    
    if (scope && !next.node) {
        const programBlock = scope.getProgramParent().block;
        
        if (scope.block === programBlock && !prev.node)
            programBlock.comments = getComments(path);
    }
    
    if (!path.parentPath.isArrayPattern()) {
        path.remove();
        return;
    }
    
    const elements = path.parentPath.get('elements');
    const n = elements.length - 1;
    
    for (const [i, el] of entries$a(elements)) {
        if (el !== path)
            continue;
        
        if (!Number(i) && n) {
            path.parentPath.node.elements[i] = null;
            break;
        }
        
        path.remove();
        break;
    }
};

const getComments = (path) => {
    const {leadingComments} = path.node;
    
    if (leadingComments?.length)
        return leadingComments;
    
    const {parentPath} = path;
    
    if (path.isVariableDeclarator() && isOneDeclaration(parentPath))
        return parentPath.node.leadingComments;
    
    return [];
};

const getPrevSibling = (path) => {
    if (!path.isVariableDeclarator())
        return path.getPrevSibling();
    
    return path.parentPath.getPrevSibling();
};

const getNextSibling = (path) => {
    if (!path.isVariableDeclarator())
        return path.getNextSibling();
    
    return path.parentPath.getNextSibling();
};

var getExportDefault$1 = {};

getExportDefault$1.getExportDefault = (path) => {
    const programParent = path.scope.getProgramParent();
    const programPath = programParent.path;
    
    for (const current of programPath.get('body')) {
        if (current.isExportDefaultDeclaration())
            return current;
    }
    
    return null;
};

var rename$1 = {};

var renameProperty$2 = {};

renameProperty$2.renameProperty = (path, from, to) => {
    path.traverse({
        ObjectProperty(path) {
            const {node} = path;
            const {key, value} = node;
            const equal = key.name === value.name;
            
            if (!equal)
                return;
            
            if (key.name !== from)
                return;
            
            key.name = to;
            value.name = to;
            node.shorthand = true;
            
            path.stop();
        },
    });
};

const {renameProperty: renameProperty$1} = renameProperty$2;

rename$1.rename = (path, from, to) => {
    const bindings = path.scope.getAllBindings();
    const bindingCurrent = bindings[from];
    
    if (!bindingCurrent)
        return;
    
    const bindingPath = bindingCurrent.path;
    
    renameProperty$1(bindingPath, from, to);
    bindingPath.scope.rename(from, to);
};

var setLiteralValue$3 = {};

setLiteralValue$3.setLiteralValue = (path, newValue) => {
    const node = path.node || path;
    const {
        raw,
        extra,
        value,
    } = node;
    
    node.value = value.replace(value, newValue);
    
    if (raw === '""') {
        node.raw = raw.replace(raw, `"${newValue}"`);
        return;
    }
    
    if (raw || !value) {
        node.raw = `'` + String.raw`${newValue}` + `'`;
        return;
    }
    
    if (extra) {
        node.raw = extra.raw.replace(value, newValue);
        node.extra.rawValue = value;
    }
};

var getPathAfterRequires$1 = {};

getPathAfterRequires$1.getPathAfterRequires = (body) => {
    let path;
    
    for (path of body) {
        if (!isRequire$1(path))
            break;
    }
    
    return path;
};

function isRequire$1(path) {
    if (!path.isVariableDeclaration())
        return false;
    
    const initPath = path.get('declarations.0.init');
    
    if (!initPath.isCallExpression())
        return false;
    
    const calleePath = initPath.get('callee');
    
    return calleePath.isIdentifier({
        name: 'require',
    });
}

var properties = {};

var traverseProperties$4 = {};

const {traverse: traverse$9, types: types$N} = bundle;
const {extract: extract$3} = extract$6;

const {
    isCallExpression: isCallExpression$5,
    isObjectExpression: isObjectExpression$5,
} = types$N;

const nodeOrPath = (path) => path.node || path;

function getNode(path) {
    if (!isObjectExpression$5(path))
        return nodeOrPath(path);
    
    if (isCallExpression$5(path.parentPath))
        return path.parentPath.node;
    
    return {
        type: 'ExpressionStatement',
        expression: nodeOrPath(path),
    };
}

traverseProperties$4.traverseProperties = (path, name, {firstLevel = false} = {}) => {
    const collector = [];
    const node = getNode(path);
    
    const fn = collect({
        name,
        collector,
    });
    
    if (firstLevel) {
        fn(path);
        return collector;
    }
    
    traverse$9(node, {
        noScope: true,
        ObjectExpression: fn,
    });
    
    return collector;
};

const collect = ({name, collector}) => (path) => {
    for (const propertyPath of path.get('properties')) {
        if (propertyPath.isSpreadElement())
            continue;
        
        if (propertyPath.isRestElement())
            continue;
        
        const keyPath = propertyPath.get('key');
        
        if (keyPath.isConditionalExpression())
            continue;
        
        const currentName = extract$3(keyPath);
        
        if (name === currentName)
            collector.push(propertyPath);
    }
};

const {
    isObjectExpression: isObjectExpression$4,
    isObjectPattern: isObjectPattern$1,
} = bundle.types;

const {extract: extract$2} = extract$6;
const {traverseProperties: traverseProperties$3} = traverseProperties$4;

properties.traverseProperties = traverseProperties$3;

properties.getProperties = (path, names) => {
    const result = {};
    
    for (const propertyPath of path.get('properties')) {
        if (propertyPath.isSpreadElement())
            continue;
        
        const keyPath = propertyPath.get('key');
        const currentName = extract$2(keyPath);
        
        if (names.includes(currentName)) {
            const name = `${currentName}Path`;
            
            result[name] = propertyPath;
            continue;
        }
    }
    
    return result;
};

properties.getProperty = (path, name) => {
    if (!isObjectExpression$4(path) && !isObjectPattern$1(path))
        throw Error(`☝️Looks like path is not 'ObjectExpression | ObjectPattern', but: '${path.type}' for path: ${path}`);
    
    const propertyPaths = path.get(`properties`);
    
    for (const propertyPath of propertyPaths) {
        const keyPath = propertyPath.get('key');
        const currentName = extract$2(keyPath);
        
        if (currentName === name)
            return propertyPath;
    }
    
    return null;
};

var getLiteralRaw$1 = {};

const isString$d = (a) => typeof a === 'string';

getLiteralRaw$1.getLiteralRaw = (path) => {
    const {
        raw,
        extra,
        value,
    } = path.node || path;
    
    if (isString$d(raw))
        return raw;
    
    if (extra && isString$d(extra.raw))
        return extra.raw;
    
    return `'${maybeEncode(value)}'`;
};

function maybeEncode(a) {
    if (a.includes(`\\'`))
        return a;
    
    return a.replaceAll(`'`, `\\'`);
}

var replaceWith$7 = {};

var replaceWithMultiple$2 = {};

var maybeBody$2 = {};

const {types: types$M} = bundle;
const {
    isStatement: isStatement$5,
    isBlockStatement: isBlockStatement$5,
    blockStatement: blockStatement$1,
    expressionStatement: expressionStatement$4,
} = types$M;

maybeBody$2.maybeBody = (path, node) => {
    const {parentPath} = path;
    
    if (node && !isStatement$5(node) || isBlockStatement$5(node) || !parentPath?.isArrowFunctionExpression?.())
        return {
            currentPath: path,
        };
    
    parentPath.node.body = blockStatement$1([
        expressionStatement$4(path.node),
    ]);
    
    return {
        currentPath: parentPath.get('body.body.0'),
    };
};

var toExpression$3 = {};

const {types: types$L} = bundle;
const {
    isExpression: isExpression$1,
    toStatement,
    expressionStatement: expressionStatement$3,
} = types$L;

toExpression$3.toExpression = (el) => {
    const {type} = el;
    
    const ignore = [
        'ObjectProperty',
    ];
    
    if (ignore.includes(type))
        return el;
    
    if (isExpression$1(el))
        return expressionStatement$3(el);
    
    return toStatement(el);
};

const {maybeBody: maybeBody$1} = maybeBody$2;
const {toExpression: toExpression$2} = toExpression$3;
const {isSequenceExpression} = bundle.types;

replaceWithMultiple$2.replaceWithMultiple = (path, nodes) => {
    const {node} = path;
    const {
        trailingComments,
        comments,
        leadingComments,
    } = node;
    
    delete path.node.trailingComments;
    
    const parentComments = path.parentPath.node.comments;
    
    const newNodes = nodes
        .filter(Boolean)
        .map(toExpression$2);
    
    removeDuplicateLeadingComments(newNodes);
    
    const {currentPath} = maybeBody$1(path);
    const newPath = currentPath.replaceWithMultiple(newNodes);
    
    if (!newPath.length)
        return newPath;
    
    if (!leadingComments && !isSequenceExpression(path))
        delete newPath[0].node.leadingComments;
    
    newPath[0].node.comments = comments || parentComments;
    newPath.at(-1).node.trailingComments = trailingComments;
    
    return newPath;
};

function removeDuplicateLeadingComments(nodes) {
    for (const node1 of nodes) {
        for (const node2 of nodes) {
            if (node1 === node2)
                continue;
            
            if (node1.leadingComments === node2.leadingComments)
                delete node2.leadingComments;
        }
    }
}

var replaceWith$6 = {};

const {maybeBody} = maybeBody$2;
const {assign: assign$a} = Object;

const parseNode$2 = (a) => {
    a = extractMark(a);
    
    if (a.node)
        return a.node;
    
    return a;
};

replaceWith$6.replaceWith = (path, node) => {
    node = parseNode$2(node);
    
    if (path?.parentPath?.isExpressionStatement() && !path.parentPath.isProgram()) {
        addMark(path, node);
        path = path.parentPath;
    }
    
    const {comments, loc} = path.node;
    const {currentPath} = maybeBody(path, node);
    
    currentPath.replaceWith(node);
    
    assign$a(currentPath.node, {
        comments,
        loc,
    });
    
    return currentPath;
};

function addMark(path, node) {
    path.__putout_replaced_with = node;
}

function extractMark(node) {
    if (node.__putout_replaced_with)
        return node.__putout_replaced_with;
    
    return node;
}

const {replaceWithMultiple: replaceWithMultiple$1} = replaceWithMultiple$2;
const {replaceWith: replaceWith$5} = replaceWith$6;
const {toExpression: toExpression$1} = toExpression$3;

replaceWith$7.replaceWith = replaceWith$5;
replaceWith$7.replaceWithMultiple = replaceWithMultiple$1;
replaceWith$7.toExpression = toExpression$1;

const {types: types$K} = bundle;

const {getBinding, getBindingPath} = getBinding$2;
const {isSimple: isSimple$1} = isSimple$2;
const {extract: extract$1} = extract$6;
const {compute} = compute$2;
const {remove: remove$1} = remove$2;
const {getExportDefault} = getExportDefault$1;
const {rename} = rename$1;
const {renameProperty} = renameProperty$2;
const {setLiteralValue: setLiteralValue$2} = setLiteralValue$3;
const {getPathAfterRequires} = getPathAfterRequires$1;

const {
    getProperty: getProperty$3,
    getProperties,
    traverseProperties: traverseProperties$2,
} = properties;

const {getLiteralRaw} = getLiteralRaw$1;

const {
    replaceWith: replaceWith$4,
    replaceWithMultiple,
    toExpression,
} = replaceWith$7;

const {
    matchesPattern,
    isImportDeclaration: isImportDeclaration$1,
    isExportDeclaration: isExportDeclaration$4,
    isStatement: isStatement$4,
    expressionStatement: expressionStatement$2,
} = types$K;

operate.getBinding = getBinding;
operate.getBindingPath = getBindingPath;
operate.getLiteralRaw = getLiteralRaw;
operate.extract = extract$1;
operate.compute = compute;
operate.replaceWith = replaceWith$4;
operate.getExportDefault = getExportDefault;
operate.toExpression = toExpression;
operate.isSimple = isSimple$1;
operate.rename = rename;
operate.renameProperty = renameProperty;
operate.setLiteralValue = setLiteralValue$2;

operate.getProperty = getProperty$3;
operate.getProperties = getProperties;
operate.traverseProperties = traverseProperties$2;

operate.replaceWithMultiple = replaceWithMultiple;

operate.insertBefore = (path, node) => {
    path.insertBefore(node);
};

operate.insertAfter = (path, node) => {
    const {comments} = path.node;
    
    if (path.node.trailingComments?.length && path.getNextSibling()?.node?.leadingComments)
        delete path.node.trailingComments;
    
    if (node.trailingComments)
        delete node.trailingComments;
    
    if (isStatement$4(path) && !isStatement$4(node))
        path.insertAfter(expressionStatement$2(node));
    else
        path.insertAfter(node);
    
    path.node.comments = comments;
};

operate.isModuleExports = (path) => {
    return matchesPattern(path.node || path, 'module.exports');
};

const isBinding = (name) => (path) => path.scope.bindings[name];

operate.findBinding = (path, name) => {
    const referencePath = path.findParent(isBinding(name));
    
    if (!referencePath)
        return null;
    
    return referencePath.scope.bindings[name];
};

operate.remove = remove$1;

operate.getPathAfterRequires = getPathAfterRequires;
operate.getPathAfterImports = (body) => {
    const n = body.length;
    let i = 0;
    
    while (i < n - 1 && isImportDeclaration$1(body[i]))
        ++i;
    
    return body[i];
};

operate.isESM = (path) => {
    const scope = path.scope.getProgramParent();
    const programPath = scope.path;
    
    for (const node of programPath.node.body) {
        if (isImportDeclaration$1(node))
            return true;
        
        if (isExportDeclaration$4(node))
            return true;
    }
    
    return false;
};

const {isSimple} = operate;
const {types: types$J} = bundle;

const {
    isStringAndMember,
    isStringAndIdentifier: isStringAndIdentifier$1,
    isIdentifierAndString,
    isCoupleLines: isCoupleLines$5,
    isStringAndArray: isStringAndArray$1,
    isIdentifierAndIdentifier: isIdentifierAndIdentifier$1,
    isSimpleAndNotEmptyObject: isSimpleAndNotEmptyObject$1,
} = is$3;

const {
    isObjectExpression: isObjectExpression$3,
    isArrayExpression: isArrayExpression$3,
    isObjectProperty: isObjectProperty$1,
    isCallExpression: isCallExpression$4,
    isAwaitExpression,
    isBooleanLiteral: isBooleanLiteral$1,
    isNullLiteral,
    isStringLiteral: isStringLiteral$6,
    isSpreadElement: isSpreadElement$1,
    isIdentifier: isIdentifier$7,
} = types$J;

const {round: round$1} = Math;

const isOneSpread = (elements) => {
    if (elements.length > 1)
        return false;
    
    const [first] = elements;
    
    return isSpreadElement$1(first);
};

const isSimpleAndCall = ([a, b]) => {
    if (!isSimple(a))
        return;
    
    return isCallExpression$4(b) || isAwaitExpression(b);
};

const isBooleanAndSimple = ([a, b]) => isBooleanLiteral$1(a) && isSimple(b);
const isBooleanAndObject = ([a, b]) => isBooleanLiteral$1(a) && isObjectExpression$3(b);
const isNullAndSimple = ([a, b]) => isNullLiteral(a) && isSimple(b);
const isSimpleAndObject = ([a, b]) => isSimple(a) && isObjectExpression$3(b);
const ONE_LINE = false;
const MULTI_LINE = true;

const isSiblingIsArray = (path) => {
    if (path.getNextSibling().isArrayExpression())
        return true;
    
    return path
        .getPrevSibling()
        .isArrayExpression();
};

function isMaxElementLengthInOneLine(elements, maxElementLengthInOneLine) {
    if (elements.length > 1)
        return false;
    
    const [first] = elements;
    
    if (!isIdentifier$7(first))
        return false;
    
    return first.node.name.length < maxElementLengthInOneLine;
}

newline.isMultiLine = (path, {elements, maxElementsInOneLine, maxElementLengthInOneLine}) => {
    const [first] = elements;
    
    if (isMaxElementLengthInOneLine(elements, maxElementLengthInOneLine))
        return ONE_LINE;
    
    if (elements.length > maxElementsInOneLine && isStringLiteral$6(first))
        return MULTI_LINE;
    
    if (elements.length > 3 && !isObjectExpression$3(first))
        return MULTI_LINE;
    
    if (isSimpleAndNotEmptyObject$1(elements))
        return MULTI_LINE;
    
    if (isOneSimple(path))
        return ONE_LINE;
    
    if (isOneSpread(elements))
        return ONE_LINE;
    
    if (elements.length === 2 && isIdentifierAndIdentifier$1(elements))
        return ONE_LINE;
    
    if (isCallInsideArrow(path))
        return ONE_LINE;
    
    if (isIncreaseIndent$1(path))
        return ONE_LINE;
    
    if (isInsideLoop(path))
        return ONE_LINE;
    
    if (isBooleanAndSimple(elements))
        return ONE_LINE;
    
    if (isNullAndSimple(elements))
        return ONE_LINE;
    
    if (isSimpleAndCall(elements))
        return ONE_LINE;
    
    if (isShortTwoSimplesInsideCall(path, maxElementsInOneLine))
        return ONE_LINE;
    
    if (isTwoStringsDifferentLength(elements))
        return ONE_LINE;
    
    if (isTwoSimplesInsideObjectProperty(path))
        return ONE_LINE;
    
    if (isStringAndArray$1(elements) && elements.length < 3)
        return ONE_LINE;
    
    if (isStringAndMember(elements))
        return ONE_LINE;
    
    if (isStringAndIdentifier$1(elements))
        return ONE_LINE;
    
    if (isIdentifierAndString(elements))
        return ONE_LINE;
    
    if (isSimpleAndObject(elements))
        return ONE_LINE;
    
    if (isStringAndString(elements) && path.parentPath.isArrayExpression() && isArrayExpression$3(path.parentPath.node.elements[0]))
        return ONE_LINE;
    
    if (isSiblingIsArray(path))
        return ONE_LINE;
    
    if (tooLong(path) || isCoupleLines$5(path) || !isNumbers(elements) && !isForOf$1(path) && isLastArg(path) && !isParentProperty(path))
        return MULTI_LINE;
    
    return ONE_LINE;
};

const isForOf$1 = ({parentPath}) => parentPath.isForOfStatement();

const isStringAndString = ([a, b]) => isStringLiteral$6(a) && isStringLiteral$6(b);

const isShortTwoSimplesInsideCall = (path, maxElementsInOneLine) => {
    const {node, parentPath} = path;
    
    const {elements} = node;
    const {length} = elements;
    const [a, b] = elements;
    
    if (!parentPath.isCallExpression())
        return false;
    
    if (!isStringLiteral$6(a) || !isStringLiteral$6(b))
        return false;
    
    return length < maxElementsInOneLine;
};

const isTwoSimplesInsideObjectProperty = (path) => {
    const {node, parentPath} = path;
    
    const {elements} = node;
    const {length} = elements;
    const [a, b] = elements;
    
    if (length > 2)
        return false;
    
    if (!parentPath.isObjectProperty())
        return false;
    
    if (!isStringLiteral$6(a) || !isStringLiteral$6(b))
        return false;
    
    return !isCoupleLines$5(path);
};

function isOneSimple(path) {
    const elements = path.get('elements');
    
    if (elements.length !== 1)
        return false;
    
    const [first] = elements;
    
    if (first.isIdentifier() && first.node.name.length < 15)
        return true;
    
    if (first.isStringLiteral() && first.node.value.length > 10)
        return false;
    
    if (!first.isIdentifier() && isSimple(first))
        return true;
    
    if (first.isCallExpression())
        return false;
    
    return first.isMemberExpression();
}

function isTwoStringsDifferentLength(strings) {
    const [a, b] = strings;
    
    if (strings.length > 2)
        return false;
    
    if (!a?.isStringLiteral() || !b?.isStringLiteral())
        return false;
    
    const aLength = a.node.value.length;
    const bLength = b.node.value.length;
    
    return round$1(bLength / aLength) > 2;
}

function isInsideLoop(path) {
    return path.parentPath.isForOfStatement();
}

function tooLong(path) {
    const elements = path.get('elements');
    
    if (elements.length < 2)
        return false;
    
    for (const el of path.get('elements')) {
        if (el.isStringLiteral() && el.node.value.length > 4)
            return true;
    }
    
    return false;
}

function isCallInsideArrow(path) {
    const {parentPath} = path;
    
    if (!parentPath.isCallExpression())
        return false;
    
    if (!parentPath.parentPath.isFunction())
        return false;
    
    return path.node.elements.length < 4;
}

function isNumbers(elements) {
    for (const element of elements) {
        if (element.isNumericLiteral())
            return true;
    }
    
    return false;
}

const isLastArg = ({parentPath}) => !parentPath.isCallExpression();

const isParentProperty = (path) => path.find(isObjectProperty$1);

newline.isIncreaseIndent = isIncreaseIndent$1;
function isIncreaseIndent$1(path) {
    const elements = path.get('elements');
    
    if (!elements.length)
        return false;
    
    if (isBooleanAndObject(elements))
        return true;
    
    if (isInsideCallLoop(path))
        return false;
    
    if (elements[0].isObjectExpression())
        return true;
    
    if (isSpreadElement$1(elements[1]))
        return false;
    
    return isStringAndObject(elements);
}

function isInsideCallLoop(path) {
    if (!path.parentPath.isCallExpression())
        return false;
    
    return path.parentPath.parentPath.isForOfStatement();
}

const isStringAndObject = (elements) => {
    const first = elements.at(0);
    const last = elements.at(-1);
    
    return isStringLiteral$6(first) && isObjectExpression$3(last);
};

newline.isCurrentNewLine = (path) => {
    if (path.isSpreadElement())
        return true;
    
    return !path.isObjectExpression();
};

var indent = {};

const {types: types$I} = bundle;
const {isIndented} = is$3;

const {
    isStringLiteral: isStringLiteral$5,
    isArrayExpression: isArrayExpression$2,
} = types$I;

const isInsideArray$1 = (path) => path.parentPath.isArrayExpression();

indent.isInsideArray = isInsideArray$1;

indent.isArrayIndented = (path) => {
    const elements = path.get('elements');
    
    if (isArrayInsideArray$1(path))
        return false;
    
    const [first] = elements;
    
    return !isTwoLongStrings(elements) || !isInsideArray$1(path) && isIndented(first);
};

indent.isArrayInsideArray = isArrayInsideArray$1;

function isArrayInsideArray$1(path) {
    if (!path.isArrayExpression() || !path.parentPath.isArrayExpression())
        return false;
    
    const parentElements = path.parentPath.node.elements;
    const parentHasArrays = parentElements.filter(isArrayExpression$2).length;
    const lastNotArray = !isArrayExpression$2(parentElements.at(-1));
    
    if (parentHasArrays && lastNotArray)
        return false;
    
    const {length} = parentElements;
    
    return length <= 3 && length !== 1;
}

const isTwoLongStrings = ([a, b]) => {
    const LONG_STRING = 20;
    
    if (!isStringLiteral$5(a) || !isStringLiteral$5(b))
        return false;
    
    return a.node.value.length > LONG_STRING;
};

var isObjectAfterSimple$1 = {};

const {isNextObject: isNextObject$1, isPrevObject} = is$3;

const SIMPLE_TYPES = [
    'ArrayExpression',
    'ObjectExpression',
    'SpreadElement',
    'CallExpression',
    'Identifier',
    'NewExpression',
];

isObjectAfterSimple$1.isObjectAfterSimple = (a) => {
    const {type} = a;
    
    if (!isNextObject$1(a) || isPrevObject(a))
        return false;
    
    return SIMPLE_TYPES.includes(type);
};

isObjectAfterSimple$1.isNextSimple = (a) => {
    const {type} = a.getNextSibling();
    
    return SIMPLE_TYPES.includes(type);
};

const {types: types$H} = bundle;
const {
    isCoupleLines: isCoupleLines$4,
    isStringAndIdentifier,
    isIdentifierAndIdentifier,
    isStringAndArray,
    isSimpleAndNotEmptyObject,
    isNextObject,
} = is$3;

const {
    isIncreaseIndent,
    isCurrentNewLine,
    isMultiLine,
} = newline;

const {
    isInsideArray,
    isArrayInsideArray,
    isArrayIndented,
} = indent;

const {
    isObjectAfterSimple,
    isNextSimple,
} = isObjectAfterSimple$1;

const {
    isObjectExpression: isObjectExpression$2,
    isSpreadElement,
    isStringLiteral: isStringLiteral$4,
    isIdentifier: isIdentifier$6,
    isFunction: isFunction$4,
    isCallExpression: isCallExpression$3,
    isObjectProperty,
} = types$H;

const isNextString = (path) => isStringLiteral$4(path.getNextSibling());
const isPrevString = (path) => isStringLiteral$4(path.getPrevSibling());
const isAroundStrings = (path) => isNextString(path) || isPrevString(path);

const isSpreadBeforeObject = (a) => {
    if (!a.isObjectExpression())
        return false;
    
    const prev = a.getPrevSibling();
    
    if (!prev.isSpreadElement())
        return false;
    
    const argCall = prev.get('argument');
    
    if (argCall.isCallExpression()) {
        const [first] = argCall.get('arguments');
        
        if (isFunction$4(first))
            return false;
    }
    
    if (prev.getPrevSibling().isObjectExpression())
        return false;
    
    return prev.get('argument').isCallExpression();
};

const isNextSimpleBetweenObjects = (a) => {
    const next = a.getNextSibling();
    const is = next.isSpreadElement() || next.isIdentifier() || next.isCallExpression();
    
    if (!is)
        return true;
    
    return next
        .getNextSibling()
        .isObjectExpression();
};

const isInsideOneElementArray = ({parentPath}) => parentPath.node.elements.length === 1;

arrayExpression$3.ArrayExpression = {
    beforeIf(path) {
        const {parentPath} = path;
        const {elements} = path.node;
        
        if (!parentPath.isArrayExpression())
            return false;
        
        if (isCoupleLines$4(parentPath))
            return false;
        
        if (isStringAndIdentifier(elements) && isInsideOneElementArray(path))
            return true;
        
        return isIdentifierAndIdentifier(elements);
    },
    before(path, {print}) {
        print.breakline();
    },
    print(path, {print, maybe}, semantics) {
        const {
            maxElementsInOneLine,
            trailingComma,
            maxElementLengthInOneLine,
        } = semantics;
        
        const elements = path.get('elements');
        const shouldIncreaseIndent = !isIncreaseIndent(path);
        
        print('[');
        
        const indented = isArrayIndented(path);
        
        maybe.indent.inc(indented && shouldIncreaseIndent);
        
        const isNewLine = isMultiLine(path, {
            elements,
            maxElementsInOneLine,
            maxElementLengthInOneLine,
        });
        
        const n = elements.length - 1;
        
        maybe.print.newline(isNewLine && elements.length);
        
        for (const [index, element] of elements.entries()) {
            const is = isNewLine && isCurrentNewLine(element);
            
            if (isSimpleAfterObject(element))
                print.newline();
            
            maybe.indent(is);
            print(element);
            
            if (index < n || trailingComma)
                maybe.print(is, ',');
            
            if (!(isObjectExpression$2(element) && isObjectProperty(path.parentPath)))
                maybe.print.newline((is || isSpreadBeforeObject(element)) && !isNextObject(element) && !isObjectExpression$2(element));
            
            maybe.print.space(is && isObjectAfterSimple(element));
            
            if (!is && index < n) {
                print(',');
                
                if (isNextSimpleBetweenObjects(element) || !(element.isObjectExpression() && isNextSimple(element)))
                    print.space();
            }
        }
        
        maybe.indent.dec(indented && shouldIncreaseIndent);
        
        const parentElements = path.parentPath.get('elements');
        
        if (isInsideArray(path) && isStringAndArray(parentElements)) {
            const parentCountTwo = parentElements.length === 2;
            const isHideIdent = !isAroundStrings(path) || parentCountTwo;
            
            maybe.indent.dec(isHideIdent);
            maybe.indent(elements.length && isNewLine);
            maybe.indent.inc(isHideIdent);
        } else if (!isArrayInsideArray(path) && !isObjectExpression$2(elements.at(-1))) {
            maybe.indent(elements.length && isNewLine);
        }
        
        if (isSimpleAndNotEmptyObject(elements) && !isSpreadElement(elements.at(-1)) && !isCallExpression$3(elements.at(-1))) {
            print(',');
            print.breakline();
        }
        
        print(']');
    },
    afterIf(path) {
        const {parentPath} = path;
        const {elements} = path.node;
        
        if (!parentPath.isArrayExpression())
            return false;
        
        if (isCoupleLines$4(parentPath))
            return false;
        
        if (isStringAndIdentifier(elements) && isInsideOneElementArray(path))
            return true;
        
        return isIdentifierAndIdentifier(elements);
    },
    after(path, {print, indent}) {
        indent.dec();
        print.breakline();
        indent.inc();
    },
};

function isSimpleAfterObject(path) {
    if (!isSpreadElement(path) && !isIdentifier$6(path) && !isCallExpression$3(path))
        return;
    
    const prev = path.getPrevSibling();
    const next = path.getNextSibling();
    
    if (next.isObjectExpression())
        return false;
    
    return prev.isObjectExpression();
}

var arrayPattern = {};

const {maybeTypeAnnotation: maybeTypeAnnotation$2} = maybeTypeAnnotation$4;
const isForOf = ({parentPath}) => parentPath.parentPath.parentPath?.isForOfStatement();

arrayPattern.ArrayPattern = maybeTypeAnnotation$2((path, {indent, maybe, print}, semantics) => {
    const {maxElementsInOneLine} = semantics;
    
    print('[');
    
    const elements = path.get('elements');
    indent.inc();
    
    const isNewLine = !isForOf(path) && elements.length > maxElementsInOneLine;
    const n = elements.length - 1;
    
    maybe.print(isNewLine && elements.length, '\n');
    
    for (const [index, element] of elements.entries()) {
        maybe.indent(isNewLine);
        print(element);
        
        if (isNewLine) {
            print(',\n');
        } else if (index < n) {
            print(',');
            print.space();
        }
    }
    
    indent.dec();
    maybe.indent(elements.length && isNewLine);
    print(']');
});

var assignmentPattern = {};

const isArg = (path) => path.parentPath.isFunction();

assignmentPattern.AssignmentPattern = {
    print(path, {print, maybe}) {
        maybe.print(shouldPrint(path), '__left');
        print.space();
        print('=');
        print.space();
        print('__right');
    },
};

function shouldPrint(path) {
    const {parentPath} = path;
    
    if (parentPath.isObjectProperty() && !parentPath.node.shorthand)
        return true;
    
    if (isArg(path))
        return true;
    
    if (parentPath.isTSParameterProperty())
        return true;
    
    return parentPath.isArrayPattern();
}

var restElement = {};

const {maybeTypeAnnotation: maybeTypeAnnotation$1} = maybeTypeAnnotation$4;

restElement.RestElement = maybeTypeAnnotation$1((path, {print}) => {
    print('...');
    print('__argument');
});

var spreadElement = {};

const {hasTrailingComment: hasTrailingComment$2} = is$3;

spreadElement.SpreadElement = (path, printer) => {
    const {print} = printer;
    print('...');
    print('__argument');
    
    if (hasTrailingComment$2(path))
        print(',');
};

var sequenceExpression = {exports: {}};

var maybeWriteBrace = {};

maybeWriteBrace.condition = (path, printer, semantics) => {
    const {parentPath} = path;
    const {type} = parentPath;
    const {roundBraces} = semantics;
    
    if (type === 'ArrowFunctionExpression')
        return true;
    
    if (type === 'ConditionalExpression' && path !== parentPath.get('test'))
        return true;
    
    if (type === 'LogicalExpression')
        return true;
    
    return roundBraces.sequence;
};

var sequenceExpressionComments = {};

const {hasLeadingComment} = is$3;
const noop$4 = () => {};

sequenceExpressionComments.printLeadingCommentLine = noop$4;
sequenceExpressionComments.printLeadingCommentBlock = noop$4;

sequenceExpressionComments.maybePrintComments = (path, {print}) => {
    if (hasLeadingComment(path)) {
        const {leadingComments} = path.node;
        
        for (const {type, value} of leadingComments) {
            if (type === 'CommentLine')
                print(`//${value}`);
            else
                print(`/*${value}*/`);
            
            print.breakline();
        }
    }
};

(function (module) {

	const {hasLeadingComment} = is$3;
	const {maybeParens} = maybeParens$e;
	const {condition} = maybeWriteBrace;

	const {
	    maybePrintComments,
	    printLeadingCommentLine,
	    printLeadingCommentBlock,
	} = sequenceExpressionComments;

	module.exports.SequenceExpression = maybeParens({
	    checkParens: false,
	    condition,
	    print(path, printer) {
	        const {
	            write,
	            traverse,
	            indent,
	            maybe,
	        } = printer;
	        
	        const expressions = path.get('expressions');
	        const n = expressions.length - 1;
	        
	        const withComment = hasLeadingComment(path);
	        
	        if (withComment) {
	            indent.inc();
	            write.breakline();
	            maybePrintComments(path, printer);
	        }
	        
	        for (const [index, expression] of expressions.entries()) {
	            traverse(expression);
	            
	            if (index < n) {
	                write(',');
	                maybe.write.space(!withComment);
	                maybe.print.breakline(withComment);
	            }
	        }
	        
	        if (withComment) {
	            indent.dec();
	            write.breakline();
	        }
	    },
	});

	module.exports.SequenceExpression.printLeadingCommentLine = printLeadingCommentLine;
	module.exports.SequenceExpression.printLeadingCommentBlock = printLeadingCommentBlock; 
} (sequenceExpression));

var sequenceExpressionExports = sequenceExpression.exports;
sequenceExpressionExports.default;

var taggedTemplateExpression = {};

taggedTemplateExpression.TaggedTemplateExpression = (path, {print}) => {
    print('__tag');
    print('__quasi');
};

var binaryExpression = {};

var maybeSpace$1 = {};

maybeSpace$1.maybeSpace = (path, {print}) => {
    const {right} = path.node;
    
    if (right.type === 'UnaryExpression' && right.operator === '+')
        return print(' ');
    
    return print.space();
};

const {
    concatenate,
    isConcatenation: isConcatenation$1,
} = concatenate$1;

const {maybeSpace} = maybeSpace$1;
const {maybeParens: maybeParens$8} = maybeParens$e;

binaryExpression.BinaryExpression = maybeParens$8((path, {print, indent, maybe}) => {
    const {operator} = path.node;
    
    if (operator === 'in' || operator === 'instanceof') {
        print('__left');
        print(' ');
        print(operator);
        print(' ');
        print('__right');
        
        return;
    }
    
    if (isConcatenation$1(path))
        return concatenate(path, {
            print,
            indent,
            maybe,
        });
    
    print('__left');
    print.space();
    print(path.node.operator);
    maybeSpace(path, {
        print,
    });
    print('__right');
});

var logicalExpression = {};

var chain$1 = {};

const {types: types$G} = bundle;
const {
    isLogicalExpression,
    isReturnStatement: isReturnStatement$1,
    isVariableDeclarator: isVariableDeclarator$1,
} = types$G;

chain$1.isRootOk = (path) => {
    return isReturnStatement$1(path) || isVariableDeclarator$1(path);
};

chain$1.chain = (path) => {
    const [downCount] = down(path);
    const [upCount, root] = up(path);
    
    return [
        root,
        downCount + upCount,
        downCount,
        upCount,
    ];
};

function down(current) {
    let count = 0;
    
    do {
        ++count;
        const right = current.get('right');
        
        if (isLogicalExpression(right))
            count += down(right)[0];
        
        current = current.get('left');
        
        const {operator} = current.node;
        
        if (operator !== '||' && operator !== '&&')
            break;
    } while (current.isLogicalExpression());
    
    return [count];
}

function up(current) {
    let count = 0;
    
    do {
        ++count;
        current = current.parentPath;
    } while (current.isLogicalExpression());
    
    return [
        count, {
            type: current.type,
        },
    ];
}

const {maybeParens: maybeParens$7} = maybeParens$e;
const {chain, isRootOk} = chain$1;

logicalExpression.LogicalExpression = maybeParens$7({
    condition(path) {
        if (path.parentPath.isUnaryExpression())
            return true;
        
        return path.parentPath.isAwaitExpression();
    },
    print(path, {print, maybe}, semantics) {
        print('__left');
        
        const needNewLine = isNewLine(path, semantics);
        
        maybe.indent.inc(needNewLine);
        needNewLine ? print.breakline() : print.space();
        maybe.indent.dec(needNewLine);
        
        print(path.node.operator);
        print.space();
        print('__right');
    },
});

function isNewLine(path, semantics) {
    const [root, count] = chain(path);
    
    if (!isRootOk(root))
        return false;
    
    if (count <= semantics.maxLogicalsInOneLine)
        return false;
    
    const {operator} = path.node;
    
    return operator === '||' || operator === '&&';
}

var conditionalExpression = {};

const {maybeParens: maybeParens$6} = maybeParens$e;

conditionalExpression.ConditionalExpression = maybeParens$6((path, {print}) => {
    print('__test');
    print.space();
    print('?');
    print.space();
    print('__consequent');
    print.space();
    print(':');
    print.space();
    print('__alternate');
});

var staticBlock = {};

staticBlock.StaticBlock = (path, {print, traverse}) => {
    print('static ');
    print('{');
    print.breakline();
    
    for (const child of path.get('body')) {
        traverse(child);
    }
    
    print.indent();
    print('}');
    print.newline();
};

var importExpression = {};

importExpression.ImportExpression = createImportExpression$1;
importExpression.createImportExpression = createImportExpression$1;

function createImportExpression$1(path, printer, semantics, {source = 'source'} = {}) {
    const {print, maybe} = printer;
    const {options} = path.node;
    
    print('import(');
    print(`__${source}`);
    
    maybe.print(options, ',');
    maybe.print.space(options);
    
    print('__options');
    print(')');
}

var parenthesizedExpression$2 = {};

const {types: types$F} = bundle;
const {isJSXElement: isJSXElement$4} = types$F;

const condition$2 = (path) => {
    const {expression} = path.node;
    return !isJSXElement$4(expression);
};

parenthesizedExpression$2.ParenthesizedExpression = {
    before(path, {print}) {
        print('(');
    },
    condition: condition$2,
    print(path, {print}) {
        print('__expression');
    },
    after(path, {print}) {
        print(')');
    },
};

const functions = functions$1;
const unaryExpressions = unaryExpressions$1;
const memberExpressions = memberExpressions$1;

const {
    ClassExpression,
    ClassDeclaration,
} = _class;

const {
    CallExpression,
    OptionalCallExpression,
} = callExpression;

const {NewExpression} = newExpression;

const {ObjectExpression} = objectExpression$2;
const {ObjectProperty} = objectProperty$3;
const {ObjectPattern} = objectPattern$1;

const {
    ClassProperty,
    ClassAccessorProperty,
    ClassPrivateProperty,
    PrivateName,
} = classProperty;

const {AssignmentExpression} = assignmentExpressionExports;
const {ArrayExpression} = arrayExpression$3;
const {ArrayPattern} = arrayPattern;
const {AssignmentPattern} = assignmentPattern;
const {RestElement} = restElement;
const {SpreadElement} = spreadElement;
const {SequenceExpression} = sequenceExpressionExports;
const {TaggedTemplateExpression} = taggedTemplateExpression;
const {BinaryExpression} = binaryExpression;
const {LogicalExpression} = logicalExpression;
const {ConditionalExpression} = conditionalExpression;
const {StaticBlock} = staticBlock;
const {ImportExpression} = importExpression;
const {ParenthesizedExpression} = parenthesizedExpression$2;

var expressions$2 = {
    ...functions,
    ...unaryExpressions,
    ...memberExpressions,
    ArrayPattern,
    ArrayExpression,
    AssignmentExpression,
    AssignmentPattern,
    BinaryExpression,
    CallExpression,
    ClassExpression,
    ClassProperty,
    ClassAccessorProperty,
    ClassPrivateProperty,
    ClassDeclaration,
    ConditionalExpression,
    NewExpression,
    LogicalExpression,
    OptionalCallExpression,
    ObjectExpression,
    ObjectProperty,
    ObjectPattern,
    ParenthesizedExpression,
    PrivateName,
    RestElement,
    ImportExpression,
    SpreadElement,
    SequenceExpression,
    StaticBlock,
    TaggedTemplateExpression,
    ThisExpression(path, {write}) {
        write('this');
    },
};

var expressionStatement$1 = {exports: {}};

var isInsideAssignNextAssignFunction = {};

const {types: types$E} = bundle;
const {
    isExpressionStatement: isExpressionStatement$2,
    isFunction: isFunction$3,
    isAssignmentExpression,
} = types$E;

isInsideAssignNextAssignFunction.isInsideAssignNextAssignFunction = (path) => {
    const {expression} = path.node;
    
    if (!isAssignmentExpression(expression))
        return false;
    
    const next = path.getNextSibling();
    
    if (isFunction$3(next) && next.node.leadingComments)
        return true;
    
    if (!isExpressionStatement$2(next))
        return false;
    
    const {leadingComments} = next.node;
    
    if (!leadingComments)
        return false;
    
    if (!isAssignmentExpression(next.node.expression))
        return false;
    
    return isFunction$3(next.node.expression.right);
};

var expressionStatementComments = {};

const {types: types$D} = bundle;
const {hasTrailingComment: hasTrailingComment$1} = is$3;

const {
    isBlockStatement: isBlockStatement$4,
    isProgram: isProgram$4,
    isIfStatement,
} = types$D;

expressionStatementComments.printLeadingCommentLine = (path, printer, semantics, {index, isLast, printComment}) => {
    const {print, indent} = printer;
    const prev = path.getPrevSibling();
    const {parentPath} = path;
    
    if (hasTrailingComment$1(prev))
        return;
    
    if (!index && !prev.node && (isIfStatement(parentPath) || isBlockStatement$4(parentPath)))
        indent();
    
    printComment();
    print.newline();
    
    if (!isLast && !path.parentPath.isIfStatement())
        print.indent();
};

expressionStatementComments.printLeadingCommentBlock = (path, printer, semantics, {printComment}) => {
    const {indent} = printer;
    const prev = path.getPrevSibling();
    
    if (hasTrailingComment$1(prev))
        return;
    
    if (isBlockStatement$4(path.parentPath) && !isProgram$4(path.parentPath.parentPath))
        indent();
    
    printComment();
};

(function (module) {

	const {types} = bundle;
	const {
	    isNext,
	    isLast,
	    isParentBlock,
	    isParentLast,
	    isNewlineBetweenSiblings,
	    satisfy,
	    noTrailingComment,
	    hasTrailingComment,
	    isCoupleLines,
	    isInsideLabel,
	} = is$3;

	const {isInsideAssignNextAssignFunction: isInsideAssignNextAssignFunction$1} = isInsideAssignNextAssignFunction;

	const {
	    printLeadingCommentLine,
	    printLeadingCommentBlock,
	} = expressionStatementComments;

	const isCommentBlock = (a) => a?.type === 'CommentBlock';

	const {
	    isCallExpression,
	    isExpressionStatement,
	    isAssignmentExpression,
	} = types;

	const not = (fn) => (...a) => !fn(...a);

	const isBeforeElse = (path) => {
	    if (!path.parentPath.isIfStatement())
	        return false;
	    
	    if (path !== path.parentPath.get('consequent'))
	        return false;
	    
	    return Boolean(path.parentPath.node.alternate);
	};

	const isInsideReturn = ({parentPath}) => parentPath.isReturnStatement();
	const notInsideReturn = not(isInsideReturn);

	const satisfyAfter = satisfy([
	    isNotLastOrParentLast,
	    isParentBlock,
	    isNext,
	    isNextUp,
	]);

	const isNextIf = (path) => path
	    .getNextSibling()
	    .isIfStatement();

	const shouldBreakline = satisfy([
	    isNewlineBetweenSiblings,
	    isNotLastBody,
	    isStrictMode,
	    isNextIf,
	]);

	module.exports.ExpressionStatement = {
	    beforeIf(path) {
	        if (isInsideReturn(path))
	            return false;
	        
	        return !isInsideLabel(path);
	    },
	    before(path, {indent}) {
	        indent();
	    },
	    print(path, {print, maybe, store, indent}) {
	        const insideReturn = isInsideReturn(path);
	        
	        print('__expression');
	        maybe.print(!insideReturn, ';');
	        
	        if (!isNext(path))
	            return;
	        
	        if (!insideReturn && shouldBreakline(path)) {
	            print.newline();
	            
	            const condition = isNext(path)
	                && noTrailingComment(path)
	                || isNextToAssignmentCall(path)
	                || isNextStatementWithBlockComment(path);
	            
	            if (condition)
	                indent();
	            
	            store(true);
	        }
	    },
	    afterIf: (path) => {
	        if (satisfyAfter(path))
	            return true;
	        
	        if (hasTrailingComment(path) && isLast(path))
	            return true;
	        
	        return isBeforeElse(path);
	    },
	    after(path, {print, maybe, store, indent}) {
	        if (hasTrailingComment(path) && isLast(path) && isCoupleLines(path))
	            print.breakline();
	        
	        if (hasTrailingComment(path) && !isCoupleLines(path))
	            return;
	        
	        if (isTopParentLast(path))
	            return;
	        
	        if (notInsideReturn(path)) {
	            if (isInsideAssignNextAssignFunction$1(path))
	                indent();
	            
	            print.newline();
	            maybe.markAfter(store(), path);
	        }
	    },
	};
	module.exports.ExpressionStatement.printLeadingCommentLine = printLeadingCommentLine;
	module.exports.ExpressionStatement.printLeadingCommentBlock = printLeadingCommentBlock;

	function isTopParentLast({parentPath}) {
	    if (!parentPath.isIfStatement())
	        return false;
	    
	    const nextParent = parentPath.parentPath;
	    
	    if (!nextParent.isIfStatement())
	        return false;
	    
	    const nextNext = nextParent.parentPath;
	    
	    if (!nextNext.isIfStatement())
	        return false;
	    
	    return isLast(nextNext);
	}

	function isNotLastBody(path) {
	    return path.parentPath.get('body') === path;
	}

	function isNotLastOrParentLast(path) {
	    return !isLast(path) && !isParentLast(path);
	}

	function isNextUp(path) {
	    return path.findParent(isNext);
	}

	function isStrictMode(path) {
	    const expressionPath = path.get('expression');
	    
	    if (!expressionPath.isStringLiteral())
	        return false;
	    
	    const {value} = path.node.expression;
	    
	    return value === 'use strict';
	}

	function isNextToAssignmentCall(path) {
	    if (isAssignmentExpression(path.node.expression))
	        return false;
	    
	    const nextPath = path.getNextSibling();
	    
	    if (!isExpressionStatement(nextPath))
	        return false;
	    
	    const {expression} = nextPath.node;
	    
	    return isCallExpression(expression);
	}

	function isNextStatementWithBlockComment(path) {
	    const {expression} = path.node;
	    
	    if (!isCallExpression(expression))
	        return false;
	    
	    if (!isCallExpression(expression.arguments[0]))
	        return false;
	    
	    return hasTrailingBlock(path);
	}

	function hasTrailingBlock(path) {
	    const {trailingComments} = path.node;
	    const [first] = trailingComments;
	    
	    return isCommentBlock(first);
	} 
} (expressionStatement$1));

var expressionStatementExports = expressionStatement$1.exports;
expressionStatementExports.default;

var variableDeclaration = {};

var maybeSpaceAfterKeyword$3 = {};

maybeSpaceAfterKeyword$3.maybeSpaceAfterKeyword = (path, {write}) => {
    const {declarations} = path.node;
    
    if (!declarations.length)
        return;
    
    const {id} = declarations[0];
    
    if (id.type === 'ArrayPattern' || id.type === 'ObjectPattern')
        return write.space();
    
    write(' ');
};

const {types: types$C} = bundle;
const {
    isNext: isNext$i,
    isCoupleLines: isCoupleLines$3,
    isNewlineBetweenSiblings: isNewlineBetweenSiblings$1,
    exists: exists$7,
    noTrailingComment: noTrailingComment$1,
} = is$3;

const {hasPrevNewline: hasPrevNewline$3} = mark;
const {maybeSpaceAfterKeyword: maybeSpaceAfterKeyword$2} = maybeSpaceAfterKeyword$3;

const {isConcatenation} = concatenate$1;
const {parseLeadingComments: parseLeadingComments$2} = comment;
const {maybeDeclare: maybeDeclare$4} = maybeDeclare$6;

const {isExportDeclaration: isExportDeclaration$3} = types$C;

const isParentTSModuleBlock = (path) => path.parentPath.isTSModuleBlock();
const isParentBlock$2 = (path) => /Program|BlockStatement|Export|LabeledStatement/.test(path.parentPath.type);
const isInsideBlock$3 = (path) => /^(Program|BlockStatement|TSModuleBlock|SwitchCase)$/.test(path.parentPath.type);
const isParentSwitchCase = (path) => path.parentPath.isSwitchCase();
const isFirstInSwitch = (path) => path.parentPath.get('consequent.0') === path;
const isParentIf = (path) => path.parentPath.isIfStatement();

variableDeclaration.VariableDeclaration = {
    beforeIf: shouldAddNewlineBefore,
    before(path, {print}) {
        print.breakline();
    },
    print: maybeDeclare$4((path, {maybe, store, write, traverse, print, indent}, semantics) => {
        const {maxVariablesInOneLine} = semantics;
        
        maybe.indent(isInsideBlock$3(path));
        
        write(path.node.kind);
        maybeSpaceAfterKeyword$2(path, {
            write,
        });
        
        const declarations = path.get('declarations');
        const n = declarations.length - 1;
        
        maybe.indent.inc(n);
        
        for (const [index, declaration] of declarations.entries()) {
            const id = declaration.get('id');
            const init = declaration.get('init');
            const isLast = index === n;
            
            traverse(id);
            
            if (exists$7(init)) {
                write.space();
                write('=');
                maybe.write.space(!isConcatenation(init));
                traverse(init);
            }
            
            if (!isLast) {
                const next = declarations[index + 1];
                
                write(',');
                
                if (!next.node.leadingComments) {
                    maybe.write.breakline(n > maxVariablesInOneLine);
                    maybe.write.space(n <= maxVariablesInOneLine);
                    continue;
                }
                
                parseLeadingComments$2(next, {print, maybe, indent}, semantics);
            }
        }
        
        maybe.indent.dec(n);
        
        if (isParentBlock$2(path) || isParentSwitchCase(path) || isParentTSModuleBlock(path) || isParentIf(path))
            write(';');
        
        let wasNewline = false;
        
        if (isParentSwitchCase(path)) {
            write.newline();
            
            if (!isFirstInSwitch(path))
                wasNewline = true;
        }
        
        if (isParentBlock$2(path) && isNext$i(path) && (noTrailingComment$1(path) || isNewlineBetweenSiblings$1(path))) {
            write.newline();
            wasNewline = true;
        }
        
        store(wasNewline);
    }),
    afterSatisfy: () => [
        isNextIf,
        isNextFn,
        noNextParentBlock,
        notLastCoupleLines,
        isNextAssign,
        isNextCoupleLines,
        notLastPrevVarNotNextVar,
        isNewlineBetweenSiblings$1,
        notLastParentExport,
        isParentTSModuleBlock,
    ],
    after(path, {maybe, store}) {
        const wasNewline = store();
        
        if (isLast$a(path.parentPath) && !path.parentPath.isBlockStatement() || !isParentBlock$2(path) && !isParentTSModuleBlock(path))
            return false;
        
        maybe.print.linebreak(wasNewline);
        maybe.print.newline(!wasNewline);
        maybe.markAfter(wasNewline, path);
    },
};

function noNextParentBlock(path) {
    if (isNext$i(path))
        return false;
    
    return path.parentPath.isBlockStatement();
}

function notLastParentExport(path) {
    if (isLast$a(path.parentPath))
        return false;
    
    return path.parentPath.isExportDeclaration();
}

function notLastCoupleLines(path) {
    if (isLast$a(path))
        return false;
    
    return isCoupleLines$3(path);
}

function notLastPrevVarNotNextVar(path) {
    const prev = path.getPrevSibling();
    const next = path.getNextSibling();
    
    if (!exists$7(prev.getPrevSibling()))
        return false;
    
    if (path.node.loc?.start.line === prev.node?.loc?.start.line + 2)
        return false;
    
    return !isLast$a(path) && prev.isVariableDeclaration() && !next.isVariableDeclaration();
}

function isNextCoupleLines(path) {
    const next = path.getNextSibling();
    const prev = path.getPrevSibling();
    
    if (!exists$7(prev.getPrevSibling()) && next.isVariableDeclaration())
        return false;
    
    if (path.node.loc?.start.line === prev.node?.loc?.start?.line + 2)
        return false;
    
    return isCoupleLines$3(next);
}

const isLast$a = (path) => path.parentPath?.isProgram() && !isNext$i(path);

function shouldAddNewlineBefore(path) {
    if (isFirst$1(path))
        return false;
    
    if (hasPrevNewline$3(path))
        return false;
    
    if (hasPrevNewline$3(path.parentPath))
        return false;
    
    const prevPath = path.getPrevSibling();
    
    if (prevPath.isStatement() && !prevPath.isExpressionStatement() && !prevPath.isBlockStatement())
        return false;
    
    return !isExportDeclaration$3(path.parentPath) && isCoupleLines$3(path);
}

function isFirst$1(path) {
    return path.node === path.parentPath.node.body?.[0];
}

const isNextIf = (path) => {
    const nextPath = path.getNextSibling();
    return nextPath.isIfStatement();
};

const isNextFn = (path) => {
    const nextPath = path.getNextSibling();
    return nextPath.isFunctionDeclaration();
};

const isNextAssign = (path) => {
    const nextPath = path.getNextSibling();
    
    if (!nextPath.isExpressionStatement())
        return false;
    
    const {parentPath} = path;
    
    if (parentPath.isBlockStatement() && parentPath.node.body.length < 3)
        return false;
    
    return nextPath.get('expression').isAssignmentExpression();
};

var ifStatement = {};

const {types: types$B} = bundle;

const {markAfter: markAfter$8} = mark;
const {
    exists: exists$6,
    isNext: isNext$h,
    isInsideIf: isInsideIf$2,
} = is$3;

const {
    isBlockStatement: isBlockStatement$3,
    isFunctionDeclaration: isFunctionDeclaration$1,
    isStatement: isStatement$3,
} = types$B;

const isTopLevel = ({parentPath}) => parentPath.parentPath.isProgram();
const isEmptyConsequent = (path) => path.get('consequent').isEmptyStatement();

const isInsideNestedBody = ({parentPath}) => {
    if (parentPath.type !== 'BlockStatement')
        return false;
    
    return parentPath.parentPath.type === 'BlockStatement';
};

const isEmptyBody = (path) => !path.node.body.length;

const isLastEmptyInsideBody = (path) => {
    const {parentPath} = path;
    
    if (!isBlockStatement$3(parentPath))
        return false;
    
    if (!isBlockStatement$3(path.node.consequent))
        return false;
    
    if (path.node.consequent.body.length)
        return false;
    
    return isFunctionDeclaration$1(path.parentPath.parentPath);
};

ifStatement.IfStatement = {
    print: (path, {indent, print, maybe, write, traverse}) => {
        const {parentPath} = path;
        const partOfAlternate = parentPath.get('alternate');
        
        if (path !== partOfAlternate)
            indent();
        
        print('if');
        print.space();
        print('(');
        print('__test');
        print(')');
        
        const consequent = path.get('consequent');
        const alternate = path.get('alternate');
        const isConsequentBlock = consequent.isBlockStatement();
        const isVar = consequent.isVariableDeclaration();
        
        if (isConsequentBlock) {
            print.space();
            print(consequent);
            
            if (isInsideIf$2(path.parentPath) || isInsideNestedBody(path))
                maybe.print.newline(isEmptyBody(consequent));
        } else {
            const is = !isEmptyConsequent(path);
            
            maybe.print.newline(is);
            maybe.indent.inc(is);
            maybe.indent(isVar);
            print(consequent);
            maybe.indent.dec(is);
        }
        
        if (alternate.isBlockStatement()) {
            write.space();
            write('else');
            write.space();
            traverse(alternate);
        } else if (alternate.isIfStatement()) {
            if (alternate.get('consequent').isBlockStatement())
                write.space();
            else
                indent();
            
            write('else ');
            traverse(alternate);
        } else if (exists$6(alternate)) {
            maybe.write.newline(isVar);
            maybe.indent(!isConsequentBlock);
            maybe.write.space(isConsequentBlock);
            write('else');
            write.splitter();
            indent.inc();
            traverse(alternate);
            indent.dec();
        }
        
        if (!isNext$h(path) && !consequent.isBlockStatement())
            return;
        
        const nextPath = path.parentPath.getNextSibling();
        
        if (path === partOfAlternate && !isTopLevel(path) && !isStatement$3(nextPath))
            print.newline();
        
        if (isLastEmptyInsideBody(path))
            print.newline();
    },
    afterSatisfy: () => [isNext$h],
    after: (path, {print}) => {
        print.linebreak();
        markAfter$8(path);
    },
};

var forOfStatement = {};

const {
    hasPrevNewline: hasPrevNewline$2,
    markAfter: markAfter$7,
    markBefore,
    isMarkedAfter: isMarkedAfter$1,
} = mark;

const {
    isFirst,
    isNext: isNext$g,
    isLast: isLast$9,
} = is$3;

forOfStatement.ForOfStatement = {
    beforeIf(path) {
        const {parentPath} = path;
        
        if (!parentPath.isBlockStatement() && parentPath.isStatement())
            return false;
        
        return !isFirst(path) && !hasPrevNewline$2(path);
    },
    before(path, {print}) {
        print.linebreak();
        markBefore(path);
    },
    print(path, {indent, print, maybe, traverse}) {
        const {node} = path;
        
        indent();
        print('for');
        maybe.print(node.await, ' await');
        print.space();
        print('(');
        print('__left');
        print(' of ');
        print('__right');
        print(')');
        
        const bodyPath = path.get('body');
        
        if (bodyPath.isBlockStatement()) {
            print.space();
            print('__body');
            
            const {length} = bodyPath.node.body;
            maybe.print.newline(!length && !isLast$9(path) && !isNext$g(path));
            
            return;
        }
        
        indent.inc();
        print.newline();
        traverse(bodyPath);
        indent.dec();
        
        maybe.markAfter(isMarkedAfter$1(bodyPath), path);
    },
    afterIf: isNext$g,
    after(path, {print}) {
        print.linebreak();
        markAfter$7(path);
    },
};

var blockStatement = {};

var insideIfWithNoBody$1 = {};

const {exists: exists$5} = is$3;

insideIfWithNoBody$1.insideIfWithNoBody = (path) => {
    if (!path.parentPath.isIfStatement())
        return false;
    
    if (!path.parentPath.parentPath.isIfStatement())
        return false;
    
    const next = path.parentPath?.parentPath.getNextSibling();
    
    return !exists$5(next);
};

var getDirectives$2 = {};

getDirectives$2.getDirectives = (path) => !path.node.directives ? [] : path.get('directives');

var isCallInsideChain$1 = {};

const {types: types$A} = bundle;
const {isLooksLikeChain} = isLooksLikeChain$4;
const {
    isReturnStatement,
    isExpressionStatement: isExpressionStatement$1,
    isMemberExpression,
    isCallExpression: isCallExpression$2,
} = types$A;

isCallInsideChain$1.isCallInsideChain = (path) => {
    if (!isCallExpression$2(path.parentPath.parentPath))
        return false;
    
    const member = path.find(isTopMemberInsideCall);
    
    if (member)
        return isLooksLikeChain(member);
    
    const callPath = path.find(isTopCall);
    
    if (!callPath)
        return false;
    
    const calleeMember = callPath.get('callee');
    
    return isLooksLikeChain(calleeMember);
};

function isTopMemberInsideCall(path) {
    if (!isMemberExpression(path))
        return false;
    
    return isExpressionStatement$1(path.parentPath.parentPath);
}

function isTopCall(path) {
    if (!isCallExpression$2(path))
        return false;
    
    const {parentPath} = path;
    
    if (isReturnStatement(parentPath))
        return true;
    
    return isExpressionStatement$1(parentPath);
}

const {types: types$z} = bundle;
const {
    isNext: isNext$f,
    isParentProgram,
    isLast: isLast$8,
    exists: exists$4,
    satisfy: satisfy$1,
} = is$3;

const {markAfter: markAfter$6} = mark;
const {parseComments: parseComments$3} = comment;
const {insideIfWithNoBody} = insideIfWithNoBody$1;
const {getDirectives: getDirectives$1} = getDirectives$2;

const {isCallInsideChain} = isCallInsideChain$1;
const {
    isArrowFunctionExpression,
    isObjectMethod,
    isFunctionDeclaration,
    isExportDeclaration: isExportDeclaration$2,
    isDoWhileStatement,
    isBlockStatement: isBlockStatement$2,
    isArrayExpression: isArrayExpression$1,
} = types$z;

const isFirstStatement = (path) => path.node.body[0];
const isFirstDirective = (path) => path.node.directives?.[0];
const isMethodOrArrow = (path) => isArrowFunctionExpression(path) || isObjectMethod(path);

const isInsideArrayTupleOfThree = (path) => {
    const {parentPath} = path.parentPath;
    
    if (!isArrayExpression$1(parentPath))
        return false;
    
    const {length} = parentPath.node.elements;
    
    return length === 3;
};

const parentIfWithoutElse = ({parentPath}) => {
    if (!parentPath.isIfStatement())
        return false;
    
    return !parentPath.node.alternate;
};

blockStatement.BlockStatement = {
    print(path, printer, semantics) {
        const {trailingComma} = semantics;
        const {
            indent,
            maybe,
            write,
            traverse,
        } = printer;
        
        const body = path.get('body');
        const directives = getDirectives$1(path);
        
        if (path.parentPath.isBlockStatement())
            indent();
        
        const insideArray = isInsideArrayTupleOfThree(path);
        maybe.indent.inc(!insideArray);
        write('{');
        
        if (isFirstStatement(path) || isFirstDirective(path))
            write.newline();
        
        for (const directive of directives) {
            traverse(directive);
        }
        
        maybe.write.linebreak(directives.length && body.length);
        const callInsideChain = isCallInsideChain(path);
        
        maybe.indent.inc(callInsideChain);
        
        for (const element of body) {
            traverse(element);
        }
        
        parseComments$3(path, printer, semantics);
        
        maybe.indent.dec(!insideArray);
        
        maybe.indent.dec(insideArray);
        maybe.indent(body.length);
        maybe.indent.inc(insideArray);
        write('}');
        
        maybe.indent.dec(callInsideChain);
        
        const {parentPath} = path;
        
        if (isObjectMethod(parentPath))
            maybe.write(isNext$f(parentPath) || trailingComma, ',');
    },
    afterIf: shouldAddNewlineAfter,
    after(path, {write}) {
        write.newline();
        markAfter$6(path.parentPath);
    },
};

const isTopLevelWithNoNext = (path) => {
    if (isNext$f(path))
        return false;
    
    return !isNext$f(path.parentPath) && isParentProgram(path.parentPath);
};

const isInsideIfWithoutElseInsideFn = (path) => {
    return parentIfWithoutElse(path) && path.find(isMethodOrArrow);
};

const isEmptyBodyNoNext = (path) => {
    const {parentPath} = path;
    return parentPath.isStatement() && !path.node.body.length && !isNext$f(parentPath);
};

const isLooksLikeInsideFn = ({parentPath}) => {
    return /FunctionExpression/.test(parentPath.type);
};

const NEWLINE = true;
const NO_NEWLINE = false;

const isInsideDoWhile = ({parentPath}) => isDoWhileStatement(parentPath);
const isInsideBlock$2 = ({parentPath}) => isBlockStatement$2(parentPath);

const isNoNewline = satisfy$1([
    isInsideDoWhile,
    isTopLevelWithNoNext,
    insideIfWithNoBody,
]);

function shouldAddNewlineAfter(path) {
    if (isInsideBlock$2(path))
        return NEWLINE;
    
    if (isNoNewline(path))
        return NO_NEWLINE;
    
    if (isInsideIfWithoutElseInsideFn(path))
        return NEWLINE;
    
    if (isEmptyBodyNoNext(path))
        return NO_NEWLINE;
    
    if (isTry(path))
        return NO_NEWLINE;
    
    if (isLooksLikeInsideFn(path))
        return NO_NEWLINE;
    
    if (isLast$8(path))
        return NO_NEWLINE;
    
    if (isExportFunction(path))
        return NO_NEWLINE;
    
    return !isNextIfAlternate(path);
}

function isExportFunction(path) {
    if (!isFunctionDeclaration(path.parentPath))
        return false;
    
    if (!isExportDeclaration$2(path.parentPath?.parentPath))
        return false;
    
    return !isNext$f(path.parentPath?.parentPath);
}

function isNextIfAlternate(path) {
    const {parentPath} = path;
    
    if (!parentPath.isIfStatement())
        return false;
    
    const alternate = parentPath.get('alternate');
    
    if (path === alternate)
        return false;
    
    return exists$4(alternate);
}

function isTry({parentPath}) {
    if (parentPath.isTryStatement())
        return true;
    
    return parentPath.parentPath?.isTryStatement();
}

var returnStatement = {};

var maybeSpaceAfterKeyword$1 = {};

maybeSpaceAfterKeyword$1.maybeSpaceAfterKeyword = (path, {print}, semantics) => {
    const {roundBraces} = semantics;
    const {argument} = path.node;
    
    if (!argument)
        return;
    
    const {type} = argument;
    
    if (type === 'SequenceExpression' && roundBraces.sequence)
        return print.space();
    
    if (type === 'StringLiteral' || type === 'TemplateLiteral')
        return print.space();
    
    if (type === 'ArrayExpression' || type === 'ObjectExpression')
        return print.space();
    
    if (type === 'UnaryExpression' && argument.operator === '!')
        return print.space();
    
    if (type === 'ArrowFunctionExpression' && roundBraces.arrow)
        return print.space();
    
    print(' ');
};

const {types: types$y} = bundle;

const {isInsideLabel: isInsideLabel$3} = is$3;
const {
    isPrevBody,
    noTrailingComment,
    isLast: isLast$7,
} = is$3;

const {hasPrevNewline: hasPrevNewline$1} = mark;
const {maybeSpaceAfterKeyword} = maybeSpaceAfterKeyword$1;

const {isJSXElement: isJSXElement$3} = types$y;
const isBodyLength = ({parentPath}) => parentPath.node?.body?.length > 2;

const isInsideIfWithElse = ({parentPath}) => parentPath.isIfStatement() && parentPath.node.alternate;

returnStatement.ReturnStatement = {
    beforeIf(path) {
        return !hasPrevNewline$1(path) && isBodyLength(path) || isPrevBody(path);
    },
    before(path, {print}) {
        print.linebreak();
    },
    print(path, printer, semantics) {
        const {maybe, print} = printer;
        
        maybe.indent(!isInsideLabel$3(path));
        print('return');
        maybeSpaceAfterKeyword(path, printer, semantics);
        
        if (isJSXWithComment(path)) {
            print('(');
            print.breakline();
            print('__argument');
            print(');');
            
            return;
        }
        
        print('__argument');
        print(';');
    },
    afterIf: (path) => {
        if (isInsideIfWithElse(path))
            return true;
        
        if (isLast$7(path))
            return false;
        
        if (isLast$7(path.parentPath))
            return false;
        
        return noTrailingComment(path);
    },
    after(path, {print}) {
        print.newline();
    },
};
function isJSXWithComment(path) {
    const arg = path.node.argument;
    
    if (!arg)
        return;
    
    const {leadingComments} = arg;
    
    return isJSXElement$3(arg) && leadingComments?.length;
}

var tryStatements = {};

const {isNext: isNext$e} = is$3;

tryStatements.TryStatement = {
    print(path, {print}) {
        const finalizer = path.get('finalizer');
        print.indent();
        print('try');
        print.space();
        print('__block');
        print('__handler');
        
        if (finalizer.node) {
            print.space();
            print('finally');
            print.space();
            print(finalizer);
            print.newline();
        }
    },
    afterSatisfy: () => [isNext$e],
    after(path, {maybe, print}) {
        maybe.print.newline(!path.node.finalizer);
        print.breakline();
    },
};

tryStatements.CatchClause = (path, {print, maybe}) => {
    const param = path.get('param');
    const body = path.get('body');
    
    print.space();
    print('catch');
    
    if (!param.node) {
        print.space();
    } else {
        print('(');
        print(param);
        print(')');
        print.space();
    }
    
    print(body);
    maybe.print.newline(isInsideBlock$1(path));
};

function isInsideBlock$1(path) {
    return path.parentPath.parentPath.isBlockStatement();
}

var debuggerStatement = {};

const {isNext: isNext$d, isInsideIf: isInsideIf$1} = is$3;
const isInsideBlock = (path) => path.parentPath.isBlockStatement();

debuggerStatement.DebuggerStatement = {
    print(path, {print, indent}) {
        indent();
        print('debugger;');
    },
    afterSatisfy: () => [
        isNext$d,
        isInsideBlock,
        isInsideIf$1,
    ],
    after(path, {print}) {
        print.newline();
    },
};

var forStatement = {};

const {exists: exists$3} = is$3;

const {markAfter: markAfter$5} = mark;

forStatement.ForStatement = {
    print(path, {print, maybe, indent}) {
        const {
            test,
            update,
            body,
        } = path.node;
        
        indent();
        print('for');
        print.space();
        print('(');
        print('__init');
        print(';');
        maybe.print.space(test);
        print('__test');
        
        print(';');
        maybe.print.space(update);
        print('__update');
        print(')');
        
        if (body.body) {
            print.space();
            print('__body');
        } else {
            const is = !path.get('body').isEmptyStatement();
            maybe.print.newline(is);
            maybe.indent.inc(is);
            print('__body');
            maybe.indent.dec(is);
        }
    },
    afterIf(path) {
        return exists$3(path.getNextSibling());
    },
    after(path, {print}) {
        print.linebreak();
        markAfter$5(path);
    },
};

var importDeclaration = {exports: {}};

var parseImportSpecifiers = {};

parseImportSpecifiers.parseImportSpecifiers = (specifiers) => {
    const defaults = [];
    const namespaces = [];
    const imports = [];
    
    for (const spec of specifiers) {
        if (spec.type === 'ImportDefaultSpecifier') {
            defaults.push(spec);
            continue;
        }
        
        if (spec.type === 'ImportNamespaceSpecifier') {
            namespaces.push(spec);
            continue;
        }
        
        if (spec.type === 'ImportSpecifier') {
            imports.push(spec);
            continue;
        }
    }
    
    return {
        defaults,
        namespaces,
        imports,
    };
};

var importAttribute = {};

importAttribute.ImportAttribute = (path, {print}) => {
    print('__key');
    print(':');
    print.space();
    print('__value');
    print(',');
};

importAttribute.maybePrintAttributes = (path, printer) => {
    if (isAssertions(path))
        return printAttributes(path, 'assert', printer);
    
    printAttributes(path, 'with', printer);
};

const isAssertions = (path) => path.node.extra?.deprecatedAssertSyntax;

function printAttributes(path, keyword, {write, traverse, indent}) {
    const attributes = path.get('attributes');
    
    if (!attributes.length)
        return;
    
    write(` ${keyword}`);
    write.space();
    
    write('{');
    write.breakline();
    indent.inc();
    
    for (const attr of attributes) {
        indent();
        traverse(attr);
        write.newline();
    }
    
    indent.dec();
    write('}');
}

var importDeclarationComments = {};

const {types: types$x} = bundle;
const {isExportDeclaration: isExportDeclaration$1} = types$x;

importDeclarationComments.printTrailingCommentLine = (path, printer, semantics, {printComment}) => {
    const {print} = printer;
    printComment();
    print.breakline();
};

importDeclarationComments.printTrailingCommentBlock = (path, printer, semantics, {printComment}) => {
    const {maybe} = printer;
    const next = path.getNextSibling();
    
    maybe.print.breakline(!isExportDeclaration$1(next));
    printComment();
};

(function (module) {

	const {parseImportSpecifiers: parseImportSpecifiers$1} = parseImportSpecifiers;

	const {markAfter} = mark;
	const {isLast, isNext} = is$3;

	const {
	    maybePrintAttributes,
	    ImportAttribute,
	} = importAttribute;

	const {
	    printTrailingCommentBlock,
	    printTrailingCommentLine,
	} = importDeclarationComments;

	module.exports.ImportAttribute = ImportAttribute;
	module.exports.ImportDeclaration = {
	    print(path, printer, semantics) {
	        const {
	            print,
	            maybe,
	            write,
	            traverse,
	            indent,
	        } = printer;
	        
	        const {phase} = path.node;
	        const isType = path.node.importKind === 'type';
	        const specifiers = path.get('specifiers');
	        
	        indent();
	        write('import');
	        maybe.write(isType, ' type');
	        maybe.write(phase, ` ${phase}`);
	        
	        let wasSpecifier = false;
	        const n = specifiers.length - 1;
	        
	        const {
	            defaults,
	            namespaces,
	            imports,
	        } = parseImportSpecifiers$1(specifiers);
	        
	        maybe.write(specifiers.length, ' ');
	        
	        for (const spec of defaults) {
	            traverse(spec.get('local'));
	            maybe.write(n, ',');
	            maybe.write.space(n);
	        }
	        
	        for (const spec of namespaces) {
	            write('* as ');
	            traverse(spec.get('local'));
	        }
	        
	        const maxSpecifiersInOneLine = parseMaxSpecifiers(imports, semantics);
	        const importsCount = imports.length - 1;
	        
	        for (const [index, spec] of imports.entries()) {
	            const last = index === importsCount;
	            const notLast = !last;
	            
	            const {imported, local} = spec.node;
	            
	            indent.inc();
	            
	            maybe.write(!wasSpecifier, '{');
	            maybe.write.breakline(importsCount >= maxSpecifiersInOneLine);
	            
	            wasSpecifier = true;
	            traverse(spec.get('imported'));
	            
	            if (imported.name !== local.name) {
	                write(' as ');
	                write(local.name);
	            }
	            
	            if (importsCount < maxSpecifiersInOneLine && notLast) {
	                maybe.write(n, ',');
	                maybe.write.space(n);
	            }
	            
	            if (importsCount >= maxSpecifiersInOneLine) {
	                maybe.write(n, ',');
	                
	                const last = index === n;
	                const penulty = index === n - 1;
	                
	                maybe.write.newline(penulty && defaults.length);
	                maybe.write.newline(last);
	            }
	            
	            indent.dec();
	            maybe.write(last, '}');
	        }
	        
	        maybe.write(specifiers.length, ' from');
	        print.space();
	        
	        print('__source');
	        maybePrintAttributes(path, printer);
	        print(';');
	        
	        if (isNext(path))
	            print.newline();
	    },
	    afterIf(path) {
	        if (isLast(path))
	            return false;
	        
	        return !path.getNextSibling().isImportDeclaration();
	    },
	    after(path, {print}) {
	        print.newline();
	        markAfter(path);
	    },
	};

	function parseMaxSpecifiers(imports, semantics) {
	    const {
	        maxSpecifiersInOneLine,
	        maxPropertiesLengthInOneLine,
	    } = semantics;
	    
	    for (const {node} of imports) {
	        if (node.imported.name !== node.local.name)
	            return 1;
	        
	        if (node.imported.name.length >= maxPropertiesLengthInOneLine)
	            return 1;
	    }
	    
	    return maxSpecifiersInOneLine;
	}

	module.exports.ImportDeclaration.printTrailingCommentBlock = printTrailingCommentBlock;
	module.exports.ImportDeclaration.printTrailingCommentLine = printTrailingCommentLine; 
} (importDeclaration));

var importDeclarationExports = importDeclaration.exports;
importDeclarationExports.default;

var exportDeclaration = {};

const {types: types$w} = bundle;

const {isParentBlock: isParentBlock$1} = is$3;
const {
    markAfter: markAfter$4,
    isMarkedAfter,
    hasPrevNewline,
} = mark;

const {
    isNewlineBetweenSiblings,
    exists: exists$2,
    isNext: isNext$c,
    isLast: isLast$6,
} = is$3;

const {
    isExportNamespaceSpecifier,
    isVariableDeclaration: isVariableDeclaration$2,
    isExportNamedDeclaration: isExportNamedDeclaration$1,
} = types$w;

const isDeclarationNewline = (path) => isMarkedAfter(path.get('declaration'));
const isInsideNamespace$1 = (path) => path.parentPath.isTSModuleBlock();

const options$2 = {
    exports: {
        maxOneLineSpecifiers: 2,
    },
};

exportDeclaration.ExportSpecifier = (path, {print}) => {
    const {local, exported} = path.node;
    
    print('__local');
    
    if (exported.name !== local.name) {
        print(' as ');
        print('__exported');
    }
};

exportDeclaration.ExportNamespaceSpecifier = (path, {print}) => {
    print('* as ');
    print('__exported');
};

exportDeclaration.ExportNamedDeclaration = {
    beforeIf(path) {
        const prev = path.getPrevSibling();
        
        if (hasPrevNewline(path))
            return false;
        
        return isVariableDeclaration$2(prev);
    },
    before(path, {print}) {
        print.linebreak();
    },
    print(path, {print, traverse, indent, maybe}, semantics) {
        const {trailingComma} = semantics;
        const {exportKind} = path.node;
        const specifiers = path.get('specifiers');
        const {maxOneLineSpecifiers} = options$2.exports;
        const source = path.get('source');
        
        indent();
        print('export');
        
        if (exportKind === 'type' && specifiers.length)
            print(' type');
        
        if (isExportNamespaceSpecifier(specifiers[0])) {
            print(' ');
            print(specifiers[0]);
            print(' from ');
            print('__source');
            print(';');
            maybe.print.newline(!isLast$6(path));
            
            return;
        }
        
        const n = specifiers.length;
        const isNewline = !exists$2(source) || n > maxOneLineSpecifiers;
        
        if (specifiers && !path.node.declaration) {
            print.space();
            print('{');
            
            if (specifiers.length) {
                indent.inc();
                maybe.print.newline(isNewline);
                
                const lastIndex = n - 1;
                
                for (const [i, spec] of specifiers.entries()) {
                    const isType = spec.node.exportKind === 'type';
                    const isLast = i < lastIndex;
                    
                    maybe.indent(isNewline);
                    maybe.print(isType, 'type ');
                    traverse(spec);
                    
                    if (isLast && !isNewline)
                        print(', ');
                    else if (isNewline)
                        maybe.print(isLast || trailingComma, ',');
                    
                    maybe.print.newline(isNewline);
                }
                
                indent.dec();
                indent();
            }
            
            print('}');
            const source = path.get('source');
            
            if (exists$2(source)) {
                print(' from ');
                traverse(source);
            }
            
            print(';');
            maybe.print.newline(isNext$c(path) || isInsideNamespace$1(path));
            
            return;
        }
        
        print(' ');
        print('__declaration');
    },
    afterIf(path) {
        if (isLast$6(path))
            return false;
        
        if (isDeclarationNewline(path))
            return false;
        
        if (isNewlineBetweenSiblings(path))
            return true;
        
        return isParentBlock$1(path);
    },
    after(path, {print, indent}) {
        const next = path.getNextSibling();
        
        if (isExportNamedDeclaration$1(next))
            indent();
        
        print.newline();
        
        markAfter$4(path);
    },
};

var exportAllDeclaration = {};

exportAllDeclaration.ExportAllDeclaration = (path, {print}) => {
    const {exportKind} = path.node;
    print('export ');
    
    if (exportKind === 'type')
        print('type ');
    
    print('* from ');
    print('__source');
    print(';');
    print.newline();
};

var whileStatement = {};

const {isNext: isNext$b} = is$3;
const {markAfter: markAfter$3} = mark;

whileStatement.WhileStatement = {
    print(path, {print, indent}) {
        indent();
        print('while');
        print.space();
        print('(');
        print('__test');
        print(')');
        
        if (path.node.body.body) {
            print.space();
            print('__body');
        } else {
            indent.inc();
            print.newline();
            print('__body');
            indent.dec();
        }
    },
    afterIf(path) {
        return isNext$b(path);
    },
    after(path, {print}) {
        print.linebreak();
        markAfter$3(path);
    },
};

var switchStatement = {};

const {
    isNext: isNext$a,
    exists: exists$1,
    isLast: isLast$5,
} = is$3;

const {parseLeadingComments: parseLeadingComments$1} = comment;

switchStatement.SwitchStatement = {
    print(path, printer, semantics) {
        const {
            print,
            maybe,
            indent,
            write,
            traverse,
        } = printer;
        
        indent();
        print('switch');
        print('(');
        print('__discriminant');
        print(') {');
        print.newline();
        
        const cases = path.get('cases');
        const n = cases.length - 1;
        
        for (const [index, switchCase] of cases.entries()) {
            const test = switchCase.get('test');
            
            indent();
            
            parseLeadingComments$1(switchCase, printer, semantics);
            
            if (exists$1(test)) {
                write('case ');
                traverse(test);
            } else {
                write('default');
            }
            
            print(':');
            
            const consequents = switchCase.get('consequent');
            const isBlock = switchCase.get('consequent.0')?.isBlockStatement();
            
            maybe.indent.inc(!isBlock);
            maybe.print.newline(!isBlock && consequents.length);
            
            for (const consequent of consequents) {
                if (!consequent.isBlockStatement()) {
                    print(consequent);
                    continue;
                }
                
                print.space();
                print(consequent);
            }
            
            maybe.indent.dec(!isBlock);
            maybe.write.linebreak(index < n);
        }
        
        print.indent();
        print('}');
        
        if (!isNext$a(path) && !isLast$5(path))
            print.newline();
    },
    afterSatisfy: () => [isNext$a],
    after(path, {print}) {
        print.breakline();
        print.newline();
    },
};

var forInStatement = {};

forInStatement.ForInStatement = (path, {print, indent}) => {
    indent();
    print('for');
    print.space();
    print('(');
    print('__left');
    print(' in ');
    print('__right');
    print(')');
    
    if (path.get('body').isBlockStatement())
        print.space();
    
    print('__body');
};

var exportDefaultDeclaration = {};

const {types: types$v} = bundle;
const {isNext: isNext$9} = is$3;

const {
    isVariableDeclaration: isVariableDeclaration$1,
    isFunction: isFunction$2,
} = types$v;

function shouldAddSemicolon(path) {
    if (path.isClassDeclaration())
        return false;
    
    return !path.isFunctionDeclaration();
}

exportDefaultDeclaration.ExportDefaultDeclaration = {
    print(path, {print, traverse, maybe}) {
        const declaration = path.get('declaration');
        print('export default ');
        traverse(declaration);
        maybe.print(shouldAddSemicolon(declaration), ';');
    },
    afterSatisfy: () => [isNext$9],
    after(path, {print, maybe}) {
        print.newline();
        maybe.print.newline(!isVarAfterFn(path));
    },
};

function isVarAfterFn(path) {
    const next = path.getNextSibling();
    
    if (!isVariableDeclaration$1(next))
        return false;
    
    const {declaration} = path.node;
    
    return isFunction$2(declaration);
}

var breakStatement = {};

const {
    isParentBlock,
    isNextParent: isNextParent$3,
    isInsideIf,
    isInsideLabel: isInsideLabel$2,
} = is$3;

const isInsideCase = (path) => path.parentPath.isSwitchCase();

breakStatement.BreakStatement = {
    split(path, {print}) {
        print.newline();
    },
    print(path, {print, maybe}) {
        const {label} = path.node;
        
        maybe.indent(!isInsideLabel$2(path));
        print('break');
        maybe.print.space(label);
        print('__label');
        print(';');
    },
    afterSatisfy: () => [
        isParentBlock,
        isNextParent$3,
        isInsideCase,
        isInsideIf,
    ],
};

var doWhileStatement = {};

const {isLast: isLast$4} = is$3;
const notLast = (path) => !isLast$4(path);

doWhileStatement.DoWhileStatement = {
    print(path, {print, indent}) {
        indent();
        print('do');
        print.space();
        print('__body');
        print.space();
        print('while');
        print.space();
        print('(');
        print('__test');
        print(')');
    },
    afterSatisfy: () => [notLast],
    after(path, {print}) {
        print.newline();
    },
};

var program$1 = {};

const {parseComments: parseComments$2} = comment;
const {getDirectives} = getDirectives$2;
const {hasCoupleTrailingComments} = is$3;

program$1.Program = (path, printer, semantics) => {
    const {body} = path.node;
    const {
        traverse,
        maybe,
        write,
    } = printer;
    
    traverse(path.get('interpreter'));
    parseComments$2(path, printer, semantics);
    
    const directives = getDirectives(path);
    
    for (const directive of directives) {
        traverse(directive);
        maybe.write.newline(body.length);
    }
    
    path.get('body').forEach(traverse);
    
    if (directives.length && !body.length)
        return;
    
    if (body.length && hasCoupleTrailingComments(body.at(-1)))
        return;
    
    write.endOfFile();
};

var continueStatement = {};

const {isInsideLabel: isInsideLabel$1} = is$3;

continueStatement.ContinueStatement = (path, {print, maybe, write}) => {
    const {label} = path.node;
    
    maybe.indent(!isInsideLabel$1(path));
    print('continue');
    
    maybe.print.space(label);
    print('__label');
    
    write(';');
    print.newline();
};

var labeledStatement = {};

const {isInsideLabel} = is$3;

labeledStatement.LabeledStatement = (path, {print, maybe}) => {
    maybe.indent(!isInsideLabel(path));
    print('__label');
    print(':');
    print.space();
    print('__body');
};

var emptyStatement = {};

const {isLast: isLast$3} = is$3;

emptyStatement.EmptyStatement = (path, {write, maybe}) => {
    const {parentPath} = path;
    write(';');
    maybe.write.newline(!isLast$3(path) && !isLast$3(parentPath));
};

const {ExpressionStatement} = expressionStatementExports;
const {VariableDeclaration} = variableDeclaration;
const {IfStatement} = ifStatement;
const {ForOfStatement} = forOfStatement;
const {BlockStatement} = blockStatement;
const {ReturnStatement} = returnStatement;
const TryStatements = tryStatements;
const {DebuggerStatement} = debuggerStatement;
const {ForStatement} = forStatement;
const importDeclarations = importDeclarationExports;
const exportDeclarations = exportDeclaration;
const {ExportAllDeclaration} = exportAllDeclaration;

const {WhileStatement} = whileStatement;
const {SwitchStatement} = switchStatement;
const {ForInStatement} = forInStatement;
const {ExportDefaultDeclaration} = exportDefaultDeclaration;
const {BreakStatement} = breakStatement;
const {DoWhileStatement} = doWhileStatement;
const {Program} = program$1;
const {ContinueStatement} = continueStatement;
const {LabeledStatement} = labeledStatement;
const {EmptyStatement} = emptyStatement;

const {
    ExportNamespaceSpecifier,
    ExportSpecifier,
} = exportDeclarations;

var statements$2 = {
    ...importDeclarations,
    ...exportDeclarations,
    BlockStatement,
    DoWhileStatement,
    ExpressionStatement,
    ExportSpecifier,
    ExportNamespaceSpecifier,
    ExportDefaultDeclaration,
    ExportAllDeclaration,
    VariableDeclaration,
    IfStatement,
    ForStatement,
    ForInStatement,
    ForOfStatement,
    ReturnStatement,
    DebuggerStatement,
    LabeledStatement,
    Program,
    EmptyStatement,
    InterpreterDirective(path, {print}) {
        // shebang, hashbang
        print(`#!${path.node.value}\n`);
        print.newline();
    },
    SwitchStatement,
    ...TryStatements,
    BreakStatement,
    ContinueStatement,
    WhileStatement,
};

var templateLiteral = {};

templateLiteral.TemplateLiteral = (path, {write, traverse}) => {
    write('`');
    
    let i = 0;
    const expressions = path.get('expressions');
    
    for (const element of path.node.quasis) {
        write(element.value.raw);
        
        const exp = expressions[i++];
        
        if (exp) {
            write('${');
            traverse(exp);
            write('}');
        }
    }
    
    write('`');
};

var identifier$2 = {};

var maybeGet = {};

maybeGet.maybeDecorators = (path) => {
    if (!path.node.decorators)
        return [];
    
    return path.get('decorators');
};

const {maybeDecorators} = maybeGet;
const {maybeParens: maybeParens$5} = maybeParens$e;
const {maybeTypeAnnotation} = maybeTypeAnnotation$4;

identifier$2.Identifier = maybeParens$5(maybeTypeAnnotation((path, printer) => {
    const {
        write,
        maybe,
        traverse,
        print,
    } = printer;
    
    const {node} = path;
    const {name, optional} = node;
    
    for (const decorator of maybeDecorators(path)) {
        traverse(decorator);
        print(' ');
    }
    
    write(name);
    maybe.write(optional, '?');
}));

var decorator = {exports: {}};

(function (module) {

	const {types} = bundle;
	const {isMemberExpression} = types;

	module.exports.Decorator = (path, {print, maybe}) => {
	    const {expression} = path.node;
	    const isMember = isMemberExpression(expression);
	    
	    print('@');
	    
	    maybe.print(isMember, '(');
	    print('__expression');
	    maybe.print(isMember, ')');
	};

	module.exports.Decorator.printLeadingCommentLine = (path, printer, semantics, {printComment}) => {
	    const {print} = printer;
	    printComment();
	    print.breakline();
	}; 
} (decorator));

var decoratorExports = decorator.exports;
decoratorExports.default;

var stringLiteral$4 = {};

stringLiteral$4.StringLiteral = (path, {write}, semantics) => {
    const {value, raw = `'${value}'`} = path.node;
    
    if (path.parentPath.isJSXAttribute()) {
        write(`"${value}"`);
        return;
    }
    
    const newValue = raw.slice(1, -1);
    write.quote();
    write(maybeEscape(newValue, semantics));
    write.quote();
};

const maybeEscape = (value, {escapeDoubleQuote, escapeSingleQuote}) => {
    const list = value.split('');
    const slash = '\\';
    
    if (escapeSingleQuote)
        return escape$1(list, {
            slash,
            quote: `'`,
        });
    
    if (escapeDoubleQuote)
        return escape$1(list, {
            slash,
            quote: `"`,
        });
    
    return value;
};

const escape$1 = (list, {slash, quote}) => {
    const res = [];
    
    for (const [index, char] of list.entries()) {
        const prev = list[index - 1];
        
        if (char === quote && prev !== slash) {
            res.push(`${slash}${char}`);
            continue;
        }
        
        res.push(char);
    }
    
    return res.join('');
};

var directiveLiteral$1 = {};

directiveLiteral$1.DirectiveLiteral = (path, {write}) => {
    write.indent();
    write(path.node.raw || `'${path.node.value}'`);
    write(';');
    write.newline();
};

var voidPattern = {};

voidPattern.VoidPattern = (path, {write}) => {
    write('void');
};

const {TemplateLiteral} = templateLiteral;
const {Identifier} = identifier$2;

const {Decorator} = decoratorExports;
const {StringLiteral} = stringLiteral$4;
const {DirectiveLiteral} = directiveLiteral$1;
const {VoidPattern} = voidPattern;

var literals$1 = {
    Identifier,
    Decorator,
    DirectiveLiteral,
    TemplateLiteral,
    VoidPattern,
    BigIntLiteral(path, {write}) {
        write(path.node.raw);
    },
    NumericLiteral(path, {write}) {
        const {
            raw,
            extra,
            value,
        } = path.node;
        
        write(raw || extra?.raw || value);
    },
    Directive(path, {print, maybe}) {
        maybe.print.breakline(path.node.leadingComments?.length);
        print('__value');
    },
    BooleanLiteral(path, {write}) {
        write(path.node.value);
    },
    StringLiteral,
    RegExpLiteral(path, {print}) {
        const {raw, pattern} = path.node;
        print(raw || `/${pattern}/`);
    },
    NullLiteral(path, {write}) {
        write('null');
    },
    MetaProperty(path, {write}) {
        write('import.meta');
    },
    Super(path, {write}) {
        write('super');
    },
};

var tsTypeLiteral = {};

tsTypeLiteral.TSTypeLiteral = (path, {indent, traverse, write}) => {
    const members = path.get('members');
    write('{');
    
    const is = isNewline(path);
    
    if (is) {
        write.newline();
        indent.inc();
    }
    
    for (const member of members) {
        indent();
        traverse(member);
    }
    
    if (is) {
        indent.dec();
        write.indent();
    }
    
    write('}');
};

function isNewline(path) {
    const members = path.get('members');
    
    if (members.length === 1 && path.parentPath.isTSTypeParameterInstantiation())
        return false;
    
    return members.length && members[0].node.typeAnnotation;
}

var tsTypeAliasDeclaration = {};

const {
    isLast: isLast$2,
    isNext: isNext$8,
    isNextParent: isNextParent$2,
} = is$3;

const {markAfter: markAfter$2} = mark;
const {maybeDeclare: maybeDeclare$3} = maybeDeclare$6;

const isNextType = (a) => a
    .getNextSibling()
    .isTSTypeAliasDeclaration();

const isNextExport = (a) => a
    .getNextSibling()
    .isExportDeclaration();

tsTypeAliasDeclaration.TSTypeAliasDeclaration = {
    beforeIf: (path) => !path.parentPath.isExportDeclaration(),
    before: (path, {indent}) => {
        indent();
    },
    print: maybeDeclare$3((path, {print, maybe, store}) => {
        const typeAnnotation = path.get('typeAnnotation');
        const isConditional = typeAnnotation.isTSConditionalType();
        
        print('type ');
        print('__id');
        print('__typeParameters');
        
        print.space();
        print('=');
        maybe.print.space(!isConditional);
        
        print('__typeAnnotation');
        print(';');
        
        const is = store(isLast$2(path) || isLast$2(path.parentPath));
        maybe.print.newline(!is);
    }),
    afterIf(path, {store}) {
        const last = store();
        
        if (last)
            return false;
        
        if (!isNext$8(path) && !isNextParent$2(path))
            return false;
        
        return !isNextType(path);
    },
    after(path, {print, maybe}) {
        maybe.indent(isNextExport(path));
        print.newline();
        markAfter$2(path);
    },
};

var tsMappedType = {};

const {types: types$u} = bundle;
const {isTSConditionalType} = types$u;

tsMappedType.TSMappedType = (path, {print, indent, maybe}) => {
    const {
        readonly,
        optional,
        nameType,
        typeAnnotation,
    } = path.node;
    
    print('{');
    print.newline();
    indent.inc();
    indent();
    
    if (readonly) {
        maybe.print(readonly === '-', '-');
        print('readonly ');
    }
    
    print('[');
    print('__key');
    print(' ');
    print('in');
    print(' ');
    print('__constraint');
    
    if (nameType) {
        print(' as');
        maybe.space(!isTSConditionalType(nameType));
        print('__nameType');
    }
    
    print(']');
    
    if (optional) {
        maybe.print(optional === '+', '+');
        maybe.print(optional === '-', '-');
        print('?');
    }
    
    if (typeAnnotation) {
        print(':');
        print.space();
        print('__typeAnnotation');
    }
    
    print(';');
    indent.dec();
    print.breakline();
    print('}');
};

var tsConditionalType = {};

tsConditionalType.TSConditionalType = (path, {print, indent}) => {
    indent.inc();
    print.breakline();
    print('__checkType');
    print(' extends ');
    print('__extendsType');
    
    indent.inc();
    print.breakline();
    
    print('? ');
    print('__trueType');
    
    print.breakline();
    
    print(': ');
    print('__falseType');
    
    indent.dec();
    indent.dec();
};

var tsTypeParameter = {};

const {exists} = is$3;

tsTypeParameter.TSTypeParameter = (path, {write, traverse}) => {
    const constraint = path.get('constraint');
    
    if (path.node.in)
        write('in ');
    else if (path.node.out)
        write('out ');
    else if (path.node.const)
        write('const ');
    
    write(path.node.name.name);
    
    if (!exists(constraint))
        return;
    
    write(' extends ');
    
    traverse(constraint);
    
    const defaultPath = path.get('default');
    
    if (exists(defaultPath)) {
        write.space();
        write('=');
        write.space();
        traverse(defaultPath);
    }
};

var tsDeclareFunction = {};

const {printParams: printParams$7} = params;
const {isNext: isNext$7} = is$3;
const {maybeDeclare: maybeDeclare$2} = maybeDeclare$6;

const isInsideDefaultExport = (path) => {
    return path.parentPath.isExportDefaultDeclaration();
};

const isInsideNamedExport = (path) => {
    return path.parentPath.isExportNamedDeclaration();
};

tsDeclareFunction.TSDeclareFunction = {
    beforeIf: (path) => !isInsideNamedExport(path),
    before: (path, {indent}) => {
        indent();
    },
    print: maybeDeclare$2((path, printer, semantics) => {
        const {print} = printer;
        
        print('function ');
        print('__id');
        
        printParams$7(path, printer, semantics);
        
        print(':');
        print.space();
        print('__returnType');
    }),
    afterIf: (path) => !isInsideDefaultExport(path),
    after: (path, {print}) => {
        print(';');
        
        if (isNext$7(path) || isNext$7(path.parentPath) || isInsideNamedExport(path))
            print.newline();
    },
};

var tsDeclareMethod = {};

const {printParams: printParams$6} = params;

tsDeclareMethod.TSDeclareMethod = (path, printer, semantics) => {
    const {print} = printer;
    const {
        accessibility,
        abstract,
        returnType,
    } = path.node;
    
    if (accessibility) {
        print(accessibility);
        print(' ');
    }
    
    if (abstract) {
        print('abstract');
        print(' ');
    }
    
    print('__key');
    
    printParams$6(path, printer, semantics);
    
    if (returnType) {
        print(':');
        print.space();
        print('__returnType');
    }
    
    print(';');
    print.newline();
};

var tsModuleDeclaration = {};

const {isNext: isNext$6} = is$3;
const {maybeDeclare: maybeDeclare$1} = maybeDeclare$6;

tsModuleDeclaration.TSModuleDeclaration = {
    print: maybeDeclare$1((path, {print}) => {
        const {kind} = path.node;
        const id = path.get('id');
        
        if (id.isStringLiteral())
            print('module ');
        else if (kind === 'namespace')
            print('namespace ');
        
        print('__id');
        print.space();
        print('__body');
    }),
    afterSatisfy: () => [isNext$6],
    after(path, {print}) {
        print.newline();
        print.newline();
    },
};

tsModuleDeclaration.TSModuleBlock = (path, {print, traverse, indent}) => {
    print('{');
    print.breakline();
    indent.inc();
    
    for (const child of path.get('body')) {
        traverse(child);
    }
    
    indent.dec();
    print('}');
};

var tsInterfaceDeclaration = {};

const {types: types$t} = bundle;

const {isNext: isNext$5, isNextParent: isNextParent$1} = is$3;
const {maybeDeclare} = maybeDeclare$6;
const {markAfter: markAfter$1} = mark;

const {
    isTSTypeAliasDeclaration,
    isExportNamedDeclaration,
    isTSModuleBlock: isTSModuleBlock$1,
} = types$t;

const isInsideNamespace = (path) => isTSModuleBlock$1(path.parentPath.parentPath);

tsInterfaceDeclaration.TSInterfaceDeclaration = {
    print: maybeDeclare((path, {print, maybe}) => {
        const {node} = path;
        
        maybe.indent(!isExportNamedDeclaration(path.parentPath));
        print('interface ');
        print('__id');
        
        if (node.extends) {
            print(' extends ');
            
            const extendsPaths = path.get('extends');
            const n = extendsPaths.length - 1;
            
            for (const [i, current] of extendsPaths.entries()) {
                print(current);
                maybe.print(i < n, ', ');
            }
        }
        
        print('__typeParameters');
        print('__body');
    }),
    afterSatisfy: () => [isNext$5, isNextParent$1],
    after(path, {print}) {
        print.linebreak();
        const exportNamed = isExportNamedDeclaration(path.parentPath);
        
        if (exportNamed && isInsideNamespace(path))
            markAfter$1(path);
        
        if (!exportNamed && !isTSTypeAliasDeclaration(path))
            print.newline();
    },
};

var tsAsExpression = {};

const {types: types$s} = bundle;
const {maybeParens: maybeParens$4} = maybeParens$e;

const {
    isVariableDeclarator,
    isObjectExpression: isObjectExpression$1,
} = types$s;

tsAsExpression.TSAsExpression = maybeParens$4((path, {print, maybe}) => {
    const is = isParens(path);
    
    maybe.print(is, '(');
    print('__expression');
    maybe.print(is, ')');
    
    print(' as ');
    print('__typeAnnotation');
});

function isParens(path) {
    const {expression} = path.node;
    
    if (isVariableDeclarator(path.parentPath))
        return false;
    
    return isObjectExpression$1(expression);
}

var tsInterfaceBody = {};

const {parseComments: parseComments$1} = comment;

tsInterfaceBody.TSInterfaceBody = (path, printer, semantics) => {
    const body = path.get('body');
    const {
        traverse,
        write,
        indent,
        maybe,
    } = printer;
    
    write.space();
    write('{');
    maybe.write.newline(body.length);
    indent.inc();
    
    parseComments$1(path, printer, semantics);
    
    for (const item of body) {
        indent();
        traverse(item);
    }
    
    indent.dec();
    indent();
    write('}');
    maybe.write.newline(findTSModuleBlock(path));
};

function findTSModuleBlock(path) {
    if (path.parentPath.parentPath.isTSModuleBlock())
        return true;
    
    return path.parentPath.parentPath.parentPath?.isTSModuleBlock();
}

var tsIntersectionType = {};

tsIntersectionType.TSIntersectionType = (path, {traverse, write}) => {
    const types = path.get('types');
    const n = types.length - 1;
    
    for (const [i, type] of types.entries()) {
        const isLast = i === n;
        
        traverse(type);
        
        if (!isLast) {
            write.space();
            write('&');
            write.space();
        }
    }
};

var tsPropertySignature = {};

const {maybePrintTypeAnnotation: maybePrintTypeAnnotation$1} = maybeTypeAnnotation$4;

const {
    hasTrailingComment,
    isNext: isNext$4,
} = is$3;

const {printKey: printKey$1} = printKey$7;

tsPropertySignature.TSPropertySignature = (path, printer) => {
    const {maybe, write} = printer;
    
    const {optional, readonly} = path.node;
    
    maybe.print(readonly, 'readonly ');
    printKey$1(path, printer);
    maybe.print(optional, '?');
    
    maybePrintTypeAnnotation$1(path, printer);
    
    if (!isTSTypeLiteralWithOneMember(path)) {
        write(';');
        write.newline();
    }
    
    if (isNext$4(path) && hasTrailingComment(path))
        write.newline();
};

function isTSTypeLiteralWithOneMember({parentPath}) {
    if (!parentPath.parentPath.isTSTypeParameterInstantiation())
        return false;
    
    return parentPath.node.members.length === 1;
}

var tsFunctionType = {};

var printReturnType$5 = {};

printReturnType$5.hasReturnType = (path) => path.node.returnType;

printReturnType$5.printReturnType = (path, {traverse}) => {
    traverse(path.get('returnType'));
};

const {printParams: printParams$5} = params;
const {printReturnType: printReturnType$4} = printReturnType$5;

const {maybeParens: maybeParens$3} = maybeParens$e;

tsFunctionType.TSFunctionType = maybeParens$3((path, printer, semantics) => {
    const {print} = printer;
    
    printParams$5(path, printer, semantics);
    print.space();
    print('=>');
    print.space();
    printReturnType$4(path, printer);
});

var tsEnumDeclaration = {};

const {
    isNext: isNext$3,
    isNextParent,
    isLast: isLast$1,
} = is$3;

const {markAfter} = mark;

tsEnumDeclaration.TSEnumDeclaration = {
    beforeIf(path) {
        return path.node.const;
    },
    before(path, {print}) {
        print('const ');
    },
    print(path, {print, traverse, indent}) {
        print('enum ');
        print('__id');
        print(' ');
        print('{');
        
        indent.inc();
        print.newline();
        
        for (const member of path.get('body.members')) {
            traverse(member);
            print(',');
            print.newline();
        }
        
        indent.dec();
        indent();
        print('}');
        
        if (isLast$1(path))
            return;
        
        print.newline();
        markAfter(path);
    },
    afterSatisfy: () => [isNext$3, isNextParent],
    after(path, {print}) {
        print.linebreak();
    },
};

var tsEnumMember = {};

tsEnumMember.TSEnumMember = (path, {print, indent}) => {
    const {initializer} = path.node;
    indent();
    print('__id');
    
    if (initializer) {
        print.space();
        print('=');
        print.space();
        print('__initializer');
    }
};

var tsTupleType = {};

tsTupleType.TSTupleType = (path, {write, traverse, indent, maybe}) => {
    const elementTypes = path.get('elementTypes');
    
    write('[');
    indent.inc();
    
    const isSame = isSameType(elementTypes);
    maybe.write.newline(isSame && elementTypes.length);
    const n = elementTypes.length - 1;
    
    for (const [i, elementType] of elementTypes.entries()) {
        maybe.indent(isSame);
        traverse(elementType);
        maybe.write(i < n || isSame, ',');
        maybe.write.newline(isSame);
        maybe.write.space(i < n && !isSame);
    }
    
    indent.dec();
    maybe.indent(isSame && elementTypes.length);
    write(']');
};

function isSameType(array) {
    let type;
    
    for (const current of array) {
        if (type && current.type !== type)
            return false;
        
        ({type} = current);
    }
    
    return true;
}

var tsNamedTupleMember = {};

tsNamedTupleMember.TSNamedTupleMember = (path, {print}) => {
    print('__label');
    print(':');
    print.space();
    print('__elementType');
};

var tsConstructorType = {};

const {printParams: printParams$4} = params;
const {printReturnType: printReturnType$3} = printReturnType$5;

tsConstructorType.TSConstructorType = (path, printer, semantics) => {
    const {print} = printer;
    
    print('new');
    print(' ');
    
    printParams$4(path, printer, semantics);
    print.space();
    print('=>');
    print.space();
    printReturnType$3(path, printer);
};

var tsCallSignatureDeclaration = {};

const {printReturnType: printReturnType$2} = printReturnType$5;
const {printParams: printParams$3} = params;

tsCallSignatureDeclaration.TSCallSignatureDeclaration = (path, printer, semantics) => {
    const {print} = printer;
    printParams$3(path, printer, semantics);
    print(':');
    print.space();
    printReturnType$2(path, printer);
    print(';');
    print.newline();
};

var tsConstructSignatureDeclaration = {};

const {printParams: printParams$2} = params;

const {
    hasReturnType: hasReturnType$1,
    printReturnType: printReturnType$1,
} = printReturnType$5;

tsConstructSignatureDeclaration.TSConstructSignatureDeclaration = (path, printer, semantics) => {
    const {write} = printer;
    
    write('new');
    printParams$2(path, printer, semantics);
    
    if (hasReturnType$1(path)) {
        write(':');
        write.space();
        printReturnType$1(path, printer);
    }
    
    write(';');
    write.newline();
};

var tsMethodSignature = {};

const {printParams: printParams$1} = params;
const {printKind} = kind;
const {
    hasReturnType,
    printReturnType,
} = printReturnType$5;

const {printKey} = printKey$7;

tsMethodSignature.TSMethodSignature = (path, printer, semantics) => {
    const {write} = printer;
    
    printKind(path, printer);
    printKey(path, printer);
    printParams$1(path, printer, semantics);
    
    if (hasReturnType(path)) {
        write(':');
        write.space();
        printReturnType(path, printer);
    }
    
    write(';');
    write.newline();
};

var tsUnionType = {};

const {maybeParens: maybeParens$2} = maybeParens$e;
const insideTypeDeclaration = ({parentPath}) => parentPath.isTSTypeAliasDeclaration();

tsUnionType.TSUnionType = maybeParens$2({
    condition: (path) => {
        return path.parentPath.isTSArrayType();
    },
    print: (path, printer, {maxTypesInOneLine}) => {
        const types = path.get('types');
        const {length} = types;
        
        if (!insideTypeDeclaration(path) || length <= maxTypesInOneLine)
            printInOneLine(types, printer);
        else
            printInCoupleLines(types, printer);
    },
});

function printInOneLine(types, {traverse, write}) {
    const n = types.length - 1;
    
    for (const [i, type] of types.entries()) {
        traverse(type);
        
        if (i < n) {
            write.space();
            write('|');
            write.space();
        }
    }
}

function printInCoupleLines(types, {traverse, write, indent}) {
    indent.inc();
    
    for (const type of types) {
        write.breakline();
        write('|');
        write.space();
        traverse(type);
    }
    
    indent.dec();
}

var tsImportType = {};

const {createImportExpression} = importExpression;

tsImportType.TSImportType = (path, printer, semantics) => {
    createImportExpression(path, printer, semantics, {
        source: 'argument',
    });
};

var tsExportAssignment = {};

const {isNext: isNext$2} = is$3;

tsExportAssignment.TSExportAssignment = {
    print: (path, {print}) => {
        print('export = ');
        print('__expression');
        print(';');
    },
    afterSatisfy: () => [isNext$2],
    after: (path, {print}) => {
        print.newline();
    },
};

var tsTypeReference = {};

tsTypeReference.TSTypeReference = (path, {print}) => {
    print('__typeName');
    print('__typeArguments');
};

var tsInferType = {};

const {maybeParens: maybeParens$1} = maybeParens$e;

tsInferType.TSInferType = maybeParens$1((path, {print}) => {
    print('infer ');
    print('__typeParameter');
});

var tsParameterProperty = {exports: {}};

(function (module) {

	const {hasLeadingComment} = is$3;

	module.exports.TSParameterProperty = (path, {print, maybe, indent}) => {
	    const {
	        decorators,
	        readonly,
	        accessibility,
	    } = path.node;
	    
	    const decoratorsLength = decorators?.length > 1;
	    
	    maybe.print.breakline(decoratorsLength);
	    
	    if (decorators) {
	        for (const decorator of path.get('decorators')) {
	            maybe.indent(decoratorsLength);
	            print(decorator);
	        }
	        
	        maybe.print.breakline(decoratorsLength);
	        
	        if (!hasLeadingComment(path))
	            indent();
	        else
	            print(' ');
	    }
	    
	    if (accessibility) {
	        print(accessibility);
	        print.space();
	    }
	    
	    if (readonly) {
	        print('readonly');
	        print.space();
	    }
	    
	    print('__parameter');
	    
	    if (hasLeadingComment(path) && !path.node.decorators)
	        print.breakline();
	};

	module.exports.TSParameterProperty.printLeadingCommentLine = (path, printer, semantics, {printComment}) => {
	    const {indent, print} = printer;
	    
	    if (path.node.decorators) {
	        printComment();
	        print.breakline();
	        
	        return;
	    }
	    
	    if (path.parentPath.isClassMethod()) {
	        indent.inc();
	        print.breakline();
	        
	        printComment();
	        print.breakline();
	        indent.dec();
	        
	        return;
	    }
	}; 
} (tsParameterProperty));

var tsParameterPropertyExports = tsParameterProperty.exports;
tsParameterPropertyExports.default;

var tsTypeQuery = {};

const {maybeParens} = maybeParens$e;

tsTypeQuery.TSTypeQuery = maybeParens((path, {print}) => {
    print('typeof ');
    print('__exprName');
});

var tsParenthesizedType$2 = {};

tsParenthesizedType$2.TSParenthesizedType = (path, {print}) => {
    print('(');
    print('__typeAnnotation');
    print(')');
};

const {isNext: isNext$1} = is$3;
const {TSTypeLiteral} = tsTypeLiteral;
const {TSTypeAliasDeclaration} = tsTypeAliasDeclaration;
const {TSMappedType} = tsMappedType;
const {TSConditionalType} = tsConditionalType;
const {TSTypeParameter} = tsTypeParameter;
const {TSDeclareFunction} = tsDeclareFunction;
const {TSDeclareMethod} = tsDeclareMethod;

const {
    TSModuleDeclaration,
    TSModuleBlock,
} = tsModuleDeclaration;

const {TSInterfaceDeclaration} = tsInterfaceDeclaration;
const {TSAsExpression} = tsAsExpression;
const {TSInterfaceBody} = tsInterfaceBody;
const {TSIntersectionType} = tsIntersectionType;
const {TSPropertySignature} = tsPropertySignature;
const {TSFunctionType} = tsFunctionType;
const {printParams} = params;
const {TSEnumDeclaration} = tsEnumDeclaration;
const {TSEnumMember} = tsEnumMember;
const {TSTupleType} = tsTupleType;
const {TSNamedTupleMember} = tsNamedTupleMember;
const {TSConstructorType} = tsConstructorType;
const {TSCallSignatureDeclaration} = tsCallSignatureDeclaration;
const {TSConstructSignatureDeclaration} = tsConstructSignatureDeclaration;
const {TSMethodSignature} = tsMethodSignature;
const {TSUnionType} = tsUnionType;

const {maybePrintTypeAnnotation} = maybeTypeAnnotation$4;
const {TSImportType} = tsImportType;
const {TSExportAssignment} = tsExportAssignment;
const {TSTypeReference} = tsTypeReference;
const {TSInferType} = tsInferType;
const {TSParameterProperty} = tsParameterPropertyExports;
const {TSTypeQuery} = tsTypeQuery;
const {TSParenthesizedType} = tsParenthesizedType$2;

var typescript$2 = {
    TSAsExpression,
    TSExportAssignment,
    TSTypeLiteral,
    TSTypeAliasDeclaration,
    TSTypeParameter,
    TSMappedType,
    TSConditionalType,
    TSDeclareFunction,
    TSModuleDeclaration,
    TSModuleBlock,
    TSIntersectionType,
    TSImportType,
    TSUnionType,
    TSTypeQuery,
    TSBigIntKeyword(path, {write}) {
        write('bigint');
    },
    TSNullKeyword(path, {write}) {
        write('null');
    },
    TSSymbolKeyword(path, {write}) {
        write('symbol');
    },
    TSNeverKeyword(path, {write}) {
        write('never');
    },
    TSUnknownKeyword(path, {write}) {
        write('unknown');
    },
    TSObjectKeyword(path, {write}) {
        write('object');
    },
    TSLiteralType(path, {print}) {
        print('__literal');
    },
    TSTupleType,
    TSInferType,
    TSRestType(path, {print}) {
        print('...');
        print('__typeAnnotation');
    },
    TSTypeParameterDeclaration(path, printer, semantics) {
        printParams(path, printer, semantics, {
            braceOpen: '<',
            braceClose: '>',
        });
    },
    TSTypeParameterInstantiation(path, printer, semantics) {
        printParams(path, printer, semantics, {
            braceOpen: '<',
            braceClose: '>',
        });
    },
    TSArrayType(path, {print}) {
        print('__elementType');
        print('[]');
    },
    TSTypeReference,
    TSTypeOperator(path, {write, print}) {
        const {operator} = path.node;
        write(`${operator} `);
        print('__typeAnnotation');
    },
    TSInterfaceDeclaration,
    TSInterfaceBody,
    TSTypeAssertion(path, {print}) {
        print('<');
        print('__typeAnnotation');
        print('>');
        print('__expression');
    },
    TSUndefinedKeyword(path, {write}) {
        write('undefined');
    },
    TSBooleanKeyword(path, {write}) {
        write('boolean');
    },
    TSSatisfiesExpression(path, {print}) {
        print('__expression');
        print(' satisfies ');
        print('__typeAnnotation');
    },
    TSNumberKeyword(path, {write}) {
        write('number');
    },
    TSIndexedAccessType(path, {print}) {
        print('__objectType');
        print('[');
        print('__indexType');
        print(']');
    },
    TSStringKeyword(path, {write}) {
        write('string');
    },
    TSInstantiationExpression(path, {print}) {
        print('__expression');
        print('__typeArguments');
    },
    TSAnyKeyword(path, {write}) {
        write('any');
    },
    TSVoidKeyword(path, {write}) {
        write('void');
    },
    TSQualifiedName(path, {print}) {
        print('__left');
        print('.');
        print('__right');
    },
    TSTypeAnnotation(path, {print}) {
        print('__typeAnnotation');
    },
    TSParameterProperty,
    TSConstructSignatureDeclaration,
    TSIndexSignature(path, printer) {
        const {print} = printer;
        print('[');
        print('__parameters.0');
        print(']');
        maybePrintTypeAnnotation(path, printer);
        print(';');
        print.newline();
    },
    TSClassImplements(path, {print}) {
        print('__expression');
        print('__typeArguments');
    },
    TSInterfaceHeritage(path, {print}) {
        print('__expression');
        print('__typeArguments');
    },
    TSParenthesizedType,
    TSPropertySignature,
    TSFunctionType,
    TSTypePredicate(path, {print}) {
        print('__parameterName');
        print(' is ');
        print('__typeAnnotation');
    },
    TSNonNullExpression(path, {print}) {
        print('__expression');
        print('!');
    },
    TSEnumDeclaration,
    TSEnumMember,
    TSImportEqualsDeclaration(path, {print, maybe}) {
        maybe.print(path.node.isExport, 'export ');
        print('import ');
        print('__id');
        print.space();
        print('=');
        print.space();
        print('__moduleReference');
        print(';');
        maybe.print.newline(isNext$1(path));
    },
    TSExternalModuleReference(path, {print}) {
        print('require(');
        print('__expression');
        print(')');
    },
    TSDeclareMethod,
    TSNamedTupleMember,
    TSConstructorType,
    TSMethodSignature,
    TSCallSignatureDeclaration,
    TSThisType(path, {print}) {
        print('this');
    },
};

var jsxElement = {};

const {types: types$r} = bundle;
const {isJSXElement: isJSXElement$2} = types$r;
const isInsideArrow = ({parentPath}) => parentPath.isArrowFunctionExpression();

jsxElement.JSXElement = {
    condition: condition$1,
    before(path, {write, indent, maybe}) {
        const {leadingComments} = path.node;
        const leadingCommentsCount = leadingComments?.length;
        
        maybe.write.space(!leadingCommentsCount && isInsideArrow(path));
        indent.inc();
        
        if (!leadingCommentsCount) {
            write('(');
            write.newline();
        }
    },
    print(path, {print, traverse, maybe}) {
        const needIndent = isNeedIndent(path);
        maybe.indent.inc(needIndent);
        
        print('__openingElement');
        path.get('children').map(traverse);
        
        print('__closingElement');
        
        maybe.indent.dec(needIndent);
    },
    after(path, {write, indent, maybe}) {
        const {leadingComments} = path.node;
        const isJSX = isJSXElement$2(path.parentPath.parentPath?.parentPath?.parentPath);
        
        if (isJSX) {
            write.breakline();
            indent.dec();
        } else {
            indent.dec();
            write.breakline();
        }
        
        maybe.write(!leadingComments?.length, ')');
    },
};

function condition$1(path) {
    if (path.parentPath.isReturnStatement())
        return true;
    
    if (path.parentPath.isParenthesizedExpression())
        return true;
    
    if (path.node.extra?.parenthesized)
        return true;
    
    if (path.parentPath.isArrowFunctionExpression())
        return true;
    
    return path.parentPath.isVariableDeclarator();
}

function isNeedIndent(path) {
    const attributesCount = path.node.openingElement.attributes.length;
    
    if (attributesCount > 2)
        return false;
    
    const insideFn = path.parentPath.isArrowFunctionExpression();
    const insideJSX = path.parentPath.isJSXElement();
    const insideCall = path.parentPath.parentPath.isCallExpression();
    
    return insideJSX || insideFn && insideCall;
}

var jsxAttribute = {};

const {isCoupleLines: isCoupleLines$2} = is$3;

jsxAttribute.JSXAttribute = {
    condition(path) {
        return isCoupleLines$2(path.parentPath);
    },
    before(path, {print, indent}) {
        indent.inc();
        print.breakline();
    },
    print(path, {print, maybe}) {
        const {value} = path.node;
        
        print('__name');
        maybe.print(value, '=');
        print('__value');
    },
    after(path, {indent}) {
        indent.dec();
    },
};

var jsxOpeningElement = {};

const {isCoupleLines: isCoupleLines$1} = is$3;

const isNotJSX = ({parentPath}) => {
    const grandPath = parentPath.parentPath;
    
    if (grandPath.isObjectProperty())
        return false;
    
    if (grandPath.isCallExpression())
        return false;
    
    if (grandPath.isJSXElement())
        return false;
    
    if (grandPath.isJSXExpressionContainer())
        return false;
    
    if (grandPath.isJSXFragment())
        return false;
    
    return !grandPath.isLogicalExpression();
};

jsxOpeningElement.JSXOpeningElement = {
    print(path, {print, maybe}) {
        maybe.indent(isNotJSX(path));
        print('<');
        print('__name');
        
        const coupleLines = isCoupleLines$1(path);
        const noCoupleLines = !coupleLines;
        const shouldIndent = coupleLines && path.parentPath.parentPath.isJSXElement();
        
        maybe.indent.inc(shouldIndent);
        
        for (const attr of path.get('attributes')) {
            maybe.print.space(noCoupleLines);
            print(attr);
        }
        
        if (isCoupleLines$1(path))
            print.breakline();
        
        if (path.node.selfClosing)
            print('/');
        
        print('>');
        maybe.indent.dec(shouldIndent);
    },
};

var jsxFragment = {};

jsxFragment.JSXFragment = {
    condition,
    before(path, {write, indent}) {
        write('(');
        indent.inc();
        write.breakline();
    },
    print(path, {print, traverse}) {
        print('__openingFragment');
        path.get('children').map(traverse);
        print('__closingFragment');
    },
    after(path, {write, indent}) {
        indent.dec();
        write.breakline();
        write(')');
    },
};

jsxFragment.JSXOpeningFragment = (path, {write}) => {
    write('<>');
};

jsxFragment.JSXClosingFragment = (path, {write}) => {
    write('</>');
};

function condition(path) {
    if (path.parentPath.isReturnStatement())
        return true;
    
    return path.parentPath.isVariableDeclarator();
}

var jsxText = {};

const {isNext} = is$3;

jsxText.JSXText = (path, {write, indent}) => {
    const {node} = path;
    const {value, extra} = node;
    const isSpacesOnly = /^\s+$/.test(value);
    const hasNext = isNext(path);
    
    if (extra?.raw.includes('&'))
        return write(extra.raw);
    
    if (isSpacesOnly && hasNext) {
        indent.inc();
        write.breakline();
        indent.dec();
        
        return;
    }
    
    if (isSpacesOnly) {
        write.breakline();
        return;
    }
    
    write(value);
};

const {JSXElement} = jsxElement;
const {JSXAttribute} = jsxAttribute;
const {isCoupleLines} = is$3;
const {JSXOpeningElement} = jsxOpeningElement;
const fragments = jsxFragment;
const {JSXText} = jsxText;
const {parseComments} = comment;

var jsx$2 = {
    ...fragments,
    JSXElement,
    JSXAttribute,
    JSXOpeningElement,
    JSXText,
    JSXEmptyExpression(path, operations, semantics) {
        parseComments(path, operations, semantics);
    },
    JSXExpressionContainer(path, {print}) {
        print('{');
        print('__expression');
        print('}');
    },
    JSXIdentifier(path, {write}) {
        write(path.node.name);
    },
    JSXMemberExpression(path, {print}) {
        print('__object');
        print('.');
        print('__property');
    },
    JSXSpreadAttribute(path, {print, maybe}) {
        const isNewline = isCoupleLines(path.parentPath);
        maybe.indent.inc(isNewline);
        maybe.print.breakline(isNewline);
        print('{');
        print('...');
        print('__argument');
        print('}');
        maybe.indent.dec(isNewline);
    },
    JSXClosingElement(path, {print}) {
        print('</');
        print('__name');
        print('>');
    },
};

const expressions$1 = expressions$2;
const statements$1 = statements$2;
const literals = literals$1;
const typescript$1 = typescript$2;
const jsx$1 = jsx$2;

var visitors$1 = {
    ...expressions$1,
    ...statements$1,
    ...literals,
    ...typescript$1,
    ...jsx$1,
};

visitors$1.default;

var maybe = {};

const isString$c = (a) => typeof a === 'string';
const constant = (a) => () => a;
const {keys: keys$3} = Object;

var rendy$1 = (template, values, modifiers) => {
    check$h(template, values);
    
    let result = template;
    
    const names = !modifiers ? keys$3(values) : template.match(/{{(.*?)}}/g);
    
    for (const key of names) {
        const [parsedKey, value] = parseValue$1(key, values, modifiers);
        const str = constant(value);
        
        while (result.includes(parsedKey))
            result = result.replace(parsedKey, str);
    }
    
    if (result.includes('{{'))
        result = result.replace(/{{.*?}}/g, '');
    
    return result;
};

function check$h(template, values) {
    if (!isString$c(template))
        throw Error('template should be a string!');
    
    if (typeof values !== 'object')
        throw Error('values should be an object!');
}

function parseValue$1(key, values, modifiers) {
    if (!modifiers)
        return [
            `{{ ${key} }}`,
            values[key],
        ];
    
    const preparedKey = key
        .replaceAll('{{', '')
        .replaceAll('}}', '')
        .replaceAll(' ', '');
    
    const value = values[preparedKey] || '';
    
    if (!preparedKey.includes('|'))
        return [key, value];
    
    const [name, modifierName] = preparedKey.split('|');
    const fn = modifiers[modifierName];
    const currentValue = values[name];
    
    if (!fn)
        return [key, currentValue];
    
    return [key, fn(currentValue)];
}

const {satisfy} = is$3;

var satisfy_1 = (plugin) => {
    if (!plugin.afterSatisfy && !plugin.beforeSatisfy && !plugin.satisfy)
        return plugin;
    
    const {
        satisfy,
        afterSatisfy = satisfy,
        beforeSatisfy = satisfy,
    } = plugin;
    
    return {
        afterIf: createIf(afterSatisfy),
        beforeIf: createIf(beforeSatisfy),
        ...plugin,
    };
};

const createIf = (getConditions) => {
    const conditions = getConditions?.() || [];
    return satisfy(conditions);
};

const rendy = rendy$1;

const {types: types$q} = bundle;
const maybeSatisfy = satisfy_1;

const {
    isProgram: isProgram$3,
    isFile: isFile$1,
    isStatement: isStatement$2,
    expressionStatement,
    program,
    file,
} = types$q;

const isFn$5 = (a) => typeof a === 'function';

maybe.maybeThrow = (a, path, b) => {
    if (!a)
        return;
    
    throw Error(rendy(b, {
        path,
        type: path.type,
    }));
};

const maybeStatement = (ast) => isStatement$2(ast) ? ast : expressionStatement(ast);

const maybeProgram = (ast) => isProgram$3(ast) ? ast : program([
    maybeStatement(ast),
]);

maybe.maybeFile = (ast) => isFile$1(ast) ? ast : file(maybeProgram(ast));

maybe.maybeVisitor = (plugin, path, printer, options) => {
    if (isFn$5(plugin))
        return plugin(path, printer, options);
    
    return objectPlugin(plugin, path, printer, options);
};

function objectPlugin(plugin, path, printer, semantics) {
    const {
        print,
        split,
        condition,
        before = split,
        beforeIf = condition,
        after = split,
        afterIf = condition,
    } = maybeSatisfy(plugin);
    
    if (beforeIf?.(path, printer, semantics))
        before(path, printer, semantics);
    
    print(path, printer, semantics);
    
    if (afterIf?.(path, printer, semantics))
        after(path, printer, semantics);
}

var debug$7 = {};

var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_process);

var justSnakeCase = snakeCase;

/*
  snakeCase('the quick brown fox'); // 'the_quick_brown_fox'
  snakeCase('the-quick-brown-fox'); // 'the_quick_brown_fox'
  snakeCase('the_quick_brown_fox'); // 'the_quick_brown_fox'
  snakeCase('theQuickBrownFox'); // 'the_quick_brown_fox'
  snakeCase('theQuickBrown Fox'); // 'the_quick_brown_Fox'
  snakeCase('thequickbrownfox'); // 'thequickbrownfox'
  snakeCase('the - quick * brown# fox'); // 'the_quick_brown_fox'
  snakeCase('theQUICKBrownFox'); // 'the_q_u_i_c_k_brown_fox'
*/

// any combination of spaces and punctuation characters
// thanks to http://stackoverflow.com/a/25575009
var wordSeparators = /[\s\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,\-.\/:;<=>?@\[\]^_`{|}~]+/;
var capitals = /[A-Z\u00C0-\u00D6\u00D9-\u00DD]/g;

function snakeCase(str) {
  //replace capitals with space + lower case equivalent for later parsing
  str = str.replace(capitals, function(match) {
    return ' ' + (match.toLowerCase() || match);
  });
  return str
    .trim()
    .split(wordSeparators)
    .join('_');
}

const process$1 = require$$0$2;
const toSnakeCase = justSnakeCase;
const {codeFrameColumns: codeFrameColumns$1} = bundle;
const {TYPES: TYPES$2} = types$17;

const {stringify: stringify$7} = JSON;
const {
    LOG,
    LOG_ALL,
    LOG_TOKENS,
    LOG_TERM,
    LOG_DEBUG,
} = {};

debug$7.createDebug = (tokens) => (a) => {
    if (!LOG_DEBUG)
        return;
    
    tokens.push({
        type: TYPES$2.DEBUG,
        value: `/*__${toSnakeCase(a)}*/`,
    });
};

debug$7.createLog = ({newline = '\n', store = createStore$1()} = {}) => ({type, value}) => {
    if (LOG_TOKENS) {
        console.log(codeFrameColumns$1(stringify$7({
            type,
            value,
        }), {}, {
            highlightCode: true,
        }));
        
        return;
    }
    
    if (LOG_ALL) {
        console.log(codeFrameColumns$1(value, {}, {
            highlightCode: true,
        }));
        
        return;
    }
    
    if (LOG) {
        if (value === newline) {
            console.log(codeFrameColumns$1(store(), {}, {
                highlightCode: true,
            }));
            
            return;
        }
        
        store(value);
    }
    
    if (LOG_TERM)
        process$1.stdout.write(value);
};

function createStore$1() {
    let chunks = [];
    
    return (...args) => {
        const [chunk] = args;
        
        if (args.length) {
            chunks.push(chunk);
            return;
        }
        
        const result = chunks.join('');
        
        chunks = [];
        
        return result;
    };
}

var overrides = {};

var parseRoundBraces$1 = {};

const isObject$7 = (a) => a && typeof a === 'object';
const isBool$4 = (a) => typeof a === 'boolean';

const ROUND_BRACES_DEFAULTS = {
    arrow: true,
    sequence: true,
    assign: false,
    new: true,
};

const ROUND_BRACES_ENABLED = {
    arrow: true,
    sequence: true,
    assign: true,
    new: true,
};

const ROUND_BRACES_DISABLED = {
    arrow: false,
    sequence: false,
    assign: false,
    new: false,
};

parseRoundBraces$1.parseRoundBraces = ({roundBraces}) => {
    if (isObject$7(roundBraces))
        return {
            ...ROUND_BRACES_DEFAULTS,
            ...roundBraces,
        };
    
    if (isBool$4(roundBraces) && roundBraces)
        return ROUND_BRACES_ENABLED;
    
    if (isBool$4(roundBraces) && !roundBraces)
        return ROUND_BRACES_DISABLED;
    
    return ROUND_BRACES_DEFAULTS;
};

parseRoundBraces$1.ROUND_BRACES_DISABLED = ROUND_BRACES_DISABLED;
parseRoundBraces$1.ROUND_BRACES_ENABLED = ROUND_BRACES_ENABLED;
parseRoundBraces$1.ROUND_BRACES_DEFAULTS = ROUND_BRACES_DEFAULTS;

var parseQuotes$1 = {};

parseQuotes$1.parseQuotes = ({quote}) => {
    if (quote === '"')
        return {
            escapeSingleQuote: false,
            escapeDoubleQuote: true,
        };
    
    return {
        escapeSingleQuote: true,
        escapeDoubleQuote: false,
    };
};

const {parseRoundBraces} = parseRoundBraces$1;
const {parseQuotes} = parseQuotes$1;

overrides.parseOverrides = (overrides = {}) => {
    const {
        format,
        semantics,
        visitors,
    } = overrides;
    
    const initiatedFormat = initFormat(format);
    
    return {
        format: initiatedFormat,
        semantics: initSemantics(initiatedFormat, semantics),
        visitors,
    };
};

const initFormat = (format) => ({
    indent: '    ',
    newline: '\n',
    space: ' ',
    splitter: '\n',
    quote: `'`,
    endOfFile: '\n',
    ...format,
});

const initSemantics = (format, semantics = {}) => ({
    comments: true,
    maxPropertiesInOneLine: 2,
    maxPropertiesLengthInOneLine: 15,
    maxSpecifiersInOneLine: 2,
    maxElementsInOneLine: 5,
    maxElementLengthInOneLine: 10,
    maxLogicalsInOneLine: 3,
    maxVariablesInOneLine: 4,
    maxTypesInOneLine: 3,
    trailingComma: true,
    ...parseQuotes(format),
    ...semantics,
    roundBraces: parseRoundBraces(semantics),
});

const fullstore$2 = fullstore$3;

const babelTraverse$2 = bundle.traverse;
const {TYPES: TYPES$1} = types$17;
const baseVisitors = visitors$1;

const {
    maybeFile,
    maybeVisitor: maybeVisitor$1,
    maybeThrow,
} = maybe;

const {createDebug: createDebug$3, createLog} = debug$7;
const {maybeMarkAfter} = mark;

const {
    parseLeadingComments,
    parseTrailingComments,
} = comment;

const {parseOverrides} = overrides;
const isObject$6 = (a) => a && typeof a === 'object';
const {round} = Math;
const isString$b = (a) => typeof a === 'string';
const {assign: assign$9, freeze} = Object;

const GET = '__';
const get = (path, command) => path.get(command.replace(GET, ''));

const createAddToken = (tokens) => {
    const log = createLog();
    
    return (token) => {
        log(token);
        tokens.push(token);
    };
};

tokenize$1.tokenize = (ast, overrides) => {
    const {
        visitors,
        format,
        semantics,
    } = parseOverrides(overrides);
    
    const tokens = [];
    const addToken = createAddToken(tokens);
    const debug = createDebug$3(tokens);
    
    const write = (value) => {
        addToken({
            type: TYPES$1.TOKEN,
            value,
        });
    };
    
    const indent = () => {
        addToken({
            type: TYPES$1.INDENT,
            value: printIndent(i, format.indent),
        });
    };
    
    const maybeIndent = (a) => a && indent();
    
    const maybeIndentInc = (a) => a && indent.inc();
    
    const maybeIndentDec = (a) => a && indent.dec();
    
    const newline = () => {
        addToken({
            type: TYPES$1.NEWLINE,
            value: format.newline,
        });
    };
    
    const maybeNewline = (a) => a && newline();
    
    const breakline = () => {
        newline();
        indent();
    };
    
    const maybeBreakline = (a) => a && breakline();
    
    const linebreak = () => {
        indent();
        newline();
    };
    
    const maybeLinebreak = (a) => a && linebreak();
    const maybeWrite = (a, b) => a && write(b);
    
    const space = () => {
        addToken({
            type: TYPES$1.SPACE,
            value: format.space,
        });
    };
    
    const maybeSpace = (a) => a && space();
    let i = 0;
    const incIndent = () => ++i;
    const decIndent = () => --i;
    
    assign$9(indent, {
        inc: incIndent,
        dec: decIndent,
    });
    
    const splitter = () => {
        addToken({
            type: TYPES$1.SPLITTER,
            value: format.splitter,
        });
    };
    
    const quote = () => {
        addToken({
            type: TYPES$1.QUOTE,
            value: format.quote,
        });
    };
    
    const endOfFile = () => {
        addToken({
            type: TYPES$1.END_OF_FILE,
            value: format.endOfFile,
        });
    };
    
    assign$9(write, {
        indent,
        newline,
        linebreak,
        breakline,
        space,
        splitter,
        quote,
        endOfFile,
    });
    
    assign$9(maybeWrite, {
        newline: maybeNewline,
        breakline: maybeBreakline,
        linebreak: maybeLinebreak,
        space: maybeSpace,
    });
    
    const maybe = {
        indent: maybeIndent,
        markAfter: maybeMarkAfter,
        write: maybeWrite,
        space: maybeSpace,
    };
    
    assign$9(maybe.indent, {
        inc: maybeIndentInc,
        dec: maybeIndentDec,
    });
    
    // should never change to avoid unexpected errors related to printing path, since it hard to debug
    const mainPrinter = freeze({
        indent,
        write,
        debug,
        traverse,
        maybe,
        quote,
        store: fullstore$2(),
    });
    
    const currentTraversers = {
        ...baseVisitors,
        ...visitors,
    };
    
    if (ast.parentPath)
        pathTraverse(ast, traverse);
    else
        babelTraverse$2(maybeFile(ast), {
            Program(path) {
                traverse(path);
                path.stop();
            },
        });
    
    function traverse(path) {
        const {type} = path;
        const currentTraverse = currentTraversers[type];
        
        if (!path.node)
            return;
        
        const print = createPrint(path, {
            write,
            traverse,
        });
        
        assign$9(print, write, {
            space,
            round,
        });
        
        const printer = {
            ...mainPrinter,
            print,
        };
        
        const maybePrint = (a, b) => a && print(b);
        
        assign$9(maybePrint, {
            newline: maybeNewline,
            breakline: maybeBreakline,
            linebreak: maybeLinebreak,
            space: maybeSpace,
        });
        
        assign$9(printer.maybe, {
            print: maybePrint,
        });
        
        maybeThrow(!currentTraverse, path, `☝️ Node type '{{ type }}' is not supported yet by @putout/printer: '{{ path }}'`);
        
        const currentIndent = i;
        parseLeadingComments(path, printer, semantics, {
            currentTraverse,
        });
        
        // this is main thing
        maybeVisitor$1(currentTraverse, path, printer, semantics);
        parseTrailingComments(path, printer, semantics, {
            currentTraverse,
        });
        maybeThrow(i !== currentIndent, path, `☝️Looks like indent level changed after token visitor: '{{ type }}', for code: '{{ path }}'`);
        
        debug(path.type);
    }
    
    return tokens;
};

function printIndent(i, indent) {
    let result = '';
    ++i;
    
    while (--i > 0) {
        result += indent;
    }
    
    return result;
}

const createPrint = (path, {traverse, write}) => (maybeLine) => {
    if (maybeLine === path)
        return null;
    
    const computed = computePath(path, maybeLine);
    
    if (isObject$6(computed))
        return traverse(computed);
    
    return write(computed);
};

const computePath = (path, maybeLine) => {
    if (isString$b(maybeLine) && maybeLine.startsWith(GET))
        return get(path, maybeLine);
    
    if (isObject$6(maybeLine))
        return maybeLine;
    
    return maybeLine;
};

function pathTraverse(ast, traverse) {
    ast.parentPath.traverse({
        enter(path) {
            if (path === ast) {
                traverse(path);
                path.stop();
            }
        },
    });
}

var printTokens$1 = {};

var cook$1 = {};

cook$1.cook = (tokens) => {
    const cookedTokens = [];
    
    for (const {value} of tokens) {
        cookedTokens.push(value);
    }
    
    return cookedTokens;
};

const {cook} = cook$1;

printTokens$1.printTokens = (tokens) => {
    const cookedTokens = cook(tokens);
    return cookedTokens.join('');
};

var json$1 = {};

var json = {};

/**
 * Variable with regex to validate blank lines
 * @name removeBlankLines
 * @var
 * @returns {Regex}
 */

var blankLines = new RegExp(/(^[ \t]*\n)/, "gm");

/**
 * removeBlankLines
 * Remove blank lines from a string.
 *
 * @name removeBlankLines
 * @function
 * @param {String} input The input string.
 * @returns {String} The result string (without blank lines).
 */
var removeBlankLines$1 = function removeBlankLines(input) {
  return input.replace(blankLines, "");
};

var lib$2 = removeBlankLines$1;

const removeBlankLines = lib$2;

const cut$1 = (a) => a.slice(0, a.indexOf('('));
const createPrefix = (name) => {
    if (name.includes('('))
        return `${cut$1(name)}(`;
    
    return `${name}(`;
};

const createSuffix = () => ');\n';
const maybeNewline = (a) => a.at(-1) === '\n' ? a : `${a}\n`;

const __json_name = '__putout_processor_json';
const __yaml_name = '__putout_processor_yaml';
const __filesystem_name$3 = '__putout_processor_filesystem';
const __ignore_name = '__putout_processor_ignore';

const __json = `${__json_name}(__object)`;
const __yaml = `${__yaml_name}(__object)`;
const __filesystem = `${__filesystem_name$3}(__object)`;
const __ignore = `${__ignore_name}(__array)`;

const TYPES = [
    __json_name,
    __yaml_name,
    __filesystem_name$3,
    __ignore_name,
];

json.__json = __json;
json.__yaml = __yaml;
json.__filesystem = __filesystem;
json.__ignore = __ignore;

json.__json_name = __json_name;
json.__yaml_name = __yaml_name;
json.__filesystem_name = __filesystem_name$3;
json.__ignore_name = __ignore_name;

json.toJS = (source, name = __json) => {
    const prefix = createPrefix(name);
    const suffix = createSuffix();
    
    return `${prefix}${source}${suffix}`;
};

json.fromJS = (source, name = __json) => {
    source = maybeNewline(source);
    const shortName = cut$1(name);
    
    source = source.slice(source.indexOf(shortName));
    
    const prefix = createPrefix(name);
    const suffix = createSuffix();
    const length = source.length - suffix.length;
    const sliced = source.slice(prefix.length, length);
    
    return maybeNewline(removeBlankLines(sliced));
};

json.isJSON = (source) => {
    for (const type of TYPES) {
        if (!source.indexOf(type))
            return true;
    }
    
    return false;
};

const {types: types$p} = bundle;
const {isJSON} = json;

const {
    isCallExpression: isCallExpression$1,
    isIdentifier: isIdentifier$5,
} = types$p;

json$1.maybeJSON = (ast, overrides) => {
    if (isASTJSON(ast))
        return {
            ...overrides,
            format: {
                ...overrides?.format,
                quote: `"`,
            },
            semantics: {
                ...overrides?.semantics,
                trailingComma: false,
                escapeSingleQuote: false,
                escapeDoubleQuote: true,
            },
        };
    
    return overrides;
};

function isASTJSON(ast) {
    const {program} = ast;
    
    if (!program)
        return false;
    
    const {body} = ast.program;
    
    if (!body.length)
        return false;
    
    const {expression} = ast.program.body[0];
    
    if (!isCallExpression$1(expression))
        return false;
    
    const {callee} = expression;
    
    if (!isIdentifier$5(callee))
        return false;
    
    return isJSON(callee.name);
}

const {tokenize} = tokenize$1;
const {printTokens} = printTokens$1;
const {maybeJSON} = json$1;

const {maybeVisitor} = maybe;
const visitors = visitors$1;

printer.print = (ast, overrides = {}) => {
    check$g(ast);
    
    const options = maybeJSON(ast, overrides);
    const tokens = tokenize(ast, options);
    
    return printTokens(tokens);
};

printer.visitors = visitors;
printer.maybeVisitor = maybeVisitor;

function check$g(ast) {
    if (typeof ast !== 'object')
        throw Error('☝️Looks like ast not an object');
}

var babel$2 = {};

const isString$a = (a) => typeof a === 'string';

var alignSpaces = (str) => {
    check$f(str);
    
    const array = str.split('\n');
    const n = array.length - 1;
    
    for (let i = 0; i < n; i++) {
        const str = array[i];
        
        if (!i || isNotSpaceString(str))
            continue;
        
        array[i] = getSpaces(array[i + 1]);
    }
    
    return array.join('\n');
};

function isNotSpaceString(s) {
    let i = s.length;
    
    if (!i)
        return false;
    
    while (--i > -1) {
        if (s[i] !== ' ')
            return true;
    }
    
    return false;
}

function getSpaces(s) {
    let spaces = '';
    
    for (let i = 0; i < s.length; i++) {
        if (s[i] !== ' ')
            return spaces;
        
        spaces += ' ';
    }
    
    return spaces;
}

function check$f(str) {
    if (!isString$a(str))
        throw Error('str should be a string!');
}

const {generate: generate$5} = bundle;
const align = alignSpaces;

const defaultOptions$6 = {
    alignSpaces: true,
};

babel$2.print = (ast, options) => {
    const {source, alignSpaces} = {
        ...defaultOptions$6,
        ...options,
    };
    
    let {code} = generate$5(ast, {
        ...source && {
            experimental_preserveFormat: true,
            retainLines: true,
        },
    }, source);
    
    if (code[0] === '\n')
        code = code.trimStart();
    
    code += '\n';
    
    if (!alignSpaces)
        return code;
    
    return align(code);
};

const putoutPrinter = printer;
const babelPrinter = babel$2;

const {isArray: isArray$d} = Array;

const maybeArray$7 = (a) => isArray$d(a) ? a : [a, {}];

var print$4 = (ast, options = {}) => {
    const [printer = 'putout', printerOptions] = maybeArray$7(options.printer);
    
    if (printer === 'babel')
        return babelPrinter.print(ast, {
            ...options,
            ...printerOptions,
        });
    
    return putoutPrinter.print(ast, printerOptions);
};

print$4.default;

var estreeToBabel$1 = {};

const {types: types$o} = bundle;
const {
    isFunctionExpression,
    objectMethod,
} = types$o;

const {assign: assign$8} = Object;

var traverseObjectExpression$1 = (propertiesPaths) => {
    for (const propPath of propertiesPaths) {
        const {
            computed,
            key,
            method,
            value,
        } = propPath.node;
        
        if (method && isFunctionExpression(value)) {
            propPath.replaceWith(objectMethod('method', key, value.params, value.body, computed));
            
            assign$8(propPath.node, {
                id: null,
                method: true,
                generator: value.generator,
                loc: getObjectMethodLoc(key, value),
                async: value.async,
                type: 'ObjectMethod',
            });
        }
    }
};

function getObjectMethodLoc(key, value) {
    if (key.loc && value.loc)
        return {
            start: key.loc.start,
            end: value.loc.end,
        };
    
    return null;
}

const {types: types$n} = bundle;
const {
    classPrivateMethod,
    classMethod,
    privateName,
    identifier: identifier$1,
} = types$n;

const {assign: assign$7} = Object;

var setClassMethod$1 = (path) => {
    const {node} = path;
    const {
        key,
        kind,
        computed,
        loc,
    } = node;
    
    const {
        body,
        params,
        expression,
        generator,
    } = node.value;
    
    const method = getClassMethod({
        kind,
        key,
        params,
        body,
        computed,
        nodeStatic: node.static,
    });
    
    path.replaceWith(method);
    assign$7(path.node, {
        loc,
        expression,
        generator,
    });
};

const isPrivateIdentifier = ({type}) => type === 'PrivateIdentifier';

function getClassMethod({kind, key, params, body, computed, nodeStatic}) {
    if (isPrivateIdentifier(key)) {
        const newKey = convertPrivateIdentifier$1(key);
        return classPrivateMethod(kind, newKey, params, body, computed);
    }
    
    return classMethod(kind, key, params, body, computed, nodeStatic);
}

function convertPrivateIdentifier$1(node) {
    return privateName(identifier$1(node.name));
}

var setClassPrivateProperty$1 = (path) => {
    path.node.type = 'ClassPrivateProperty';
};

const {types: types$m} = bundle;
const {identifier} = types$m;

// acorn stores name in PrivateName.name
// babel stores name in PrivateName.id.name
var setClassPrivateName$1 = ({node}) => {
    if (!node.name)
        return;
    
    node.id = identifier(node.name);
    node.id.loc = {
        start: {
            line: node.loc.start.line,
            column: node.loc.start.column + 1,
        },
        end: node.loc.end,
    };
    delete node.name;
};

const {types: types$l} = bundle;
const {
    directive,
    directiveLiteral,
} = types$l;

var setDirectives$1 = (path) => {
    const {node} = path;
    
    if (node.directives)
        return;
    
    node.directives = [];
    for (const statementPath of path.get('body')) {
        if (statementPath.type !== 'ExpressionStatement')
            continue;
        
        const statement = statementPath.node;
        
        if (!('directive' in statement))
            continue;
        
        if (!statement.directive)
            continue;
        
        const literal = directiveLiteral(statement.directive);
        const currentDirective = directive(literal);
        
        node.directives.push(currentDirective);
        statementPath.remove();
    }
};

var convertChainExpression$1 = (path) => {
    const expressionPath = path.get('expression');
    const {expression} = path.node;
    
    if (expressionPath.isCallExpression()) {
        const calleePath = expressionPath.get('callee');
        
        expression.type = 'OptionalCallExpression';
        
        if (calleePath.isMemberExpression())
            expression.callee.type = 'OptionalMemberExpression';
    } else {
        expression.type = 'OptionalMemberExpression';
    }
    
    path.replaceWith(expression);
};

var convertImportDeclaration$1 = (path) => {
    const {attributes = []} = path.node;
    path.node.attributes = attributes;
};

const {assign: assign$6} = Object;

var convertExportDeclaration$1 = (path) => {
    const {attributes = []} = path.node;
    
    assign$6(path.node, {
        attributes,
    });
};

var parenthesizedExpression$1 = {};

parenthesizedExpression$1.convertParenthesizedExpression = ({convertParens}) => (path) => {
    if (!convertParens)
        return;
    
    const {expression} = path.node;
    
    expression.extra = expression.extra || {};
    expression.extra.parenthesized = true;
    
    path.replaceWith(expression);
};

var tsParenthesizedType$1 = {};

tsParenthesizedType$1.convertTSParenthesizedType = ({convertParens}) => (path) => {
    if (!convertParens)
        return;
    
    const {typeAnnotation} = path.node;
    
    typeAnnotation.extra = typeAnnotation.extra || {};
    typeAnnotation.extra.parenthesized = true;
    
    path.replaceWith(typeAnnotation);
};

var comments = {};

comments.convertNodeComments = (node) => {
    const {comments} = node;
    
    if (!comments)
        return;
    
    delete node.comments;
    node.leadingComments = undefined;
    node.trailingComments = undefined;
    node.innerComments = undefined;
    
    for (const comment of comments) {
        const group = getCommentGroup(comment);
        
        if (!node[group])
            node[group] = [];
        
        delete comment.leading;
        delete comment.trailing;
        comment.type = getCommentType(comment);
        node[group].push(comment);
    }
};

comments.convertProgramComments = (comments) => {
    for (const comment of comments) {
        comment.type = getCommentType(comment);
    }
    
    return comments;
};

const getCommentType = ({type}) => `Comment${type}`;

function getCommentGroup({trailing, leading}) {
    if (trailing)
        return 'trailingComments';
    
    if (leading)
        return 'leadingComments';
    
    return 'innerComments'; // Dangling comments, such as `[/* a */]`.
}

const isString$9 = (a) => typeof a === 'string';
const isNumber$2 = (a) => typeof a === 'number';
const isNull = (a) => a === null;
const isBool$3 = (a) => typeof a === 'boolean';

var setLiteral$1 = (node) => {
    const {type, value} = node;
    
    if (type !== 'Literal')
        return;
    
    if (isNull(value)) {
        node.type = 'NullLiteral';
        return;
    }
    
    if (isString$9(value)) {
        node.type = 'StringLiteral';
        return;
    }
    
    if (isNumber$2(value)) {
        node.type = 'NumericLiteral';
        return;
    }
    
    if (isBool$3(value)) {
        node.type = 'BooleanLiteral';
        return;
    }
    
    if (node.regex) {
        transformRegExp$1(node);
        return;
    }
};

function transformRegExp$1(node) {
    node.type = 'RegExpLiteral';
    
    for (const key of Object.keys(node.regex)) {
        node[key] = node.regex[key];
    }
    
    delete node.regex;
}

const {convertProgramComments} = comments;

var getAst = (node) => {
    if (node.type === 'File')
        return node;
    
    const {
        comments = [],
        tokens,
        ...program
    } = node;
    
    const ast = {
        type: 'File',
        program: {
            ...program,
            directives: [],
        },
        comments: convertProgramComments(comments),
        tokens,
    };
    
    return ast;
};

var ts = {};

ts.convertPropertyDefinition = (path) => {
    const {node} = path;
    
    if (node.key.type === 'PrivateIdentifier') {
        const {key} = node;
        
        node.type = 'ClassPrivateProperty';
        node.key = createPrivateName(key);
        
        return;
    }
    
    path.node.type = 'ClassProperty';
};

ts.convertTSInterfaceHeritage = (path) => {
    let {expression} = path.node;
    
    while (expression.type === 'MemberExpression') {
        const {object, property} = expression;
        
        expression.type = 'TSQualifiedName';
        expression.left = object;
        expression.right = property;
        
        delete expression.object;
        delete expression.property;
        
        expression = object;
    }
};

ts.convertPrivateIdentifier = (path) => {
    path.replaceWith(createPrivateName(path.node));
};

ts.convertTSAbstractMethodDefinition = (path) => {
    const {node} = path;
    
    const {
        generator,
        async,
        params,
        id,
        returnType,
    } = node.value;
    
    const newNode = {
        ...node,
        abstract: true,
        generator,
        async,
        params,
        id,
        returnType,
        type: 'TSDeclareMethod',
    };
    
    delete newNode.value;
    
    path.replaceWith(newNode);
};

const createPrivateName = (node) => ({
    type: 'PrivateName',
    id: {
        ...node,
        type: 'Identifier',
    },
    loc: node.loc,
});

const {traverse: traverse$8, types: types$k} = bundle;
const traverseObjectExpression = traverseObjectExpression$1;
const setClassMethod = setClassMethod$1;
const setClassPrivateProperty = setClassPrivateProperty$1;
const setClassPrivateName = setClassPrivateName$1;
const setDirectives = setDirectives$1;
const convertChainExpression = convertChainExpression$1;
const convertImportDeclaration = convertImportDeclaration$1;
const convertExportDeclaration = convertExportDeclaration$1;
const {convertParenthesizedExpression} = parenthesizedExpression$1;
const {convertTSParenthesizedType} = tsParenthesizedType$1;
const {convertNodeComments} = comments;
const setLiteral = setLiteral$1;
const getAST = getAst;

const {
    convertTSInterfaceHeritage,
    convertTSAbstractMethodDefinition,
    convertPropertyDefinition,
    convertPrivateIdentifier,
} = ts;

const {
    isObjectExpression,
    isExportDeclaration,
} = types$k;

const defaultOptions$5 = {
    convertParens: true,
};

estreeToBabel$1.estreeToBabel = (node, options) => {
    const ast = getAST(node);
    
    const allOptions = {
        ...defaultOptions$5,
        ...options,
    };
    
    traverse$8(ast, {
        noScope: true,
        ParenthesizedExpression: convertParenthesizedExpression(allOptions),
        TSParenthesizedType: convertTSParenthesizedType(allOptions),
        enter(path) {
            const {node} = path;
            const {type} = node;
            
            if (type.endsWith('Literal')) {
                setLiteral(node);
                return setEsprimaRaw(node);
            }
            
            if (type === 'JSXText')
                return setEsprimaRaw(node);
            
            if (type === 'BlockStatement' || type === 'Program')
                return setDirectives(path);
            
            if (type === 'Property')
                return setObjectProperty(node);
            
            if (type === 'MethodDefinition')
                return setClassMethod(path);
            
            if (type === 'FieldDefinition')
                return setClassPrivateProperty(path);
            
            if (type === 'PrivateName')
                return setClassPrivateName(path);
            
            if (type === 'ImportDeclaration')
                return convertImportDeclaration(path);
            
            if (isExportDeclaration(path))
                return convertExportDeclaration(path);
            
            if (type === 'ChainExpression')
                return convertChainExpression(path);
            
            if (type === 'TSAbstractMethodDefinition')
                return convertTSAbstractMethodDefinition(path);
            
            if (type === 'TSInterfaceHeritage')
                return convertTSInterfaceHeritage(path);
            
            if (type === 'PropertyDefinition')
                return convertPropertyDefinition(path);
            
            if (type === 'PrivateIdentifier')
                return convertPrivateIdentifier(path);
        },
        exit(path) {
            const {node} = path;
            
            convertNodeComments(node);
            
            if (isObjectExpression(node))
                return traverseObjectExpression(path.get('properties'));
        },
    });
    return ast;
};

function setObjectProperty(node) {
    node.type = 'ObjectProperty';
}

// avoid additional traversing in @putout/engine-parser
// add "raw" field, that exists in all ESTree AST
// but located in "extra.raw" in Babel AST
// which makes writing transforms more long and error prone
function setEsprimaRaw(node) {
    const {raw} = node;
    
    node.raw = raw || node.extra?.raw;
    node.extra = node.extra || {
        raw,
    };
}

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var acorn$1 = {};

var once$9 = {exports: {}};

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
var wrappy_1 = wrappy$1;
function wrappy$1 (fn, cb) {
  if (fn && cb) return wrappy$1(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k];
  });

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    var ret = fn.apply(this, args);
    var cb = args[args.length-1];
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k];
      });
    }
    return ret
  }
}

var wrappy = wrappy_1;
once$9.exports = wrappy(once$8);
once$9.exports.strict = wrappy(onceStrict);

once$8.proto = once$8(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once$8(this)
    },
    configurable: true
  });

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  });
});

function once$8 (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true;
    return f.value = fn.apply(this, arguments)
  };
  f.called = false;
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true;
    return f.value = fn.apply(this, arguments)
  };
  var name = fn.name || 'Function wrapped with `once`';
  f.onceError = name + " shouldn't be called more than once";
  f.called = false;
  return f
}

var onceExports = once$9.exports;

const noop$3 = () => {};

var empty = /*#__PURE__*/Object.freeze({
	__proto__: null,
	default: noop$3
});

var require$$1$1 = /*@__PURE__*/getAugmentedNamespace(empty);

// eslint-disable-next-line node/no-unsupported-features/es-syntax

// eslint-disable-next-line node/no-unsupported-features/es-syntax
function privateMethods(Parser) {
  const ExtendedParser = noop$3();

  return class extends ExtendedParser {
    // Parse private methods
    parseClassElement(_constructorAllowsSuper) {
      const oldInClassMemberName = this._inClassMemberName;
      this._inClassMemberName = true;
      const result = super.parseClassElement.apply(this, arguments);
      this._inClassMemberName = oldInClassMemberName;
      return result
    }

    parsePropertyName(prop) {
      const isPrivate = this.options.ecmaVersion >= 8 && this._inClassMemberName && this.type == this.privateNameToken && !prop.static;
      this._inClassMemberName = false;
      if (!isPrivate) return super.parsePropertyName(prop)
      return this.parsePrivateClassElementName(prop)
    }
  }
}

var acornPrivateMethods = /*#__PURE__*/Object.freeze({
	__proto__: null,
	default: privateMethods
});

var require$$2 = /*@__PURE__*/getAugmentedNamespace(acornPrivateMethods);

var acornStage3;
var hasRequiredAcornStage3;

function requireAcornStage3 () {
	if (hasRequiredAcornStage3) return acornStage3;
	hasRequiredAcornStage3 = 1;

	acornStage3 = function(Parser) {
	  return Parser.extend(
	    require$$1$1,
	    require$$1$1,
	    require$$2
	  )
	};
	return acornStage3;
}

const once$7 = onceExports;

const initAcorn = once$7(() => {
    const {Parser} = require$$1$1;
    
    const stage3 = requireAcornStage3();
    const typescript = require$$1$1.default;
    
    return Parser.extend(typescript(), stage3);
});

acorn$1.parse = function acornParse(source) {
    const parser = initAcorn();
    const options = {
        locations: true,
        comment: true,
        ecmaVersion: 2023,
        sourceType: 'module',
        allowAwaitOutsideFunction: true,
        allowReturnOutsideFunction: true,
        allowImportExportEverywhere: true,
        preserveParens: true,
    };
    
    const tokensToAvoidEsprima = Array.from(parser.tokenizer(source, options));
    const result = parser.parse(source, options);
    
    return {
        ...result,
        tokens: tokensToAvoidEsprima,
    };
};

var babel$1 = {};

var plugins$1 = [
    'importMeta',
    'importAttributes',
    'deprecatedImportAssert',
    'dynamicImport',
    'bigInt',
    'classProperties',
    'decorators-legacy',
    'decoratorAutoAccessors',
    'destructuringPrivate',
    'exportDefaultFrom',
    'throwExpressions',
    'deferredImportEvaluation',
    ['discardBinding', {
        syntaxType: 'void',
    }],
    'sourcePhaseImports',
    ['optionalChainingAssign', {
        version: '2023-07',
    }],
];

var options$1 = {
    allowReturnOutsideFunction: true,
    allowUndeclaredExports: true,
    allowImportExportEverywhere: true,
};

const once$6 = onceExports;

const plugins = plugins$1;
const options = options$1;
const {assign: assign$5} = Object;
const getFlow = (a) => !a.indexOf('// @flow');
const clean = (a) => a.filter(Boolean);
const initBabel = once$6(() => bundle);

babel$1.parse = function babelParse(source, overrides) {
    const {
        sourceFileName,
        isTS,
        isJSX = true,
        isFlow = getFlow(source),
        isRecovery,
        printer,
    } = overrides;
    
    const {parse} = initBabel();
    const parserOptions = {
        sourceFileName,
        sourceType: 'module',
        tokens: true,
        ...options,
        errorRecovery: isRecovery,
        plugins: clean([
            ...plugins,
            ...getBabelLangExts({
                isTS,
                isFlow,
                isJSX,
            }),
        ]),
    };
    
    if (printer === 'babel')
        assign$5(parserOptions, {
            createParenthesizedExpressions: true,
        });
    
    const ast = parse(source, parserOptions);
    
    ast.program.extra.__putout_printer = printer;
    return ast;
};

function getBabelLangExts({isTS, isFlow, isJSX}) {
    const langs = [
        isJSX && 'jsx',
    ];
    
    if (isTS || isFlow)
        return langs.concat(['typescript']);
    
    return langs;
}

var espree$1 = {};

const once$5 = onceExports;
const initEspree = once$5(() => require$$1$1);

espree$1.parse = function espreeParse(source) {
    const {parse} = initEspree();
    const preventUsingEsprima = true;
    
    return parse(source, {
        loc: true,
        tokens: preventUsingEsprima,
        comment: true,
        ecmaVersion: 2023,
        sourceType: 'module',
        ecmaFeatures: {
            jsx: true,
        },
    });
};

var esprima$1 = {};

const once$4 = onceExports;
const initEsprima = once$4(() => require$$1$1);

esprima$1.parse = function esprimaParse(source) {
    const {parse} = initEsprima();
    
    return parse(source, {
        loc: true,
        tokens: true,
        comment: true,
        sourceType: 'module',
        jsx: true,
    });
};

var tenko$1 = {};

const once$3 = onceExports;
const initTenko = once$3(() => require$$1$1);

tenko$1.parse = (source) => {
    const {Tenko} = initTenko();
    
    const {ast} = Tenko(source, {
        goalMode: 'module',
        allowGlobalReturn: true,
        exposeScopes: true,
    });
    
    return ast;
};

var hermes$1 = {};

const once$2 = onceExports;
const initHermes = once$2(() => require$$1$1);

hermes$1.parse = function hermesParse(source) {
    const parser = initHermes();
    
    const options = {
        babel: true,
        allowReturnOutsideFunction: true,
        flow: 'detect',
        locations: true,
        tokens: true,
    };
    
    return parser.parse(source, options);
};

var tryCatch$7 = (fn, ...args) => {
    try {
        return [null, fn(...args)];
    } catch(e) {
        return [e];
    }
};

const tryCatch$6 = tryCatch$7;

var secondChance$1 = (fn, source, messages, args) => {
    const [a, ...others] = args;
    const [errorA, resultA] = tryCatch$6(fn, source, a);
    
    if (!errorA)
        return resultA;
    
    if (checkError(errorA, messages))
        throw errorA;
    
    for (const b of others) {
        const [errorB, resultB] = tryCatch$6(fn, source, b);
        
        if (!errorB)
            return resultB;
    }
    
    throw errorA;
};

function checkError(error, messages) {
    for (const message of messages) {
        if (error.message.includes(message))
            return true;
    }
    
    return false;
}

const acorn = acorn$1;
const babel = babel$1;
const espree = espree$1;
const esprima = esprima$1;
const tenko = tenko$1;
const hermes = hermes$1;
const secondChance = secondChance$1;
const isObject$5 = (a) => typeof a === 'object';

const MESSAGES = [
    'has already been declared',
];

var customParser$1 = (source, parser, {isTS, isJSX, printer}) => {
    const options = {
        parser,
        printer,
        isTS,
        isJSX,
    };
    
    const optionsB = {
        ...options,
        isJSX: false,
    };
    
    const optionsC = {
        ...options,
        isRecovery: true,
    };
    
    return secondChance(customParse, source, MESSAGES, [
        options,
        optionsB,
        optionsC,
    ]);
};

function customParse(source, {parser, printer, isTS, isJSX, isRecovery}) {
    if (parser === 'babel')
        return babel.parse(source, {
            isTS,
            isJSX,
            isRecovery,
            printer,
        });
    
    if (isObject$5(parser))
        return parser.parse(source, {
            isJSX,
            isTS,
        });
    
    if (parser === 'espree')
        return espree.parse(source);
    
    if (parser === 'acorn')
        return acorn.parse(source);
    
    if (parser === 'esprima')
        return esprima.parse(source);
    
    if (parser === 'tenko')
        return tenko.parse(source);
    
    if (parser === 'hermes')
        return hermes.parse(source);
    
    return commonjsRequire(parser).parse(source);
}

var tryThrowWithReason$3 = {};

const tryCatch$5 = tryCatch$7;

tryThrowWithReason$3.tryThrowWithReason = (fn, ...args) => {
    const [error, result] = tryCatch$5(fn, ...args);
    
    if (error) {
        error.reason = 'parse';
        throw error;
    }
    
    return result;
};

const {estreeToBabel} = estreeToBabel$1;
const customParser = customParser$1;
const {tryThrowWithReason: tryThrowWithReason$2} = tryThrowWithReason$3;
const {assign: assign$4} = Object;
const isString$8 = (a) => typeof a === 'string';

var parse$5 = (source, options) => {
    check$e(source);
    
    const {
        parser,
        printer = 'putout',
        isTS,
        isJSX,
    } = options || {};
    
    const {parse} = getParser({
        printer,
        parser,
        isTS,
        isJSX,
    });
    
    return tryThrowWithReason$2(parse, source);
};

const getParser = ({parser = 'babel', isTS, isJSX, printer}) => ({
    parse(source) {
        const options = {};
        
        if (printer === 'babel')
            assign$4(options, {
                convertParens: false,
            });
        
        const ast = estreeToBabel(customParser(source, parser, {
            isTS,
            isJSX,
            printer,
        }), options);
        
        return ast;
    },
});

function check$e(source) {
    if (!isString$8(source))
        throw Error(`☝️ Looks like type of 'source' is not 'string', but '${typeof source}'`);
}

parse$5.default;

const {generate: generate$4} = bundle;

var generate_1$1 = (node, options, sourceMaps) => {
    return generate$4(node, {
        comments: false,
        ...options,
    }, sourceMaps);
};

generate_1$1.default;

var template$a = {exports: {}};

/*
MIT License

Copyright (c) 2018-2023 Simon Y. Blackwell

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/ function $cf838c15c8b009ba$var$vrgs(f) {
    var s = f + "", i = s.indexOf("...");
    return i >= 0 && (i < s.indexOf(")") || s.indexOf("arguments") >= 0);
}
function $cf838c15c8b009ba$export$22f15dd4e5be7e52(fn, o) {
    /*o = {
		serializer, // used to serialize arguments of single argument functions, multis are not serialized
		equals, // equality tester, will force use of slower multiarg approach even for single arg functions
		maxAge, // max cache age is ms, set > 0 && < Infinity if you want automatic clearing
		maxArgs, // max args to use for signature
		vargs = vrgs(fn) // set to true if function may have variable or beyond-signature arguments, default is best attempt at infering
	  } = {}
	*/ o || (o = {});
    var vargs = o.vargs || $cf838c15c8b009ba$var$vrgs(fn), k = [], cache = new Map(), u, to, d = function(key) {
        return to = setTimeout(function() {
            if (u) {
                cache.delete(key);
                return;
            }
            // dealing with multi-arg function, c and k are Arrays
            k.splice(key, 1);
        //v.splice(key,1);
        }, o.maxAge);
    }, c = o.maxAge > 0 && o.maxAge < Infinity ? d : 0, eq = o.equals ? o.equals : 0, maxargs = o.maxArgs, srlz = o.serializer, f; // memoized function to return
    if (fn.length === 1 && !o.equals && !vargs) {
        // for single argument functions, just use a Map lookup
        f = function(a) {
            if (srlz) a = srlz(a);
            var r;
            return cache.get(a) || (!c || c(a), cache.set(a, r = fn.call(this, a)), r);
        };
        u = 1;
    } else if (eq) // for multiple arg functions, loop through a cache of all the args
    // looking at each arg separately so a test can abort as soon as possible
    f = function() {
        var l = maxargs || arguments.length, kl = k.length, i = -1;
        while(++i < kl)if (k[i].length === l) {
            var j = -1;
            while(++j < l && eq(arguments[j], k[i][j])); // compare each arg
            if (j === l) return k[i].val //the args matched;
            ;
        }
        // set change timeout only when new value computed, hits will not push out the tte, but it is arguable they should not
        k[i] = arguments;
        return !c || c(i), arguments.val = fn.apply(this, k[i]);
    };
    else f = function() {
        var l = maxargs || arguments.length, kl = k.length, i = -1;
        while(++i < kl)if (k[i].length === l) {
            var j = -1;
            while(++j < l && arguments[j] === k[i][j]); // compare each arg
            if (j === l) return k[i].val //the args matched;
            ;
        }
        // set change timeout only when new value computed, hits will not push out the tte, but it is arguable they should not
        k[i] = arguments;
        return !c || c(i), arguments.val = fn.apply(this, k[i]);
    };
    // reset all the caches
    f.clear = function() {
        if (to) clearTimeout(to);
        cache.clear();
        k = [];
    };
    f.keys = function() {
        return u ? [
            ...cache.keys()
        ] : k.slice();
    };
    f.values = function() {
        return u ? [
            ...cache.values()
        ] : k.map((args)=>args.val);
    };
    return f;
}

var nanoMemoize = /*#__PURE__*/Object.freeze({
	__proto__: null,
	default: $cf838c15c8b009ba$export$22f15dd4e5be7e52,
	nanomemoize: $cf838c15c8b009ba$export$22f15dd4e5be7e52
});

var require$$3 = /*@__PURE__*/getAugmentedNamespace(nanoMemoize);

(function (module) {

	const {types, template} = bundle;
	const {nanomemoize} = require$$3;
	const plugins = plugins$1;
	const options = options$1;

	const defaults = {
	    ...options,
	    plugins: [
	        ...plugins,
	        'typescript',
	        'jsx',
	    ],
	};

	const {
	    isExpressionStatement,
	    isTSExternalModuleReference,
	} = types;

	const extractExpression = (a) => {
	    if (isExpressionStatement(a))
	        return a.expression;
	    
	    if (isTSExternalModuleReference(a))
	        return a.expression;
	    
	    return a;
	};

	module.exports = nanomemoize((value, options) => {
	    const fn = template(value, {
	        ...defaults,
	        ...options,
	    });
	    
	    return (...a) => {
	        const result = fn(...a);
	        return extractExpression(result);
	    };
	});

	module.exports.ast = nanomemoize((value, options) => {
	    const result = template.ast(value, {
	        ...defaults,
	        ...options,
	    });
	    
	    return extractExpression(result);
	});

	module.exports.program = nanomemoize((value, options) => {
	    const result = template.program(value, {
	        ...defaults,
	        ...options,
	    });
	    
	    return result;
	});

	module.exports.program.ast = nanomemoize((value, options) => {
	    const result = template.program.ast(value, {
	        ...defaults,
	        ...options,
	    });
	    
	    return result;
	});

	module.exports.ast.fresh = (value, options) => {
	    const result = template.ast(value, {
	        ...defaults,
	        ...options,
	    });
	    
	    return extractExpression(result);
	};

	module.exports.extractExpression = extractExpression; 
} (template$a));

var templateExports$1 = template$a.exports;
templateExports$1.default;

const print$3 = print$4;
const parse$4 = parse$5;
const generate$3 = generate_1$1;
const template$9 = templateExports$1;

parser$5.print = print$3;
parser$5.parse = parse$4;
parser$5.generate = generate$3;
parser$5.template = template$9;

var shebang = {};

shebang.mergeShebang = (shebang, source) => {
    if (!shebang)
        return source;
    
    return `${shebang}\n${source}`;
};

shebang.cutShebang = (source) => {
    if (source.indexOf('#'))
        return [source, ''];
    
    const lines = source.split('\n');
    
    const result = lines
        .slice(1)
        .join('\n');
    
    const [shebang] = lines;
    
    return [
        result,
        `${shebang}\n`,
    ];
};

var defaultOptions$4 = {};

var lib$1 = {};

var asyncLoader = {};

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
function resolve() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : '/';

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter$1(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
}
// path.normalize(path)
// posix version
function normalize(path) {
  var isPathAbsolute = isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter$1(path.split('/'), function(p) {
    return !!p;
  }), !isPathAbsolute).join('/');

  if (!path && !isPathAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isPathAbsolute ? '/' : '') + path;
}
// posix version
function isAbsolute(path) {
  return path.charAt(0) === '/';
}

// posix version
function join$4() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return normalize(filter$1(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
}


// path.relative(from, to)
// posix version
function relative$1(from, to) {
  from = resolve(from).substr(1);
  to = resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
}

var sep = '/';
var delimiter = ':';

function dirname$2(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
}

function basename$3(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
}


function extname(path) {
  return splitPath(path)[3];
}
var _polyfillNode_path = {
  extname: extname,
  basename: basename$3,
  dirname: dirname$2,
  sep: sep,
  delimiter: delimiter,
  relative: relative$1,
  join: join$4,
  isAbsolute: isAbsolute,
  normalize: normalize,
  resolve: resolve
};
function filter$1 (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b' ?
    function (str, start, len) { return str.substr(start, len) } :
    function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

var _polyfillNode_path$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	basename: basename$3,
	default: _polyfillNode_path,
	delimiter: delimiter,
	dirname: dirname$2,
	extname: extname,
	isAbsolute: isAbsolute,
	join: join$4,
	normalize: normalize,
	relative: relative$1,
	resolve: resolve,
	sep: sep
});

var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_path$1);

var tryToCatch$1 = async (fn, ...args) => {
    check$d(fn);
    
    try {
        return [null, await fn(...args)];
    } catch(e) {
        return [e];
    }
};

function check$d(fn) {
    if (typeof fn !== 'function')
        throw Error('fn should be a function!');
}

var simpleImport$1 = {};

// How in other way to mock import using mock require in CommonJS?
simpleImport$1.simpleImport = async (url) => {
    const result = await import(url);
    return result.default || result;
};

const process = require$$0$2;
const {join: join$3} = require$$0$1;
const once$1 = onceExports;
const {nanomemoize} = require$$3;
const tryToCatch = tryToCatch$1;
const {simpleImport} = simpleImport$1;

const {assign: assign$3} = Object;
const stub$2 = () => () => {};

asyncLoader.createAsyncLoader = (type) => nanomemoize(async (name, load) => {
    if (name === 'none')
        return stub$2();
    
    if (name.startsWith('import:')) {
        const shortName = name.replace('import:', '');
        
        return await cleverLoad([
            require.resolve(shortName),
        ], load);
    }
    
    const namesBase = [
        `@putout/${type}-${name}`,
        `putout-${type}-${name}`,
    ];
    
    const namesFromPluginsDirs = namesBase.flatMap(buildPluginsDirs);
    
    const names = Array.from(new Set([
        ...namesBase,
        ...namesFromPluginsDirs,
    ]));
    
    return await cleverLoad(names, load);
});

async function cleverLoad(names, load = simpleImport) {
    let e;
    let reporter;
    
    for (const name of names) {
        [e, reporter] = await tryToCatch(load, name);
        
        if (!e)
            return reporter;
        
        if (e.code === 'ERR_UNSUPPORTED_DIR_IMPORT') {
            const fullName = require.resolve(name);
            
            [e, reporter] = await tryToCatch(load, fullName);
            
            if (!e)
                return reporter;
        }
        
        if (e.code === 'ERR_MODULE_NOT_FOUND')
            continue;
        
        assign$3(e, {
            message: `${name}: ${e.message}`,
        });
        
        throw e;
    }
    
    assign$3(e, {
        message: e.message.replace(/\simported.*/, ''),
    });
    
    throw e;
}

const getPutoutLoadDir = once$1(() => process.env.PUTOUT_LOAD_DIR);

function buildPluginsDirs(name) {
    const dir = getPutoutLoadDir();
    
    if (!dir)
        return [name];
    
    const base = join$3(dir, name);
    
    return [
        base,
        `${base}.js`,
    ];
}

var validateRulesRelations$2 = {};

var parsePluginNames$2 = {};

const isStr$4 = (a) => typeof a === 'string';
const {isArray: isArray$c} = Array;
const {entries: entries$9} = Object;

parsePluginNames$2.parsePluginNames = (plugins) => {
    const result = [];
    
    for (const plugin of plugins) {
        if (isStr$4(plugin)) {
            result.push([plugin]);
            continue;
        }
        
        if (isArray$c(plugin)) {
            const [pluginName, fn] = plugin;
            result.push([pluginName, fn]);
            continue;
        }
        
        result.push(...entries$9(plugin));
    }
    
    return result;
};

var parseRules$2 = {};

const {isArray: isArray$b} = Array;
const isBool$2 = (a) => typeof a === 'boolean';
const isStr$3 = (a) => typeof a === 'string';
const isObj = (a) => typeof a === 'object';
const {entries: entries$8} = Object;
const {stringify: stringify$6} = JSON;

const notSupportedError = (a) => Error(`☝️ Rule format not supported ${a}: ${typeof a}`);
const rulesUsedInsteadOfMatchError = (a) => Error(`☝️ Looks like you need to change "rules" to "match" for ${stringify$6(a)}`);
const stateOptionError = ({rule, value}) => Error(`☝️ ${rule}: state option can be "on" or "off" only, when used as string, received: "${value}"`);
const defaultOptions$3 = () => Object.create(null);

const parseState = (rule, value) => {
    validateState(rule, value);
    
    if (value === 'on')
        return true;
    
    if (value === 'off')
        return false;
    
    return value;
};

parseRules$2.parseRules = (rules) => {
    const result = [];
    const plugin = null;
    const msg = '';
    
    check$c(rules);
    
    for (const [rule, value] of entries$8(rules)) {
        if (isStr$3(value)) {
            result.push({
                rule,
                state: parseState(rule, value),
                plugin,
                msg,
                options: defaultOptions$3(),
            });
            continue;
        }
        
        if (isBool$2(value)) {
            result.push({
                rule,
                state: value,
                plugin,
                msg,
                options: defaultOptions$3(),
            });
            continue;
        }
        
        const looksLikeArray = isArray$b(value);
        const looksLikeNormalArray = looksLikeArray && value.length;
        
        if (looksLikeNormalArray) {
            result.push(parseArray(rule, value));
            continue;
        }
        
        if (isObj(value))
            throw rulesUsedInsteadOfMatchError(value);
        
        throw notSupportedError(value);
    }
    
    return result;
};

function parseArray(rule, args) {
    const plugin = null;
    const [rawState] = args;
    
    const state = parseState(rule, rawState);
    
    if (args.length === 3) {
        const [, msg, options] = args;
        
        return {
            rule,
            state,
            plugin,
            msg,
            options,
        };
    }
    
    const [, msg = ''] = args;
    
    return {
        rule,
        state,
        plugin,
        msg: '',
        options: msg,
    };
}

function validateState(rule, value) {
    if (isBool$2(value))
        return true;
    
    if (/^(on|off)$/.test(value))
        return true;
    
    if (isObj(value))
        return true;
    
    throw stateOptionError({
        rule,
        value,
    });
}

const cut = (a) => a.split('/')[0];

parseRules$2.enableNestedRules = (rules) => {
    const newRules = {};
    
    for (const [rule, value] of entries$8(rules)) {
        if (rule.includes('/') && parseState(rule, value))
            newRules[cut(rule)] = 'on';
        
        newRules[rule] = value;
    }
    
    return newRules;
};

function check$c(rules) {
    if (isArray$b(rules))
        throw Error(`☝️Looks like type of 'rules' passed to @putout/engine-loader is 'array', expected: 'object'.`);
}

var mergeRules$2 = {};

const defaultOptions$2 = () => Object.create(null);

mergeRules$2.mergeRules = ([rule, plugin], rules) => {
    for (const currentRule of rules) {
        if (currentRule.rule !== rule)
            continue;
        
        const {msg, options} = currentRule;
        
        return {
            rule,
            plugin,
            msg,
            options,
        };
    }
    
    return {
        rule,
        plugin,
        msg: '',
        options: defaultOptions$2(),
    };
};

var validateRules$2 = {};

const parseSlashes = (rule) => {
    if (rule.includes('/'))
        return rule
            .split('/')
            .shift();
    
    return rule;
};

const parsePluginName = (a) => {
    return a
        .replace('import:@putout/plugin-', '')
        .replace('@putout/plugin-', '');
};

validateRules$2.validateRules = ({items, rules}) => {
    const ruleItems = Object.keys(rules);
    
    for (const rule of ruleItems) {
        let isName = false;
        let isWithSlash = false;
        let isIncludes = false;
        
        for (const [pluginName, plugin = {}] of items) {
            const parsedPluginName = parsePluginName(pluginName);
            
            isName = parsedPluginName === rule;
            isWithSlash = parsedPluginName === parseSlashes(rule);
            isIncludes = rule.includes(parsedPluginName);
            
            if (isName && plugin.rules)
                throw Error(`Rule '${rule}' cannot be applied to nested plugin '${pluginName}'`);
            
            if (isName || isWithSlash || isIncludes)
                break;
        }
        
        if (!isName && !isWithSlash && !isIncludes)
            throw Error(`No plugin found for a rule: '${rule}'`);
    }
};

var isEnabled$4 = {};

isEnabled$4.isEnabled = (name, rules) => {
    for (const {rule, state} of rules) {
        if (rule === name)
            return state;
    }
    
    for (const {rule, state} of rules) {
        if (rule.includes('/') && RegExp(`^${rule}`).test(name))
            return state;
    }
    
    for (const {rule, state} of rules) {
        if (RegExp(`^${rule}/`).test(name))
            return state;
    }
    
    return true;
};

var getLoadedRules$2 = {};

getLoadedRules$2.getLoadedRules = (rules) => {
    const loadedRules = [];
    
    for (const item of rules) {
        const {rule} = item;
        
        if (rule.includes('/'))
            continue;
        
        loadedRules.push(item);
    }
    
    return loadedRules;
};

const {parseRules: parseRules$1} = parseRules$2;
const {mergeRules: mergeRules$1} = mergeRules$2;
const {validateRules: validateRules$1} = validateRules$2;
const {isEnabled: isEnabled$3} = isEnabled$4;
const {getLoadedRules: getLoadedRules$1} = getLoadedRules$2;

var rules = {
    parseRules: parseRules$1,
    mergeRules: mergeRules$1,
    validateRules: validateRules$1,
    isEnabled: isEnabled$3,
    getLoadedRules: getLoadedRules$1,
};

var check$b = {};

const isString$7 = (a) => typeof a === 'string';

check$b.check = (options) => {
    if (!options || typeof options !== 'object')
        throw Error('options should be an object!');
};

check$b.checkRule = (rule) => {
    if (!isString$7(rule))
        throw Error(`☝️ Looks like plugin name type is not 'string', but: '${typeof rule}'`);
};

const {parsePluginNames: parsePluginNames$1} = parsePluginNames$2;
const {validateRules} = rules;
const {check: check$a} = check$b;

validateRulesRelations$2.validateRulesRelations = (options) => {
    check$a(options);
    
    const {pluginNames = [], rules = {}} = options;
    const items = parsePluginNames$1(pluginNames);
    
    validateRules({
        rules,
        items,
    });
};

var loadPluginsAsync$1 = {};

var prepareRules$2 = {};

const {parsePluginNames} = parsePluginNames$2;
const {enableNestedRules} = parseRules$2;

const {parseRules, getLoadedRules} = rules;

prepareRules$2.prepareRules = ({rules, pluginNames}) => {
    const enabledRules = enableNestedRules(rules);
    const cookedEnabledRules = parseRules(enabledRules);
    const loadedRules = getLoadedRules(cookedEnabledRules);
    const items = parsePluginNames(pluginNames);
    const cookedRules = parseRules(rules);
    
    return {
        items,
        loadedRules,
        cookedRules,
    };
};

const supportedKeys = [
    'find',
    'traverse',
    'replace',
    'include',
    'exclude',
    'rules',
    'declare',
    'scan',
];

var validatePlugin$2 = ({plugin, rule}) => {
    const keys = Object.keys(plugin);
    
    for (const key of supportedKeys) {
        if (keys.includes(key))
            return;
    }
    
    throw Error(`☝️ Cannot determine type of plugin '${rule}'. Here is list of supported plugins: https://git.io/JqcMn`);
};

var filterEnabledPlugins$2 = {};

const {isEnabled: isEnabled$2, mergeRules} = rules;

const {isArray: isArray$a} = Array;
const maybeTuple = (a) => isArray$a(a) ? a : ['on', a];

// Would be great to have ability to filter
// disabled plugins and prevent them from loading
// but we can't because of a way multi-rule plugins
// works. We can't determine count and names of all
// rules of a plugin before load.
filterEnabledPlugins$2.filterEnabledPlugins = ({plugins, cookedRules}) => {
    const result = [];
    
    for (const [name, plugin] of plugins) {
        if (!isEnabled$2(name, cookedRules))
            continue;
        
        const [status, currentPlugin] = maybeTuple(plugin);
        
        if (!isExectRuleEnabled(name, status, cookedRules))
            continue;
        
        result.push(mergeRules(
            [name, currentPlugin],
            cookedRules,
        ));
    }
    
    return result;
};

function isExectRuleEnabled(name, status, rules) {
    if (status === 'on')
        return true;
    
    for (const {rule, state} of rules) {
        if (rule.includes('/') && RegExp(`^${rule}`).test(name))
            return state;
    }
    
    return false;
}

const {basename: basename$2} = require$$0$1;

const {isEnabled: isEnabled$1} = rules;

const {prepareRules: prepareRules$1} = prepareRules$2;

const validatePlugin$1 = validatePlugin$2;
const {filterEnabledPlugins: filterEnabledPlugins$1} = filterEnabledPlugins$2;

const {createAsyncLoader: createAsyncLoader$2} = asyncLoader;
const {check: check$9, checkRule: checkRule$1} = check$b;

const loadPluginAsync = createAsyncLoader$2('plugin');

loadPluginsAsync$1.loadPluginsAsync = async (options) => {
    check$9(options);
    
    const {pluginNames = [], rules = {}} = options;
    const {
        items,
        loadedRules,
        cookedRules,
    } = prepareRules$1({
        rules,
        pluginNames,
    });
    
    const plugins = await loadPlugins$3({
        items,
        loadedRules,
    });
    
    return filterEnabledPlugins$1({
        plugins,
        cookedRules,
    });
};

const splitRule$1 = (rule) => [rule, 'putout'];

async function loadPlugins$3({items, loadedRules}) {
    const promises = [];
    const enabledRules = [];
    
    for (const [rule, itemPlugin] of items) {
        if (!isEnabled$1(rule, loadedRules))
            continue;
        
        checkRule$1(rule);
        
        const [name] = splitRule$1(rule);
        const plugin = itemPlugin || loadPluginAsync(name);
        
        enabledRules.push(parseRuleName(rule));
        promises.push(plugin);
    }
    
    const resolvedPlugins = await Promise.all(promises);
    const plugins = [];
    
    for (const [i, rule] of enabledRules.entries()) {
        const plugin = resolvedPlugins[i];
        
        validatePlugin$1({
            plugin,
            rule,
        });
        
        const {rules} = plugin;
        
        if (rules) {
            plugins.push(...extendRules$1(rule, rules));
            continue;
        }
        
        plugins.push([rule, plugin]);
    }
    
    return plugins;
}

function extendRules$1(rule, plugin) {
    const result = [];
    const entries = Object.entries(plugin);
    
    for (const [name, plugin] of entries) {
        result.push([`${rule}/${name}`, plugin]);
    }
    
    return result;
}

function parseRuleName(rule) {
    if (rule.startsWith('import:')) {
        const shortName = basename$2(rule.replace('import:', ''));
        
        return shortName.replace('plugin-', '');
    }
    
    return rule;
}

var loadPlugins$2 = {};

var load = {};

var _polyfillNode_module = {};

var _polyfillNode_module$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	default: _polyfillNode_module
});

var require$$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_module$1);

var hasRequiredLoad;

function requireLoad () {
	if (hasRequiredLoad) return load;
	hasRequiredLoad = 1;

	const process = require$$0$2;
	const {createRequire} = require$$1;
	const {join} = require$$0$1;
	const tryCatch = tryCatch$7;
	const once = onceExports;
	const {assign} = Object;

	const bigFirst = (a) => `${a[0].toUpperCase()}${a.slice(1)}`;

	const load$1 = (type) => ({name, namespace}) => {
	    const [pluginPath, customRequire] = getPath(namespace, type, name);
	    
	    if (!pluginPath)
	        throw Error(`${bigFirst(type)} "${namespace}-${type}-${name}" could not be found!`);
	    
	    const [error, result] = tryCatch(customRequire, pluginPath);
	    
	    /* c8 ignore start */
	    if (error?.code === 'ERR_REQUIRE_ESM')
	        assign(error, {
	            message: `☝️ Looks like '${name}' is ESM, use 'await putoutAsync()' instead`,
	            name,
	        });
	    
	    /* c8 ignore end */
	    if (error)
	        throw error;
	    
	    return result;
	};

	load.loadPlugin = load$1('plugin');
	load.loadProcessor = load$1('processor');

	function getPath(namespace, type, name) {
	    if (name.startsWith('import:'))
	        return getModulePath(name.replace('import:', ''));
	    
	    let [path, customRequire] = getModulePath(`@${namespace}/${type}-${name}`);
	    
	    if (!path)
	        [path, customRequire] = getModulePath(`${namespace}-${type}-${name}`);
	    
	    if (!path)
	        [path, customRequire] = getModulePath(name);
	    
	    return [path, customRequire];
	}

	const {
	    PUTOUT_YARN_PNP = 'putout',
	} = {};

	const createCustomRequire = once(() => createRequire(require.resolve(PUTOUT_YARN_PNP)));
	const createPutoutRequire = once(() => createRequire(require.resolve('putout')));

	// That's all for Yarn P'n'P
	//
	// We need to create a couple version of require for plugins, formatters and processors:
	// - declared in 🐊Putout package.json;
	// - declared in module that want to extend 🐊Putout;
	//
	// https://yarnpkg.com/advanced/rulebook#modules-shouldnt-hardcode-node_modules-paths-to-access-other-modules
	function getModulePath(name, {again = false} = {}) {
	    let path;
	    
	    const customRequire = createCustomRequire();
	    const putoutRequire = createPutoutRequire();
	    
	    [, path] = tryCatch(putoutRequire.resolve, name);
	    
	    if (path)
	        return [path, putoutRequire];
	    
	    [, path] = tryCatch(customRequire.resolve, name);
	    
	    if (!path && !again)
	        return getModulePath(buildPluginsDir(name), {
	            again: true,
	        });
	    
	    return [path, customRequire];
	}

	const getPutoutLoadDir = once(() => process.env.PUTOUT_LOAD_DIR);

	function buildPluginsDir(name) {
	    const dir = getPutoutLoadDir();
	    
	    if (!dir)
	        return name;
	    
	    return join(dir, name);
	}
	return load;
}

const validatePlugin = validatePlugin$2;
const {prepareRules} = prepareRules$2;

const {isEnabled} = rules;

const {filterEnabledPlugins} = filterEnabledPlugins$2;
const {check: check$8, checkRule} = check$b;

const {isArray: isArray$9} = Array;

loadPlugins$2.loadPlugins = (options) => {
    check$8(options);
    
    const {pluginNames = [], rules = {}} = options;
    const {
        items,
        loadedRules,
        cookedRules,
    } = prepareRules({
        rules,
        pluginNames,
    });
    
    const plugins = loadPlugins$1({
        items,
        loadedRules,
    });
    
    return filterEnabledPlugins({
        plugins,
        cookedRules,
    });
};

const splitRule = (rule) => [rule, 'putout'];

const parseRule = (rule) => rule
    .replace('import:@putout/plugin-', '')
    .replace('@putout/plugin-', '');

const maybeFromTuple = (a) => isArray$9(a) ? a[1] : a;

function loadPlugins$1({items, loadedRules}) {
    const plugins = [];
    
    for (const [rule, itemPlugin] of items) {
        if (!isEnabled(rule, loadedRules))
            continue;
        
        checkRule(rule);
        const parsedRule = parseRule(rule);
        
        const [name, namespace] = splitRule(rule);
        const plugin = maybeFromTuple(itemPlugin) || loadPlugin({
            name,
            namespace,
        });
        
        validatePlugin({
            plugin,
            rule,
        });
        
        const {rules} = plugin;
        
        if (rules) {
            plugins.push(...extendRules(parsedRule, rules));
            continue;
        }
        
        plugins.push([parsedRule, plugin]);
    }
    
    return plugins;
}

function extendRules(rule, plugin) {
    const result = [];
    const entries = Object.entries(plugin);
    
    for (const [name, plugin] of entries) {
        result.push([`${rule}/${name}`, plugin]);
    }
    
    return result;
}

// add support of esm.sh
// https://github.com/esm-dev/esm.sh/issues/1045
function loadPlugin({name, namespace}) {
    const {loadPlugin} = requireLoad();
    
    return loadPlugin({
        name,
        namespace,
    });
}

var loadProcessorsAsync$1 = {};

const isStr$2 = (a) => typeof a === 'string';
const {isArray: isArray$8} = Array;

const isOn = (a) => a === 'on';
const isOff = (a) => a === 'off';

var parseProcessorNames$1 = (plugins) => {
    const result = [];
    
    for (const plugin of plugins) {
        if (isStr$2(plugin)) {
            result.push([plugin]);
            continue;
        }
        
        if (isArray$8(plugin)) {
            const [pluginName, fn] = plugin;
            
            if (isOff(fn))
                continue;
            
            if (isOn(fn)) {
                result.push([pluginName]);
                continue;
            }
            
            result.push([pluginName, fn]);
            continue;
        }
    }
    
    return result;
};

const {createAsyncLoader: createAsyncLoader$1} = asyncLoader;

const parseProcessorNames = parseProcessorNames$1;

const {check: check$7} = check$b;

loadProcessorsAsync$1.loadProcessorsAsync = async (options, load) => {
    check$7(options);
    
    const {processors = []} = options;
    const parsedProcessors = parseProcessorNames(processors);
    const loadProcessor = createAsyncLoader$1('processor');
    
    const list = [];
    
    for (const [name, fn] of parsedProcessors) {
        if (fn) {
            list.push(fn);
            continue;
        }
        
        list.push(loadProcessor(name, load));
    }
    
    return await Promise.all(list);
};

const {createAsyncLoader} = asyncLoader;

const {validateRulesRelations: validateRulesRelations$1} = validateRulesRelations$2;
const {loadPluginsAsync} = loadPluginsAsync$1;
const {loadPlugins} = loadPlugins$2;
const {loadProcessorsAsync} = loadProcessorsAsync$1;

lib$1.loadPlugins = loadPlugins;
lib$1.loadPluginsAsync = loadPluginsAsync;
lib$1.loadProcessorsAsync = loadProcessorsAsync;
lib$1.createAsyncLoader = createAsyncLoader;
lib$1.validateRulesRelations = validateRulesRelations$1;

var lib = {};

var browser = {exports: {}};

/**
 * Helpers.
 */

var ms;
var hasRequiredMs;

function requireMs () {
	if (hasRequiredMs) return ms;
	hasRequiredMs = 1;
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	ms = function (val, options) {
	  options = options || {};
	  var type = typeof val;
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isFinite(val)) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error(
	    'val is not a non-empty string or a valid number. val=' +
	      JSON.stringify(val)
	  );
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
	    str
	  );
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'weeks':
	    case 'week':
	    case 'w':
	      return n * w;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (msAbs >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (msAbs >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (msAbs >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return plural(ms, msAbs, d, 'day');
	  }
	  if (msAbs >= h) {
	    return plural(ms, msAbs, h, 'hour');
	  }
	  if (msAbs >= m) {
	    return plural(ms, msAbs, m, 'minute');
	  }
	  if (msAbs >= s) {
	    return plural(ms, msAbs, s, 'second');
	  }
	  return ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, msAbs, n, name) {
	  var isPlural = msAbs >= n * 1.5;
	  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
	}
	return ms;
}

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = requireMs();
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		const split = (typeof namespaces === 'string' ? namespaces : '')
			.trim()
			.replace(/\s+/g, ',')
			.split(',')
			.filter(Boolean);

		for (const ns of split) {
			if (ns[0] === '-') {
				createDebug.skips.push(ns.slice(1));
			} else {
				createDebug.names.push(ns);
			}
		}
	}

	/**
	 * Checks if the given string matches a namespace template, honoring
	 * asterisks as wildcards.
	 *
	 * @param {String} search
	 * @param {String} template
	 * @return {Boolean}
	 */
	function matchesTemplate(search, template) {
		let searchIndex = 0;
		let templateIndex = 0;
		let starIndex = -1;
		let matchIndex = 0;

		while (searchIndex < search.length) {
			if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
				// Match character or proceed with wildcard
				if (template[templateIndex] === '*') {
					starIndex = templateIndex;
					matchIndex = searchIndex;
					templateIndex++; // Skip the '*'
				} else {
					searchIndex++;
					templateIndex++;
				}
			} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition
				// Backtrack to the last '*' and try to match more characters
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else {
				return false; // No match
			}
		}

		// Handle trailing '*' in template
		while (templateIndex < template.length && template[templateIndex] === '*') {
			templateIndex++;
		}

		return templateIndex === template.length;
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names,
			...createDebug.skips.map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		for (const skip of createDebug.skips) {
			if (matchesTemplate(name, skip)) {
				return false;
			}
		}

		for (const ns of createDebug.names) {
			if (matchesTemplate(name, ns)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

var common = setup;

(function (module, exports) {
	/**
	 * This is the web browser implementation of `debug()`.
	 */

	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = localstorage();
	exports.destroy = (() => {
		let warned = false;

		return () => {
			if (!warned) {
				warned = true;
				console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
			}
		};
	})();

	/**
	 * Colors.
	 */

	exports.colors = [
		'#0000CC',
		'#0000FF',
		'#0033CC',
		'#0033FF',
		'#0066CC',
		'#0066FF',
		'#0099CC',
		'#0099FF',
		'#00CC00',
		'#00CC33',
		'#00CC66',
		'#00CC99',
		'#00CCCC',
		'#00CCFF',
		'#3300CC',
		'#3300FF',
		'#3333CC',
		'#3333FF',
		'#3366CC',
		'#3366FF',
		'#3399CC',
		'#3399FF',
		'#33CC00',
		'#33CC33',
		'#33CC66',
		'#33CC99',
		'#33CCCC',
		'#33CCFF',
		'#6600CC',
		'#6600FF',
		'#6633CC',
		'#6633FF',
		'#66CC00',
		'#66CC33',
		'#9900CC',
		'#9900FF',
		'#9933CC',
		'#9933FF',
		'#99CC00',
		'#99CC33',
		'#CC0000',
		'#CC0033',
		'#CC0066',
		'#CC0099',
		'#CC00CC',
		'#CC00FF',
		'#CC3300',
		'#CC3333',
		'#CC3366',
		'#CC3399',
		'#CC33CC',
		'#CC33FF',
		'#CC6600',
		'#CC6633',
		'#CC9900',
		'#CC9933',
		'#CCCC00',
		'#CCCC33',
		'#FF0000',
		'#FF0033',
		'#FF0066',
		'#FF0099',
		'#FF00CC',
		'#FF00FF',
		'#FF3300',
		'#FF3333',
		'#FF3366',
		'#FF3399',
		'#FF33CC',
		'#FF33FF',
		'#FF6600',
		'#FF6633',
		'#FF9900',
		'#FF9933',
		'#FFCC00',
		'#FFCC33'
	];

	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */

	// eslint-disable-next-line complexity
	function useColors() {
		// NB: In an Electron preload script, document will be defined but not fully
		// initialized. Since we know we're in Chrome, we'll just detect this case
		// explicitly
		if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
			return true;
		}

		// Internet Explorer and Edge do not support colors.
		if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
			return false;
		}

		let m;

		// Is webkit? http://stackoverflow.com/a/16459606/376773
		// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
		// eslint-disable-next-line no-return-assign
		return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
			// Is firebug? http://stackoverflow.com/a/398120/376773
			(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
			// Is firefox >= v31?
			// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
			(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
			// Double check webkit in userAgent just in case we are in a worker
			(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
	}

	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */

	function formatArgs(args) {
		args[0] = (this.useColors ? '%c' : '') +
			this.namespace +
			(this.useColors ? ' %c' : ' ') +
			args[0] +
			(this.useColors ? '%c ' : ' ') +
			'+' + module.exports.humanize(this.diff);

		if (!this.useColors) {
			return;
		}

		const c = 'color: ' + this.color;
		args.splice(1, 0, c, 'color: inherit');

		// The final "%c" is somewhat tricky, because there could be other
		// arguments passed either before or after the %c, so we need to
		// figure out the correct index to insert the CSS into
		let index = 0;
		let lastC = 0;
		args[0].replace(/%[a-zA-Z%]/g, match => {
			if (match === '%%') {
				return;
			}
			index++;
			if (match === '%c') {
				// We only are interested in the *last* %c
				// (the user may have provided their own)
				lastC = index;
			}
		});

		args.splice(lastC, 0, c);
	}

	/**
	 * Invokes `console.debug()` when available.
	 * No-op when `console.debug` is not a "function".
	 * If `console.debug` is not available, falls back
	 * to `console.log`.
	 *
	 * @api public
	 */
	exports.log = console.debug || console.log || (() => {});

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	function save(namespaces) {
		try {
			if (namespaces) {
				exports.storage.setItem('debug', namespaces);
			} else {
				exports.storage.removeItem('debug');
			}
		} catch (error) {
			// Swallow
			// XXX (@Qix-) should we be logging these?
		}
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	function load() {
		let r;
		try {
			r = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG') ;
		} catch (error) {
			// Swallow
			// XXX (@Qix-) should we be logging these?
		}

		// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
		if (!r && typeof browser$1$1 !== 'undefined' && 'env' in browser$1$1) {
			r = browser$1$1.env.DEBUG;
		}

		return r;
	}

	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */

	function localstorage() {
		try {
			// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
			// The Browser also has localStorage in the global context.
			return localStorage;
		} catch (error) {
			// Swallow
			// XXX (@Qix-) should we be logging these?
		}
	}

	module.exports = common(exports);

	const {formatters} = module.exports;

	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */

	formatters.j = function (v) {
		try {
			return JSON.stringify(v);
		} catch (error) {
			return '[UnexpectedJSONParseError]: ' + error.message;
		}
	}; 
} (browser, browser.exports));

var browserExports = browser.exports;
browserExports.default;

var debug$6 = {};

const debug$5 = browserExports;

debug$6.createDebug = (namespace) => {
    const log = debug$5(namespace);
    
    return new Proxy(log, {
        apply(target, thisArg, args) {
            commonjsGlobal.__putout_debug?.(namespace, ...args);
            return target(...args);
        },
        get(target, prop) {
            if (commonjsGlobal.__putout_debug?.[prop])
                return true;
            
            return target[prop];
        },
    });
};

const tryCatch$4 = tryCatch$7;
const {createDebug: createDebug$2} = debug$6;

const {stringify: stringify$5} = JSON;

const isFn$4 = (a) => typeof a === 'function';
const getPath$2 = (path) => path.path || path;
const debug$4 = createDebug$2('putout:runner:fix');

const chooseFixArgs = ({path, pathOptions, options}) => {
    if (pathOptions)
        return [
            path,
            pathOptions, {
                options,
            },
        ];
    
    return [
        path, {
            options,
        },
    ];
};

const tryToFix = (fix, {path, pathOptions, position, options}) => {
    const [e] = tryCatch$4(fix, ...chooseFixArgs({
        path,
        pathOptions,
        options,
    }));
    
    const {scope} = path.path || path;
    
    if (!e && scope)
        scope
            .getProgramParent()
            .crawl();
    
    if (!e)
        return;
    
    e.loc = e.loc || position;
    e.reason = 'fix';
    
    throw e;
};

var runFix$3 = (is, fix, {path, pathOptions, rule, position, options}) => {
    if (!is)
        return;
    
    if (debug$4.enabled)
        debug$4(`${rule}:`, position, getPath$2(path).toString());
    
    validate$3('fix', fix);
    
    tryToFix(fix, {
        path,
        pathOptions,
        position,
        options,
    });
};

function validate$3(name, fn) {
    if (!isFn$4(fn))
        throw Error(`☝️ Looks like '${name}' is not a 'function' but '${typeof fn}' with value: '${stringify$5(fn)}'. More on writing 🐊Putout Plugins: https://git.io/JqcMn`);
}

var getPosition$2 = {};

const getPath$1 = (item) => item.path || item[0] || item;

getPosition$2.getPath = getPath$1;
getPosition$2.getPosition = (path, shebang) => {
    const parsedPath = getPath$1(path);
    
    validatePath(parsedPath);
    
    const {node} = parsedPath;
    const {loc} = node;
    
    if (!loc)
        return {
            line: 0,
            column: 0,
        };
    
    const {line, column} = node.loc.start;
    
    return {
        line: shebang ? line + 1 : line,
        column,
    };
};

function validatePath(path) {
    if (!path.node)
        throw Error(`☝️ Looks like 'push' called without a 'path' argument.`);
}

const {isArray: isArray$7} = Array;
const maybeArray$6 = (a) => isArray$7(a) ? a : [a];

var maybeArray_1 = (a) => {
    if (!a)
        return [];
    
    return maybeArray$6(a);
};

var validate$2 = {};

const isFn$3 = (a) => typeof a === 'function';
const {stringify: stringify$4} = JSON;

validate$2.validate = (name, fn) => {
    if (!isFn$3(fn))
        throw Error(`☝️ Looks like '${name}' is not a 'function' but '${typeof fn}' with value: '${stringify$4(fn)}'. More on using Includer: https://git.io/JqcMn`);
};

var store = {};

const {
    values,
    entries: entries$7,
    assign: assign$2,
} = Object;

const toArray = (a) => Array.from(a);
const isNotRemoved = (a) => a.node;
const notRemoved = (a) => toArray(a).filter(isNotRemoved);
const id = (a) => a;

store.listStore = createListStore();
store.pathStore = createListStore(notRemoved);

store.mapStore = createStore({
    get(map) {
        return values(map);
    },
    set(map, name, data) {
        map[name] = data;
    },
});

store.upStore = createStore({
    get(map) {
        return values(map);
    },
    set(map, name, data) {
        map[name] = map[name] || {};
        assign$2(map[name], data);
    },
});

store.upListStore = createStore({
    get(map) {
        return values(map).map(notRemoved);
    },
    set(map, name, data) {
        map[name] = map[name] || new Set();
        map[name].add(data);
    },
});

function createStore({set, get}) {
    return (map = {}) => {
        const fn = (...args) => {
            if (!args.length)
                return get(map);
            
            const [name, data] = args;
            
            if (args.length === 1)
                return map[name];
            
            set(map, name, data);
        };
        
        fn.clear = () => {
            map = {};
        };
        
        fn.entries = () => entries$7(map);
        
        return fn;
    };
}

function createListStore(returns = id) {
    return (list = new Set()) => {
        const fn = (...args) => {
            if (!args.length)
                return returns(toArray(list));
            
            const [a] = args;
            list.add(a);
        };
        
        fn.clear = () => {
            const a = list;
            
            list = new Set();
            
            return returns(toArray(a));
        };
        
        return fn;
    };
}

const {traverse: traverse$7} = bundle;
const {generate: generate$2} = parser$5;

const runFix$2 = runFix$3;
const {getPosition: getPosition$1} = getPosition$2;
const maybeArray$5 = maybeArray_1;
const {validate: validate$1} = validate$2;

const {
    listStore,
    mapStore,
    upStore,
    upListStore,
    pathStore,
} = store;

const {merge: merge$2} = traverse$7.visitors;
const {assign: assign$1} = Object;

const parse$3 = (name, plugin, options) => {
    const list = [];
    
    if (plugin[name]) {
        validate$1(name, plugin[name]);
        list.push(...maybeArray$5(plugin[name]()));
    }
    
    if (options[name])
        list.push(...maybeArray$5(options[name]));
    
    return list;
};

var mergeVisitors$1 = (pluginsToMerge, {fix, shebang, template}) => {
    const mergeItems = [];
    const pushed = {};
    
    for (const {rule, plugin, msg, options} of pluginsToMerge) {
        const {
            push,
            pull,
            store,
            upstore,
            listStore,
            pathStore,
            uplist,
        } = getStore(plugin, {
            fix,
            rule,
            shebang,
            msg,
            options,
        });
        
        pushed[rule] = pull;
        
        const visitor = plugin.traverse({
            push,
            store,
            listStore,
            pathStore,
            upstore,
            uplist,
            generate: generate$2,
            options,
        });
        
        if (!visitor)
            throw Error(`☝️ Visitors cannot be empty in "${rule}"`);
        
        assign$1(options, {
            include: parse$3('include', plugin, options),
            exclude: parse$3('exclude', plugin, options),
        });
        
        mergeItems.push(...template({
            rule,
            visitor,
            options,
        }));
    }
    
    const entries = Object.entries(pushed);
    
    const visitor = merge$2(mergeItems);
    
    return {
        entries,
        visitor,
    };
};

function getStore(plugin, {fix, rule, shebang, msg, options}) {
    const store = mapStore();
    const list = listStore();
    const upstore = upStore();
    const placesStore = listStore();
    const uplist = upListStore();
    const paths = pathStore();
    
    const push = (path, pathOptions) => {
        const position = getPosition$1(path, shebang);
        const message = msg || plugin.report(path, pathOptions);
        
        placesStore({
            message,
            position,
        });
        
        runFix$2(fix, plugin.fix, {
            path,
            pathOptions,
            rule,
            position,
            options,
        });
    };
    
    const pull = () => {
        store.clear();
        list.clear();
        upstore.clear();
        uplist.clear();
        paths.clear();
        
        return placesStore.clear();
    };
    
    return {
        push,
        pull,
        store,
        listStore: list,
        upstore,
        uplist,
        pathStore: paths,
    };
}

mergeVisitors$1.default;

const {traverse: babelTraverse$1, types: types$j} = bundle;

const {generate: generate$1} = parser$5;
const {merge: merge$1} = babelTraverse$1.visitors;

var superFind$1 = function superFind({rule, find, ast, options, template, traverse = babelTraverse$1}) {
    const pushItems = [];
    
    const push = (a) => {
        pushItems.push(a);
    };
    
    const returnItems = find(ast, {
        traverse: createTraverse$1({
            rule,
            options,
            template,
            traverse,
        }),
        generate: generate$1,
        types: types$j,
        push,
        options,
    });
    
    return [
        ...pushItems,
        ...returnItems || [],
    ];
};

const createTraverse$1 = ({rule, options, template, traverse}) => (ast, visitor) => {
    const templateVisitors = merge$1(template({
        rule,
        visitor,
        options,
    }));
    
    return traverse(ast, templateVisitors);
};

superFind$1.default;

var template$8 = {exports: {}};

var compare$5 = {};

var vars = {};

const isString$6 = (a) => typeof a === 'string';
const isUndefined = (a) => typeof a === 'undefined';
const isEmpty = (obj) => !Object.keys(obj).length;

var jessy$1 = (selector, divider, value) => {
    if (!value) {
        value = divider;
        divider = '.';
    }
    
    check$6(selector, value);
    
    if (!selector)
        return value;
    
    if (isEmpty(value))
        return undefined;
    
    const selects = selector
        .split(divider)
        .filter(Boolean);
    
    for (const [i, name] of selects.entries()) {
        const nestedName = selects
            .slice(i)
            .join(divider);
        
        if (!isUndefined(value[nestedName])) {
            value = value[nestedName];
            break;
        }
        
        if (!value[name]) {
            value = undefined;
            break;
        }
        
        value = value[name];
    }
    
    return value;
};

function check$6(selector, obj) {
    if (!isString$6(selector))
        throw Error('selector should be string!');
    
    if (typeof obj !== 'object')
        throw Error('obj should be object!');
}

const isNumber$1 = (a) => !Number.isNaN(a) && typeof a === 'number';
const isNumberLike = (a, b = Number(a)) => isNumber$1(b);
const isString$5 = (a) => typeof a === 'string';
const notSecure = (a) => /__proto__|prototype/.test(a);

var nessy$1 = (selector, value, divider, obj) => {
    if (!obj) {
        obj = divider || {};
        divider = '.';
    }
    
    const result = obj;
    
    check$5(selector);
    
    const array = selector
        .split(divider)
        .filter(Boolean);
    const n = array.length - 1;
    
    for (const [i, name] of array.entries()) {
        if (notSecure(name))
            continue;
        
        if (i === n) {
            obj[name] = value;
        } else if (!obj[name]) {
            const nextKey = array[i + 1];
            
            obj[name] = isNumberLike(nextKey) ? [] : {};
        }

        
        obj = obj[name];
    }
    
    return result;
};

function check$5(selector) {
    if (!isString$5(selector))
        throw Error('selector should be string!');
}

var prepareBodyWay$1 = {};

const TS_MODULE_REG = /\.body\.0\.expression$/;
const CLASS_BODY_REG = /\.body\.0\.key$/;
const BODY_REG = /\.body\.0$/;

prepareBodyWay$1.prepareBodyWay = (way) => {
    return way
        .replace(TS_MODULE_REG, '')
        .replace(CLASS_BODY_REG, '')
        .replace(BODY_REG, '');
};

var is$2 = {};

const {template: template$7} = parser$5;
const {types: types$i} = bundle;
const {
    isBlockStatement: isBlockStatement$1,
    isTSModuleBlock,
    isBooleanLiteral,
    isIdentifier: isIdentifier$4,
    isLiteral: isLiteral$1,
    isTemplateElement: isTemplateElement$2,
    isFunction: isFunction$1,
    isImportDefaultSpecifier,
    isExportSpecifier,
    isRegExpLiteral,
    isJSXText: isJSXText$2,
    isJSXIdentifier: isJSXIdentifier$1,
    isJSXAttribute: isJSXAttribute$1,
    isTSTypeReference: isTSTypeReference$1,
    isTSTypeParameterDeclaration,
} = types$i;

const isStr$1 = (a) => typeof a === 'string';

const ANY_OBJECT = '__object';
const ANY_ARRAY = '__array';
const ARGS = '__args';
const TYPE_PARAMS = '__type_params';
const IMPORTS = '__imports';
const EXPORTS = '__exports';
const BODY = '__body';
const JSX_CHILDREN = '__jsx_children';
const JSX_ATTRIBUTES = '__jsx_attributes';
const NOP = '__nop';
const ANY = '__';
const ID = '__identifier';
const BOOL = '__bool';

const LINKED_NODE = /^__[a-z]$/;
const LINKED_ARGS = /__args__[a-z]$/;
const LINKED_ID = /^__identifier__[a-z]$/;
const LINKED_BOOL = /^__bool__[a-z]$/;

const ALL = [
    ANY_OBJECT,
    ANY_ARRAY,
    ARGS,
    TYPE_PARAMS,
    BOOL,
    JSX_CHILDREN,
    JSX_ATTRIBUTES,
    IMPORTS,
    EXPORTS,
    BODY,
    ANY,
    ID,
    LINKED_NODE,
    LINKED_ARGS,
    LINKED_ID,
    LINKED_BOOL,
];

is$2.isTemplate = (a) => /[(;={.\s]/.test(a) || !/^[A-Z]/.test(a);

is$2.is = (str, array = ALL) => {
    for (const item of array) {
        if (check$4(str, item))
            return true;
    }
    
    return false;
};

function check$4(str, item) {
    if (isStr$1(item))
        return str === item;
    
    return item.test(str);
}

is$2.isNameStr = (a) => LINKED_NODE.test(a);
is$2.isImportsStr = (a) => a === IMPORTS;
is$2.isExportsStr = (a) => a === EXPORTS;
is$2.isArgsStr = (a) => a === ARGS || LINKED_ARGS.test(a);
is$2.isTypeParamsStr = (a) => a === TYPE_PARAMS;
is$2.isJSXChildrenStr = (a) => a === JSX_CHILDREN;
is$2.isJSXAttributesStr = (a) => a === JSX_ATTRIBUTES;
is$2.isObjectStr = (a) => a === ANY_OBJECT;
is$2.isArrayStr = (a) => a === ANY_ARRAY;
is$2.isAnyStr = (a) => a === ANY;
is$2.isBodyStr = (a) => a === BODY;

const isBody = (a) => isIdentifier$4(a, {
    name: BODY,
});

const isFunctionDeclarationBody = (a) => {
    if (isBody(a))
        return true;
    
    if (!isBlockStatement$1(a) && !isTSModuleBlock(a))
        return false;
    
    return isBody(a.body[0].expression);
};

const isNop = (a) => isIdentifier$4(a, {
    name: NOP,
});

const isAnyObject = (a) => isIdentifier$4(a, {
    name: ANY_OBJECT,
});

const isAnyArray = (a) => isIdentifier$4(a, {
    name: ANY_ARRAY,
});

const isId$2 = (a, b) => {
    if (!isIdentifier$4(b, {name: ID}))
        return false;
    
    return isIdentifier$4(a);
};

const isBool$1 = (a, b) => {
    if (!isIdentifier$4(b, {name: BOOL}))
        return false;
    
    return isBooleanLiteral(a);
};

const isEqualType$1 = (a, b) => a.type === b.type;
const {isArray: isArray$6} = Array;

is$2.isId = isId$2;
is$2.isBool = isBool$1;
is$2.isEqualType = isEqualType$1;
is$2.isStr = (a) => typeof a === 'string';
is$2.isAny = (a) => {
    if (isIdentifier$4(a, {name: ANY}))
        return true;
    
    return isJSXText$2(a, {
        value: ANY,
    });
};

is$2.isAnyLiteral = (a, b) => {
    if (!isLiteral$1(b, {value: ANY}))
        return false;
    
    return isEqualType$1(a, b);
};

is$2.isArgs = (a) => {
    const b = !isArray$6(a) ? a : a[0];
    
    return isIdentifier$4(b, {
        name: ARGS,
    });
};

const isTypeParams = (node) => {
    if (!isTSTypeParameterDeclaration(node))
        return false;
    
    const {params} = node;
    const {name} = params[0];
    
    return isIdentifier$4(name, {
        name: TYPE_PARAMS,
    });
};

is$2.isEqualTypeParams = (a, b) => {
    if (!a)
        return false;
    
    if (!isTypeParams(b))
        return false;
    
    return isEqualType$1(a, b);
};

is$2.isLinkedArgs = (a) => {
    const b = !isArray$6(a) ? a : a[0];
    return isIdentifier$4(b) && LINKED_ARGS.test(b.name);
};

is$2.isJSXChildren = (a) => {
    const b = !isArray$6(a) ? a : a[0];
    
    return isJSXText$2(b, {
        value: JSX_CHILDREN,
    });
};

is$2.isJSXAttributes = (a) => {
    const b = !isArray$6(a) ? a : a[0];
    
    if (!isJSXAttribute$1(b))
        return false;
    
    return isJSXIdentifier$1(b.name, {
        name: JSX_ATTRIBUTES,
    });
};

is$2.isLinkedId = (a, b) => {
    if (!isIdentifier$4(b) || !LINKED_ID.test(b.name))
        return false;
    
    return isIdentifier$4(a);
};

is$2.isLinkedBool = (a, b) => {
    if (!isIdentifier$4(b) || !LINKED_BOOL.test(b.name))
        return false;
    
    return isBooleanLiteral(a);
};

is$2.isLinkedRegExp = (a, b) => {
    if (!isRegExpLiteral(b) || !LINKED_NODE.test(b.pattern))
        return false;
    
    return isRegExpLiteral(a);
};

is$2.isPath = (path) => Boolean(path.node);
is$2.isArray = isArray$6;

is$2.isObject = (a) => {
    if (!a)
        return false;
    
    if (isArray$6(a))
        return false;
    
    return typeof a === 'object';
};

is$2.isArrays = (a, b) => {
    if (!isArray$6(a) || !isArray$6(b))
        return false;
    
    return a.length === b.length;
};

is$2.isImports = (a) => {
    const b = !isArray$6(a) ? a : a[0];
    
    if (!isImportDefaultSpecifier(b))
        return false;
    
    return isIdentifier$4(b.local, {
        name: IMPORTS,
    });
};

is$2.isExports = (a) => {
    const b = !isArray$6(a) ? a : a[0];
    
    if (!isExportSpecifier(b))
        return false;
    
    return isIdentifier$4(b.local, {
        name: EXPORTS,
    });
};

const __OBJECT_TYPE = 'ObjectPattern|ObjectExpression';
const __ARRAY_TYPE = 'ArrayPattern|ArrayExpression';

is$2.isEqualAnyArray = (node, templateNode) => {
    if (!isAnyArray(templateNode))
        return false;
    
    const {type} = node;
    
    return __ARRAY_TYPE.includes(type);
};

is$2.isEqualAnyObject = (node, templateNode) => {
    if (!isAnyObject(templateNode))
        return false;
    
    const {type} = node;
    
    return __OBJECT_TYPE.includes(type);
};

is$2.isEqualBody = (node, templateNode) => {
    if (!node)
        return false;
    
    if (!isBody(templateNode))
        return false;
    
    return node.type === 'BlockStatement';
};

is$2.isEqualFunctionDeclarationBody = (node, templateNode) => {
    if (!node)
        return false;
    
    if (!isFunctionDeclarationBody(templateNode))
        return false;
    
    const {type} = node;
    
    return /BlockStatement|TSModuleBlock/.test(type);
};

is$2.isEqualNop = (node, templateNode) => {
    if (!isNop(templateNode))
        return false;
    
    if (!isFunction$1(node))
        return false;
    
    const {body} = node;
    
    if (!isBlockStatement$1(body))
        return false;
    
    return !body.body.length;
};

is$2.isLinkedNode = (a) => {
    if (isIdentifier$4(a) && LINKED_NODE.test(a.name))
        return true;
    
    if (isLiteral$1(a) && LINKED_NODE.test(a.value))
        return true;
    
    if (isJSXText$2(a) && LINKED_NODE.test(a.value))
        return true;
    
    if (isJSXIdentifier$1(a) && LINKED_NODE.test(a.name))
        return true;
    
    if (isTemplateElement$2(a) && LINKED_NODE.test(a.value.raw))
        return true;
    
    return isTSTypeReference$1(a) && LINKED_NODE.test(a.typeName.name);
};

is$2.parseTemplate = (tmpl, {program} = {}) => {
    const parse = !program ? template$7.ast : template$7.program.ast;
    const node = parse(tmpl) || template$7.ast.fresh(tmpl);
    
    if (tmpl === ANY_OBJECT)
        return [node, __OBJECT_TYPE];
    
    if (tmpl === ANY_ARRAY)
        return [node, __ARRAY_TYPE];
    
    const {type} = node;
    
    return [node, type];
};

is$2.isInsideTypeReference = (path) => path.isIdentifier() && path.parentPath?.isTSTypeReference();
is$2.isInsideTypeParameter = (path) => path.isIdentifier() && path.parentPath?.isTSTypeParameter();

const jessy = jessy$1;
const nessy = nessy$1;
const {traverse: traverse$6, types: types$h} = bundle;
const {template: template$6} = parser$5;

const {replaceWith: replaceWith$3, extract} = operate;

const {prepareBodyWay} = prepareBodyWay$1;
const {
    is: is$1,
    isArgsStr,
    isTypeParamsStr,
    isJSXChildrenStr,
    isJSXAttributesStr,
    isImportsStr,
    isExportsStr,
    isInsideTypeReference,
    isInsideTypeParameter,
    isBodyStr,
} = is$2;

const {
    isIdentifier: isIdentifier$3,
    isStatement: isStatement$1,
    isJSXElement: isJSXElement$1,
    isJSXAttribute,
    isStringLiteral: isStringLiteral$3,
    isTemplateLiteral: isTemplateLiteral$1,
    templateElement,
} = types$h;

const {extractExpression: extractExpression$1} = template$6;

const {entries: entries$6} = Object;
const isNumber = (a) => typeof a === 'number';
const isString$4 = (a) => typeof a === 'string';

const parseNode$1 = (a) => a.node || a;
const {stringify: stringify$3} = JSON;

vars.getTemplateValues = (node, str) => {
    if (!isString$4(str))
        throw Error(`☝️ Looks like argument 'template' of 'getTemplateValues(node, template)': is not a string, but '${stringify$3(str)}'`);
    
    node = parseNode$1(node);
    
    const templateNode = template$6.ast(str);
    const waysFrom = findVarsWays$2(templateNode);
    
    return getValues$2({
        node,
        waysFrom,
    });
};

vars.findVarsWays = findVarsWays$2;

function findVarsWays$2(node) {
    if (isIdentifier$3(node) && is$1(node.name))
        return {
            [node.name]: [''],
        };
    
    const vars = {};
    
    traverse$6(node, {
        noScope: true,
        'Identifier|JSXIdentifier|BooleanLiteral|StringLiteral|TemplateElement|RegExpLiteral|JSXText|JSXAttribute|TSTypeReference|TSTypeParameter'(path) {
            if (isInsideTypeReference(path))
                return;
            
            if (isInsideTypeParameter(path))
                return;
            
            const {node} = path;
            
            if (isJSXAttribute(path.parentPath) && path.parentPath.node.name === node)
                return;
            
            const way = [];
            const name = extract(node);
            
            if (!is$1(name))
                return;
            
            path.find(({key, listKey}) => {
                if (isNumber(key)) {
                    way.unshift(`${listKey}.${key}`);
                    return;
                }
                
                way.unshift(key);
            });
            
            vars[name] = vars[name] || [];
            vars[name].push(way.join('.'));
        },
    });
    
    return vars;
}

vars.getValues = getValues$2;

function getValues$2({waysFrom, node}) {
    const result = {};
    
    for (const [name, ways] of entries$6(waysFrom)) {
        for (let way of ways) {
            if (isImportsStr(name) || isExportsStr(name))
                way = way.replace(/\.0.local$/, '');
            else if (isArgsStr(name) || isJSXChildrenStr(name) || isJSXAttributesStr(name) || isTypeParamsStr(name))
                way = way.replace(/\.0$/, '');
            
            if (!isJSXElement$1(node))
                way = way.replace(/\.expression$/, '');
            
            if (isBodyStr(name))
                way = prepareBodyWay(way);
            
            result[name] = result[name] || extractExpression$1(jessy(way, node));
        }
    }
    
    return result;
}

const makeRaw = (a) => a.replace('`', '\\`');

vars.setValues = setValues$2;

function setValues$2({waysTo, values, path}) {
    const node = extractExpression$1(path.node);
    
    for (const [name, ways] of entries$6(waysTo)) {
        for (let way of ways) {
            if (!way) {
                replaceWith$3(path, values[name]);
                continue;
            }
            
            if (isImportsStr(name) || isExportsStr(name))
                way = way.replace(/\.0.local$/, '');
            
            if (isArgsStr(name) || isJSXChildrenStr(name) || isJSXAttributesStr(name))
                way = way.replace(/\.0$/, '');
            
            if (isStatement$1(values[name]))
                way = way.replace(/\.expression$/, '');
            
            if (isStringLiteral$3(values[name]) && isTemplateLiteral$1(node)) {
                const {value} = values[name];
                
                const element = templateElement({
                    raw: makeRaw(value),
                });
                
                nessy(way, element, node);
                continue;
            }
            
            if (isBodyStr(name))
                way = prepareBodyWay(way);
            
            const {extra} = jessy(way, node);
            
            if (extra) {
                const valueExtra = values[name].extra;
                
                values[name].extra = {
                    ...extra,
                    ...valueExtra,
                };
            }
            
            nessy(way, values[name], node);
        }
    }
}

var runComparators$1 = {};

var log$5 = {exports: {}};

const debug$3 = browserExports('putout:compare');

const {isArray: isArray$5} = Array;
const isObject$4 = (a) => a && typeof a === 'object';

log$5.exports = (a, b) => {
    if (!debug$3.enabled)
        return;
    
    const parsedValue = parseValue(a);
    const parsedPathValue = parseValue(b);
    
    return debug$3(`${parsedValue} = ${parsedPathValue}`);
};

log$5.exports._parseValue = parseValue;
function parseValue(a) {
    if (isArray$5(a) && a[0]) {
        const [{
            type,
            name,
            value,
        }] = a;
        
        return `${type}: ["${name || value}"]`;
    }
    
    if (isObject$4(a)) {
        const {
            type,
            name,
            value,
        } = a;
        
        return `${type}: "${name || value}"`;
    }
    
    return `${typeof a}: "${a}"`;
}

var logExports = log$5.exports;

var link$1 = {exports: {}};

const {types: types$g} = bundle;
const {
    isIdentifier: isIdentifier$2,
    isLiteral,
    isStringLiteral: isStringLiteral$2,
    isTemplateElement: isTemplateElement$1,
    isTSTypeReference,
    isJSXText: isJSXText$1,
    isJSXIdentifier,
} = types$g;

const parseName = (node) => {
    node = node[0] || node;
    const {name, value} = node;
    
    if (isIdentifier$2(node) || isJSXIdentifier(node))
        return name;
    
    if (isLiteral(node))
        return value;
    
    if (isTemplateElement$1(node))
        return node.value.cooked;
    
    if (isTSTypeReference(node))
        return node.typeName.name;
    
    if (isJSXText$1(node))
        return node.value;
    
    throw Error(`☝️ Looks like type of node '${node.type}' not supported by 'compare -> link -> parseName()'`);
};

link$1.exports = ({add, value, nodeValue, templateStore}) => {
    const name = parseName(value);
    
    if (isStringLiteral$2(value) && !isStringLiteral$2(nodeValue))
        return false;
    
    if (!templateStore[name]) {
        templateStore[name] = nodeValue;
        return true;
    }
    
    if (isIdentifier$2(templateStore[name]) && isTSTypeReference(nodeValue))
        return true;
    
    add(templateStore[name], nodeValue, {
        plain: true,
    });
    
    return true;
};

link$1.exports._parseName = parseName;

var linkExports = link$1.exports;

var comparePlain$1 = {};

var comparePrimitives$2 = {};

const {is} = is$2;

const isPrimitive = (a) => typeof a !== 'object' || a === null;

comparePrimitives$2.comparePrimitives = (node, template) => {
    return isPrimitive(template) && !is(template) && template === node;
};

const {types: types$f} = bundle;
const {isObject: isObject$3, isArrays: isArrays$1} = is$2;
const {comparePrimitives: comparePrimitives$1} = comparePrimitives$2;

const {isIdentifier: isIdentifier$1} = types$f;

comparePlain$1.comparePlain = (node, template, {add}) => {
    if (!node && node === template)
        return true;
    
    if (!node)
        return false;
    
    if (comparePrimitives$1(node, template))
        return true;
    
    if (isIdentifier$1(node) && node.name === template.name)
        return true;
    
    if (isObject$3(template) && !Array.isArray(template))
        return add(node, template, {
            plain: true,
        });
    
    if (isArrays$1(node, template))
        return add(node, template, {
            plain: true,
        });
    
    return false;
};

const {types: types$e} = bundle;

const log$4 = logExports;
const link = linkExports;

const {
    isId: isId$1,
    isBool,
    isObject: isObject$2,
    isArrays,
    isAny,
    isAnyLiteral,
    isArgs,
    isEqualTypeParams,
    isJSXChildren,
    isJSXAttributes,
    isLinkedArgs,
    isLinkedId: isLinkedId$1,
    isLinkedBool,
    isImports,
    isExports,
    isEqualAnyObject: isEqualAnyObject$1,
    isEqualAnyArray: isEqualAnyArray$1,
    isEqualBody: isEqualBody$1,
    isEqualFunctionDeclarationBody,
    isEqualNop: isEqualNop$1,
    isLinkedNode: isLinkedNode$1,
    isLinkedRegExp: isLinkedRegExp$1,
} = is$2;

const {comparePlain} = comparePlain$1;
const {comparePrimitives} = comparePrimitives$2;

const {
    isClassBody,
    isBlock,
    isJSXText,
    isTemplateElement,
} = types$e;

const isEmptyBlock = (a) => isBlock(a) && !a.body.length;

const second = (f) => (a, b) => f(b);

const comparators$1 = [
    comparePrimitives,
    compareTemplateElements,
    compareJSXTexts,
    compareAny$2,
    second(isClassBody),
    second(isEmptyBlock),
    second(isAny),
    isId$1,
    isBool,
    isEqualAnyArray$1,
    isEqualAnyObject$1,
    isEqualBody$1,
    isEqualFunctionDeclarationBody,
    isEqualNop$1,
    isEqualTypeParams,
    isLinkedRegExp$1,
    linkNodes,
    isAnyLiteral,
    second(isImports),
    second(isExports),
    second(isArgs),
    second(isJSXChildren),
    second(isJSXAttributes),
    addObject,
    compareArrays,
];

runComparators$1.runComparators = (node, template, {add, templateStore, plain}) => {
    let i = -1;
    const n = comparators$1.length;
    
    log$4(template, node);
    
    if (plain)
        return comparePlain(node, template, {
            add,
        });
    
    while (++i < n) {
        const compare = comparators$1[i];
        
        if (compare(node, template, {add, templateStore}))
            return true;
    }
    
    return false;
};

function compareAny$2(node, template) {
    return template === '__';
}

function compareArrays(node, template, {add}) {
    const is = isArrays(node, template);
    
    if (is)
        add(node, template);
    
    return is;
}

function compareTemplateElements(node, template) {
    if (!isTemplateElement(node) || !isTemplateElement(template))
        return false;
    
    const isValue = node.value.raw === template.value.raw;
    const isCooked = node.value.cooked === template.value.cooked;
    const isTail = node.tail === template.tail;
    
    return isValue && isCooked && isTail;
}

function linkNodes(node, template, {add, templateStore}) {
    const is = node
        && (isLinkedNode$1(template)
        || isLinkedArgs(template)
        || isLinkedId$1(node, template)
        || isLinkedBool(node, template));
    
    if (is)
        return link({
            add,
            value: template,
            nodeValue: node,
            templateStore,
        });
    
    return false;
}

function addObject(node, template, {add}) {
    const is = isObject$2(template);
    
    if (is)
        add(node, template);
    
    return is;
}

function compareJSXTexts(node, template) {
    if (!isJSXText(node) || !isJSXText(template))
        return false;
    
    return /^\s+$/.test(template.value) && /^\s+$/.test(node.value);
}

var topLevelComparators = {};

const {types: types$d} = bundle;
const {
    isEqualBody,
    isEqualAnyObject,
    isEqualAnyArray,
    isLinkedNode,
    isLinkedId,
    isLinkedRegExp,
    isEqualNop,
} = is$2;

const {
    isIdentifier,
    isStringLiteral: isStringLiteral$1,
} = types$d;

const comparators = [
    isEqualAnyObject,
    isEqualAnyArray,
    isEqualNop,
    isLinkedAndIdentifier,
    isLinkedAndStringLiteral,
    isLinkedId,
    isLinkedRegExp,
    isEqualBody,
];

topLevelComparators.runTopLevelComparators = (node, templateNode) => {
    let i = -1;
    const n = comparators.length;
    
    while (++i < n) {
        const compare = comparators[i];
        
        if (compare(node, templateNode))
            return true;
    }
    
    return false;
};

function isLinkedAndIdentifier(node, templateNode) {
    return isIdentifier(node) && isLinkedNode(templateNode);
}

function isLinkedAndStringLiteral(node, templateNode) {
    return isStringLiteral$1(node) && isLinkedNode(templateNode);
}

const {template: template$5} = parser$5;

const {
    findVarsWays: findVarsWays$1,
    getValues: getValues$1,
    setValues: setValues$1,
    getTemplateValues: getTemplateValues$1,
} = vars;

const {runComparators} = runComparators$1;
const {runTopLevelComparators} = topLevelComparators;

const {
    isStr,
    isId,
    isPath: isPath$1,
    isEqualType,
    isTemplate: isTemplate$2,
    parseTemplate: parseTemplate$2,
} = is$2;

const {extractExpression} = template$5;
const addWaterMark = (a) => a;

const {keys: keys$2} = Object;
const {isArray: isArray$4} = Array;
const noop$2 = () => {};
const isEmptyArray = (a) => isArray$4(a) && !a.length;

const compareType = (type) => (path) => path.type === type;
const superPush = (array) => (a, b, c = {}) => array.push([a, b, c]);
const maybeArray$4 = (a) => isArray$4(a) ? a : [a];

const findParent = (path, type) => {
    const newPathNode = path.findParent(compareType(type));
    
    if (!newPathNode)
        return null;
    
    return newPathNode.node;
};

function parseNode(a) {
    if (isStr(a))
        return template$5.ast(a);
    
    if (!a.node)
        return a;
    
    return a.node;
}

compare$5.compare = compare$4;
compare$5.parseTemplate = parseTemplate$2;
compare$5.isTemplate = isTemplate$2;

compare$5.findVarsWays = findVarsWays$1;
compare$5.getValues = getValues$1;
compare$5.setValues = setValues$1;
compare$5.getTemplateValues = getTemplateValues$1;

function compare$4(path, template, options = {}, equal = noop$2) {
    const {findUp = true} = options;
    
    if (!path && !template)
        return true;
    
    if (!path)
        return false;
    
    if (!template)
        return false;
    
    const node = addWaterMark(extractExpression(parseNode(path)));
    const templateNode = extractExpression(parseNode(template));
    
    equal(node, templateNode);
    
    if (isId(node, templateNode))
        return true;
    
    if (node.type === template)
        return true;
    
    if (runTopLevelComparators(node, templateNode))
        return true;
    
    if (findUp && isPath$1(path) && !isEqualType(node, templateNode)) {
        const {type} = templateNode;
        const newPathNode = findParent(path, type);
        
        return superCompareIterate(newPathNode, templateNode);
    }
    
    return superCompareIterate(node, templateNode);
}

compare$5.compareAny = (path, templateNodes, options) => {
    templateNodes = maybeArray$4(templateNodes);
    
    for (const template of templateNodes) {
        if (compare$4(path, template, options))
            return true;
    }
    
    return false;
};

compare$5.compareAll = (path, templateNodes, options) => {
    templateNodes = maybeArray$4(templateNodes);
    
    for (const template of templateNodes) {
        if (!compare$4(path, template, options))
            return false;
    }
    
    return true;
};

// @babel/template creates empty array directives
// extra duplicate value
const ignore$2 = [
    'loc',
    'start',
    'end',
    'directives',
    'extra',
    'raw',
    'comments',
    'leadingComments',
    'innerComments',
    'parent',
    'phase',
    'range',
    'trailingComments',
    'importKind',
    'exportKind',
    '__putout_runner_replace',
];

function superCompareIterate(node, template) {
    let item = [node, template];
    
    const array = [item];
    const templateStore = {};
    const add = superPush(array);
    
    while (item = array.pop()) {
        const [node, template, {plain} = {}] = item;
        
        if (!node || isEmptyArray(node) && !isEmptyArray(template))
            return false;
        
        for (const key of keys$2(template)) {
            if (ignore$2.includes(key))
                continue;
            
            const nodeValue = extractExpression(node[key]);
            const value = extractExpression(template[key]);
            
            const is = runComparators(nodeValue, value, {
                add,
                templateStore,
                plain,
            });
            
            if (!is)
                return false;
        }
    }
    
    return true;
}

const tryCatch$3 = tryCatch$7;

const {
    compareAny: compareAny$1,
    compareAll,
    parseTemplate: parseTemplate$1,
    isTemplate: isTemplate$1,
} = compare$5;

const maybeArray$3 = maybeArray_1;
const {createDebug: createDebug$1} = debug$6;
const debug$2 = createDebug$1('putout:runner:template');

const {entries: entries$5} = Object;
const isFn$2 = (a) => typeof a === 'function';

const log$3 = (rule, path) => {
    debug$2.enabled && debug$2(rule, path.toString());
};

const {stringify: stringify$2} = JSON;

template$8.exports._log = log$3;

const exclude = ({rule, tmpl, fn, nodesExclude}) => {
    if (!isFn$2(fn) || !nodesExclude.length)
        return {
            [tmpl]: fn,
        };
    
    const visit = wrapWithCheck({
        rule,
        fn,
        nodesExclude,
        nodesInclude: [],
    });
    
    return {
        [tmpl]: visit,
    };
};

template$8.exports = ({rule, visitor, options}) => {
    const parsed = [];
    const nodesExclude = maybeArray$3(options.exclude);
    const nodesInclude = maybeArray$3(options.include);
    
    for (const [tmpl, fn] of entries$5(visitor)) {
        if (!tmpl)
            continue;
        
        if (!isTemplate$1(tmpl)) {
            parsed.push(exclude({
                rule,
                tmpl,
                fn,
                nodesExclude,
            }));
            continue;
        }
        
        const [node, type] = parseTemplate$1(tmpl);
        
        const visit = wrapWithCheck({
            rule,
            fn,
            nodesExclude,
            nodesInclude: [
                node,
                ...nodesInclude,
            ],
        });
        
        parsed.push({
            [type]: visit,
        });
    }
    
    return parsed;
};

template$8.exports._log = log$3;

const wrapWithCheck = ({rule, nodesInclude, nodesExclude, fn}) => (path) => {
    log$3(rule, path);
    
    if (nodesExclude.length && compareAny$1(path, nodesExclude))
        return;
    
    if (nodesInclude.length && !compareAll(path, nodesInclude))
        return;
    
    if (!isFn$2(fn))
        throw Error(`☝️ Looks like provided visitor is not a function: ${stringify$2(fn)}. More on using Traverser: https://git.io/JqcMn`);
    
    const [e] = tryCatch$3(fn, path);
    
    if (e) {
        e.rule = rule;
        throw e;
    }
};

var templateExports = template$8.exports;

var progress = {};

var domain;

// This constructor is used to store event handlers. Instantiating this is
// faster than explicitly calling `Object.create(null)` to get a "clean" empty
// object (tested with v8 v4.9).
function EventHandlers() {}
EventHandlers.prototype = Object.create(null);

function EventEmitter$1() {
  EventEmitter$1.init.call(this);
}

// nodejs oddity
// require('events') === require('events').EventEmitter
EventEmitter$1.EventEmitter = EventEmitter$1;

EventEmitter$1.usingDomains = false;

EventEmitter$1.prototype.domain = undefined;
EventEmitter$1.prototype._events = undefined;
EventEmitter$1.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter$1.defaultMaxListeners = 10;

EventEmitter$1.init = function() {
  this.domain = null;
  if (EventEmitter$1.usingDomains) {
    // if there is an active domain, then attach to it.
    if (domain.active && !(this instanceof domain.Domain)) {
      this.domain = domain.active;
    }
  }

  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter$1.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter$1.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter$1.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter$1.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events, domain;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no 'error' event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] :
                                          [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
                            existing.length + ' ' + type + ' listeners added. ' +
                            'Use emitter.setMaxListeners() to increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }

  return target;
}
function emitWarning(e) {
  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
}
EventEmitter$1.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;

EventEmitter$1.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}

EventEmitter$1.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter$1.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// emits a 'removeListener' event iff the listener was removed
EventEmitter$1.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || (list.listener && list.listener === listener)) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length; i-- > 0;) {
          if (list[i] === listener ||
              (list[i].listener && list[i].listener === listener)) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (list.length === 1) {
          list[0] = undefined;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };
    
// Alias for removeListener added in NodeJS 10.0
// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener
EventEmitter$1.prototype.off = function(type, listener){
    return this.removeListener(type, listener);
};

EventEmitter$1.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        for (var i = 0, key; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        do {
          this.removeListener(type, listeners[listeners.length - 1]);
        } while (listeners[0]);
      }

      return this;
    };

EventEmitter$1.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === 'function')
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }

  return ret;
};

EventEmitter$1.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter$1.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter$1.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, i) {
  var copy = new Array(i);
  while (i--)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

var _polyfillNode_events = /*#__PURE__*/Object.freeze({
	__proto__: null,
	EventEmitter: EventEmitter$1,
	default: EventEmitter$1
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_events);

const {EventEmitter} = require$$0;

progress.createProgress = () => {
    let pluginsCount = 0;
    let pluginsIndex = 0;
    
    const progress = new EventEmitter();
    
    progress.reset = () => {
        pluginsIndex = 0;
        pluginsCount = 0;
    };
    
    progress.file = ({i, n, percent, rule}) => {
        progress.emit('file', {
            i,
            n,
            rule,
            percent,
        });
    };
    
    progress.inc = () => {
        ++pluginsCount;
    };
    
    progress.start = (rule) => {
        ++pluginsIndex;
        progress.emit('start', {
            pluginsIndex,
            pluginsCount,
            rule,
        });
    };
    
    progress.push = (rule) => {
        progress.emit('push', {
            pluginsIndex,
            pluginsCount,
            rule,
        });
    };
    
    progress.end = (rule) => {
        progress.emit('end', {
            rule,
            pluginsIndex,
            pluginsCount,
        });
    };
    
    return progress;
};

var tryThrowWithReason$1 = {};

const tryCatch$2 = tryCatch$7;

tryThrowWithReason$1.tryThrowWithReason = (fn, ...args) => {
    const [error, result] = tryCatch$2(fn, ...args);
    
    if (error) {
        error.reason ??= 'traverse';
        throw error;
    }
    
    return result;
};

var includer = {};

const log$2 = browserExports('putout:runner:include');
const maybeArray$2 = maybeArray_1;
const {validate} = validate$2;

const stub$1 = () => [];
const good = () => true;

includer.include = ({rule, plugin, msg, options}) => {
    const {
        fix,
        report,
        include,
        exclude = stub$1,
        filter = good,
    } = plugin;
    
    validate('include', include);
    validate('report', report);
    
    const traverse = getTraverse$1(include(), filter, rule);
    
    return {
        rule,
        msg,
        options: {
            ...options,
            exclude: [
                ...exclude(),
                ...maybeArray$2(options.exclude),
            ],
        },
        plugin: {
            report,
            fix,
            traverse,
        },
    };
};

const prePush = ({rule, filter, push, options}) => (path) => {
    log$2(rule);
    
    if (!filter(path, {options}))
        return;
    
    push(path);
};

const getTraverse$1 = (include, filter, rule) => ({push, options}) => {
    const result = {};
    const visitor = prePush({
        rule,
        filter,
        push,
        options,
    });
    
    for (const str of include)
        result[str] = visitor;
    
    return result;
};

var replacer = {};

var watermark$1 = {exports: {}};

const wrap = (fn) => (...a) => (...b) => fn(...a, ...b);

var wraptile$1 = (fn, ...a) => {
    check$3(fn);
    
    if (a.length)
        return wrap(fn)(...a);
    
    return wrap(fn);
};

function check$3(fn) {
    if (typeof fn !== 'function')
        throw Error('fn should be a function!');
}

const {entries: entries$4} = Object;
const {isArray: isArray$3} = Array;

var findPath$1 = (parentPath) => {
    let current = {
        parentPath,
    };
    
    const path = [];
    
    while (current = current.parentPath) {
        path.unshift(findKey(current, current.parent));
    }
    
    return path.join('.');
};

function findKey(path, parent) {
    const {node} = path;
    let key;
    let value;
    
    for ([key, value] of entries$4(parent)) {
        if (isArray$3(value)) {
            const index = value.indexOf(node);
            
            if (index >= 0)
                return `${key}.${index}`;
            
            continue;
        }
        
        if (value === node)
            break;
    }
    
    return key;
}

const wraptile = wraptile$1;

const {types: types$c} = bundle;
const findPath = findPath$1;

const {isProgram: isProgram$2} = types$c;
const name = '__putout_runner_replace';
const hasWatermark = (watermark) => (path) => path.node?.[name]?.has(watermark);

watermark$1.exports = (from, to, path) => {
    const {watermark, highWatermark} = create(from, to, path);
    const program = path.findParent(isProgram$2);
    const options = {
        watermark,
        highWatermark,
        program,
        path,
    };
    
    return {
        init: wraptile(init$1, options),
        has: wraptile(has, options),
        add: wraptile(add, options),
    };
};

watermark$1.exports.REPLACE_WATERMARK = name;

watermark$1.exports.create = create;
function create(from, to, path) {
    const watermark = `${from} -> ${to}`;
    const highWatermark = `${findPath(path)}: ${watermark}`;
    
    return {
        watermark,
        highWatermark,
    };
}

watermark$1.exports.init = init$1;
function init$1({path, program}) {
    if (path.node)
        path.node[name] = path.node[name] || new Set();
    
    program.node[name] = program.node[name] || new Set();
}

watermark$1.exports.add = add;
function add({path, program, watermark, highWatermark}) {
    init$1({
        path,
        program,
    });
    
    path?.node[name].add(watermark);
    program.node[name].add(highWatermark);
}

watermark$1.exports.has = has;
function has({path, program, watermark, highWatermark}) {
    const {node} = path;
    const {loc} = node;
    
    if (node?.[name].has(watermark) || path.findParent(hasWatermark(watermark)) && !loc)
        return true;
    
    return program.node[name].has(highWatermark);
}

var watermarkExports = watermark$1.exports;

const {template: template$4, print: print$2} = parser$5;
const {remove, replaceWith: replaceWith$2} = operate;
const {types: types$b} = bundle;

const {
    compare: compare$3,
    findVarsWays,
    getValues,
    setValues,
} = compare$5;

const maybeArray$1 = maybeArray_1;
const watermark = watermarkExports;
const {createDebug} = debug$6;
const debug$1 = createDebug('putout:runner:replace');

const log$1 = (from, path) => {
    debug$1.enabled && debug$1(`${from} -> ${path}\n`);
};

const {
    isExpression,
    isStatement,
    isExpressionStatement,
} = types$b;

const PRINT_OPTIONS = {
    printer: ['putout', {
        format: {
            newline: '',
            indent: '',
            splitter: ' ',
            endOfFile: '',
        },
    }],
};

const isString$3 = (a) => typeof a === 'string';

const {keys: keys$1, entries: entries$3} = Object;
const {stringify: stringify$1} = JSON;

const stub = () => [];
const stubMatch = () => ({});
const packKeys = (a) => () => keys$1(a);
const isObject$1 = (a) => typeof a === 'object';

replacer.replace = ({rule, plugin, msg, options}) => {
    const maybeMatch = plugin.match || stubMatch;
    const match = maybeMatch({
        options,
    });
    
    const {
        report,
        exclude = stub,
        replace,
        filter = getFilter(match),
    } = plugin;
    
    const replaceItems = replace({
        options,
    });
    
    const fix = getFix(replaceItems, match);
    const include = packKeys(replaceItems);
    
    return {
        rule,
        msg,
        options: {
            ...options,
            exclude: [
                ...exclude(),
                ...maybeArray$1(options.exclude),
            ],
        },
        plugin: {
            report,
            fix,
            filter,
            include,
        },
    };
};

replacer.clearWatermark = (ast) => {
    delete ast.program[watermark.REPLACE_WATERMARK];
};

const isFn$1 = (a) => typeof a === 'function';

const parseExpression = (nodeFrom, {node}) => {
    if (nodeFrom.type !== node.type && isExpressionStatement(node))
        return node.expression;
    
    return node;
};

const fix$4 = (from, to, path) => {
    const nodeFrom = template$4.ast(from);
    const mark = watermark(from, to, path);
    
    mark.init();
    
    if (mark.has())
        return;
    
    const waysFrom = findVarsWays(nodeFrom);
    const node = parseExpression(nodeFrom, path);
    
    const values = getValues({
        waysFrom,
        node,
    });
    
    const nodeTo = parseTo(to, values, path);
    
    if (!nodeTo) {
        log$1(from, `''`);
        return remove(path);
    }
    
    checkExpressionStatement(nodeFrom, nodeTo, path);
    
    const waysTo = findVarsWays(nodeTo);
    const newPath = replaceWith$2(path, nodeTo);
    
    if (!nodeTo.__putout_replace_cooked) {
        validateTemplateValues(waysTo, waysFrom);
        
        setValues({
            waysTo,
            values,
            path: newPath,
        });
    }
    
    mark.add();
    path.scope
        .getBlockParent()
        .crawl();
    
    log$1(from, newPath);
};

const getFix = (items, match) => (path) => {
    for (const [from, to] of entries$3(items)) {
        const nodeFrom = template$4.ast(from);
        
        if (compare$3(path, nodeFrom, {findUp: false})) {
            const matchFn = match[from];
            
            if (!matchFn || runMatch(path, nodeFrom, matchFn))
                fix$4(from, to, path);
        }
    }
};

const getFilter = (match) => (path) => {
    const all = entries$3(match);
    
    for (const [from, matchProperty] of all) {
        const nodeFrom = template$4.ast(from);
        
        if (!compare$3(path.node, nodeFrom, {findUp: false}))
            continue;
        
        return runMatch(path, nodeFrom, matchProperty);
    }
    
    return true;
};

function runMatch(path, nodeFrom, matchProperty) {
    const waysFrom = findVarsWays(nodeFrom);
    const {node} = path;
    
    const values = getValues({
        waysFrom,
        node,
    });
    
    validateMatchProperty(matchProperty);
    
    return matchProperty(values, path);
}

function parseTo(to, values, path) {
    const toStr = isFn$1(to) ? to(values, path) : to;
    
    if (!toStr)
        return null;
    
    if (isObject$1(toStr) && toStr.type) {
        toStr.__putout_replace_cooked = true;
        return toStr;
    }
    
    if (!isString$3(toStr))
        throw Error(`☝️ Looks like you passed 'replace' value with a wrong type. Allowed: 'string', 'node' and 'path'. Received: '${typeof toStr}' with value '${toStr}'.`);
    
    return template$4.ast.fresh(toStr);
}

function validateMatchProperty(match) {
    if (!isFn$1(match))
        throw Error(`☝️ Looks like 'match' property value is not a 'function', but '${typeof match}' with value '${match}'.`);
}

const validateTemplateValues = (a, b) => {
    for (const key of keys$1(a)) {
        if (!b[key])
            throw Error(`☝️ Looks like template values not linked: ${stringify$1(keys$1(b))} -> ${stringify$1(keys$1(a))}`);
    }
};

function checkExpressionStatement(nodeFrom, nodeTo, path) {
    if (!isExpression(nodeFrom))
        return;
    
    if (!isStatement(nodeTo) || isExpressionStatement(nodeTo))
        return;
    
    if (isExpressionStatement(path) || isExpressionStatement(path.parentPath))
        return;
    
    throw Error(`☝️ Looks like a try to put Statement in place of Expression, use 'match' to filter out such cases: '${print$2(nodeFrom, PRINT_OPTIONS)} -> ${print$2(nodeTo, PRINT_OPTIONS)}'. For code: '${path}'`);
}

var declarator = {};

var declare$1 = {};

var record = {};

const prefix = '__putout_declare_undefined_variables';
const getProgramParentPath = (path) => path.scope.getProgramParent().path;

const maybeInit = (a, b) => b[a] = b[a] || {};

record.checkDeclarationForESLint = (name, path) => {
    const programPath = getProgramParentPath(path);
    maybeInit(prefix, programPath);
    
    return programPath[prefix][name];
};

record.addDeclarationForESLint = (name, path) => {
    const programPath = getProgramParentPath(path);
    maybeInit(prefix, programPath);
    
    return programPath[prefix][name] = true;
};

record.setModuleType = (type, path) => {
    const programPath = getProgramParentPath(path);
    maybeInit(prefix, programPath);
    
    programPath[prefix].__putout_module_type = type;
    
    return type;
};

record.getModuleType = (path) => {
    const programPath = getProgramParentPath(path);
    maybeInit(prefix, programPath);
    
    return programPath[prefix].__putout_module_type;
};

const {template: template$3} = parser$5;
const {isESM, insertAfter} = operate;

const {compare: compare$2} = compare$5;

const {types: types$a} = bundle;

const {
    addDeclarationForESLint,
    checkDeclarationForESLint,
    getModuleType,
    setModuleType,
} = record;

const {
    isImportDeclaration,
    isVariableDeclaration,
} = types$a;

const {keys} = Object;
const isString$2 = (a) => typeof a === 'string';

const getLastVarPath = (bodyPath) => bodyPath
    .filter(isVariableDeclaration)
    .pop();

const isLast = (insertionPath, bodyPath) => bodyPath.at(-1) === insertionPath;
const isLocalImport = (path) => path.node.source.value.includes('.');

const cutName = (a) => a
    .split('.')
    .shift();

const parseType = (path) => isESM(path) ? 'esm' : 'commonjs';

const TS_EXCLUDE = [
    'TSMethodSignature',
    'TSParameterProperty',
    'TSFunctionType',
    'TSDeclareMethod',
    'TSDeclareFunction',
    'TSTypeAliasDeclaration',
    'TSQualifiedName',
];

declare$1.declare = (declarations) => ({
    report: report$4,
    include: include$1,
    fix: fix$3(declarations),
    filter: filter(declarations),
});

const report$4 = (path) => {
    const {name} = path.node;
    const peaceOfName = cutName(name);
    
    return `Declare '${peaceOfName}', it referenced but not defined`;
};

const include$1 = () => [
    'ReferencedIdentifier',
];

const filter = (declarations) => (path, {options}) => {
    if (TS_EXCLUDE.includes(path.parentPath.type))
        return false;
    
    const {dismiss = [], type: typeOverride} = options;
    
    const allDeclarations = {
        ...declarations,
        ...options.declarations,
    };
    
    const names = keys(allDeclarations);
    const {scope, node} = path;
    const {name} = node;
    
    if (!names.includes(name))
        return false;
    
    if (dismiss.includes(name))
        return false;
    
    if (scope.hasBinding(name) || checkDeclarationForESLint(name, path))
        return false;
    
    const type = computeType(path, typeOverride);
    
    return parseCode(type, allDeclarations[name]);
};

const fix$3 = (declarations) => (path, {options}) => {
    const type = getModuleType(path);
    
    const allDeclarations = {
        ...declarations,
        ...options.declarations,
    };
    
    const {name} = path.node;
    const code = parseCode(type, allDeclarations[name]);
    
    const scope = path.scope.getProgramParent();
    const programPath = scope.path;
    const bodyPath = programPath.get('body');
    
    const node = template$3.ast.fresh(code);
    
    insert(node, bodyPath);
    addDeclarationForESLint(name, path);
};

const parseCode = (type, current) => {
    if (isString$2(current))
        return current;
    
    return current[type];
};

function getInsertionPath(node, bodyPath) {
    const lastImportPath = getLastImportPath(bodyPath);
    const lastVarPath = getLastVarPath(bodyPath);
    
    if (isVariableDeclaration(node) && lastImportPath)
        return lastImportPath;
    
    if ((isImportDeclaration(node) || isRequire(node)) && lastImportPath)
        return lastImportPath;
    
    if (isVariableDeclaration(node) && lastVarPath && !isLast(lastVarPath, bodyPath))
        return lastVarPath;
    
    return null;
}

const isRequire = (node) => compare$2(node, 'const __a = require(__b)');

function insert(node, bodyPath) {
    const insertionPath = getInsertionPath(node, bodyPath);
    const [first] = bodyPath;
    
    if (isVariableDeclaration(node) && isImportDeclaration(insertionPath) || isRequire(insertionPath))
        return insertAfter(insertionPath, node);
    
    if (isVariableDeclaration(node)) {
        if (isRequire(first))
            return first.insertAfter(node);
        
        return first.insertBefore(node);
    }
    
    if (!insertionPath)
        return first.insertBefore(node);
    
    if (insertionPath.isImportDeclaration() && isLocalImport(insertionPath))
        return insertionPath.insertBefore(node);
    
    return insertAfter(insertionPath, node);
}

const getLastImportPath = (bodyPath) => {
    const imports = [];
    const localImports = [];
    
    for (const path of bodyPath) {
        if (!path.isImportDeclaration())
            continue;
        
        if (isLocalImport(path)) {
            localImports.push(path);
            continue;
        }
        
        imports.push(path);
    }
    
    return imports.pop() || localImports.pop();
};

function computeType(path, type) {
    if (type)
        return setModuleType(type, path);
    
    const newType = getModuleType(path);
    
    if (newType)
        return newType;
    
    return setModuleType(parseType(path), path);
}

const {declare: index} = declare$1;

const {stringify} = JSON;
const isFn = (a) => typeof a === 'function';

declarator.declare = ({rule, plugin, msg, options}) => {
    validateDeclare(plugin.declare);
    
    return {
        rule,
        plugin: index(plugin.declare()),
        msg,
        options,
    };
};

function validateDeclare(declare) {
    if (!isFn(declare))
        throw Error(`☝️ Looks like 'declare' property value is not a 'function', but '${typeof declare}' with value '${stringify(declare)}'.`);
}

var scanner = {};

var filesystem = {};

var maybeFs = {};

const fullstore$1 = fullstore$3;
const driverStore = fullstore$1();

const {assign} = Object;
const noop$1 = () => {};
const returns = (a) => () => a;

const defaultFS = {
    renameFile: noop$1,
    removeFile: noop$1,
    createDirectory: noop$1,
    readFileContent: returns(''),
    writeFileContent: noop$1,
    copyFile: noop$1,
};

const maybeFS$1 = assign({}, defaultFS);

maybeFs.renameFile = (oldName, newName) => {
    maybeFS$1.renameFile(oldName, newName);
};

maybeFs.removeFile = (name) => {
    maybeFS$1.removeFile(name);
};

maybeFs.copyFile = (from, to) => {
    maybeFS$1.copyFile(from, to);
};

maybeFs.createDirectory = (name) => {
    maybeFS$1.createDirectory(name);
};

maybeFs.readFileContent = (name) => {
    return maybeFS$1.readFileContent(name);
};

maybeFs.writeFileContent = (name, content) => {
    maybeFS$1.writeFileContent(name, content);
};

maybeFs.init = init;

function init(fsDriver) {
    assign(maybeFS$1, fsDriver);
}

maybeFs.pause = () => {
    driverStore(maybeFS$1);
    deinit();
};

maybeFs.start = () => {
    init(driverStore());
};

maybeFs.deinit = deinit;

function deinit() {
    assign(maybeFS$1, defaultFS);
}

var property = {};

const {types: types$9} = bundle;
const {
    arrayExpression: arrayExpression$2,
    stringLiteral: stringLiteral$3,
    objectProperty: objectProperty$2,
} = types$9;

property.createTypeProperty = (type) => {
    const value = stringLiteral$3(type);
    return createProperty$1('type', value);
};

property.createFilesProperty = (files) => {
    const value = arrayExpression$2(files);
    return createProperty$1('files', value);
};

property.createFilenameProperty = (filename) => {
    const value = stringLiteral$3(filename);
    return createProperty$1('filename', value);
};

property.createContentProperty = (content) => {
    const value = stringLiteral$3(content);
    return createProperty$1('content', value);
};

function createProperty$1(name, value) {
    const key = stringLiteral$3(name);
    return objectProperty$2(key, value);
}

const {
    join: join$2,
    basename: basename$1,
    dirname: dirname$1,
} = require$$0$1;

const {types: types$8} = bundle;
const tryCatch$1 = tryCatch$7;

const {
    setLiteralValue: setLiteralValue$1,
    getProperty: getProperty$2,
    traverseProperties: traverseProperties$1,
} = operate;

const maybeFS = maybeFs;

const {
    createTypeProperty,
    createFilesProperty,
    createFilenameProperty,
    createContentProperty,
} = property;

const {
    isProgram: isProgram$1,
    objectExpression: objectExpression$1,
} = types$8;

const isString$1 = (a) => typeof a === 'string';
const {isArray: isArray$2} = Array;
const maybeArray = (a) => isArray$2(a) ? a : [a];

const toBase64 = (content) => {
    const [e, result] = tryCatch$1(btoa, content);
    
    if (e)
        return btoa(escape(content));
    
    return result;
};

const fromBase64 = (content) => {
    if (content.includes(' '))
        return content;
    
    const [e, decoded] = tryCatch$1(atob, content);
    
    if (!e)
        return unescape(decoded);
    
    return content;
};

const getRegExp = (wildcard) => {
    const escaped = wildcard
        .replace(/\./g, '\\.')
        .replace(/\*/g, '.*')
        .replace('?', '.?');
    
    return RegExp(`^${escaped}$`);
};

filesystem.getParentDirectory = getParentDirectory$2;

function getParentDirectory$2(filePath) {
    if (!filePath.parentPath)
        return null;
    
    const {parentPath} = filePath.parentPath.parentPath;
    
    if (isProgram$1(parentPath))
        return null;
    
    return parentPath;
}

filesystem.findFile = findFile$5;

function isExcluded({name, base, exclude}) {
    for (const currentExclude of exclude) {
        if (name === currentExclude || getRegExp(currentExclude).test(base))
            return true;
    }
    
    return false;
}

function findFile$5(node, name, exclude = []) {
    checkName(name);
    
    const filePaths = [];
    const names = maybeArray(name);
    
    for (const filenamePath of traverseProperties$1(node, 'filename')) {
        const {value} = filenamePath.node.value;
        const base = basename$1(value);
        
        for (const name of names) {
            if (value === name || getRegExp(name).test(base)) {
                const path = filenamePath.parentPath;
                const excluded = isExcluded({
                    name,
                    base,
                    exclude,
                });
                
                if (excluded)
                    continue;
                
                filePaths.push(path);
            }
        }
    }
    
    return filePaths;
}

function checkName(name) {
    if (!isString$1(name) && !isArray$2(name))
        throw Error(`☝️ Looks like you forget to pass the 'name' of a file to 'findFile(filePath: Path|FilePath, name: string | string[]): FilePath'`);
}

function getFilenamePath(filePath) {
    const filenamePath = getProperty$2(filePath, 'filename');
    return filenamePath.get('value');
}

function getFilename$4(filePath) {
    const {value} = getFilenamePath(filePath).node;
    return value;
}

filesystem.getFileType = getFileType$2;

function getFileType$2(filePath) {
    const typePath = getProperty$2(filePath, 'type');
    return typePath.node.value.value;
}

filesystem.getFileContent = getFileContent;

function getFileContent(filePath) {
    const content = getProperty$2(filePath, 'content');
    
    return [
        Boolean(content),
        content?.node.value.value,
    ];
}

filesystem.getFilename = getFilename$4;

filesystem.renameFile = (filePath, name) => {
    const oldName = getFilename$4(filePath);
    const valuePath = getFilenamePath(filePath);
    const baseName = oldName
        .split('/')
        .pop();
    
    const newName = name
        .split('/')
        .pop();
    
    const newFilename = oldName.replace(baseName, newName);
    
    setLiteralValue$1(valuePath, newFilename);
    maybeFS.renameFile(oldName, newFilename);
};

filesystem.removeFile = removeFile$1;
function removeFile$1(filePath) {
    const filename = getFilename$4(filePath);
    
    if (!getParentDirectory$2(filePath))
        return;
    
    filePath.remove();
    maybeFS.removeFile(filename);
}

filesystem.removeEmptyDirectory = (dirPath) => {
    const type = getFileType$2(dirPath);
    
    if (type !== 'directory')
        return;
    
    let nextParentDir = dirPath;
    
    while (!readDirectory(dirPath).length) {
        const name = getFilename$4(dirPath);
        
        if (name === '/')
            break;
        
        nextParentDir = getParentDirectory$2(dirPath);
        
        if (!nextParentDir)
            break;
        
        removeFile$1(dirPath);
        dirPath = nextParentDir;
    }
};

filesystem.moveFile = (filePath, dirPath) => {
    if (filePath === dirPath)
        return;
    
    const dirname = getFilename$4(dirPath);
    const filename = getFilename$4(filePath);
    const dirPathFiles = getFiles$1(dirPath);
    const filenamePath = getProperty$2(filePath, 'filename');
    
    const basename = filename
        .split('/')
        .pop();
    
    const newFilename = join$2(dirname, basename);
    
    maybeRemoveFile(dirPath, newFilename);
    
    setLiteralValue$1(filenamePath.get('value'), newFilename);
    dirPathFiles.node.value.elements.push(filePath.node);
    
    filePath.remove();
    maybeFS.renameFile(filename, newFilename);
};

filesystem.copyFile = (filePath, dirPath) => {
    const dirname = getFilename$4(dirPath);
    const filename = getFilename$4(filePath);
    
    const basename = filename
        .split('/')
        .pop();
    
    const newFilename = join$2(dirname, basename);
    const [hasContent, content] = getFileContent(filePath);
    
    const copiedFile = objectExpression$1([
        createTypeProperty('file'),
        createFilenameProperty(newFilename),
        hasContent && createContentProperty(content),
    ].filter(Boolean));
    
    maybeRemoveFile(dirPath, newFilename);
    
    const dirPathFiles = getFiles$1(dirPath);
    dirPathFiles.node.value.elements.push(copiedFile);
    
    maybeFS.copyFile(filename, newFilename);
};

function maybeRemoveFile(dirPath, filename) {
    const type = getFileType$2(dirPath);
    
    if (type !== 'directory') {
        const filename = getFilename$4(dirPath);
        throw Error(`☝️ Looks like '${filename}' is not a directory, but: '${type}'. Rename to '${filename}/'`);
    }
    
    const dirPathFiles = getProperty$2(dirPath, 'files');
    const name = join$2(getFilename$4(dirPath), basename$1(filename));
    const [fileToOverwrite] = findFile$5(dirPathFiles, name);
    
    if (!fileToOverwrite)
        return;
    
    fileToOverwrite.remove();
}

filesystem.createFile = (dirPath, name, content) => {
    maybeRemoveFile(dirPath, name);
    
    const dirPathFiles = getFiles$1(dirPath);
    const parentFilename = getFilename$4(dirPath);
    const filename = join$2(parentFilename, name);
    
    const typeProperty = createTypeProperty('file');
    const filenameProperty = createFilenameProperty(filename);
    
    const properties = [
        typeProperty,
        filenameProperty,
        content && createContentProperty(content),
    ].filter(Boolean);
    
    dirPathFiles.node.value.elements.push(objectExpression$1(properties));
    
    const filePath = dirPathFiles.get('value.elements').at(-1);
    
    if (isString$1(content))
        writeFileContent$1(filePath, content);
    
    return filePath;
};

const getFiles$1 = (dirPath) => getProperty$2(dirPath, 'files');

filesystem.readDirectory = readDirectory;
function readDirectory(dirPath) {
    const fileType = getFileType$2(dirPath);
    
    if (fileType !== 'directory')
        return [];
    
    return getFiles$1(dirPath).get('value.elements');
}

filesystem.createDirectory = createDirectory$1;

function createDirectory$1(dirPath, name) {
    const dirPathFiles = getFiles$1(dirPath);
    const parentFilename = getFilename$4(dirPath);
    const filename = join$2(parentFilename, name);
    
    const typeProperty = createTypeProperty('directory');
    const filesProperty = createFilesProperty([]);
    const filenameProperty = createFilenameProperty(filename);
    
    dirPathFiles.node.value.elements.push(objectExpression$1([
        typeProperty,
        filenameProperty,
        filesProperty,
    ]));
    
    maybeFS.createDirectory(filename);
    
    return dirPathFiles.get('value.elements').at(-1);
}

filesystem.readFileContent = (filePath) => {
    const fileType = getFileType$2(filePath);
    
    if (fileType === 'directory')
        return '';
    
    const [hasContent, content] = getFileContent(filePath);
    
    if (hasContent)
        return fromBase64(content);
    
    const filename = getFilename$4(filePath);
    const fileContent = maybeFS.readFileContent(filename);
    
    const property = createContentProperty(toBase64(fileContent));
    
    filePath.node.properties.push(property);
    
    return fileContent;
};

filesystem.writeFileContent = writeFileContent$1;

function writeFileContent$1(filePath, content) {
    const fileType = getFileType$2(filePath);
    
    if (fileType === 'directory')
        return;
    
    const filename = getFilename$4(filePath);
    
    maybeFS.writeFileContent(filename, content);
    
    const contentPath = getProperty$2(filePath, 'content');
    
    if (contentPath) {
        setLiteralValue$1(contentPath.node.value, toBase64(content));
        return;
    }
    
    const property = createContentProperty(toBase64(content));
    filePath.node.properties.push(property);
}

filesystem.createNestedDirectory = (path, name) => {
    const rootPath = getRootDirectory(path);
    const dir = dirname$1(name);
    
    if (dir === getFilename$4(path))
        return createDirectory$1(path, basename$1(name));
    
    let currentDir = name;
    
    const rootDir = getFilename$4(rootPath);
    const directories = [];
    let prevDir = currentDir;
    
    while (currentDir !== rootDir) {
        directories.unshift(currentDir);
        prevDir = currentDir;
        currentDir = dirname$1(currentDir);
        
        if (currentDir === prevDir) {
            currentDir = rootDir;
            
            for (const [i, dir] of directories.entries()) {
                directories[i] = join$2(rootDir, dir);
            }
            
            directories.shift();
            break;
        }
    }
    
    let lastDirectoryPath = findFile$5(rootPath, directories).at(-1) || rootPath;
    const lastDirectoryName = getFilename$4(lastDirectoryPath);
    
    const n = directories.length;
    
    let i = directories.indexOf(lastDirectoryName) + 1;
    
    for (; i < n; i++) {
        const name = basename$1(directories[i]);
        lastDirectoryPath = createDirectory$1(lastDirectoryPath, name);
    }
    
    return lastDirectoryPath;
};

filesystem.getRootDirectory = getRootDirectory;
function getRootDirectory(path) {
    let currentDirPath = getParentDirectory$2(path);
    
    if (!currentDirPath)
        return path;
    
    let prevPath = currentDirPath;
    
    while (currentDirPath = getParentDirectory$2(currentDirPath)) {
        prevPath = currentDirPath;
    }
    
    return prevPath;
}

filesystem.init = maybeFS.init;
filesystem.deinit = maybeFS.deinit;

filesystem.pause = maybeFS.pause;
filesystem.start = maybeFS.start;

var convertSimpleFilesystemToFilesystem = {};

const {basename, dirname} = require$$0$1;
const {types: types$7} = bundle;
const {
    createDirectory,
    getFileType: getFileType$1,
    getFilename: getFilename$3,
    findFile: findFile$4,
} = filesystem;

const {__filesystem_name: __filesystem_name$2} = json;
const {replaceWith: replaceWith$1, getProperty: getProperty$1} = operate;

const {
    objectExpression,
    arrayExpression: arrayExpression$1,
    stringLiteral: stringLiteral$2,
    isArrayExpression,
    isStringLiteral,
    isTemplateLiteral,
    objectProperty: objectProperty$1,
} = types$7;

convertSimpleFilesystemToFilesystem.report = () => `Convert Simple Filesystem to Filesystem`;

const isDirectory = (a) => a.endsWith('/');
const getType = (a) => {
    const type = isDirectory(a) ? 'directory' : 'file';
    
    return objectProperty$1(stringLiteral$2('type'), stringLiteral$2(type));
};

const createFilename = (filename) => {
    return objectProperty$1(stringLiteral$2('filename'), stringLiteral$2(filename));
};

const getFiles = (a) => {
    if (isDirectory(a))
        return objectProperty$1(stringLiteral$2('files'), arrayExpression$1([]));
    
    return null;
};

const getContent = (a) => {
    return objectProperty$1(stringLiteral$2('content'), stringLiteral$2(a));
};

function parseContent(node, path) {
    if (isStringLiteral(node))
        return node.value;
    
    if (isTemplateLiteral(node))
        return btoa(node.quasis[0].value.raw);
    
    throw Error(`☝️ Looks like wrong content type: '${node.type}' from file: '${path}'`);
}

convertSimpleFilesystemToFilesystem.fix = (path) => {
    const array = arrayExpression$1([]);
    
    for (const element of path.get('elements')) {
        if (isArrayExpression(element)) {
            const [nodeValue, nodeContent] = element.node.elements;
            const {value} = nodeValue;
            
            const content = parseContent(nodeContent, element);
            
            array.elements.push(objectExpression([
                getType(value),
                createFilename(value),
                getContent(content),
            ]));
            continue;
        }
        
        if (isStringLiteral(element)) {
            const {value} = element.node;
            
            array.elements.push(objectExpression([
                getType(value),
                createFilename(noTrailingSlash(value)),
                getFiles(value),
            ].filter(Boolean)));
            continue;
        }
        
        throw Error(`☝️ Looks like file '${element}' has wrong type: '${element.type}' expected: 'string | array'`);
    }
    
    buildTree(path, array);
};

convertSimpleFilesystemToFilesystem.traverse = ({push}) => ({
    [`${__filesystem_name$2}(__array)`]: (path) => {
        const root = path.get('arguments.0');
        push(root);
    },
});

const noTrailingSlash = (a) => {
    if (a === '/')
        return a;
    
    return a.endsWith('/') ? a.slice(0, -1) : a;
};

function buildTree(path, list) {
    const [root, ...files] = findFile$4(list, '*');
    
    for (const filePath of files) {
        const filename = getFilename$3(filePath);
        
        check$2(filename);
        
        const type = getFileType$1(filePath);
        const dir = dirname(filename);
        const name = basename(filename);
        const [dirPath] = findFile$4(root, dir);
        
        if (!dirPath || getFileType$1(dirPath) !== 'directory')
            throw Error(`☝️ Looks like directory '${dir}/' is missing`);
        
        if (type === 'directory') {
            createDirectory(dirPath, name);
            continue;
        }
        
        const filesProperty = getProperty$1(dirPath, 'files');
        filesProperty.node.value.elements.push(filePath.node);
    }
    
    replaceWith$1(path, root);
}

function check$2(filename) {
    if (!filename.includes('/'))
        throw Error(`☝️ Looks like directory path is missing: '${filename}'`);
}

var convertFilesystemToSimpleFilesystem = {};

const {types: types$6} = bundle;
const {replaceWith, getProperty} = operate;
const {__filesystem_name: __filesystem_name$1} = json;

const {
    findFile: findFile$3,
    getFilename: getFilename$2,
    getFileType,
} = filesystem;

const {
    stringLiteral: stringLiteral$1,
    arrayExpression,
} = types$6;

const {isArray: isArray$1} = Array;
const maybeAddSlash = (a) => a === '/' ? a : `${a}/`;

convertFilesystemToSimpleFilesystem.report = () => `Convert Filesystem to Simple Filesystem`;

convertFilesystemToSimpleFilesystem.fix = (root, {files}) => {
    const names = [];
    
    for (const file of files) {
        const filename = getFilename$2(file);
        const type = getFileType(file);
        const contentPath = getProperty(file, 'content');
        const content = contentPath?.node?.value;
        
        if (content) {
            names.push([filename, content.value]);
            continue;
        }
        
        if (type === 'directory') {
            names.push(maybeAddSlash(filename));
            continue;
        }
        
        names.push(filename);
    }
    
    const list = [];
    
    for (const name of names) {
        if (isArray$1(name)) {
            list.push(arrayExpression([
                stringLiteral$1(name[0]),
                stringLiteral$1(name[1]),
            ]));
            continue;
        }
        
        list.push(stringLiteral$1(name));
    }
    
    replaceWith(root, arrayExpression(list));
};

convertFilesystemToSimpleFilesystem.traverse = ({push}) => ({
    [`${__filesystem_name$1}(__object)`]: (path) => {
        const root = path.get('arguments.0');
        const files = findFile$3(root, '*');
        
        push(root, {
            files,
        });
    },
});

const fullstore = fullstore$3;
const {compare: compare$1} = compare$5;
const {__filesystem_name} = json;

const {
    findFile: findFile$2,
    pause,
    start,
} = filesystem;

const log = browserExports('putout:runner:scanner');

const fromSimple = convertSimpleFilesystemToFilesystem;
const toSimple = convertFilesystemToSimpleFilesystem;

scanner.scan = ({rule, plugin, msg, options}, {progress}) => {
    const {
        scan,
        report,
        fix,
    } = plugin;
    
    progress.inc();
    
    const traverse = getTraverse({
        scan,
        rule,
        progress,
    });
    
    return {
        rule,
        msg,
        options,
        plugin: {
            report,
            fix,
            traverse,
        },
    };
};

const watchPush = ({push, rule, progress}) => (...a) => {
    progress.push(rule);
    push(...a);
};

const createFileProgress = ({rule, progress}) => ({i, n}) => {
    ++i;
    const percent = `${Math.round(i / n * 100)}%`;
    
    progress.file({
        i,
        n,
        percent,
        rule,
    });
};

const createTrackFile = (fileProgress) => function*(...a) {
    const files = findFile$2(...a);
    const n = files.length;
    
    for (const [i, file] of files.entries()) {
        fileProgress({
            i,
            n,
        });
        yield file;
    }
};

const getTraverse = ({scan, rule, progress}) => ({push, options}) => ({
    [`${__filesystem_name}(__)`](path) {
        log(rule);
        progress.start(rule);
        
        const rootPath = path.get('arguments.0');
        const isSimple = fullstore(false);
        
        const fileProgress = createFileProgress({
            rule,
            progress,
        });
        
        const trackFile = createTrackFile(fileProgress);
        
        runSimple(fromSimple, {
            shouldConvert: true,
            path,
            isSimple,
        });
        
        scan(rootPath, {
            push: watchPush({
                push,
                rule,
                progress,
            }),
            progress: fileProgress,
            trackFile,
            options,
        });
        
        runSimple(toSimple, {
            shouldConvert: isSimple(),
            path,
            isSimple,
        });
        
        progress.end(rule);
    },
});

const runFix$1 = ({fix, isSimple}) => (...a) => {
    isSimple(true);
    return fix(...a);
};

function runSimple(plugin, {path, isSimple, shouldConvert = true}) {
    const {traverse, fix} = plugin;
    
    if (!shouldConvert)
        return;
    
    const push = runFix$1({
        fix,
        isSimple,
    });
    
    const visitors = traverse({
        push,
    });
    
    const [visit, template] = parseVisitor(visitors);
    
    if (compare$1(path, template)) {
        pause();
        visit(path);
        start();
    }
}

function parseVisitor(visitors) {
    const to = visitors[`${__filesystem_name}(__object)`];
    const from = visitors[`${__filesystem_name}(__array)`];
    
    if (to)
        return [
            to,
            `${__filesystem_name}(__object)`,
        ];
    
    return [
        from,
        `${__filesystem_name}(__array)`,
    ];
}

const {traverse: defaultTraverse} = bundle;
const once = onceExports;
const debug = browserExports('putout:runner:find');

const runFix = runFix$3;
const mergeVisitors = mergeVisitors$1;
const superFind = superFind$1;
const template$2 = templateExports;
const {createProgress: createProgress$1} = progress;
const {tryThrowWithReason} = tryThrowWithReason$1;

const {include} = includer;
const {replace, clearWatermark} = replacer;
const {declare} = declarator;
const {scan: scan$1} = scanner;

const {getPath, getPosition} = getPosition$2;

const isRemoved = (a) => a?.removed;

lib.runPlugins = ({ast, shebang, fix, fixCount = 2, plugins, progress = createProgress$1(), traverse = defaultTraverse}) => {
    let places = [];
    
    const merge = once(mergeVisitors);
    const {
        pluginsFind,
        pluginsTraverse,
    } = splitPlugins(plugins, {
        progress,
    });
    
    for (let i = 0; i < fixCount; i++) {
        places = run({
            ast,
            fix,
            shebang,
            pluginsFind,
            pluginsTraverse,
            merge,
            template: template$2,
            traverse,
        });
        
        progress.reset();
        
        if (!fix || !places.length)
            return places;
        
        clearWatermark(ast);
    }
    
    return places;
};

lib.getPosition = getPosition;

const run = ({ast, fix, shebang, pluginsFind, pluginsTraverse, template, merge, traverse}) => [
    ...runWithoutMerge({
        ast,
        fix,
        shebang,
        template,
        pluginsFind,
        traverse,
    }),
    ...runWithMerge({
        ast,
        fix,
        shebang,
        template,
        pluginsTraverse,
        merge,
        traverse,
    }),
];

function runWithMerge({ast, fix, shebang, template, pluginsTraverse, merge, traverse}) {
    const {entries, visitor} = merge(pluginsTraverse, {
        fix,
        shebang,
        template,
    });
    
    tryThrowWithReason(traverse, ast, visitor);
    
    const places = [];
    
    for (const [rule, pull] of entries) {
        const items = pull();
        
        for (const {message, position} of items) {
            places.push({
                rule,
                message,
                position,
            });
        }
    }
    
    return places;
}

function runWithoutMerge({ast, fix, shebang, template, pluginsFind, traverse}) {
    const places = [];
    
    for (const {rule, plugin, msg, options} of pluginsFind) {
        debug(`find: ${rule}`);
        
        const {report, find} = plugin;
        
        const items = tryThrowWithReason(superFind, {
            rule,
            find,
            ast,
            options,
            fix,
            shebang,
            template,
            traverse,
        });
        
        if (!items.length)
            continue;
        
        for (const item of items) {
            const message = msg || report(item);
            const {parentPath} = getPath(item);
            const position = getPosition(item, shebang);
            
            places.push({
                rule,
                message,
                position,
            });
            
            if (isRemoved(parentPath))
                continue;
            
            runFix(fix, plugin.fix, {
                path: item,
                rule,
                position,
                options,
            });
        }
    }
    
    return places;
}

function splitPlugins(plugins, {progress}) {
    const pluginsFind = [];
    const pluginsTraverse = [];
    
    for (const item of plugins) {
        const {plugin} = item;
        
        if (plugin.find) {
            pluginsFind.push(item);
            continue;
        }
        
        if (plugin.traverse) {
            pluginsTraverse.push(item);
            continue;
        }
        
        if (plugin.replace) {
            pluginsTraverse.push(include(replace(item)));
            continue;
        }
        
        if (plugin.declare) {
            pluginsTraverse.push(include(declare(item)));
            continue;
        }
        
        if (plugin.include) {
            pluginsTraverse.push(include(item));
            continue;
        }
        
        if (plugin.scan) {
            pluginsTraverse.push(scan$1(item, {
                progress,
            }));
            continue;
        }
    }
    
    return {
        pluginsFind,
        pluginsTraverse,
    };
}

const loader = lib$1;
const runner = lib;
const {createProgress} = progress;

defaultOptions$4.defaultOptions = (opts = {}) => {
    const {
        parser = 'babel',
        printer = opts.printer || 'putout',
        fix = true,
        fixCount = 3,
        loadPlugins = loader.loadPlugins,
        loadPluginsAsync = loader.loadPluginsAsync,
        runPlugins = runner.runPlugins,
        progress = createProgress(),
    } = opts;
    
    return {
        ...opts,
        parser,
        printer,
        fix,
        fixCount,
        loadPlugins,
        loadPluginsAsync,
        runPlugins,
        progress,
    };
};

var transform$5 = {};

var parseError$2 = (e, type = 'parser') => {
    const {line, column} = e.loc || {
        line: 1,
        column: 1,
    };
    
    const rule = e.rule ? `${e.rule} (parser)` : type;
    const message = cutBrackets(e.message);
    
    return [{
        rule,
        message,
        position: {
            line,
            column,
        },
    }];
};

const cutBrackets = (a) => a.replace(/\s\(\d:\d+\)/, '');

const tryCatch = tryCatch$7;

const {validateRulesRelations} = lib$1;
const {defaultOptions: defaultOptions$1} = defaultOptions$4;
const {cutShebang: cutShebang$1} = shebang;
const parseError$1 = parseError$2;

const maybeParseError = (a) => !a ? [] : parseError$1(a, 'loader');

// why we pass 'source' to 'transform()'?
// because we need to calculate position in a right way
// and determine is shebang is existing
//
// 25     return {¬
// 26         line: shebang ? line + 1 : line,¬
// 27         column,¬
// 28     };¬
//
transform$5.transform = (ast, source, opts) => {
    opts = defaultOptions$1(opts);
    
    const {
        plugins: pluginNames,
        cache,
        rules,
        fix,
        fixCount,
        loadPlugins,
        runPlugins,
        progress,
    } = opts;
    
    const [, shebang] = cutShebang$1(source);
    
    const [validationError] = tryCatch(validateRulesRelations, {
        rules,
        pluginNames,
    });
    
    const plugins = loadPlugins({
        pluginNames,
        cache,
        rules,
    });
    
    const places = runPlugins({
        ast,
        shebang,
        fix,
        fixCount,
        plugins,
        progress,
    });
    
    return [
        ...maybeParseError(validationError),
        ...places,
    ];
};

transform$5.transformAsync = async (ast, source, opts) => {
    opts = defaultOptions$1(opts);
    
    const {
        plugins: pluginNames,
        cache,
        rules,
        fix,
        fixCount,
        loadPluginsAsync,
        runPlugins,
        progress,
    } = opts;
    
    const [, shebang] = cutShebang$1(source);
    
    const [validationError] = tryCatch(validateRulesRelations, {
        rules,
        pluginNames,
    });
    
    const plugins = await loadPluginsAsync({
        pluginNames,
        cache,
        rules,
    });
    
    const places = runPlugins({
        ast,
        shebang,
        fix,
        fixCount,
        plugins,
        progress,
    });
    
    return [
        ...maybeParseError(validationError),
        ...places,
    ];
};

var findPlaces$2 = {};

const {transform: transform$4, transformAsync: transformAsync$1} = transform$5;

findPlaces$2.findPlaces = (ast, source, opts) => {
    return transform$4(ast, source, {
        ...opts,
        fix: false,
    });
};

findPlaces$2.findPlacesAsync = async (ast, source, opts) => {
    return await transformAsync$1(ast, source, {
        ...opts,
        fix: false,
    });
};

const {isArray} = Array;
const noop = () => {};

var report$3 = () => {
    let filesCount = 0;
    let errorsCount = 0;
    
    return async (formatter, options) => {
        const {
            name,
            rule,
            source,
            places,
            index = 0,
            count = 1,
            trace = noop,
            formatterOptions = {},
        } = options;
        
        if (!isArray(places))
            throw Error(`☝️ Looks like for 'places: Places[]' you passed the wrong type: '${typeof places}'`);
        
        if (places.length)
            ++filesCount;
        
        errorsCount += places.length;
        
        trace('progress', {
            rule,
            name,
            options: formatterOptions,
            source,
            places,
            index,
            count,
            filesCount,
            errorsCount,
        });
        
        return await formatter({
            rule,
            name,
            options: formatterOptions,
            source,
            places,
            index,
            count,
            filesCount,
            errorsCount,
        });
    };
};

report$3.default;

var traverse$5 = {};

const {types: types$5, traverse: babelTraverse} = bundle;

const {
    compare,
    parseTemplate,
    isTemplate,
    getTemplateValues,
} = compare$5;

const {isFile, isProgram} = types$5;
const {merge} = babelTraverse.visitors;
const {entries: entries$2} = Object;

traverse$5.traverse = traverse$4;

const isPath = (path) => Boolean(path.node);
const createTraverse = (path) => {
    if (isPath(path))
        return path.traverse.bind(path);
    
    const noScope = !isFile(path) && !isProgram(path);
    
    return (visitors) => {
        babelTraverse(path, {
            noScope,
            ...visitors,
        });
    };
};

const getTemplate = ([a]) => a;

function traverse$4(basePath, visitor) {
    const traverse = createTraverse(basePath);
    const items = [];
    const parsedVisitors = entries$2(visitor);
    
    const withTemplates = parsedVisitors
        .map(getTemplate)
        .find(isTemplate);
    
    if (!withTemplates)
        return traverse(visitor);
    
    for (const [tmpl, fn] of parsedVisitors) {
        if (!isTemplate(tmpl)) {
            items.push({
                [tmpl]: fn,
            });
            continue;
        }
        
        const [node, type] = parseTemplate(tmpl);
        const visit = getVisit({
            fn,
            node,
            tmpl,
        });
        
        items.push({
            [type]: visit,
        });
    }
    
    traverse(merge(items));
}

const getVisit = ({fn, node, tmpl}) => (path) => {
    if (!compare(path, node))
        return;
    
    fn(path, getTemplateValues(path.node, tmpl));
};

traverse$5.contains = (path, items) => {
    let found = false;
    
    const visit = (path) => {
        found = true;
        path.stop();
    };
    
    const visitors = {};
    
    for (const item of items) {
        visitors[item] = visit;
    }
    
    traverse$4(path, visitors);
    
    return found;
};

var jsx = {};

const {setLiteralValue} = operate;
const {types: types$4} = bundle;
const {isJSXElement} = types$4;

jsx.hasTagName = (path, name) => {
    const node = path.node || path;
    
    if (!isJSXElement(path))
        return false;
    
    return node.openingElement.name.name === name;
};

jsx.getAttributePath = (path, name) => {
    const attributes = path.get('openingElement.attributes');
    
    for (const attr of attributes) {
        if (attr.node.name.name === name)
            return attr;
    }
    
    return null;
};

jsx.getAttributeNode = getAttributeNode;
function getAttributeNode(path, name) {
    let result = null;
    
    if (!path)
        return result;
    
    const node = path.node || path;
    const {attributes} = node.openingElement;
    
    for (const attr of attributes) {
        if (attr.name.name === name) {
            result = attr;
            break;
        }
    }
    
    return result;
}

jsx.getAttributeValue = getAttributeValue;
function getAttributeValue(path, attributeName) {
    const attribute = getAttributeNode(path, attributeName);
    
    if (!attribute)
        return '';
    
    return attribute.value.value;
}
jsx.addAttributeValue = addAttributeValue;
function addAttributeValue(path, name, value) {
    const attributeNode = getAttributeNode(path, name);
    
    if (attributeNode.value.value.includes(value))
        return;
    
    setLiteralValue(attributeNode.value, `${attributeNode.value.value} ${value}`);
}
jsx.removeAttributeValue = removeAttributeValue;
function removeAttributeValue(path, name, attributeValue) {
    if (!path)
        return;
    
    const node = path.node || path;
    const classAttribute = getAttributeNode(node, name);
    
    const {value} = classAttribute.value;
    
    if (value.includes(attributeValue))
        setLiteralValue(classAttribute.value, value.replace(RegExp(`\\s?${attributeValue}`), ''));
}
jsx.setAttributeValue = (node, name, value) => {
    const attributeNode = getAttributeNode(node, name);
    
    if (attributeNode)
        setLiteralValue(attributeNode.value, value);
};

jsx.addClassName = (path, name) => {
    addAttributeValue(path, 'className', name);
};

jsx.getClassName = getClassName;
function getClassName(path) {
    return getAttributeValue(path, 'className');
}

jsx.removeClassName = (path, name) => {
    removeAttributeValue(path, 'className', name);
};

jsx.containsClassName = (path, className) => {
    const classNameValue = getClassName(path);
    return classNameValue.includes(className);
};

jsx.hasDataName = (path, value = '') => {
    const attribute = getAttributeValue(path, 'data-name');
    return attribute === value;
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to translate `/./s` to `/[\0-\uFFFF]/`.
 */

var compatDotallSTransform = {

  // Whether `u` flag present. In which case we transform to
  // \u{10FFFF} instead of \uFFFF.
  _hasUFlag: false,

  // Only run this plugin if we have `s` flag.
  shouldRun: function shouldRun(ast) {
    var shouldRun = ast.flags.includes('s');

    if (!shouldRun) {
      return false;
    }

    // Strip the `s` flag.
    ast.flags = ast.flags.replace('s', '');

    // Whether we have also `u`.
    this._hasUFlag = ast.flags.includes('u');

    return true;
  },
  Char: function Char(path) {
    var node = path.node;


    if (node.kind !== 'meta' || node.value !== '.') {
      return;
    }

    var toValue = '\\uFFFF';
    var toSymbol = '\uFFFF';

    if (this._hasUFlag) {
      toValue = '\\u{10FFFF}';
      toSymbol = '\uDBFF\uDFFF';
    }

    path.replace({
      type: 'CharacterClass',
      expressions: [{
        type: 'ClassRange',
        from: {
          type: 'Char',
          value: '\\0',
          kind: 'decimal',
          symbol: '\0'
        },
        to: {
          type: 'Char',
          value: toValue,
          kind: 'unicode',
          symbol: toSymbol
        }
      }]
    });
  }
};

compatDotallSTransform.default;

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to translate `/(?<name>a)\k<name>/` to `/(a)\1/`.
 */

var compatNamedCapturingGroupsTransform = {
  // To track the names of the groups, and return them
  // in the transform result state.
  //
  // A map from name to number: {foo: 2, bar: 4}
  _groupNames: {},

  /**
   * Initialises the trasnform.
   */
  init: function init() {
    this._groupNames = {};
  },


  /**
   * Returns extra state, which eventually is returned to
   */
  getExtra: function getExtra() {
    return this._groupNames;
  },
  Group: function Group(path) {
    var node = path.node;


    if (!node.name) {
      return;
    }

    // Record group name.
    this._groupNames[node.name] = node.number;

    delete node.name;
    delete node.nameRaw;
  },
  Backreference: function Backreference(path) {
    var node = path.node;


    if (node.kind !== 'name') {
      return;
    }

    node.kind = 'number';
    node.reference = node.number;
    delete node.referenceRaw;
  }
};

compatNamedCapturingGroupsTransform.default;

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to remove `x` flag `/foo/x` to `/foo/`.
 *
 * Note: other features of `x` flags (whitespace, comments) are
 * already removed at parsing stage.
 */

var compatXFlagTransform = {
  RegExp: function RegExp(_ref) {
    var node = _ref.node;

    if (node.flags.includes('x')) {
      node.flags = node.flags.replace('x', '');
    }
  }
};

compatXFlagTransform.default;

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var transforms$1 = {
  // "dotAll" `s` flag
  dotAll: compatDotallSTransform,

  // Named capturing groups.
  namedCapturingGroups: compatNamedCapturingGroupsTransform,

  // `x` flag
  xFlag: compatXFlagTransform
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * Helper `gen` function calls node type handler.
 */

function gen$1(node) {
  return node ? generator$3[node.type](node) : '';
}

/**
 * AST handler.
 */
var generator$3 = {
  RegExp: function RegExp(node) {
    return '/' + gen$1(node.body) + '/' + node.flags;
  },
  Alternative: function Alternative(node) {
    return (node.expressions || []).map(gen$1).join('');
  },
  Disjunction: function Disjunction(node) {
    return gen$1(node.left) + '|' + gen$1(node.right);
  },
  Group: function Group(node) {
    var expression = gen$1(node.expression);

    if (node.capturing) {
      // A named group.
      if (node.name) {
        return '(?<' + (node.nameRaw || node.name) + '>' + expression + ')';
      }

      return '(' + expression + ')';
    }

    return '(?:' + expression + ')';
  },
  Backreference: function Backreference(node) {
    switch (node.kind) {
      case 'number':
        return '\\' + node.reference;
      case 'name':
        return '\\k<' + (node.referenceRaw || node.reference) + '>';
      default:
        throw new TypeError('Unknown Backreference kind: ' + node.kind);
    }
  },
  Assertion: function Assertion(node) {
    switch (node.kind) {
      case '^':
      case '$':
      case '\\b':
      case '\\B':
        return node.kind;

      case 'Lookahead':
        {
          var assertion = gen$1(node.assertion);

          if (node.negative) {
            return '(?!' + assertion + ')';
          }

          return '(?=' + assertion + ')';
        }

      case 'Lookbehind':
        {
          var _assertion = gen$1(node.assertion);

          if (node.negative) {
            return '(?<!' + _assertion + ')';
          }

          return '(?<=' + _assertion + ')';
        }

      default:
        throw new TypeError('Unknown Assertion kind: ' + node.kind);
    }
  },
  CharacterClass: function CharacterClass(node) {
    var expressions = node.expressions.map(gen$1).join('');

    if (node.negative) {
      return '[^' + expressions + ']';
    }

    return '[' + expressions + ']';
  },
  ClassRange: function ClassRange(node) {
    return gen$1(node.from) + '-' + gen$1(node.to);
  },
  Repetition: function Repetition(node) {
    return '' + gen$1(node.expression) + gen$1(node.quantifier);
  },
  Quantifier: function Quantifier(node) {
    var quantifier = void 0;
    var greedy = node.greedy ? '' : '?';

    switch (node.kind) {
      case '+':
      case '?':
      case '*':
        quantifier = node.kind;
        break;
      case 'Range':
        // Exact: {1}
        if (node.from === node.to) {
          quantifier = '{' + node.from + '}';
        }
        // Open: {1,}
        else if (!node.to) {
            quantifier = '{' + node.from + ',}';
          }
          // Closed: {1,3}
          else {
              quantifier = '{' + node.from + ',' + node.to + '}';
            }
        break;
      default:
        throw new TypeError('Unknown Quantifier kind: ' + node.kind);
    }

    return '' + quantifier + greedy;
  },
  Char: function Char(node) {
    var value = node.value;

    switch (node.kind) {
      case 'simple':
        {
          if (node.escaped) {
            return '\\' + value;
          }
          return value;
        }

      case 'hex':
      case 'unicode':
      case 'oct':
      case 'decimal':
      case 'control':
      case 'meta':
        return value;

      default:
        throw new TypeError('Unknown Char kind: ' + node.kind);
    }
  },
  UnicodeProperty: function UnicodeProperty(node) {
    var escapeChar = node.negative ? 'P' : 'p';
    var namePart = void 0;

    if (!node.shorthand && !node.binary) {
      namePart = node.name + '=';
    } else {
      namePart = '';
    }

    return '\\' + escapeChar + '{' + namePart + node.value + '}';
  }
};

var generator_1 = {
  /**
   * Generates a regexp string from an AST.
   *
   * @param Object ast - an AST node
   */
  generate: gen$1
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var NON_BINARY_PROP_NAMES_TO_ALIASES = {
  General_Category: 'gc',
  Script: 'sc',
  Script_Extensions: 'scx'
};

var NON_BINARY_ALIASES_TO_PROP_NAMES = inverseMap(NON_BINARY_PROP_NAMES_TO_ALIASES);

var BINARY_PROP_NAMES_TO_ALIASES = {
  ASCII: 'ASCII',
  ASCII_Hex_Digit: 'AHex',
  Alphabetic: 'Alpha',
  Any: 'Any',
  Assigned: 'Assigned',
  Bidi_Control: 'Bidi_C',
  Bidi_Mirrored: 'Bidi_M',
  Case_Ignorable: 'CI',
  Cased: 'Cased',
  Changes_When_Casefolded: 'CWCF',
  Changes_When_Casemapped: 'CWCM',
  Changes_When_Lowercased: 'CWL',
  Changes_When_NFKC_Casefolded: 'CWKCF',
  Changes_When_Titlecased: 'CWT',
  Changes_When_Uppercased: 'CWU',
  Dash: 'Dash',
  Default_Ignorable_Code_Point: 'DI',
  Deprecated: 'Dep',
  Diacritic: 'Dia',
  Emoji: 'Emoji',
  Emoji_Component: 'Emoji_Component',
  Emoji_Modifier: 'Emoji_Modifier',
  Emoji_Modifier_Base: 'Emoji_Modifier_Base',
  Emoji_Presentation: 'Emoji_Presentation',
  Extended_Pictographic: 'Extended_Pictographic',
  Extender: 'Ext',
  Grapheme_Base: 'Gr_Base',
  Grapheme_Extend: 'Gr_Ext',
  Hex_Digit: 'Hex',
  IDS_Binary_Operator: 'IDSB',
  IDS_Trinary_Operator: 'IDST',
  ID_Continue: 'IDC',
  ID_Start: 'IDS',
  Ideographic: 'Ideo',
  Join_Control: 'Join_C',
  Logical_Order_Exception: 'LOE',
  Lowercase: 'Lower',
  Math: 'Math',
  Noncharacter_Code_Point: 'NChar',
  Pattern_Syntax: 'Pat_Syn',
  Pattern_White_Space: 'Pat_WS',
  Quotation_Mark: 'QMark',
  Radical: 'Radical',
  Regional_Indicator: 'RI',
  Sentence_Terminal: 'STerm',
  Soft_Dotted: 'SD',
  Terminal_Punctuation: 'Term',
  Unified_Ideograph: 'UIdeo',
  Uppercase: 'Upper',
  Variation_Selector: 'VS',
  White_Space: 'space',
  XID_Continue: 'XIDC',
  XID_Start: 'XIDS'
};

var BINARY_ALIASES_TO_PROP_NAMES = inverseMap(BINARY_PROP_NAMES_TO_ALIASES);

var GENERAL_CATEGORY_VALUE_TO_ALIASES = {
  Cased_Letter: 'LC',
  Close_Punctuation: 'Pe',
  Connector_Punctuation: 'Pc',
  Control: ['Cc', 'cntrl'],
  Currency_Symbol: 'Sc',
  Dash_Punctuation: 'Pd',
  Decimal_Number: ['Nd', 'digit'],
  Enclosing_Mark: 'Me',
  Final_Punctuation: 'Pf',
  Format: 'Cf',
  Initial_Punctuation: 'Pi',
  Letter: 'L',
  Letter_Number: 'Nl',
  Line_Separator: 'Zl',
  Lowercase_Letter: 'Ll',
  Mark: ['M', 'Combining_Mark'],
  Math_Symbol: 'Sm',
  Modifier_Letter: 'Lm',
  Modifier_Symbol: 'Sk',
  Nonspacing_Mark: 'Mn',
  Number: 'N',
  Open_Punctuation: 'Ps',
  Other: 'C',
  Other_Letter: 'Lo',
  Other_Number: 'No',
  Other_Punctuation: 'Po',
  Other_Symbol: 'So',
  Paragraph_Separator: 'Zp',
  Private_Use: 'Co',
  Punctuation: ['P', 'punct'],
  Separator: 'Z',
  Space_Separator: 'Zs',
  Spacing_Mark: 'Mc',
  Surrogate: 'Cs',
  Symbol: 'S',
  Titlecase_Letter: 'Lt',
  Unassigned: 'Cn',
  Uppercase_Letter: 'Lu'
};

var GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES = inverseMap(GENERAL_CATEGORY_VALUE_TO_ALIASES);

var SCRIPT_VALUE_TO_ALIASES = {
  Adlam: 'Adlm',
  Ahom: 'Ahom',
  Anatolian_Hieroglyphs: 'Hluw',
  Arabic: 'Arab',
  Armenian: 'Armn',
  Avestan: 'Avst',
  Balinese: 'Bali',
  Bamum: 'Bamu',
  Bassa_Vah: 'Bass',
  Batak: 'Batk',
  Bengali: 'Beng',
  Bhaiksuki: 'Bhks',
  Bopomofo: 'Bopo',
  Brahmi: 'Brah',
  Braille: 'Brai',
  Buginese: 'Bugi',
  Buhid: 'Buhd',
  Canadian_Aboriginal: 'Cans',
  Carian: 'Cari',
  Caucasian_Albanian: 'Aghb',
  Chakma: 'Cakm',
  Cham: 'Cham',
  Cherokee: 'Cher',
  Common: 'Zyyy',
  Coptic: ['Copt', 'Qaac'],
  Cuneiform: 'Xsux',
  Cypriot: 'Cprt',
  Cyrillic: 'Cyrl',
  Deseret: 'Dsrt',
  Devanagari: 'Deva',
  Dogra: 'Dogr',
  Duployan: 'Dupl',
  Egyptian_Hieroglyphs: 'Egyp',
  Elbasan: 'Elba',
  Ethiopic: 'Ethi',
  Georgian: 'Geor',
  Glagolitic: 'Glag',
  Gothic: 'Goth',
  Grantha: 'Gran',
  Greek: 'Grek',
  Gujarati: 'Gujr',
  Gunjala_Gondi: 'Gong',
  Gurmukhi: 'Guru',
  Han: 'Hani',
  Hangul: 'Hang',
  Hanifi_Rohingya: 'Rohg',
  Hanunoo: 'Hano',
  Hatran: 'Hatr',
  Hebrew: 'Hebr',
  Hiragana: 'Hira',
  Imperial_Aramaic: 'Armi',
  Inherited: ['Zinh', 'Qaai'],
  Inscriptional_Pahlavi: 'Phli',
  Inscriptional_Parthian: 'Prti',
  Javanese: 'Java',
  Kaithi: 'Kthi',
  Kannada: 'Knda',
  Katakana: 'Kana',
  Kayah_Li: 'Kali',
  Kharoshthi: 'Khar',
  Khmer: 'Khmr',
  Khojki: 'Khoj',
  Khudawadi: 'Sind',
  Lao: 'Laoo',
  Latin: 'Latn',
  Lepcha: 'Lepc',
  Limbu: 'Limb',
  Linear_A: 'Lina',
  Linear_B: 'Linb',
  Lisu: 'Lisu',
  Lycian: 'Lyci',
  Lydian: 'Lydi',
  Mahajani: 'Mahj',
  Makasar: 'Maka',
  Malayalam: 'Mlym',
  Mandaic: 'Mand',
  Manichaean: 'Mani',
  Marchen: 'Marc',
  Medefaidrin: 'Medf',
  Masaram_Gondi: 'Gonm',
  Meetei_Mayek: 'Mtei',
  Mende_Kikakui: 'Mend',
  Meroitic_Cursive: 'Merc',
  Meroitic_Hieroglyphs: 'Mero',
  Miao: 'Plrd',
  Modi: 'Modi',
  Mongolian: 'Mong',
  Mro: 'Mroo',
  Multani: 'Mult',
  Myanmar: 'Mymr',
  Nabataean: 'Nbat',
  New_Tai_Lue: 'Talu',
  Newa: 'Newa',
  Nko: 'Nkoo',
  Nushu: 'Nshu',
  Ogham: 'Ogam',
  Ol_Chiki: 'Olck',
  Old_Hungarian: 'Hung',
  Old_Italic: 'Ital',
  Old_North_Arabian: 'Narb',
  Old_Permic: 'Perm',
  Old_Persian: 'Xpeo',
  Old_Sogdian: 'Sogo',
  Old_South_Arabian: 'Sarb',
  Old_Turkic: 'Orkh',
  Oriya: 'Orya',
  Osage: 'Osge',
  Osmanya: 'Osma',
  Pahawh_Hmong: 'Hmng',
  Palmyrene: 'Palm',
  Pau_Cin_Hau: 'Pauc',
  Phags_Pa: 'Phag',
  Phoenician: 'Phnx',
  Psalter_Pahlavi: 'Phlp',
  Rejang: 'Rjng',
  Runic: 'Runr',
  Samaritan: 'Samr',
  Saurashtra: 'Saur',
  Sharada: 'Shrd',
  Shavian: 'Shaw',
  Siddham: 'Sidd',
  SignWriting: 'Sgnw',
  Sinhala: 'Sinh',
  Sogdian: 'Sogd',
  Sora_Sompeng: 'Sora',
  Soyombo: 'Soyo',
  Sundanese: 'Sund',
  Syloti_Nagri: 'Sylo',
  Syriac: 'Syrc',
  Tagalog: 'Tglg',
  Tagbanwa: 'Tagb',
  Tai_Le: 'Tale',
  Tai_Tham: 'Lana',
  Tai_Viet: 'Tavt',
  Takri: 'Takr',
  Tamil: 'Taml',
  Tangut: 'Tang',
  Telugu: 'Telu',
  Thaana: 'Thaa',
  Thai: 'Thai',
  Tibetan: 'Tibt',
  Tifinagh: 'Tfng',
  Tirhuta: 'Tirh',
  Ugaritic: 'Ugar',
  Vai: 'Vaii',
  Warang_Citi: 'Wara',
  Yi: 'Yiii',
  Zanabazar_Square: 'Zanb'
};

var SCRIPT_VALUE_ALIASES_TO_VALUE = inverseMap(SCRIPT_VALUE_TO_ALIASES);

function inverseMap(data) {
  var inverse = {};

  for (var name in data) {
    if (!data.hasOwnProperty(name)) {
      continue;
    }
    var value = data[name];
    if (Array.isArray(value)) {
      for (var i = 0; i < value.length; i++) {
        inverse[value[i]] = name;
      }
    } else {
      inverse[value] = name;
    }
  }

  return inverse;
}

function isValidName(name) {
  return NON_BINARY_PROP_NAMES_TO_ALIASES.hasOwnProperty(name) || NON_BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name) || BINARY_PROP_NAMES_TO_ALIASES.hasOwnProperty(name) || BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name);
}

function isValidValue(name, value) {
  if (isGeneralCategoryName(name)) {
    return isGeneralCategoryValue(value);
  }

  if (isScriptCategoryName(name)) {
    return isScriptCategoryValue(value);
  }

  return false;
}

function isAlias(name) {
  return NON_BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name) || BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name);
}

function isGeneralCategoryName(name) {
  return name === 'General_Category' || name == 'gc';
}

function isScriptCategoryName(name) {
  return name === 'Script' || name === 'Script_Extensions' || name === 'sc' || name === 'scx';
}

function isGeneralCategoryValue(value) {
  return GENERAL_CATEGORY_VALUE_TO_ALIASES.hasOwnProperty(value) || GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES.hasOwnProperty(value);
}

function isScriptCategoryValue(value) {
  return SCRIPT_VALUE_TO_ALIASES.hasOwnProperty(value) || SCRIPT_VALUE_ALIASES_TO_VALUE.hasOwnProperty(value);
}

function isBinaryPropertyName(name) {
  return BINARY_PROP_NAMES_TO_ALIASES.hasOwnProperty(name) || BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name);
}

function getCanonicalName(name) {
  if (NON_BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name)) {
    return NON_BINARY_ALIASES_TO_PROP_NAMES[name];
  }

  if (BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name)) {
    return BINARY_ALIASES_TO_PROP_NAMES[name];
  }

  return null;
}

function getCanonicalValue(value) {
  if (GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES.hasOwnProperty(value)) {
    return GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES[value];
  }

  if (SCRIPT_VALUE_ALIASES_TO_VALUE.hasOwnProperty(value)) {
    return SCRIPT_VALUE_ALIASES_TO_VALUE[value];
  }

  if (BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(value)) {
    return BINARY_ALIASES_TO_PROP_NAMES[value];
  }

  return null;
}

var parserUnicodeProperties = {
  isAlias: isAlias,
  isValidName: isValidName,
  isValidValue: isValidValue,
  isGeneralCategoryValue: isGeneralCategoryValue,
  isScriptCategoryValue: isScriptCategoryValue,
  isBinaryPropertyName: isBinaryPropertyName,
  getCanonicalName: getCanonicalName,
  getCanonicalValue: getCanonicalValue,

  NON_BINARY_PROP_NAMES_TO_ALIASES: NON_BINARY_PROP_NAMES_TO_ALIASES,
  NON_BINARY_ALIASES_TO_PROP_NAMES: NON_BINARY_ALIASES_TO_PROP_NAMES,

  BINARY_PROP_NAMES_TO_ALIASES: BINARY_PROP_NAMES_TO_ALIASES,
  BINARY_ALIASES_TO_PROP_NAMES: BINARY_ALIASES_TO_PROP_NAMES,

  GENERAL_CATEGORY_VALUE_TO_ALIASES: GENERAL_CATEGORY_VALUE_TO_ALIASES,
  GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES: GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES,

  SCRIPT_VALUE_TO_ALIASES: SCRIPT_VALUE_TO_ALIASES,
  SCRIPT_VALUE_ALIASES_TO_VALUE: SCRIPT_VALUE_ALIASES_TO_VALUE
};

/**
 * LR parser generated by the Syntax tool.
 *
 * https://www.npmjs.com/package/syntax-cli
 *
 *   npm install -g syntax-cli
 *
 *   syntax-cli --help
 *
 * To regenerate run:
 *
 *   syntax-cli \
 *     --grammar ~/path-to-grammar-file \
 *     --mode <parsing-mode> \
 *     --output ~/path-to-output-parser-file.js
 */

/**
 * Matched token text.
 */

var _slicedToArray$2 = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toConsumableArray$8(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var yytext = void 0;

/**
 * Storage object.
 */
var yy = {};

/**
 * Result of semantic action.
 */
var __ = void 0;

/**
 * Result location object.
 */
var __loc = void 0;

function yyloc(start, end) {
  if (!yy.options.captureLocations) {
    return null;
  }

  // Epsilon doesn't produce location.
  if (!start || !end) {
    return start || end;
  }

  return {
    startOffset: start.startOffset,
    endOffset: end.endOffset,
    startLine: start.startLine,
    endLine: end.endLine,
    startColumn: start.startColumn,
    endColumn: end.endColumn
  };
}

var EOF = '$';

/**
 * List of productions (generated by Syntax tool).
 */
var productions = [[-1, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [0, 4, function (_1, _2, _3, _4, _1loc, _2loc, _3loc, _4loc) {
  __loc = yyloc(_1loc, _4loc);
  __ = Node({
    type: 'RegExp',
    body: _2,
    flags: checkFlags(_4)
  }, loc(_1loc, _4loc || _3loc));
}], [1, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [1, 0, function () {
  __loc = null;__ = '';
}], [2, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [2, 2, function (_1, _2, _1loc, _2loc) {
  __loc = yyloc(_1loc, _2loc);__ = _1 + _2;
}], [3, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [4, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [4, 3, function (_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  // Location for empty disjunction: /|/
  var _loc = null;

  if (_2loc) {
    _loc = loc(_1loc || _2loc, _3loc || _2loc);
  }
  __ = Node({
    type: 'Disjunction',
    left: _1,
    right: _3
  }, _loc);
}], [5, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  if (_1.length === 0) {
    __ = null;
    return;
  }

  if (_1.length === 1) {
    __ = Node(_1[0], __loc);
  } else {
    __ = Node({
      type: 'Alternative',
      expressions: _1
    }, __loc);
  }
}], [6, 0, function () {
  __loc = null;__ = [];
}], [6, 2, function (_1, _2, _1loc, _2loc) {
  __loc = yyloc(_1loc, _2loc);__ = _1.concat(_2);
}], [7, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Node(Object.assign({ type: 'Assertion' }, _1), __loc);
}], [7, 2, function (_1, _2, _1loc, _2loc) {
  __loc = yyloc(_1loc, _2loc);
  __ = _1;

  if (_2) {
    __ = Node({
      type: 'Repetition',
      expression: _1,
      quantifier: _2
    }, __loc);
  }
}], [8, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = { kind: '^' };
}], [8, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = { kind: '$' };
}], [8, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = { kind: '\\b' };
}], [8, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = { kind: '\\B' };
}], [8, 3, function (_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = {
    kind: 'Lookahead',
    assertion: _2
  };
}], [8, 3, function (_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = {
    kind: 'Lookahead',
    negative: true,
    assertion: _2
  };
}], [8, 3, function (_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = {
    kind: 'Lookbehind',
    assertion: _2
  };
}], [8, 3, function (_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = {
    kind: 'Lookbehind',
    negative: true,
    assertion: _2
  };
}], [9, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [9, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [9, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Char(_1, 'simple', __loc);
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Char(_1.slice(1), 'simple', __loc);__.escaped = true;
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Char(_1, 'unicode', __loc);__.isSurrogatePair = true;
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Char(_1, 'unicode', __loc);
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = UnicodeProperty(_1, __loc);
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Char(_1, 'control', __loc);
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Char(_1, 'hex', __loc);
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Char(_1, 'oct', __loc);
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = GroupRefOrDecChar(_1, __loc);
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Char(_1, 'meta', __loc);
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Char(_1, 'meta', __loc);
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = NamedGroupRefOrChars(_1, _1loc);
}], [11, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [11, 0], [12, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [12, 2, function (_1, _2, _1loc, _2loc) {
  __loc = yyloc(_1loc, _2loc);
  _1.greedy = false;
  __ = _1;
}], [13, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Node({
    type: 'Quantifier',
    kind: _1,
    greedy: true
  }, __loc);
}], [13, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Node({
    type: 'Quantifier',
    kind: _1,
    greedy: true
  }, __loc);
}], [13, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Node({
    type: 'Quantifier',
    kind: _1,
    greedy: true
  }, __loc);
}], [13, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  var range = getRange(_1);
  __ = Node({
    type: 'Quantifier',
    kind: 'Range',
    from: range[0],
    to: range[0],
    greedy: true
  }, __loc);
}], [13, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Node({
    type: 'Quantifier',
    kind: 'Range',
    from: getRange(_1)[0],
    greedy: true
  }, __loc);
}], [13, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  var range = getRange(_1);
  __ = Node({
    type: 'Quantifier',
    kind: 'Range',
    from: range[0],
    to: range[1],
    greedy: true
  }, __loc);
}], [14, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [14, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [15, 3, function (_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  var nameRaw = String(_1);
  var name = decodeUnicodeGroupName(nameRaw);
  if (!yy.options.allowGroupNameDuplicates && namedGroups.hasOwnProperty(name)) {
    throw new SyntaxError('Duplicate of the named group "' + name + '".');
  }

  namedGroups[name] = _1.groupNumber;

  __ = Node({
    type: 'Group',
    capturing: true,
    name: name,
    nameRaw: nameRaw,
    number: _1.groupNumber,
    expression: _2
  }, __loc);
}], [15, 3, function (_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = Node({
    type: 'Group',
    capturing: true,
    number: _1.groupNumber,
    expression: _2
  }, __loc);
}], [16, 3, function (_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = Node({
    type: 'Group',
    capturing: false,
    expression: _2
  }, __loc);
}], [17, 3, function (_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = Node({
    type: 'CharacterClass',
    negative: true,
    expressions: _2
  }, __loc);
}], [17, 3, function (_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = Node({
    type: 'CharacterClass',
    expressions: _2
  }, __loc);
}], [18, 0, function () {
  __loc = null;__ = [];
}], [18, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [19, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = [_1];
}], [19, 2, function (_1, _2, _1loc, _2loc) {
  __loc = yyloc(_1loc, _2loc);__ = [_1].concat(_2);
}], [19, 4, function (_1, _2, _3, _4, _1loc, _2loc, _3loc, _4loc) {
  __loc = yyloc(_1loc, _4loc);
  checkClassRange(_1, _3);

  __ = [Node({
    type: 'ClassRange',
    from: _1,
    to: _3
  }, loc(_1loc, _3loc))];

  if (_4) {
    __ = __.concat(_4);
  }
}], [20, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [20, 2, function (_1, _2, _1loc, _2loc) {
  __loc = yyloc(_1loc, _2loc);__ = [_1].concat(_2);
}], [20, 4, function (_1, _2, _3, _4, _1loc, _2loc, _3loc, _4loc) {
  __loc = yyloc(_1loc, _4loc);
  checkClassRange(_1, _3);

  __ = [Node({
    type: 'ClassRange',
    from: _1,
    to: _3
  }, loc(_1loc, _3loc))];

  if (_4) {
    __ = __.concat(_4);
  }
}], [21, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Char(_1, 'simple', __loc);
}], [21, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [22, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [22, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Char(_1, 'meta', __loc);
}]];

/**
 * Encoded tokens map.
 */
var tokens = { "SLASH": "23", "CHAR": "24", "BAR": "25", "BOS": "26", "EOS": "27", "ESC_b": "28", "ESC_B": "29", "POS_LA_ASSERT": "30", "R_PAREN": "31", "NEG_LA_ASSERT": "32", "POS_LB_ASSERT": "33", "NEG_LB_ASSERT": "34", "ESC_CHAR": "35", "U_CODE_SURROGATE": "36", "U_CODE": "37", "U_PROP_VALUE_EXP": "38", "CTRL_CH": "39", "HEX_CODE": "40", "OCT_CODE": "41", "DEC_CODE": "42", "META_CHAR": "43", "ANY": "44", "NAMED_GROUP_REF": "45", "Q_MARK": "46", "STAR": "47", "PLUS": "48", "RANGE_EXACT": "49", "RANGE_OPEN": "50", "RANGE_CLOSED": "51", "NAMED_CAPTURE_GROUP": "52", "L_PAREN": "53", "NON_CAPTURE_GROUP": "54", "NEG_CLASS": "55", "R_BRACKET": "56", "L_BRACKET": "57", "DASH": "58", "$": "59" };

/**
 * Parsing table (generated by Syntax tool).
 */
var table = [{ "0": 1, "23": "s2" }, { "59": "acc" }, { "3": 3, "4": 4, "5": 5, "6": 6, "23": "r10", "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "s7" }, { "23": "r6", "25": "s12" }, { "23": "r7", "25": "r7", "31": "r7" }, { "7": 14, "8": 15, "9": 16, "10": 25, "14": 27, "15": 42, "16": 43, "17": 26, "23": "r9", "24": "s28", "25": "r9", "26": "s17", "27": "s18", "28": "s19", "29": "s20", "30": "s21", "31": "r9", "32": "s22", "33": "s23", "34": "s24", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "52": "s44", "53": "s45", "54": "s46", "55": "s40", "57": "s41" }, { "1": 8, "2": 9, "24": "s10", "59": "r3" }, { "59": "r1" }, { "24": "s11", "59": "r2" }, { "24": "r4", "59": "r4" }, { "24": "r5", "59": "r5" }, { "5": 13, "6": 6, "23": "r10", "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "r8", "25": "r8", "31": "r8" }, { "23": "r11", "24": "r11", "25": "r11", "26": "r11", "27": "r11", "28": "r11", "29": "r11", "30": "r11", "31": "r11", "32": "r11", "33": "r11", "34": "r11", "35": "r11", "36": "r11", "37": "r11", "38": "r11", "39": "r11", "40": "r11", "41": "r11", "42": "r11", "43": "r11", "44": "r11", "45": "r11", "52": "r11", "53": "r11", "54": "r11", "55": "r11", "57": "r11" }, { "23": "r12", "24": "r12", "25": "r12", "26": "r12", "27": "r12", "28": "r12", "29": "r12", "30": "r12", "31": "r12", "32": "r12", "33": "r12", "34": "r12", "35": "r12", "36": "r12", "37": "r12", "38": "r12", "39": "r12", "40": "r12", "41": "r12", "42": "r12", "43": "r12", "44": "r12", "45": "r12", "52": "r12", "53": "r12", "54": "r12", "55": "r12", "57": "r12" }, { "11": 47, "12": 48, "13": 49, "23": "r38", "24": "r38", "25": "r38", "26": "r38", "27": "r38", "28": "r38", "29": "r38", "30": "r38", "31": "r38", "32": "r38", "33": "r38", "34": "r38", "35": "r38", "36": "r38", "37": "r38", "38": "r38", "39": "r38", "40": "r38", "41": "r38", "42": "r38", "43": "r38", "44": "r38", "45": "r38", "46": "s52", "47": "s50", "48": "s51", "49": "s53", "50": "s54", "51": "s55", "52": "r38", "53": "r38", "54": "r38", "55": "r38", "57": "r38" }, { "23": "r14", "24": "r14", "25": "r14", "26": "r14", "27": "r14", "28": "r14", "29": "r14", "30": "r14", "31": "r14", "32": "r14", "33": "r14", "34": "r14", "35": "r14", "36": "r14", "37": "r14", "38": "r14", "39": "r14", "40": "r14", "41": "r14", "42": "r14", "43": "r14", "44": "r14", "45": "r14", "52": "r14", "53": "r14", "54": "r14", "55": "r14", "57": "r14" }, { "23": "r15", "24": "r15", "25": "r15", "26": "r15", "27": "r15", "28": "r15", "29": "r15", "30": "r15", "31": "r15", "32": "r15", "33": "r15", "34": "r15", "35": "r15", "36": "r15", "37": "r15", "38": "r15", "39": "r15", "40": "r15", "41": "r15", "42": "r15", "43": "r15", "44": "r15", "45": "r15", "52": "r15", "53": "r15", "54": "r15", "55": "r15", "57": "r15" }, { "23": "r16", "24": "r16", "25": "r16", "26": "r16", "27": "r16", "28": "r16", "29": "r16", "30": "r16", "31": "r16", "32": "r16", "33": "r16", "34": "r16", "35": "r16", "36": "r16", "37": "r16", "38": "r16", "39": "r16", "40": "r16", "41": "r16", "42": "r16", "43": "r16", "44": "r16", "45": "r16", "52": "r16", "53": "r16", "54": "r16", "55": "r16", "57": "r16" }, { "23": "r17", "24": "r17", "25": "r17", "26": "r17", "27": "r17", "28": "r17", "29": "r17", "30": "r17", "31": "r17", "32": "r17", "33": "r17", "34": "r17", "35": "r17", "36": "r17", "37": "r17", "38": "r17", "39": "r17", "40": "r17", "41": "r17", "42": "r17", "43": "r17", "44": "r17", "45": "r17", "52": "r17", "53": "r17", "54": "r17", "55": "r17", "57": "r17" }, { "4": 57, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 59, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 61, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 63, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "r22", "24": "r22", "25": "r22", "26": "r22", "27": "r22", "28": "r22", "29": "r22", "30": "r22", "31": "r22", "32": "r22", "33": "r22", "34": "r22", "35": "r22", "36": "r22", "37": "r22", "38": "r22", "39": "r22", "40": "r22", "41": "r22", "42": "r22", "43": "r22", "44": "r22", "45": "r22", "46": "r22", "47": "r22", "48": "r22", "49": "r22", "50": "r22", "51": "r22", "52": "r22", "53": "r22", "54": "r22", "55": "r22", "57": "r22" }, { "23": "r23", "24": "r23", "25": "r23", "26": "r23", "27": "r23", "28": "r23", "29": "r23", "30": "r23", "31": "r23", "32": "r23", "33": "r23", "34": "r23", "35": "r23", "36": "r23", "37": "r23", "38": "r23", "39": "r23", "40": "r23", "41": "r23", "42": "r23", "43": "r23", "44": "r23", "45": "r23", "46": "r23", "47": "r23", "48": "r23", "49": "r23", "50": "r23", "51": "r23", "52": "r23", "53": "r23", "54": "r23", "55": "r23", "57": "r23" }, { "23": "r24", "24": "r24", "25": "r24", "26": "r24", "27": "r24", "28": "r24", "29": "r24", "30": "r24", "31": "r24", "32": "r24", "33": "r24", "34": "r24", "35": "r24", "36": "r24", "37": "r24", "38": "r24", "39": "r24", "40": "r24", "41": "r24", "42": "r24", "43": "r24", "44": "r24", "45": "r24", "46": "r24", "47": "r24", "48": "r24", "49": "r24", "50": "r24", "51": "r24", "52": "r24", "53": "r24", "54": "r24", "55": "r24", "57": "r24" }, { "23": "r25", "24": "r25", "25": "r25", "26": "r25", "27": "r25", "28": "r25", "29": "r25", "30": "r25", "31": "r25", "32": "r25", "33": "r25", "34": "r25", "35": "r25", "36": "r25", "37": "r25", "38": "r25", "39": "r25", "40": "r25", "41": "r25", "42": "r25", "43": "r25", "44": "r25", "45": "r25", "46": "r25", "47": "r25", "48": "r25", "49": "r25", "50": "r25", "51": "r25", "52": "r25", "53": "r25", "54": "r25", "55": "r25", "56": "r25", "57": "r25", "58": "r25" }, { "23": "r26", "24": "r26", "25": "r26", "26": "r26", "27": "r26", "28": "r26", "29": "r26", "30": "r26", "31": "r26", "32": "r26", "33": "r26", "34": "r26", "35": "r26", "36": "r26", "37": "r26", "38": "r26", "39": "r26", "40": "r26", "41": "r26", "42": "r26", "43": "r26", "44": "r26", "45": "r26", "46": "r26", "47": "r26", "48": "r26", "49": "r26", "50": "r26", "51": "r26", "52": "r26", "53": "r26", "54": "r26", "55": "r26", "56": "r26", "57": "r26", "58": "r26" }, { "23": "r27", "24": "r27", "25": "r27", "26": "r27", "27": "r27", "28": "r27", "29": "r27", "30": "r27", "31": "r27", "32": "r27", "33": "r27", "34": "r27", "35": "r27", "36": "r27", "37": "r27", "38": "r27", "39": "r27", "40": "r27", "41": "r27", "42": "r27", "43": "r27", "44": "r27", "45": "r27", "46": "r27", "47": "r27", "48": "r27", "49": "r27", "50": "r27", "51": "r27", "52": "r27", "53": "r27", "54": "r27", "55": "r27", "56": "r27", "57": "r27", "58": "r27" }, { "23": "r28", "24": "r28", "25": "r28", "26": "r28", "27": "r28", "28": "r28", "29": "r28", "30": "r28", "31": "r28", "32": "r28", "33": "r28", "34": "r28", "35": "r28", "36": "r28", "37": "r28", "38": "r28", "39": "r28", "40": "r28", "41": "r28", "42": "r28", "43": "r28", "44": "r28", "45": "r28", "46": "r28", "47": "r28", "48": "r28", "49": "r28", "50": "r28", "51": "r28", "52": "r28", "53": "r28", "54": "r28", "55": "r28", "56": "r28", "57": "r28", "58": "r28" }, { "23": "r29", "24": "r29", "25": "r29", "26": "r29", "27": "r29", "28": "r29", "29": "r29", "30": "r29", "31": "r29", "32": "r29", "33": "r29", "34": "r29", "35": "r29", "36": "r29", "37": "r29", "38": "r29", "39": "r29", "40": "r29", "41": "r29", "42": "r29", "43": "r29", "44": "r29", "45": "r29", "46": "r29", "47": "r29", "48": "r29", "49": "r29", "50": "r29", "51": "r29", "52": "r29", "53": "r29", "54": "r29", "55": "r29", "56": "r29", "57": "r29", "58": "r29" }, { "23": "r30", "24": "r30", "25": "r30", "26": "r30", "27": "r30", "28": "r30", "29": "r30", "30": "r30", "31": "r30", "32": "r30", "33": "r30", "34": "r30", "35": "r30", "36": "r30", "37": "r30", "38": "r30", "39": "r30", "40": "r30", "41": "r30", "42": "r30", "43": "r30", "44": "r30", "45": "r30", "46": "r30", "47": "r30", "48": "r30", "49": "r30", "50": "r30", "51": "r30", "52": "r30", "53": "r30", "54": "r30", "55": "r30", "56": "r30", "57": "r30", "58": "r30" }, { "23": "r31", "24": "r31", "25": "r31", "26": "r31", "27": "r31", "28": "r31", "29": "r31", "30": "r31", "31": "r31", "32": "r31", "33": "r31", "34": "r31", "35": "r31", "36": "r31", "37": "r31", "38": "r31", "39": "r31", "40": "r31", "41": "r31", "42": "r31", "43": "r31", "44": "r31", "45": "r31", "46": "r31", "47": "r31", "48": "r31", "49": "r31", "50": "r31", "51": "r31", "52": "r31", "53": "r31", "54": "r31", "55": "r31", "56": "r31", "57": "r31", "58": "r31" }, { "23": "r32", "24": "r32", "25": "r32", "26": "r32", "27": "r32", "28": "r32", "29": "r32", "30": "r32", "31": "r32", "32": "r32", "33": "r32", "34": "r32", "35": "r32", "36": "r32", "37": "r32", "38": "r32", "39": "r32", "40": "r32", "41": "r32", "42": "r32", "43": "r32", "44": "r32", "45": "r32", "46": "r32", "47": "r32", "48": "r32", "49": "r32", "50": "r32", "51": "r32", "52": "r32", "53": "r32", "54": "r32", "55": "r32", "56": "r32", "57": "r32", "58": "r32" }, { "23": "r33", "24": "r33", "25": "r33", "26": "r33", "27": "r33", "28": "r33", "29": "r33", "30": "r33", "31": "r33", "32": "r33", "33": "r33", "34": "r33", "35": "r33", "36": "r33", "37": "r33", "38": "r33", "39": "r33", "40": "r33", "41": "r33", "42": "r33", "43": "r33", "44": "r33", "45": "r33", "46": "r33", "47": "r33", "48": "r33", "49": "r33", "50": "r33", "51": "r33", "52": "r33", "53": "r33", "54": "r33", "55": "r33", "56": "r33", "57": "r33", "58": "r33" }, { "23": "r34", "24": "r34", "25": "r34", "26": "r34", "27": "r34", "28": "r34", "29": "r34", "30": "r34", "31": "r34", "32": "r34", "33": "r34", "34": "r34", "35": "r34", "36": "r34", "37": "r34", "38": "r34", "39": "r34", "40": "r34", "41": "r34", "42": "r34", "43": "r34", "44": "r34", "45": "r34", "46": "r34", "47": "r34", "48": "r34", "49": "r34", "50": "r34", "51": "r34", "52": "r34", "53": "r34", "54": "r34", "55": "r34", "56": "r34", "57": "r34", "58": "r34" }, { "23": "r35", "24": "r35", "25": "r35", "26": "r35", "27": "r35", "28": "r35", "29": "r35", "30": "r35", "31": "r35", "32": "r35", "33": "r35", "34": "r35", "35": "r35", "36": "r35", "37": "r35", "38": "r35", "39": "r35", "40": "r35", "41": "r35", "42": "r35", "43": "r35", "44": "r35", "45": "r35", "46": "r35", "47": "r35", "48": "r35", "49": "r35", "50": "r35", "51": "r35", "52": "r35", "53": "r35", "54": "r35", "55": "r35", "56": "r35", "57": "r35", "58": "r35" }, { "23": "r36", "24": "r36", "25": "r36", "26": "r36", "27": "r36", "28": "r36", "29": "r36", "30": "r36", "31": "r36", "32": "r36", "33": "r36", "34": "r36", "35": "r36", "36": "r36", "37": "r36", "38": "r36", "39": "r36", "40": "r36", "41": "r36", "42": "r36", "43": "r36", "44": "r36", "45": "r36", "46": "r36", "47": "r36", "48": "r36", "49": "r36", "50": "r36", "51": "r36", "52": "r36", "53": "r36", "54": "r36", "55": "r36", "56": "r36", "57": "r36", "58": "r36" }, { "10": 70, "18": 65, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "10": 70, "18": 83, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "23": "r47", "24": "r47", "25": "r47", "26": "r47", "27": "r47", "28": "r47", "29": "r47", "30": "r47", "31": "r47", "32": "r47", "33": "r47", "34": "r47", "35": "r47", "36": "r47", "37": "r47", "38": "r47", "39": "r47", "40": "r47", "41": "r47", "42": "r47", "43": "r47", "44": "r47", "45": "r47", "46": "r47", "47": "r47", "48": "r47", "49": "r47", "50": "r47", "51": "r47", "52": "r47", "53": "r47", "54": "r47", "55": "r47", "57": "r47" }, { "23": "r48", "24": "r48", "25": "r48", "26": "r48", "27": "r48", "28": "r48", "29": "r48", "30": "r48", "31": "r48", "32": "r48", "33": "r48", "34": "r48", "35": "r48", "36": "r48", "37": "r48", "38": "r48", "39": "r48", "40": "r48", "41": "r48", "42": "r48", "43": "r48", "44": "r48", "45": "r48", "46": "r48", "47": "r48", "48": "r48", "49": "r48", "50": "r48", "51": "r48", "52": "r48", "53": "r48", "54": "r48", "55": "r48", "57": "r48" }, { "4": 85, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 87, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 89, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "r13", "24": "r13", "25": "r13", "26": "r13", "27": "r13", "28": "r13", "29": "r13", "30": "r13", "31": "r13", "32": "r13", "33": "r13", "34": "r13", "35": "r13", "36": "r13", "37": "r13", "38": "r13", "39": "r13", "40": "r13", "41": "r13", "42": "r13", "43": "r13", "44": "r13", "45": "r13", "52": "r13", "53": "r13", "54": "r13", "55": "r13", "57": "r13" }, { "23": "r37", "24": "r37", "25": "r37", "26": "r37", "27": "r37", "28": "r37", "29": "r37", "30": "r37", "31": "r37", "32": "r37", "33": "r37", "34": "r37", "35": "r37", "36": "r37", "37": "r37", "38": "r37", "39": "r37", "40": "r37", "41": "r37", "42": "r37", "43": "r37", "44": "r37", "45": "r37", "52": "r37", "53": "r37", "54": "r37", "55": "r37", "57": "r37" }, { "23": "r39", "24": "r39", "25": "r39", "26": "r39", "27": "r39", "28": "r39", "29": "r39", "30": "r39", "31": "r39", "32": "r39", "33": "r39", "34": "r39", "35": "r39", "36": "r39", "37": "r39", "38": "r39", "39": "r39", "40": "r39", "41": "r39", "42": "r39", "43": "r39", "44": "r39", "45": "r39", "46": "s56", "52": "r39", "53": "r39", "54": "r39", "55": "r39", "57": "r39" }, { "23": "r41", "24": "r41", "25": "r41", "26": "r41", "27": "r41", "28": "r41", "29": "r41", "30": "r41", "31": "r41", "32": "r41", "33": "r41", "34": "r41", "35": "r41", "36": "r41", "37": "r41", "38": "r41", "39": "r41", "40": "r41", "41": "r41", "42": "r41", "43": "r41", "44": "r41", "45": "r41", "46": "r41", "52": "r41", "53": "r41", "54": "r41", "55": "r41", "57": "r41" }, { "23": "r42", "24": "r42", "25": "r42", "26": "r42", "27": "r42", "28": "r42", "29": "r42", "30": "r42", "31": "r42", "32": "r42", "33": "r42", "34": "r42", "35": "r42", "36": "r42", "37": "r42", "38": "r42", "39": "r42", "40": "r42", "41": "r42", "42": "r42", "43": "r42", "44": "r42", "45": "r42", "46": "r42", "52": "r42", "53": "r42", "54": "r42", "55": "r42", "57": "r42" }, { "23": "r43", "24": "r43", "25": "r43", "26": "r43", "27": "r43", "28": "r43", "29": "r43", "30": "r43", "31": "r43", "32": "r43", "33": "r43", "34": "r43", "35": "r43", "36": "r43", "37": "r43", "38": "r43", "39": "r43", "40": "r43", "41": "r43", "42": "r43", "43": "r43", "44": "r43", "45": "r43", "46": "r43", "52": "r43", "53": "r43", "54": "r43", "55": "r43", "57": "r43" }, { "23": "r44", "24": "r44", "25": "r44", "26": "r44", "27": "r44", "28": "r44", "29": "r44", "30": "r44", "31": "r44", "32": "r44", "33": "r44", "34": "r44", "35": "r44", "36": "r44", "37": "r44", "38": "r44", "39": "r44", "40": "r44", "41": "r44", "42": "r44", "43": "r44", "44": "r44", "45": "r44", "46": "r44", "52": "r44", "53": "r44", "54": "r44", "55": "r44", "57": "r44" }, { "23": "r45", "24": "r45", "25": "r45", "26": "r45", "27": "r45", "28": "r45", "29": "r45", "30": "r45", "31": "r45", "32": "r45", "33": "r45", "34": "r45", "35": "r45", "36": "r45", "37": "r45", "38": "r45", "39": "r45", "40": "r45", "41": "r45", "42": "r45", "43": "r45", "44": "r45", "45": "r45", "46": "r45", "52": "r45", "53": "r45", "54": "r45", "55": "r45", "57": "r45" }, { "23": "r46", "24": "r46", "25": "r46", "26": "r46", "27": "r46", "28": "r46", "29": "r46", "30": "r46", "31": "r46", "32": "r46", "33": "r46", "34": "r46", "35": "r46", "36": "r46", "37": "r46", "38": "r46", "39": "r46", "40": "r46", "41": "r46", "42": "r46", "43": "r46", "44": "r46", "45": "r46", "46": "r46", "52": "r46", "53": "r46", "54": "r46", "55": "r46", "57": "r46" }, { "23": "r40", "24": "r40", "25": "r40", "26": "r40", "27": "r40", "28": "r40", "29": "r40", "30": "r40", "31": "r40", "32": "r40", "33": "r40", "34": "r40", "35": "r40", "36": "r40", "37": "r40", "38": "r40", "39": "r40", "40": "r40", "41": "r40", "42": "r40", "43": "r40", "44": "r40", "45": "r40", "52": "r40", "53": "r40", "54": "r40", "55": "r40", "57": "r40" }, { "25": "s12", "31": "s58" }, { "23": "r18", "24": "r18", "25": "r18", "26": "r18", "27": "r18", "28": "r18", "29": "r18", "30": "r18", "31": "r18", "32": "r18", "33": "r18", "34": "r18", "35": "r18", "36": "r18", "37": "r18", "38": "r18", "39": "r18", "40": "r18", "41": "r18", "42": "r18", "43": "r18", "44": "r18", "45": "r18", "52": "r18", "53": "r18", "54": "r18", "55": "r18", "57": "r18" }, { "25": "s12", "31": "s60" }, { "23": "r19", "24": "r19", "25": "r19", "26": "r19", "27": "r19", "28": "r19", "29": "r19", "30": "r19", "31": "r19", "32": "r19", "33": "r19", "34": "r19", "35": "r19", "36": "r19", "37": "r19", "38": "r19", "39": "r19", "40": "r19", "41": "r19", "42": "r19", "43": "r19", "44": "r19", "45": "r19", "52": "r19", "53": "r19", "54": "r19", "55": "r19", "57": "r19" }, { "25": "s12", "31": "s62" }, { "23": "r20", "24": "r20", "25": "r20", "26": "r20", "27": "r20", "28": "r20", "29": "r20", "30": "r20", "31": "r20", "32": "r20", "33": "r20", "34": "r20", "35": "r20", "36": "r20", "37": "r20", "38": "r20", "39": "r20", "40": "r20", "41": "r20", "42": "r20", "43": "r20", "44": "r20", "45": "r20", "52": "r20", "53": "r20", "54": "r20", "55": "r20", "57": "r20" }, { "25": "s12", "31": "s64" }, { "23": "r21", "24": "r21", "25": "r21", "26": "r21", "27": "r21", "28": "r21", "29": "r21", "30": "r21", "31": "r21", "32": "r21", "33": "r21", "34": "r21", "35": "r21", "36": "r21", "37": "r21", "38": "r21", "39": "r21", "40": "r21", "41": "r21", "42": "r21", "43": "r21", "44": "r21", "45": "r21", "52": "r21", "53": "r21", "54": "r21", "55": "r21", "57": "r21" }, { "56": "s72" }, { "56": "r55" }, { "10": 70, "20": 73, "21": 75, "22": 76, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r56", "58": "s74" }, { "24": "r62", "28": "r62", "35": "r62", "36": "r62", "37": "r62", "38": "r62", "39": "r62", "40": "r62", "41": "r62", "42": "r62", "43": "r62", "44": "r62", "45": "r62", "56": "r62", "58": "r62" }, { "24": "r63", "28": "r63", "35": "r63", "36": "r63", "37": "r63", "38": "r63", "39": "r63", "40": "r63", "41": "r63", "42": "r63", "43": "r63", "44": "r63", "45": "r63", "56": "r63", "58": "r63" }, { "24": "r64", "28": "r64", "35": "r64", "36": "r64", "37": "r64", "38": "r64", "39": "r64", "40": "r64", "41": "r64", "42": "r64", "43": "r64", "44": "r64", "45": "r64", "56": "r64", "58": "r64" }, { "24": "r65", "28": "r65", "35": "r65", "36": "r65", "37": "r65", "38": "r65", "39": "r65", "40": "r65", "41": "r65", "42": "r65", "43": "r65", "44": "r65", "45": "r65", "56": "r65", "58": "r65" }, { "23": "r52", "24": "r52", "25": "r52", "26": "r52", "27": "r52", "28": "r52", "29": "r52", "30": "r52", "31": "r52", "32": "r52", "33": "r52", "34": "r52", "35": "r52", "36": "r52", "37": "r52", "38": "r52", "39": "r52", "40": "r52", "41": "r52", "42": "r52", "43": "r52", "44": "r52", "45": "r52", "46": "r52", "47": "r52", "48": "r52", "49": "r52", "50": "r52", "51": "r52", "52": "r52", "53": "r52", "54": "r52", "55": "r52", "57": "r52" }, { "56": "r57" }, { "10": 70, "21": 77, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r62", "58": "s68" }, { "56": "r59" }, { "10": 70, "20": 79, "21": 75, "22": 76, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r63", "58": "s80" }, { "10": 70, "18": 78, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "56": "r58" }, { "56": "r60" }, { "10": 70, "21": 81, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r62", "58": "s68" }, { "10": 70, "18": 82, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "56": "r61" }, { "56": "s84" }, { "23": "r53", "24": "r53", "25": "r53", "26": "r53", "27": "r53", "28": "r53", "29": "r53", "30": "r53", "31": "r53", "32": "r53", "33": "r53", "34": "r53", "35": "r53", "36": "r53", "37": "r53", "38": "r53", "39": "r53", "40": "r53", "41": "r53", "42": "r53", "43": "r53", "44": "r53", "45": "r53", "46": "r53", "47": "r53", "48": "r53", "49": "r53", "50": "r53", "51": "r53", "52": "r53", "53": "r53", "54": "r53", "55": "r53", "57": "r53" }, { "25": "s12", "31": "s86" }, { "23": "r49", "24": "r49", "25": "r49", "26": "r49", "27": "r49", "28": "r49", "29": "r49", "30": "r49", "31": "r49", "32": "r49", "33": "r49", "34": "r49", "35": "r49", "36": "r49", "37": "r49", "38": "r49", "39": "r49", "40": "r49", "41": "r49", "42": "r49", "43": "r49", "44": "r49", "45": "r49", "46": "r49", "47": "r49", "48": "r49", "49": "r49", "50": "r49", "51": "r49", "52": "r49", "53": "r49", "54": "r49", "55": "r49", "57": "r49" }, { "25": "s12", "31": "s88" }, { "23": "r50", "24": "r50", "25": "r50", "26": "r50", "27": "r50", "28": "r50", "29": "r50", "30": "r50", "31": "r50", "32": "r50", "33": "r50", "34": "r50", "35": "r50", "36": "r50", "37": "r50", "38": "r50", "39": "r50", "40": "r50", "41": "r50", "42": "r50", "43": "r50", "44": "r50", "45": "r50", "46": "r50", "47": "r50", "48": "r50", "49": "r50", "50": "r50", "51": "r50", "52": "r50", "53": "r50", "54": "r50", "55": "r50", "57": "r50" }, { "25": "s12", "31": "s90" }, { "23": "r51", "24": "r51", "25": "r51", "26": "r51", "27": "r51", "28": "r51", "29": "r51", "30": "r51", "31": "r51", "32": "r51", "33": "r51", "34": "r51", "35": "r51", "36": "r51", "37": "r51", "38": "r51", "39": "r51", "40": "r51", "41": "r51", "42": "r51", "43": "r51", "44": "r51", "45": "r51", "46": "r51", "47": "r51", "48": "r51", "49": "r51", "50": "r51", "51": "r51", "52": "r51", "53": "r51", "54": "r51", "55": "r51", "57": "r51" }];

/**
 * Parsing stack.
 */
var stack = [];

/**
 * Tokenizer instance.
 */
var tokenizer = void 0;
/**
 * Generic tokenizer used by the parser in the Syntax tool.
 *
 * https://www.npmjs.com/package/syntax-cli
 *
 * See `--custom-tokinzer` to skip this generation, and use a custom one.
 */

var lexRules = [[/^#[^\n]+/, function () {/* skip comments */}], [/^\s+/, function () {/* skip whitespace */}], [/^-/, function () {
  return 'DASH';
}], [/^\//, function () {
  return 'CHAR';
}], [/^#/, function () {
  return 'CHAR';
}], [/^\|/, function () {
  return 'CHAR';
}], [/^\./, function () {
  return 'CHAR';
}], [/^\{/, function () {
  return 'CHAR';
}], [/^\{\d+\}/, function () {
  return 'RANGE_EXACT';
}], [/^\{\d+,\}/, function () {
  return 'RANGE_OPEN';
}], [/^\{\d+,\d+\}/, function () {
  return 'RANGE_CLOSED';
}], [/^\\k<(([\u0041-\u005a\u0061-\u007a\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e-\u066f\u0671-\u06d3\u06d5\u06e5-\u06e6\u06ee-\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4-\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc-\u09dd\u09df-\u09e1\u09f0-\u09f1\u09fc\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0-\u0ae1\u0af9\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60-\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0-\u0ce1\u0cf1-\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32-\u0e33\u0e40-\u0e46\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2-\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065-\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae-\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5-\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a-\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd-\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5-\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\ude80-\ude9c\udea0-\uded0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf75\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00\ude10-\ude13\ude15-\ude17\ude19-\ude35\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee4\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd23\udf00-\udf1c\udf27\udf30-\udf45\udfe0-\udff6]|\ud804[\udc03-\udc37\udc83-\udcaf\udcd0-\udce8\udd03-\udd26\udd44\udd50-\udd72\udd76\udd83-\uddb2\uddc1-\uddc4\uddda\udddc\ude00-\ude11\ude13-\ude2b\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udede\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3d\udf50\udf5d-\udf61]|\ud805[\udc00-\udc34\udc47-\udc4a\udc5f\udc80-\udcaf\udcc4-\udcc5\udcc7\udd80-\uddae\uddd8-\udddb\ude00-\ude2f\ude44\ude80-\udeaa\udeb8\udf00-\udf1a]|\ud806[\udc00-\udc2b\udca0-\udcdf\udcff\udda0-\udda7\uddaa-\uddd0\udde1\udde3\ude00\ude0b-\ude32\ude3a\ude50\ude5c-\ude89\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc2e\udc40\udc72-\udc8f\udd00-\udd06\udd08-\udd09\udd0b-\udd30\udd46\udd60-\udd65\udd67-\udd68\udd6a-\udd89\udd98\udee0-\udef2]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\uded0-\udeed\udf00-\udf2f\udf40-\udf43\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf50\udf93-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb]|\ud838[\udd00-\udd2c\udd37-\udd3d\udd4e\udec0-\udeeb]|\ud83a[\udc00-\udcc4\udd00-\udd43\udd4b]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\}))(([\u0030-\u0039\u0041-\u005a\u005f\u0061-\u007a\u00aa\u00b5\u00b7\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u05d0-\u05ea\u05ef-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u07fd\u0800-\u082d\u0840-\u085b\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u08d3-\u08e1\u08e3-\u0963\u0966-\u096f\u0971-\u0983\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7-\u09c8\u09cb-\u09ce\u09d7\u09dc-\u09dd\u09df-\u09e3\u09e6-\u09f1\u09fc\u09fe\u0a01-\u0a03\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a3c\u0a3e-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0af9-\u0aff\u0b01-\u0b03\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47-\u0b48\u0b4b-\u0b4d\u0b56-\u0b57\u0b5c-\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82-\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c00-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56\u0c58-\u0c5a\u0c60-\u0c63\u0c66-\u0c6f\u0c80-\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5-\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1-\u0cf2\u0d00-\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d54-\u0d57\u0d5f-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82-\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2-\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18-\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1369-\u1371\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772-\u1773\u1780-\u17d3\u17d7\u17dc-\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1878\u1880-\u18aa\u18b0-\u18f5\u1900-\u191e\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19da\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1ab0-\u1abd\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1cd0-\u1cd2\u1cd4-\u1cfa\u1d00-\u1df9\u1dfb-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u203f-\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua827\ua840-\ua873\ua880-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua8fd-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\ua9e0-\ua9fe\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabea\uabec-\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe2f\ufe33-\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\uddfd\ude80-\ude9c\udea0-\uded0\udee0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf7a\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udca0-\udca9\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00-\ude03\ude05-\ude06\ude0c-\ude13\ude15-\ude17\ude19-\ude35\ude38-\ude3a\ude3f\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee6\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd27\udd30-\udd39\udf00-\udf1c\udf27\udf30-\udf50\udfe0-\udff6]|\ud804[\udc00-\udc46\udc66-\udc6f\udc7f-\udcba\udcd0-\udce8\udcf0-\udcf9\udd00-\udd34\udd36-\udd3f\udd44-\udd46\udd50-\udd73\udd76\udd80-\uddc4\uddc9-\uddcc\uddd0-\uddda\udddc\ude00-\ude11\ude13-\ude37\ude3e\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udeea\udef0-\udef9\udf00-\udf03\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3b-\udf44\udf47-\udf48\udf4b-\udf4d\udf50\udf57\udf5d-\udf63\udf66-\udf6c\udf70-\udf74]|\ud805[\udc00-\udc4a\udc50-\udc59\udc5e-\udc5f\udc80-\udcc5\udcc7\udcd0-\udcd9\udd80-\uddb5\uddb8-\uddc0\uddd8-\udddd\ude00-\ude40\ude44\ude50-\ude59\ude80-\udeb8\udec0-\udec9\udf00-\udf1a\udf1d-\udf2b\udf30-\udf39]|\ud806[\udc00-\udc3a\udca0-\udce9\udcff\udda0-\udda7\uddaa-\uddd7\uddda-\udde1\udde3-\udde4\ude00-\ude3e\ude47\ude50-\ude99\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc36\udc38-\udc40\udc50-\udc59\udc72-\udc8f\udc92-\udca7\udca9-\udcb6\udd00-\udd06\udd08-\udd09\udd0b-\udd36\udd3a\udd3c-\udd3d\udd3f-\udd47\udd50-\udd59\udd60-\udd65\udd67-\udd68\udd6a-\udd8e\udd90-\udd91\udd93-\udd98\udda0-\udda9\udee0-\udef6]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\ude60-\ude69\uded0-\udeed\udef0-\udef4\udf00-\udf36\udf40-\udf43\udf50-\udf59\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf4f-\udf87\udf8f-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99\udc9d-\udc9e]|\ud834[\udd65-\udd69\udd6d-\udd72\udd7b-\udd82\udd85-\udd8b\uddaa-\uddad\ude42-\ude44]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb\udfce-\udfff]|\ud836[\ude00-\ude36\ude3b-\ude6c\ude75\ude84\ude9b-\ude9f\udea1-\udeaf]|\ud838[\udc00-\udc06\udc08-\udc18\udc1b-\udc21\udc23-\udc24\udc26-\udc2a\udd00-\udd2c\udd30-\udd3d\udd40-\udd49\udd4e\udec0-\udef9]|\ud83a[\udc00-\udcc4\udcd0-\udcd6\udd00-\udd4b\udd50-\udd59]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d]|\udb40[\udd00-\uddef])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\})|[\u200c\u200d])*>/, function () {
  var groupName = yytext.slice(3, -1);
  validateUnicodeGroupName(groupName, this.getCurrentState());
  return 'NAMED_GROUP_REF';
}], [/^\\b/, function () {
  return 'ESC_b';
}], [/^\\B/, function () {
  return 'ESC_B';
}], [/^\\c[a-zA-Z]/, function () {
  return 'CTRL_CH';
}], [/^\\0\d{1,2}/, function () {
  return 'OCT_CODE';
}], [/^\\0/, function () {
  return 'DEC_CODE';
}], [/^\\\d{1,3}/, function () {
  return 'DEC_CODE';
}], [/^\\u[dD][89abAB][0-9a-fA-F]{2}\\u[dD][c-fC-F][0-9a-fA-F]{2}/, function () {
  return 'U_CODE_SURROGATE';
}], [/^\\u\{[0-9a-fA-F]{1,}\}/, function () {
  return 'U_CODE';
}], [/^\\u[0-9a-fA-F]{4}/, function () {
  return 'U_CODE';
}], [/^\\[pP]\{\w+(?:=\w+)?\}/, function () {
  return 'U_PROP_VALUE_EXP';
}], [/^\\x[0-9a-fA-F]{2}/, function () {
  return 'HEX_CODE';
}], [/^\\[tnrdDsSwWvf]/, function () {
  return 'META_CHAR';
}], [/^\\\//, function () {
  return 'ESC_CHAR';
}], [/^\\[ #]/, function () {
  return 'ESC_CHAR';
}], [/^\\[\^\$\.\*\+\?\(\)\\\[\]\{\}\|\/]/, function () {
  return 'ESC_CHAR';
}], [/^\\[^*?+\[()\\|]/, function () {
  var s = this.getCurrentState();
  if (s === 'u_class' && yytext === "\\-") {
    return 'ESC_CHAR';
  } else if (s === 'u' || s === 'xu' || s === 'u_class') {
    throw new SyntaxError('invalid Unicode escape ' + yytext);
  }
  return 'ESC_CHAR';
}], [/^\(/, function () {
  return 'CHAR';
}], [/^\)/, function () {
  return 'CHAR';
}], [/^\(\?=/, function () {
  return 'POS_LA_ASSERT';
}], [/^\(\?!/, function () {
  return 'NEG_LA_ASSERT';
}], [/^\(\?<=/, function () {
  return 'POS_LB_ASSERT';
}], [/^\(\?<!/, function () {
  return 'NEG_LB_ASSERT';
}], [/^\(\?:/, function () {
  return 'NON_CAPTURE_GROUP';
}], [/^\(\?<(([\u0041-\u005a\u0061-\u007a\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e-\u066f\u0671-\u06d3\u06d5\u06e5-\u06e6\u06ee-\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4-\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc-\u09dd\u09df-\u09e1\u09f0-\u09f1\u09fc\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0-\u0ae1\u0af9\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60-\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0-\u0ce1\u0cf1-\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32-\u0e33\u0e40-\u0e46\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2-\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065-\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae-\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5-\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a-\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd-\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5-\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\ude80-\ude9c\udea0-\uded0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf75\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00\ude10-\ude13\ude15-\ude17\ude19-\ude35\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee4\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd23\udf00-\udf1c\udf27\udf30-\udf45\udfe0-\udff6]|\ud804[\udc03-\udc37\udc83-\udcaf\udcd0-\udce8\udd03-\udd26\udd44\udd50-\udd72\udd76\udd83-\uddb2\uddc1-\uddc4\uddda\udddc\ude00-\ude11\ude13-\ude2b\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udede\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3d\udf50\udf5d-\udf61]|\ud805[\udc00-\udc34\udc47-\udc4a\udc5f\udc80-\udcaf\udcc4-\udcc5\udcc7\udd80-\uddae\uddd8-\udddb\ude00-\ude2f\ude44\ude80-\udeaa\udeb8\udf00-\udf1a]|\ud806[\udc00-\udc2b\udca0-\udcdf\udcff\udda0-\udda7\uddaa-\uddd0\udde1\udde3\ude00\ude0b-\ude32\ude3a\ude50\ude5c-\ude89\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc2e\udc40\udc72-\udc8f\udd00-\udd06\udd08-\udd09\udd0b-\udd30\udd46\udd60-\udd65\udd67-\udd68\udd6a-\udd89\udd98\udee0-\udef2]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\uded0-\udeed\udf00-\udf2f\udf40-\udf43\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf50\udf93-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb]|\ud838[\udd00-\udd2c\udd37-\udd3d\udd4e\udec0-\udeeb]|\ud83a[\udc00-\udcc4\udd00-\udd43\udd4b]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\}))(([\u0030-\u0039\u0041-\u005a\u005f\u0061-\u007a\u00aa\u00b5\u00b7\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u05d0-\u05ea\u05ef-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u07fd\u0800-\u082d\u0840-\u085b\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u08d3-\u08e1\u08e3-\u0963\u0966-\u096f\u0971-\u0983\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7-\u09c8\u09cb-\u09ce\u09d7\u09dc-\u09dd\u09df-\u09e3\u09e6-\u09f1\u09fc\u09fe\u0a01-\u0a03\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a3c\u0a3e-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0af9-\u0aff\u0b01-\u0b03\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47-\u0b48\u0b4b-\u0b4d\u0b56-\u0b57\u0b5c-\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82-\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c00-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56\u0c58-\u0c5a\u0c60-\u0c63\u0c66-\u0c6f\u0c80-\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5-\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1-\u0cf2\u0d00-\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d54-\u0d57\u0d5f-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82-\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2-\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18-\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1369-\u1371\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772-\u1773\u1780-\u17d3\u17d7\u17dc-\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1878\u1880-\u18aa\u18b0-\u18f5\u1900-\u191e\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19da\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1ab0-\u1abd\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1cd0-\u1cd2\u1cd4-\u1cfa\u1d00-\u1df9\u1dfb-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u203f-\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua827\ua840-\ua873\ua880-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua8fd-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\ua9e0-\ua9fe\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabea\uabec-\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe2f\ufe33-\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\uddfd\ude80-\ude9c\udea0-\uded0\udee0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf7a\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udca0-\udca9\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00-\ude03\ude05-\ude06\ude0c-\ude13\ude15-\ude17\ude19-\ude35\ude38-\ude3a\ude3f\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee6\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd27\udd30-\udd39\udf00-\udf1c\udf27\udf30-\udf50\udfe0-\udff6]|\ud804[\udc00-\udc46\udc66-\udc6f\udc7f-\udcba\udcd0-\udce8\udcf0-\udcf9\udd00-\udd34\udd36-\udd3f\udd44-\udd46\udd50-\udd73\udd76\udd80-\uddc4\uddc9-\uddcc\uddd0-\uddda\udddc\ude00-\ude11\ude13-\ude37\ude3e\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udeea\udef0-\udef9\udf00-\udf03\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3b-\udf44\udf47-\udf48\udf4b-\udf4d\udf50\udf57\udf5d-\udf63\udf66-\udf6c\udf70-\udf74]|\ud805[\udc00-\udc4a\udc50-\udc59\udc5e-\udc5f\udc80-\udcc5\udcc7\udcd0-\udcd9\udd80-\uddb5\uddb8-\uddc0\uddd8-\udddd\ude00-\ude40\ude44\ude50-\ude59\ude80-\udeb8\udec0-\udec9\udf00-\udf1a\udf1d-\udf2b\udf30-\udf39]|\ud806[\udc00-\udc3a\udca0-\udce9\udcff\udda0-\udda7\uddaa-\uddd7\uddda-\udde1\udde3-\udde4\ude00-\ude3e\ude47\ude50-\ude99\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc36\udc38-\udc40\udc50-\udc59\udc72-\udc8f\udc92-\udca7\udca9-\udcb6\udd00-\udd06\udd08-\udd09\udd0b-\udd36\udd3a\udd3c-\udd3d\udd3f-\udd47\udd50-\udd59\udd60-\udd65\udd67-\udd68\udd6a-\udd8e\udd90-\udd91\udd93-\udd98\udda0-\udda9\udee0-\udef6]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\ude60-\ude69\uded0-\udeed\udef0-\udef4\udf00-\udf36\udf40-\udf43\udf50-\udf59\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf4f-\udf87\udf8f-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99\udc9d-\udc9e]|\ud834[\udd65-\udd69\udd6d-\udd72\udd7b-\udd82\udd85-\udd8b\uddaa-\uddad\ude42-\ude44]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb\udfce-\udfff]|\ud836[\ude00-\ude36\ude3b-\ude6c\ude75\ude84\ude9b-\ude9f\udea1-\udeaf]|\ud838[\udc00-\udc06\udc08-\udc18\udc1b-\udc21\udc23-\udc24\udc26-\udc2a\udd00-\udd2c\udd30-\udd3d\udd40-\udd49\udd4e\udec0-\udef9]|\ud83a[\udc00-\udcc4\udcd0-\udcd6\udd00-\udd4b\udd50-\udd59]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d]|\udb40[\udd00-\uddef])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\})|[\u200c\u200d])*>/, function () {
  yytext = yytext.slice(3, -1);
  validateUnicodeGroupName(yytext, this.getCurrentState());
  return 'NAMED_CAPTURE_GROUP';
}], [/^\(/, function () {
  return 'L_PAREN';
}], [/^\)/, function () {
  return 'R_PAREN';
}], [/^[*?+[^$]/, function () {
  return 'CHAR';
}], [/^\\\]/, function () {
  return 'ESC_CHAR';
}], [/^\]/, function () {
  this.popState();return 'R_BRACKET';
}], [/^\^/, function () {
  return 'BOS';
}], [/^\$/, function () {
  return 'EOS';
}], [/^\*/, function () {
  return 'STAR';
}], [/^\?/, function () {
  return 'Q_MARK';
}], [/^\+/, function () {
  return 'PLUS';
}], [/^\|/, function () {
  return 'BAR';
}], [/^\./, function () {
  return 'ANY';
}], [/^\//, function () {
  return 'SLASH';
}], [/^[^*?+\[()\\|]/, function () {
  return 'CHAR';
}], [/^\[\^/, function () {
  var s = this.getCurrentState();this.pushState(s === 'u' || s === 'xu' ? 'u_class' : 'class');return 'NEG_CLASS';
}], [/^\[/, function () {
  var s = this.getCurrentState();this.pushState(s === 'u' || s === 'xu' ? 'u_class' : 'class');return 'L_BRACKET';
}]];
var lexRulesByConditions = { "INITIAL": [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 22, 23, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "u": [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "xu": [0, 1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "x": [0, 1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 22, 23, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "u_class": [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "class": [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 22, 23, 24, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51] };

var EOF_TOKEN = {
  type: EOF,
  value: ''
};

tokenizer = {
  initString: function initString(string) {
    this._string = string;
    this._cursor = 0;

    this._states = ['INITIAL'];
    this._tokensQueue = [];

    this._currentLine = 1;
    this._currentColumn = 0;
    this._currentLineBeginOffset = 0;

    /**
     * Matched token location data.
     */
    this._tokenStartOffset = 0;
    this._tokenEndOffset = 0;
    this._tokenStartLine = 1;
    this._tokenEndLine = 1;
    this._tokenStartColumn = 0;
    this._tokenEndColumn = 0;

    return this;
  },


  /**
   * Returns tokenizer states.
   */
  getStates: function getStates() {
    return this._states;
  },
  getCurrentState: function getCurrentState() {
    return this._states[this._states.length - 1];
  },
  pushState: function pushState(state) {
    this._states.push(state);
  },
  begin: function begin(state) {
    this.pushState(state);
  },
  popState: function popState() {
    if (this._states.length > 1) {
      return this._states.pop();
    }
    return this._states[0];
  },
  getNextToken: function getNextToken() {
    // Something was queued, return it.
    if (this._tokensQueue.length > 0) {
      return this.onToken(this._toToken(this._tokensQueue.shift()));
    }

    if (!this.hasMoreTokens()) {
      return this.onToken(EOF_TOKEN);
    }

    var string = this._string.slice(this._cursor);
    var lexRulesForState = lexRulesByConditions[this.getCurrentState()];

    for (var i = 0; i < lexRulesForState.length; i++) {
      var lexRuleIndex = lexRulesForState[i];
      var lexRule = lexRules[lexRuleIndex];

      var matched = this._match(string, lexRule[0]);

      // Manual handling of EOF token (the end of string). Return it
      // as `EOF` symbol.
      if (string === '' && matched === '') {
        this._cursor++;
      }

      if (matched !== null) {
        yytext = matched;
        yytext.length;
        var token = lexRule[1].call(this);

        if (!token) {
          return this.getNextToken();
        }

        // If multiple tokens are returned, save them to return
        // on next `getNextToken` call.

        if (Array.isArray(token)) {
          var tokensToQueue = token.slice(1);
          token = token[0];
          if (tokensToQueue.length > 0) {
            var _tokensQueue;

            (_tokensQueue = this._tokensQueue).unshift.apply(_tokensQueue, _toConsumableArray$8(tokensToQueue));
          }
        }

        return this.onToken(this._toToken(token, yytext));
      }
    }

    if (this.isEOF()) {
      this._cursor++;
      return EOF_TOKEN;
    }

    this.throwUnexpectedToken(string[0], this._currentLine, this._currentColumn);
  },


  /**
   * Throws default "Unexpected token" exception, showing the actual
   * line from the source, pointing with the ^ marker to the bad token.
   * In addition, shows `line:column` location.
   */
  throwUnexpectedToken: function throwUnexpectedToken(symbol, line, column) {
    var lineSource = this._string.split('\n')[line - 1];
    var lineData = '';

    if (lineSource) {
      var pad = ' '.repeat(column);
      lineData = '\n\n' + lineSource + '\n' + pad + '^\n';
    }

    throw new SyntaxError(lineData + 'Unexpected token: "' + symbol + '" ' + ('at ' + line + ':' + column + '.'));
  },
  getCursor: function getCursor() {
    return this._cursor;
  },
  getCurrentLine: function getCurrentLine() {
    return this._currentLine;
  },
  getCurrentColumn: function getCurrentColumn() {
    return this._currentColumn;
  },
  _captureLocation: function _captureLocation(matched) {
    var nlRe = /\n/g;

    // Absolute offsets.
    this._tokenStartOffset = this._cursor;

    // Line-based locations, start.
    this._tokenStartLine = this._currentLine;
    this._tokenStartColumn = this._tokenStartOffset - this._currentLineBeginOffset;

    // Extract `\n` in the matched token.
    var nlMatch = void 0;
    while ((nlMatch = nlRe.exec(matched)) !== null) {
      this._currentLine++;
      this._currentLineBeginOffset = this._tokenStartOffset + nlMatch.index + 1;
    }

    this._tokenEndOffset = this._cursor + matched.length;

    // Line-based locations, end.
    this._tokenEndLine = this._currentLine;
    this._tokenEndColumn = this._currentColumn = this._tokenEndOffset - this._currentLineBeginOffset;
  },
  _toToken: function _toToken(tokenType) {
    var yytext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    return {
      // Basic data.
      type: tokenType,
      value: yytext,

      // Location data.
      startOffset: this._tokenStartOffset,
      endOffset: this._tokenEndOffset,
      startLine: this._tokenStartLine,
      endLine: this._tokenEndLine,
      startColumn: this._tokenStartColumn,
      endColumn: this._tokenEndColumn
    };
  },
  isEOF: function isEOF() {
    return this._cursor === this._string.length;
  },
  hasMoreTokens: function hasMoreTokens() {
    return this._cursor <= this._string.length;
  },
  _match: function _match(string, regexp) {
    var matched = string.match(regexp);
    if (matched) {
      // Handle `\n` in the matched token to track line numbers.
      this._captureLocation(matched[0]);
      this._cursor += matched[0].length;
      return matched[0];
    }
    return null;
  },


  /**
   * Allows analyzing, and transforming token. Default implementation
   * just passes the token through.
   */
  onToken: function onToken(token) {
    return token;
  }
};

/**
 * Expose tokenizer so it can be accessed in semantic actions.
 */
yy.lexer = tokenizer;
yy.tokenizer = tokenizer;

/**
 * Global parsing options. Some options can be shadowed per
 * each `parse` call, if the optations are passed.
 *
 * Initalized to the `captureLocations` which is passed
 * from the generator. Other options can be added at runtime.
 */
yy.options = {
  captureLocations: true
};

/**
 * Parsing module.
 */
var yyparse = {
  /**
   * Sets global parsing options.
   */
  setOptions: function setOptions(options) {
    yy.options = options;
    return this;
  },


  /**
   * Returns parsing options.
   */
  getOptions: function getOptions() {
    return yy.options;
  },


  /**
   * Parses a string.
   */
  parse: function parse(string, parseOptions) {
    if (!tokenizer) {
      throw new Error('Tokenizer instance wasn\'t specified.');
    }

    tokenizer.initString(string);

    /**
     * If parse options are passed, override global parse options for
     * this call, and later restore global options.
     */
    var globalOptions = yy.options;
    if (parseOptions) {
      yy.options = Object.assign({}, yy.options, parseOptions);
    }

    /**
     * Allow callers to do setup work based on the
     * parsing string, and passed options.
     */
    yyparse.onParseBegin(string, tokenizer, yy.options);

    stack.length = 0;
    stack.push(0);

    var token = tokenizer.getNextToken();
    var shiftedToken = null;

    do {
      if (!token) {
        // Restore options.
        yy.options = globalOptions;
        unexpectedEndOfInput();
      }

      var state = stack[stack.length - 1];
      var column = tokens[token.type];

      if (!table[state].hasOwnProperty(column)) {
        yy.options = globalOptions;
        unexpectedToken(token);
      }

      var entry = table[state][column];

      // Shift action.
      if (entry[0] === 's') {
        var _loc2 = null;

        if (yy.options.captureLocations) {
          _loc2 = {
            startOffset: token.startOffset,
            endOffset: token.endOffset,
            startLine: token.startLine,
            endLine: token.endLine,
            startColumn: token.startColumn,
            endColumn: token.endColumn
          };
        }

        shiftedToken = this.onShift(token);

        stack.push({ symbol: tokens[shiftedToken.type], semanticValue: shiftedToken.value, loc: _loc2 }, Number(entry.slice(1)));

        token = tokenizer.getNextToken();
      }

      // Reduce action.
      else if (entry[0] === 'r') {
          var productionNumber = entry.slice(1);
          var production = productions[productionNumber];
          var hasSemanticAction = typeof production[2] === 'function';
          var semanticValueArgs = hasSemanticAction ? [] : null;

          var locationArgs = hasSemanticAction && yy.options.captureLocations ? [] : null;

          if (production[1] !== 0) {
            var rhsLength = production[1];
            while (rhsLength-- > 0) {
              stack.pop();
              var stackEntry = stack.pop();

              if (hasSemanticAction) {
                semanticValueArgs.unshift(stackEntry.semanticValue);

                if (locationArgs) {
                  locationArgs.unshift(stackEntry.loc);
                }
              }
            }
          }

          var reduceStackEntry = { symbol: production[0] };

          if (hasSemanticAction) {
            yytext = shiftedToken ? shiftedToken.value : null;
            shiftedToken ? shiftedToken.value.length : null;

            var semanticActionArgs = locationArgs !== null ? semanticValueArgs.concat(locationArgs) : semanticValueArgs;

            production[2].apply(production, _toConsumableArray$8(semanticActionArgs));

            reduceStackEntry.semanticValue = __;

            if (locationArgs) {
              reduceStackEntry.loc = __loc;
            }
          }

          var nextState = stack[stack.length - 1];
          var symbolToReduceWith = production[0];

          stack.push(reduceStackEntry, table[nextState][symbolToReduceWith]);
        }

        // Accept.
        else if (entry === 'acc') {
            stack.pop();
            var parsed = stack.pop();

            if (stack.length !== 1 || stack[0] !== 0 || tokenizer.hasMoreTokens()) {
              // Restore options.
              yy.options = globalOptions;
              unexpectedToken(token);
            }

            if (parsed.hasOwnProperty('semanticValue')) {
              yy.options = globalOptions;
              yyparse.onParseEnd(parsed.semanticValue);
              return parsed.semanticValue;
            }

            yyparse.onParseEnd();

            // Restore options.
            yy.options = globalOptions;
            return true;
          }
    } while (tokenizer.hasMoreTokens() || stack.length > 1);
  },
  setTokenizer: function setTokenizer(customTokenizer) {
    tokenizer = customTokenizer;
    return yyparse;
  },
  getTokenizer: function getTokenizer() {
    return tokenizer;
  },
  onParseBegin: function onParseBegin(string, tokenizer, options) {},
  onParseEnd: function onParseEnd(parsed) {},


  /**
   * Allows analyzing, and transforming shifted token. Default implementation
   * just passes the token through.
   */
  onShift: function onShift(token) {
    return token;
  }
};

/**
 * Tracks capturing groups.
 */
var capturingGroupsCount = 0;

/**
 * Tracks named groups.
 */
var namedGroups = {};

/**
 * Parsing string.
 */
var parsingString = '';

yyparse.onParseBegin = function (string, lexer) {
  parsingString = string;
  capturingGroupsCount = 0;
  namedGroups = {};

  var lastSlash = string.lastIndexOf('/');
  var flags = string.slice(lastSlash);

  if (flags.includes('x') && flags.includes('u')) {
    lexer.pushState('xu');
  } else {
    if (flags.includes('x')) {
      lexer.pushState('x');
    }
    if (flags.includes('u')) {
      lexer.pushState('u');
    }
  }
};

/**
 * On shifting `(` remember its number to used on reduce.
 */
yyparse.onShift = function (token) {
  if (token.type === 'L_PAREN' || token.type === 'NAMED_CAPTURE_GROUP') {
    token.value = new String(token.value);
    token.value.groupNumber = ++capturingGroupsCount;
  }
  return token;
};

/**
 * Extracts ranges from the range string.
 */
function getRange(text) {
  var range = text.match(/\d+/g).map(Number);

  if (Number.isFinite(range[1]) && range[1] < range[0]) {
    throw new SyntaxError('Numbers out of order in ' + text + ' quantifier');
  }

  return range;
}

/**
 * Checks class range
 */
function checkClassRange(from, to) {
  if (from.kind === 'control' || to.kind === 'control' || !isNaN(from.codePoint) && !isNaN(to.codePoint) && from.codePoint > to.codePoint) {
    throw new SyntaxError('Range ' + from.value + '-' + to.value + ' out of order in character class');
  }
}

// ---------------------- Unicode property -------------------------------------------

var unicodeProperties = parserUnicodeProperties;

/**
 * Unicode property.
 */
function UnicodeProperty(matched, loc) {
  var negative = matched[1] === 'P';
  var separatorIdx = matched.indexOf('=');

  var name = matched.slice(3, separatorIdx !== -1 ? separatorIdx : -1);
  var value = void 0;

  // General_Category allows using only value as a shorthand.
  var isShorthand = separatorIdx === -1 && unicodeProperties.isGeneralCategoryValue(name);

  // Binary propery name.
  var isBinaryProperty = separatorIdx === -1 && unicodeProperties.isBinaryPropertyName(name);

  if (isShorthand) {
    value = name;
    name = 'General_Category';
  } else if (isBinaryProperty) {
    value = name;
  } else {
    if (!unicodeProperties.isValidName(name)) {
      throw new SyntaxError('Invalid unicode property name: ' + name + '.');
    }

    value = matched.slice(separatorIdx + 1, -1);

    if (!unicodeProperties.isValidValue(name, value)) {
      throw new SyntaxError('Invalid ' + name + ' unicode property value: ' + value + '.');
    }
  }

  return Node({
    type: 'UnicodeProperty',
    name: name,
    value: value,
    negative: negative,
    shorthand: isShorthand,
    binary: isBinaryProperty,
    canonicalName: unicodeProperties.getCanonicalName(name) || name,
    canonicalValue: unicodeProperties.getCanonicalValue(value) || value
  }, loc);
}

// ----------------------------------------------------------------------------------


/**
 * Creates a character node.
 */
function Char(value, kind, loc) {
  var symbol = void 0;
  var codePoint = void 0;

  switch (kind) {
    case 'decimal':
      {
        codePoint = Number(value.slice(1));
        symbol = String.fromCodePoint(codePoint);
        break;
      }
    case 'oct':
      {
        codePoint = parseInt(value.slice(1), 8);
        symbol = String.fromCodePoint(codePoint);
        break;
      }
    case 'hex':
    case 'unicode':
      {
        if (value.lastIndexOf('\\u') > 0) {
          var _value$split$slice = value.split('\\u').slice(1),
              _value$split$slice2 = _slicedToArray$2(_value$split$slice, 2),
              lead = _value$split$slice2[0],
              trail = _value$split$slice2[1];

          lead = parseInt(lead, 16);
          trail = parseInt(trail, 16);
          codePoint = (lead - 0xd800) * 0x400 + (trail - 0xdc00) + 0x10000;

          symbol = String.fromCodePoint(codePoint);
        } else {
          var hex = value.slice(2).replace('{', '');
          codePoint = parseInt(hex, 16);
          if (codePoint > 0x10ffff) {
            throw new SyntaxError('Bad character escape sequence: ' + value);
          }

          symbol = String.fromCodePoint(codePoint);
        }
        break;
      }
    case 'meta':
      {
        switch (value) {
          case '\\t':
            symbol = '\t';
            codePoint = symbol.codePointAt(0);
            break;
          case '\\n':
            symbol = '\n';
            codePoint = symbol.codePointAt(0);
            break;
          case '\\r':
            symbol = '\r';
            codePoint = symbol.codePointAt(0);
            break;
          case '\\v':
            symbol = '\v';
            codePoint = symbol.codePointAt(0);
            break;
          case '\\f':
            symbol = '\f';
            codePoint = symbol.codePointAt(0);
            break;
          case '\\b':
            symbol = '\b';
            codePoint = symbol.codePointAt(0);
          case '\\0':
            symbol = '\0';
            codePoint = 0;
          case '.':
            symbol = '.';
            codePoint = NaN;
            break;
          default:
            codePoint = NaN;
        }
        break;
      }
    case 'simple':
      {
        symbol = value;
        codePoint = symbol.codePointAt(0);
        break;
      }
  }

  return Node({
    type: 'Char',
    value: value,
    kind: kind,
    symbol: symbol,
    codePoint: codePoint
  }, loc);
}

/**
 * Valid flags per current ECMAScript spec and
 * stage 3+ proposals.
 */
var validFlags = 'gimsuxy';

/**
 * Checks the flags are valid, and that
 * we don't duplicate flags.
 */
function checkFlags(flags) {
  var seen = new Set();

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = flags[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var flag = _step.value;

      if (seen.has(flag) || !validFlags.includes(flag)) {
        throw new SyntaxError('Invalid flags: ' + flags);
      }
      seen.add(flag);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return flags.split('').sort().join('');
}

/**
 * Parses patterns like \1, \2, etc. either as a backreference
 * to a group, or a deciaml char code.
 */
function GroupRefOrDecChar(text, textLoc) {
  var reference = Number(text.slice(1));

  if (reference > 0 && reference <= capturingGroupsCount) {
    return Node({
      type: 'Backreference',
      kind: 'number',
      number: reference,
      reference: reference
    }, textLoc);
  }

  return Char(text, 'decimal', textLoc);
}

/**
 * Unicode names.
 */
var uReStart = /^\\u[0-9a-fA-F]{4}/; // only matches start of string
var ucpReStart = /^\\u\{[0-9a-fA-F]{1,}\}/; // only matches start of string
var ucpReAnywhere = /\\u\{[0-9a-fA-F]{1,}\}/; // matches anywhere in string

/**
 * Validates Unicode group name.
 */
function validateUnicodeGroupName(name, state) {
  var isUnicodeName = ucpReAnywhere.test(name);
  var isUnicodeState = state === 'u' || state === 'xu' || state === 'u_class';

  if (isUnicodeName && !isUnicodeState) {
    throw new SyntaxError('invalid group Unicode name "' + name + '", use `u` flag.');
  }

  return name;
}

// Matches the following production: https://tc39.es/ecma262/#prod-RegExpUnicodeEscapeSequence
//
//  RegExpUnicodeEscapeSequence ::
//    `u` LeadSurrogate `\u` TrailSurrogate   # as 'leadSurrogate', 'trailSurrogate'
//    `u` LeadSurrogate                       # as 'leadSurrogateOnly'
//    `u` TrailSurrogate                      # as 'trailSurrogateOnly'
//    `u` NonSurrogate                        # as 'nonSurrogate'
//    `u` `{` CodePoint `}`                   # as 'codePoint'
//
//  LeadSurrogate ::
//    Hex4Digits but only if the SV of Hex4Digits is in the inclusive range 0xD800 to 0xDBFF        # [dD][89aAbB][0-9a-fA-F]{2}
//
//  TrailSurrogate ::
//    Hex4Digits but only if the SV of Hex4Digits is in the inclusive range 0xDC00 to 0xDFFF        # [dD][c-fC-F][0-9a-fA-F]{2}
//
//  NonSurrogate ::
//    Hex4Digits but only if the SV of Hex4Digits is not in the inclusive range 0xD800 to 0xDFFF    # [0-9a-ce-fA-CE-F][0-9a-fA-F]{3}|[dD][0-7][0-9a-fA-F]{2}
//
//  CodePoint ::
//    HexDigits but only if MV of HexDigits ≤ 0x10FFFF                                              # 0*(?:[0-9a-fA-F]{1,5}|10[0-9a-fA-F]{4})
//
var uidRe = /\\u(?:([dD][89aAbB][0-9a-fA-F]{2})\\u([dD][c-fC-F][0-9a-fA-F]{2})|([dD][89aAbB][0-9a-fA-F]{2})|([dD][c-fC-F][0-9a-fA-F]{2})|([0-9a-ce-fA-CE-F][0-9a-fA-F]{3}|[dD][0-7][0-9a-fA-F]{2})|\{(0*(?:[0-9a-fA-F]{1,5}|10[0-9a-fA-F]{4}))\})/;

function decodeUnicodeGroupName(name) {
  return name.replace(new RegExp(uidRe, 'g'), function (_, leadSurrogate, trailSurrogate, leadSurrogateOnly, trailSurrogateOnly, nonSurrogate, codePoint) {
    if (leadSurrogate) {
      return String.fromCodePoint(parseInt(leadSurrogate, 16), parseInt(trailSurrogate, 16));
    }
    if (leadSurrogateOnly) {
      return String.fromCodePoint(parseInt(leadSurrogateOnly, 16));
    }
    if (trailSurrogateOnly) {
      // TODO: Per the spec: https://tc39.es/ecma262/#prod-RegExpUnicodeEscapeSequence
      // > Each `\u` TrailSurrogate for which the choice of associated `u` LeadSurrogate is ambiguous shall be associated with the nearest possible `u` LeadSurrogate that would otherwise have no corresponding `\u` TrailSurrogate.
      return String.fromCodePoint(parseInt(trailSurrogateOnly, 16));
    }
    if (nonSurrogate) {
      return String.fromCodePoint(parseInt(nonSurrogate, 16));
    }
    if (codePoint) {
      return String.fromCodePoint(parseInt(codePoint, 16));
    }
    return _;
  });
}

/**
 * Extracts from `\k<foo>` pattern either a backreference
 * to a named capturing group (if it presents), or parses it
 * as a list of char: `\k`, `<`, `f`, etc.
 */
function NamedGroupRefOrChars(text, textLoc) {
  var referenceRaw = text.slice(3, -1);
  var reference = decodeUnicodeGroupName(referenceRaw);

  if (namedGroups.hasOwnProperty(reference)) {
    return Node({
      type: 'Backreference',
      kind: 'name',
      number: namedGroups[reference],
      reference: reference,
      referenceRaw: referenceRaw
    }, textLoc);
  }

  // Else `\k<foo>` should be parsed as a list of `Char`s.
  // This is really a 0.01% edge case, but we should handle it.

  var startOffset = null;
  var startLine = null;
  var endLine = null;
  var startColumn = null;

  if (textLoc) {
    startOffset = textLoc.startOffset;
    startLine = textLoc.startLine;
    endLine = textLoc.endLine;
    startColumn = textLoc.startColumn;
  }

  var charRe = /^[\w$<>]/;
  var loc = void 0;

  var chars = [
  // Init to first \k, taking 2 symbols.
  Char(text.slice(1, 2), 'simple', startOffset ? {
    startLine: startLine,
    endLine: endLine,
    startColumn: startColumn,
    startOffset: startOffset,
    endOffset: startOffset += 2,
    endColumn: startColumn += 2
  } : null)];

  // For \k
  chars[0].escaped = true;

  // Other symbols.
  text = text.slice(2);

  while (text.length > 0) {
    var matched = null;

    // Unicode, \u003B or \u{003B}
    if ((matched = text.match(uReStart)) || (matched = text.match(ucpReStart))) {
      if (startOffset) {
        loc = {
          startLine: startLine,
          endLine: endLine,
          startColumn: startColumn,
          startOffset: startOffset,
          endOffset: startOffset += matched[0].length,
          endColumn: startColumn += matched[0].length
        };
      }
      chars.push(Char(matched[0], 'unicode', loc));
      text = text.slice(matched[0].length);
    }

    // Simple char.
    else if (matched = text.match(charRe)) {
        if (startOffset) {
          loc = {
            startLine: startLine,
            endLine: endLine,
            startColumn: startColumn,
            startOffset: startOffset,
            endOffset: ++startOffset,
            endColumn: ++startColumn
          };
        }
        chars.push(Char(matched[0], 'simple', loc));
        text = text.slice(1);
      }
  }

  return chars;
}

/**
 * Creates an AST node with a location.
 */
function Node(node, loc) {
  if (yy.options.captureLocations) {
    node.loc = {
      source: parsingString.slice(loc.startOffset, loc.endOffset),
      start: {
        line: loc.startLine,
        column: loc.startColumn,
        offset: loc.startOffset
      },
      end: {
        line: loc.endLine,
        column: loc.endColumn,
        offset: loc.endOffset
      }
    };
  }
  return node;
}

/**
 * Creates location node.
 */
function loc(start, end) {
  if (!yy.options.captureLocations) {
    return null;
  }

  return {
    startOffset: start.startOffset,
    endOffset: end.endOffset,
    startLine: start.startLine,
    endLine: end.endLine,
    startColumn: start.startColumn,
    endColumn: end.endColumn
  };
}

function unexpectedToken(token) {
  if (token.type === EOF) {
    unexpectedEndOfInput();
  }

  tokenizer.throwUnexpectedToken(token.value, token.startLine, token.startColumn);
}

function unexpectedEndOfInput() {
  parseError('Unexpected end of input.');
}

function parseError(message) {
  throw new SyntaxError(message);
}

var regexpTree$4 = yyparse;

regexpTree$4.default;

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var regexpTreeParser = regexpTree$4;

/**
 * Original parse function.
 */
var generatedParseFn = regexpTreeParser.parse.bind(regexpTreeParser);

/**
 * Parses a regular expression.
 *
 * Override original `regexpTreeParser.parse` to convert a value to a string,
 * since in regexp-tree we may pass strings, and RegExp instance.
 */
regexpTreeParser.parse = function (regexp, options) {
  return generatedParseFn('' + regexp, options);
};

// By default do not capture locations; callers may override.
regexpTreeParser.setOptions({ captureLocations: false });

var parser$4 = regexpTreeParser;

parser$4.default;

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var _createClass$6 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$6(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DEFAULT_COLLECTION_PROP = 'expressions';
var DEFAULT_SINGLE_PROP = 'expression';

/**
 * NodePath class encapsulates a traversing node,
 * its parent node, property name in the parent node, and
 * an index (in case if a node is part of a collection).
 * It also provides set of methods for AST manipulation.
 */

var NodePath$3 = function () {
  /**
   * NodePath constructor.
   *
   * @param Object node - an AST node
   * @param NodePath parentPath - a nullable parent path
   * @param string property - property name of the node in the parent
   * @param number index - index of the node in a collection.
   */
  function NodePath(node) {
    var parentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var property = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    _classCallCheck$6(this, NodePath);

    this.node = node;
    this.parentPath = parentPath;
    this.parent = parentPath ? parentPath.node : null;
    this.property = property;
    this.index = index;
  }

  _createClass$6(NodePath, [{
    key: '_enforceProp',
    value: function _enforceProp(property) {
      if (!this.node.hasOwnProperty(property)) {
        throw new Error('Node of type ' + this.node.type + ' doesn\'t have "' + property + '" collection.');
      }
    }

    /**
     * Sets a node into a children collection or the single child.
     * By default child nodes are supposed to be under `expressions` property.
     * An explicit property can be passed.
     *
     * @param Object node - a node to set into a collection or as single child
     * @param number index - index at which to set
     * @param string property - name of the collection or single property
     */

  }, {
    key: 'setChild',
    value: function setChild(node) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var property = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;


      var childPath = void 0;
      if (index != null) {
        if (!property) {
          property = DEFAULT_COLLECTION_PROP;
        }
        this._enforceProp(property);
        this.node[property][index] = node;
        childPath = NodePath.getForNode(node, this, property, index);
      } else {
        if (!property) {
          property = DEFAULT_SINGLE_PROP;
        }
        this._enforceProp(property);
        this.node[property] = node;
        childPath = NodePath.getForNode(node, this, property, null);
      }
      return childPath;
    }

    /**
     * Appends a node to a children collection.
     * By default child nodes are supposed to be under `expressions` property.
     * An explicit property can be passed.
     *
     * @param Object node - a node to set into a collection or as single child
     * @param string property - name of the collection or single property
     */

  }, {
    key: 'appendChild',
    value: function appendChild(node) {
      var property = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;


      if (!property) {
        property = DEFAULT_COLLECTION_PROP;
      }
      this._enforceProp(property);
      var end = this.node[property].length;
      return this.setChild(node, end, property);
    }

    /**
     * Inserts a node into a collection.
     * By default child nodes are supposed to be under `expressions` property.
     * An explicit property can be passed.
     *
     * @param Object node - a node to insert into a collection
     * @param number index - index at which to insert
     * @param string property - name of the collection property
     */

  }, {
    key: 'insertChildAt',
    value: function insertChildAt(node, index) {
      var property = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_COLLECTION_PROP;

      this._enforceProp(property);

      this.node[property].splice(index, 0, node);

      // If we inserted a node before the traversing index,
      // we should increase the later.
      if (index <= NodePath.getTraversingIndex()) {
        NodePath.updateTraversingIndex(1);
      }

      this._rebuildIndex(this.node, property);
    }

    /**
     * Removes a node.
     */

  }, {
    key: 'remove',
    value: function remove() {
      if (this.isRemoved()) {
        return;
      }
      NodePath.registry.delete(this.node);

      this.node = null;

      if (!this.parent) {
        return;
      }

      // A node is in a collection.
      if (this.index !== null) {
        this.parent[this.property].splice(this.index, 1);

        // If we remove a node before the traversing index,
        // we should increase the later.
        if (this.index <= NodePath.getTraversingIndex()) {
          NodePath.updateTraversingIndex(-1);
        }

        // Rebuild index.
        this._rebuildIndex(this.parent, this.property);

        this.index = null;
        this.property = null;

        return;
      }

      // A simple node.
      delete this.parent[this.property];
      this.property = null;
    }

    /**
     * Rebuilds child nodes index (used on remove/insert).
     */

  }, {
    key: '_rebuildIndex',
    value: function _rebuildIndex(parent, property) {
      var parentPath = NodePath.getForNode(parent);

      for (var i = 0; i < parent[property].length; i++) {
        var path = NodePath.getForNode(parent[property][i], parentPath, property, i);
        path.index = i;
      }
    }

    /**
     * Whether the path was removed.
     */

  }, {
    key: 'isRemoved',
    value: function isRemoved() {
      return this.node === null;
    }

    /**
     * Replaces a node with the passed one.
     */

  }, {
    key: 'replace',
    value: function replace(newNode) {
      NodePath.registry.delete(this.node);

      this.node = newNode;

      if (!this.parent) {
        return null;
      }

      // A node is in a collection.
      if (this.index !== null) {
        this.parent[this.property][this.index] = newNode;
      }

      // A simple node.
      else {
          this.parent[this.property] = newNode;
        }

      // Rebuild the node path for the new node.
      return NodePath.getForNode(newNode, this.parentPath, this.property, this.index);
    }

    /**
     * Updates a node inline.
     */

  }, {
    key: 'update',
    value: function update(nodeProps) {
      Object.assign(this.node, nodeProps);
    }

    /**
     * Returns parent.
     */

  }, {
    key: 'getParent',
    value: function getParent() {
      return this.parentPath;
    }

    /**
     * Returns nth child.
     */

  }, {
    key: 'getChild',
    value: function getChild() {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (this.node.expressions) {
        return NodePath.getForNode(this.node.expressions[n], this, DEFAULT_COLLECTION_PROP, n);
      } else if (this.node.expression && n == 0) {
        return NodePath.getForNode(this.node.expression, this, DEFAULT_SINGLE_PROP);
      }
      return null;
    }

    /**
     * Whether a path node is syntactically equal to the passed one.
     *
     * NOTE: we don't rely on `source` property from the `loc` data
     * (which would be the fastest comparison), since it might be unsync
     * after several modifications. We use here simple `JSON.stringify`
     * excluding the `loc` data.
     *
     * @param NodePath other - path to compare to.
     * @return boolean
     */

  }, {
    key: 'hasEqualSource',
    value: function hasEqualSource(path) {
      return JSON.stringify(this.node, jsonSkipLoc) === JSON.stringify(path.node, jsonSkipLoc);
    }

    /**
     * JSON-encodes a node skipping location.
     */

  }, {
    key: 'jsonEncode',
    value: function jsonEncode() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          format = _ref.format,
          useLoc = _ref.useLoc;

      return JSON.stringify(this.node, useLoc ? null : jsonSkipLoc, format);
    }

    /**
     * Returns previous sibling.
     */

  }, {
    key: 'getPreviousSibling',
    value: function getPreviousSibling() {
      if (!this.parent || this.index == null) {
        return null;
      }
      return NodePath.getForNode(this.parent[this.property][this.index - 1], NodePath.getForNode(this.parent), this.property, this.index - 1);
    }

    /**
     * Returns next sibling.
     */

  }, {
    key: 'getNextSibling',
    value: function getNextSibling() {
      if (!this.parent || this.index == null) {
        return null;
      }
      return NodePath.getForNode(this.parent[this.property][this.index + 1], NodePath.getForNode(this.parent), this.property, this.index + 1);
    }

    /**
     * Returns a NodePath instance for a node.
     *
     * The same NodePath can be reused in several places, e.g.
     * a parent node passed for all its children.
     */

  }], [{
    key: 'getForNode',
    value: function getForNode(node) {
      var parentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var prop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;

      if (!node) {
        return null;
      }

      if (!NodePath.registry.has(node)) {
        NodePath.registry.set(node, new NodePath(node, parentPath, prop, index == -1 ? null : index));
      }

      var path = NodePath.registry.get(node);

      if (parentPath !== null) {
        path.parentPath = parentPath;
        path.parent = path.parentPath.node;
      }

      if (prop !== null) {
        path.property = prop;
      }

      if (index >= 0) {
        path.index = index;
      }

      return path;
    }

    /**
     * Initializes the NodePath registry. The registry is a map from
     * a node to its NodePath instance.
     */

  }, {
    key: 'initRegistry',
    value: function initRegistry() {
      if (!NodePath.registry) {
        NodePath.registry = new Map();
      }
      NodePath.registry.clear();
    }

    /**
     * Updates index of a currently traversing collection.
     */

  }, {
    key: 'updateTraversingIndex',
    value: function updateTraversingIndex(dx) {
      return NodePath.traversingIndexStack[NodePath.traversingIndexStack.length - 1] += dx;
    }

    /**
     * Returns current traversing index.
     */

  }, {
    key: 'getTraversingIndex',
    value: function getTraversingIndex() {
      return NodePath.traversingIndexStack[NodePath.traversingIndexStack.length - 1];
    }
  }]);

  return NodePath;
}();

NodePath$3.initRegistry();

/**
 * Index of a currently traversing collection is stored on top of the
 * `NodePath.traversingIndexStack`. Remove/insert methods can adjust
 * this index.
 */
NodePath$3.traversingIndexStack = [];

// Helper function used to skip `loc` in JSON operations.
function jsonSkipLoc(prop, value) {
  if (prop === 'loc') {
    return undefined;
  }
  return value;
}

var nodePath = NodePath$3;

nodePath.default;

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var NodePath$2 = nodePath;

/**
 * Does an actual AST traversal, using visitor pattern,
 * and calling set of callbacks.
 *
 * Based on https://github.com/olov/ast-traverse
 *
 * Expects AST in Mozilla Parser API: nodes which are supposed to be
 * handled should have `type` property.
 *
 * @param Object root - a root node to start traversal from.
 *
 * @param Object options - an object with set of callbacks:
 *
 *   - `pre(node, parent, prop, index)` - a hook called on node enter
 *   - `post`(node, parent, prop, index) - a hook called on node exit
 *   - `skipProperty(prop)` - a predicated whether a property should be skipped
 */
function astTraverse(root) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var pre = options.pre;
  var post = options.post;
  var skipProperty = options.skipProperty;

  function visit(node, parent, prop, idx) {
    if (!node || typeof node.type !== 'string') {
      return;
    }

    var res = undefined;
    if (pre) {
      res = pre(node, parent, prop, idx);
    }

    if (res !== false) {

      // A node can be replaced during traversal, so we have to
      // recalculate it from the parent, to avoid traversing "dead" nodes.
      if (parent && parent[prop]) {
        if (!isNaN(idx)) {
          node = parent[prop][idx];
        } else {
          node = parent[prop];
        }
      }

      for (var _prop in node) {
        if (node.hasOwnProperty(_prop)) {
          if (skipProperty ? skipProperty(_prop, node) : _prop[0] === '$') {
            continue;
          }

          var child = node[_prop];

          // Collection node.
          //
          // NOTE: a node (or several nodes) can be removed or inserted
          // during traversal.
          //
          // Current traversing index is stored on top of the
          // `NodePath.traversingIndexStack`. The stack is used to support
          // recursive nature of the traversal.
          //
          // In this case `NodePath.traversingIndex` (which we use here) is
          // updated in the NodePath remove/insert methods.
          //
          if (Array.isArray(child)) {
            var index = 0;
            NodePath$2.traversingIndexStack.push(index);
            while (index < child.length) {
              visit(child[index], node, _prop, index);
              index = NodePath$2.updateTraversingIndex(1);
            }
            NodePath$2.traversingIndexStack.pop();
          }

          // Simple node.
          else {
              visit(child, node, _prop);
            }
        }
      }
    }

    if (post) {
      post(node, parent, prop, idx);
    }
  }

  visit(root, null);
}

var traverse$3 = {
  /**
   * Traverses an AST.
   *
   * @param Object ast - an AST node
   *
   * @param Object | Array<Object> handlers:
   *
   *   an object (or an array of objects)
   *
   *   Each such object contains a handler function per node.
   *   In case of an array of handlers, they are applied in order.
   *   A handler may return a transformed node (or a different type).
   *
   *   The per-node function may instead be an object with functions pre and post.
   *   pre is called before visiting the node, post after.
   *   If a handler is a function, it is treated as the pre function, with an empty post.
   *
   * @param Object options:
   *
   *   a config object, specifying traversal options:
   *
   *   `asNodes`: boolean - whether handlers should receives raw AST nodes
   *   (false by default), instead of a `NodePath` wrapper. Note, by default
   *   `NodePath` wrapper provides a set of convenient method to manipulate
   *   a traversing AST, and also has access to all parents list. A raw
   *   nodes traversal should be used in rare cases, when no `NodePath`
   *   features are needed.
   *
   * Special hooks:
   *
   *   - `shouldRun(ast)` - a predicate determining whether the handler
   *                        should be applied.
   *
   * NOTE: Multiple handlers are used as an optimization of applying all of
   * them in one AST traversal pass.
   */
  traverse: function traverse(ast, handlers) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { asNodes: false };


    if (!Array.isArray(handlers)) {
      handlers = [handlers];
    }

    // Filter out handlers by result of `shouldRun`, if the method is present.
    handlers = handlers.filter(function (handler) {
      if (typeof handler.shouldRun !== 'function') {
        return true;
      }
      return handler.shouldRun(ast);
    });

    NodePath$2.initRegistry();

    // Allow handlers to initializer themselves.
    handlers.forEach(function (handler) {
      if (typeof handler.init === 'function') {
        handler.init(ast);
      }
    });

    function getPathFor(node, parent, prop, index) {
      var parentPath = NodePath$2.getForNode(parent);
      var nodePath = NodePath$2.getForNode(node, parentPath, prop, index);

      return nodePath;
    }

    // Handle actual nodes.
    astTraverse(ast, {
      /**
       * Handler on node enter.
       */
      pre: function pre(node, parent, prop, index) {
        var nodePath = void 0;
        if (!options.asNodes) {
          nodePath = getPathFor(node, parent, prop, index);
        }

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = handlers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var handler = _step.value;

            // "Catch-all" `*` handler.
            if (typeof handler['*'] === 'function') {
              if (nodePath) {
                // A path/node can be removed by some previous handler.
                if (!nodePath.isRemoved()) {
                  var handlerResult = handler['*'](nodePath);
                  // Explicitly stop traversal.
                  if (handlerResult === false) {
                    return false;
                  }
                }
              } else {
                handler['*'](node, parent, prop, index);
              }
            }

            // Per-node handler.
            var handlerFuncPre = void 0;
            if (typeof handler[node.type] === 'function') {
              handlerFuncPre = handler[node.type];
            } else if (typeof handler[node.type] === 'object' && typeof handler[node.type].pre === 'function') {
              handlerFuncPre = handler[node.type].pre;
            }

            if (handlerFuncPre) {
              if (nodePath) {
                // A path/node can be removed by some previous handler.
                if (!nodePath.isRemoved()) {
                  var _handlerResult = handlerFuncPre.call(handler, nodePath);
                  // Explicitly stop traversal.
                  if (_handlerResult === false) {
                    return false;
                  }
                }
              } else {
                handlerFuncPre.call(handler, node, parent, prop, index);
              }
            }
          } // Loop over handlers
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      },
      // pre func

      /**
       * Handler on node exit.
       */
      post: function post(node, parent, prop, index) {
        if (!node) {
          return;
        }

        var nodePath = void 0;
        if (!options.asNodes) {
          nodePath = getPathFor(node, parent, prop, index);
        }

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = handlers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var handler = _step2.value;

            // Per-node handler.
            var handlerFuncPost = void 0;
            if (typeof handler[node.type] === 'object' && typeof handler[node.type].post === 'function') {
              handlerFuncPost = handler[node.type].post;
            }

            if (handlerFuncPost) {
              if (nodePath) {
                // A path/node can be removed by some previous handler.
                if (!nodePath.isRemoved()) {
                  var handlerResult = handlerFuncPost.call(handler, nodePath);
                  // Explicitly stop traversal.
                  if (handlerResult === false) {
                    return false;
                  }
                }
              } else {
                handlerFuncPost.call(handler, node, parent, prop, index);
              }
            }
          } // Loop over handlers
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      },
      // post func

      /**
       * Skip locations by default.
       */
      skipProperty: function skipProperty(prop) {
        return prop === 'loc';
      }
    });
  }
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var _createClass$5 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$5(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var generator$2 = generator_1;
var parser$3 = parser$4;
var traverse$2 = traverse$3;

/**
 * Transform result.
 */

var TransformResult = function () {
  /**
   * Initializes a transform result for an AST.
   *
   * @param Object ast - an AST node
   * @param mixed extra - any extra data a transform may return
   */
  function TransformResult(ast) {
    var extra = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck$5(this, TransformResult);

    this._ast = ast;
    this._source = null;
    this._string = null;
    this._regexp = null;
    this._extra = extra;
  }

  _createClass$5(TransformResult, [{
    key: 'getAST',
    value: function getAST() {
      return this._ast;
    }
  }, {
    key: 'setExtra',
    value: function setExtra(extra) {
      this._extra = extra;
    }
  }, {
    key: 'getExtra',
    value: function getExtra() {
      return this._extra;
    }
  }, {
    key: 'toRegExp',
    value: function toRegExp() {
      if (!this._regexp) {
        this._regexp = new RegExp(this.getSource(), this._ast.flags);
      }
      return this._regexp;
    }
  }, {
    key: 'getSource',
    value: function getSource() {
      if (!this._source) {
        this._source = generator$2.generate(this._ast.body);
      }
      return this._source;
    }
  }, {
    key: 'getFlags',
    value: function getFlags() {
      return this._ast.flags;
    }
  }, {
    key: 'toString',
    value: function toString() {
      if (!this._string) {
        this._string = generator$2.generate(this._ast);
      }
      return this._string;
    }
  }]);

  return TransformResult;
}();

var transform$3 = {
  /**
   * Expose `TransformResult`.
   */
  TransformResult: TransformResult,

  /**
   * Transforms a regular expression applying a set of
   * transformation handlers.
   *
   * @param string | AST | RegExp:
   *
   *   a regular expression in different representations: a string,
   *   a RegExp object, or an AST.
   *
   * @param Object | Array<Object>:
   *
   *   a handler (or a list of handlers) from `traverse` API.
   *
   * @return TransformResult instance.
   *
   * Example:
   *
   *   transform(/[a-z]/i, {
   *     onChar(path) {
   *       const {node} = path;
   *
   *       if (...) {
   *         path.remove();
   *       }
   *     }
   *   });
   */
  transform: function transform(regexp, handlers) {
    var ast = regexp;

    if (regexp instanceof RegExp) {
      regexp = '' + regexp;
    }

    if (typeof regexp === 'string') {
      ast = parser$3.parse(regexp, {
        captureLocations: true
      });
    }

    traverse$2.traverse(ast, handlers);

    return new TransformResult(ast);
  }
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var compatTransforms = transforms$1;
var _transform$1 = transform$3;

var compatTranspiler$1 = {
  /**
   * Translates a regexp in new syntax to equivalent regexp in old syntax.
   *
   * @param string|RegExp|AST - regexp
   * @param Array transformsWhitelist - names of the transforms to apply
   */
  transform: function transform(regexp) {
    var transformsWhitelist = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    var transformToApply = transformsWhitelist.length > 0 ? transformsWhitelist : Object.keys(compatTransforms);

    var result = void 0;

    // Collect extra data per transform.
    var extra = {};

    transformToApply.forEach(function (transformName) {

      if (!compatTransforms.hasOwnProperty(transformName)) {
        throw new Error('Unknown compat-transform: ' + transformName + '. ' + 'Available transforms are: ' + Object.keys(compatTransforms).join(', '));
      }

      var handler = compatTransforms[transformName];

      result = _transform$1.transform(regexp, handler);
      regexp = result.getAST();

      // Collect `extra` transform result.
      if (typeof handler.getExtra === 'function') {
        extra[transformName] = handler.getExtra();
      }
    });

    // Set the final extras for all transforms.
    result.setExtra(extra);

    return result;
  }
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * Performs a deep copy of an simple object.
 * Only handles scalar values, arrays and objects.
 *
 * @param obj Object
 */

var clone$1 = function clone(obj) {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  var res = void 0;
  if (Array.isArray(obj)) {
    res = [];
  } else {
    res = {};
  }
  for (var i in obj) {
    res[i] = clone(obj[i]);
  }
  return res;
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to transform surrogate pairs into single unicode code point
 *
 * \ud83d\ude80 -> \u{1f680}
 */

var charSurrogatePairToSingleUnicodeTransform = {
  shouldRun: function shouldRun(ast) {
    return ast.flags.includes('u');
  },
  Char: function Char(path) {
    var node = path.node;

    if (node.kind !== 'unicode' || !node.isSurrogatePair || isNaN(node.codePoint)) {
      return;
    }
    node.value = '\\u{' + node.codePoint.toString(16) + '}';
    delete node.isSurrogatePair;
  }
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var UPPER_A_CP$1 = 'A'.codePointAt(0);
var UPPER_Z_CP$1 = 'Z'.codePointAt(0);
var LOWER_A_CP = 'a'.codePointAt(0);
var LOWER_Z_CP = 'z'.codePointAt(0);
var DIGIT_0_CP = '0'.codePointAt(0);
var DIGIT_9_CP = '9'.codePointAt(0);

/**
 * A regexp-tree plugin to transform coded chars into simple chars.
 *
 * \u0061 -> a
 */
var charCodeToSimpleCharTransform = {
  Char: function Char(path) {
    var node = path.node,
        parent = path.parent;

    if (isNaN(node.codePoint) || node.kind === 'simple') {
      return;
    }

    if (parent.type === 'ClassRange') {
      if (!isSimpleRange(parent)) {
        return;
      }
    }

    if (!isPrintableASCIIChar(node.codePoint)) {
      return;
    }

    var symbol = String.fromCodePoint(node.codePoint);
    var newChar = {
      type: 'Char',
      kind: 'simple',
      value: symbol,
      symbol: symbol,
      codePoint: node.codePoint
    };
    if (needsEscape(symbol, parent.type)) {
      newChar.escaped = true;
    }
    path.replace(newChar);
  }
};

/**
 * Checks if a range is included either in 0-9, a-z or A-Z
 * @param classRange
 * @returns {boolean}
 */
function isSimpleRange(classRange) {
  var from = classRange.from,
      to = classRange.to;

  return from.codePoint >= DIGIT_0_CP && from.codePoint <= DIGIT_9_CP && to.codePoint >= DIGIT_0_CP && to.codePoint <= DIGIT_9_CP || from.codePoint >= UPPER_A_CP$1 && from.codePoint <= UPPER_Z_CP$1 && to.codePoint >= UPPER_A_CP$1 && to.codePoint <= UPPER_Z_CP$1 || from.codePoint >= LOWER_A_CP && from.codePoint <= LOWER_Z_CP && to.codePoint >= LOWER_A_CP && to.codePoint <= LOWER_Z_CP;
}

/**
 * Checks if a code point in the range of printable ASCII chars
 * (DEL char excluded)
 * @param codePoint
 * @returns {boolean}
 */
function isPrintableASCIIChar(codePoint) {
  return codePoint >= 0x20 && codePoint <= 0x7e;
}

function needsEscape(symbol, parentType) {
  if (parentType === 'ClassRange' || parentType === 'CharacterClass') {
    return (/[\]\\^-]/.test(symbol)
    );
  }

  return (/[*[()+?^$./\\|{}]/.test(symbol)
  );
}

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var UPPER_A_CP = 'A'.codePointAt(0);
var UPPER_Z_CP = 'Z'.codePointAt(0);
/**
 * Transforms case-insensitive regexp to lowercase
 *
 * /AaBbÏ/i -> /aabbï/i
 */
var charCaseInsensitiveLowercaseTransform = {
  _AZClassRanges: null,
  _hasUFlag: false,
  init: function init(ast) {
    this._AZClassRanges = new Set();
    this._hasUFlag = ast.flags.includes('u');
  },
  shouldRun: function shouldRun(ast) {
    return ast.flags.includes('i');
  },
  Char: function Char(path) {
    var node = path.node,
        parent = path.parent;

    if (isNaN(node.codePoint)) {
      return;
    }

    // Engine support for case-insensitive matching without the u flag
    // for characters above \u1000 does not seem reliable.
    if (!this._hasUFlag && node.codePoint >= 0x1000) {
      return;
    }

    if (parent.type === 'ClassRange') {
      // The only class ranges we handle must be inside A-Z.
      // After the `from` char is processed, the isAZClassRange test
      // will be false, so we use a Set to keep track of parents and
      // process the `to` char.
      if (!this._AZClassRanges.has(parent) && !isAZClassRange(parent)) {
        return;
      }
      this._AZClassRanges.add(parent);
    }

    var lower = node.symbol.toLowerCase();
    if (lower !== node.symbol) {
      node.value = displaySymbolAsValue(lower, node);
      node.symbol = lower;
      node.codePoint = lower.codePointAt(0);
    }
  }
};

function isAZClassRange(classRange) {
  var from = classRange.from,
      to = classRange.to;
  // A-Z

  return from.codePoint >= UPPER_A_CP && from.codePoint <= UPPER_Z_CP && to.codePoint >= UPPER_A_CP && to.codePoint <= UPPER_Z_CP;
}

function displaySymbolAsValue(symbol, node) {
  var codePoint = symbol.codePointAt(0);
  if (node.kind === 'decimal') {
    return '\\' + codePoint;
  }
  if (node.kind === 'oct') {
    return '\\0' + codePoint.toString(8);
  }
  if (node.kind === 'hex') {
    return '\\x' + codePoint.toString(16);
  }
  if (node.kind === 'unicode') {
    if (node.isSurrogatePair) {
      var _getSurrogatePairFrom = getSurrogatePairFromCodePoint(codePoint),
          lead = _getSurrogatePairFrom.lead,
          trail = _getSurrogatePairFrom.trail;

      return '\\u' + '0'.repeat(4 - lead.length) + lead + '\\u' + '0'.repeat(4 - trail.length) + trail;
    } else if (node.value.includes('{')) {
      return '\\u{' + codePoint.toString(16) + '}';
    } else {
      var code = codePoint.toString(16);
      return '\\u' + '0'.repeat(4 - code.length) + code;
    }
  }
  // simple
  return symbol;
}

/**
 * Converts a code point to a surrogate pair.
 * Conversion algorithm is taken from The Unicode Standard 3.0 Section 3.7
 * (https://www.unicode.org/versions/Unicode3.0.0/ch03.pdf)
 * @param {number} codePoint - Between 0x10000 and 0x10ffff
 * @returns {{lead: string, trail: string}}
 */
function getSurrogatePairFromCodePoint(codePoint) {
  var lead = Math.floor((codePoint - 0x10000) / 0x400) + 0xd800;
  var trail = (codePoint - 0x10000) % 0x400 + 0xdc00;
  return {
    lead: lead.toString(16),
    trail: trail.toString(16)
  };
}

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to remove duplicates from character classes.
 */

var charClassRemoveDuplicatesTransform = {
  CharacterClass: function CharacterClass(path) {
    var node = path.node;

    var sources = {};

    for (var i = 0; i < node.expressions.length; i++) {
      var childPath = path.getChild(i);
      var source = childPath.jsonEncode();

      if (sources.hasOwnProperty(source)) {
        childPath.remove();

        // Since we remove the current node.
        // TODO: make it simpler for users with a method.
        i--;
      }

      sources[source] = true;
    }
  }
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * Flattens a nested disjunction node to a list.
 *
 * /a|b|c|d/
 *
 * {{{a, b}, c}, d} -> [a, b, c, d]
 */

function _toConsumableArray$7(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function disjunctionToList$1(node) {
  if (node.type !== 'Disjunction') {
    throw new TypeError('Expected "Disjunction" node, got "' + node.type + '"');
  }

  var list = [];

  if (node.left && node.left.type === 'Disjunction') {
    list.push.apply(list, _toConsumableArray$7(disjunctionToList$1(node.left)).concat([node.right]));
  } else {
    list.push(node.left, node.right);
  }

  return list;
}

/**
 * Builds a nested disjunction node from a list.
 *
 * /a|b|c|d/
 *
 * [a, b, c, d] -> {{{a, b}, c}, d}
 */
function listToDisjunction$1(list) {
  return list.reduce(function (left, right) {
    return {
      type: 'Disjunction',
      left: left,
      right: right
    };
  });
}

/**
 * Increases a quantifier by one.
 * Does not change greediness.
 * * -> +
 * + -> {2,}
 * ? -> {1,2}
 * {2} -> {3}
 * {2,} -> {3,}
 * {2,3} -> {3,4}
 */
function increaseQuantifierByOne$2(quantifier) {
  if (quantifier.kind === '*') {

    quantifier.kind = '+';
  } else if (quantifier.kind === '+') {

    quantifier.kind = 'Range';
    quantifier.from = 2;
    delete quantifier.to;
  } else if (quantifier.kind === '?') {

    quantifier.kind = 'Range';
    quantifier.from = 1;
    quantifier.to = 2;
  } else if (quantifier.kind === 'Range') {

    quantifier.from += 1;
    if (quantifier.to) {
      quantifier.to += 1;
    }
  }
}

var utils = {
  disjunctionToList: disjunctionToList$1,
  listToDisjunction: listToDisjunction$1,
  increaseQuantifierByOne: increaseQuantifierByOne$2
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var _require$8 = utils,
    increaseQuantifierByOne$1 = _require$8.increaseQuantifierByOne;

/**
 * A regexp-tree plugin to merge quantifiers
 *
 * a+a+ -> a{2,}
 * a{2}a{3} -> a{5}
 * a{1,2}a{2,3} -> a{3,5}
 */


var quantifiersMergeTransform = {
  Repetition: function Repetition(path) {
    var node = path.node,
        parent = path.parent;


    if (parent.type !== 'Alternative' || !path.index) {
      return;
    }

    var previousSibling = path.getPreviousSibling();

    if (!previousSibling) {
      return;
    }

    if (previousSibling.node.type === 'Repetition') {
      if (!previousSibling.getChild().hasEqualSource(path.getChild())) {
        return;
      }

      var _extractFromTo = extractFromTo(previousSibling.node.quantifier),
          previousSiblingFrom = _extractFromTo.from,
          previousSiblingTo = _extractFromTo.to;

      var _extractFromTo2 = extractFromTo(node.quantifier),
          nodeFrom = _extractFromTo2.from,
          nodeTo = _extractFromTo2.to;

      // It's does not seem reliable to merge quantifiers with different greediness
      // when none of both is a greedy open range


      if (previousSibling.node.quantifier.greedy !== node.quantifier.greedy && !isGreedyOpenRange(previousSibling.node.quantifier) && !isGreedyOpenRange(node.quantifier)) {
        return;
      }

      // a*a* -> a*
      // a*a+ -> a+
      // a+a+ -> a{2,}
      // a{2}a{4} -> a{6}
      // a{1,2}a{2,3} -> a{3,5}
      // a{1,}a{2,} -> a{3,}
      // a+a{2,} -> a{3,}

      // a??a{2,} -> a{2,}
      // a*?a{2,} -> a{2,}
      // a+?a{2,} -> a{3,}

      node.quantifier.kind = 'Range';
      node.quantifier.from = previousSiblingFrom + nodeFrom;
      if (previousSiblingTo && nodeTo) {
        node.quantifier.to = previousSiblingTo + nodeTo;
      } else {
        delete node.quantifier.to;
      }
      if (isGreedyOpenRange(previousSibling.node.quantifier) || isGreedyOpenRange(node.quantifier)) {
        node.quantifier.greedy = true;
      }

      previousSibling.remove();
    } else {
      if (!previousSibling.hasEqualSource(path.getChild())) {
        return;
      }

      increaseQuantifierByOne$1(node.quantifier);
      previousSibling.remove();
    }
  }
};

function isGreedyOpenRange(quantifier) {
  return quantifier.greedy && (quantifier.kind === '+' || quantifier.kind === '*' || quantifier.kind === 'Range' && !quantifier.to);
}

function extractFromTo(quantifier) {
  var from = void 0,
      to = void 0;
  if (quantifier.kind === '*') {
    from = 0;
  } else if (quantifier.kind === '+') {
    from = 1;
  } else if (quantifier.kind === '?') {
    from = 0;
    to = 1;
  } else {
    from = quantifier.from;
    if (quantifier.to) {
      to = quantifier.to;
    }
  }
  return { from: from, to: to };
}

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to replace different range-based quantifiers
 * with their symbol equivalents.
 *
 * a{0,} -> a*
 * a{1,} -> a+
 * a{1} -> a
 *
 * NOTE: the following is automatically handled in the generator:
 *
 * a{3,3} -> a{3}
 */

var quantifierRangeToSymbolTransform = {
  Quantifier: function Quantifier(path) {
    var node = path.node;


    if (node.kind !== 'Range') {
      return;
    }

    // a{0,} -> a*
    rewriteOpenZero(path);

    // a{1,} -> a+
    rewriteOpenOne(path);

    // a{1} -> a
    rewriteExactOne(path);
  }
};

function rewriteOpenZero(path) {
  var node = path.node;


  if (node.from !== 0 || node.to) {
    return;
  }

  node.kind = '*';
  delete node.from;
}

function rewriteOpenOne(path) {
  var node = path.node;


  if (node.from !== 1 || node.to) {
    return;
  }

  node.kind = '+';
  delete node.from;
}

function rewriteExactOne(path) {
  var node = path.node;


  if (node.from !== 1 || node.to !== 1) {
    return;
  }

  path.parentPath.replace(path.parentPath.node.expression);
}

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to simplify character classes
 * spanning only one or two chars.
 *
 * [a-a] -> [a]
 * [a-b] -> [ab]
 */

var charClassClassrangesToCharsTransform = {
  ClassRange: function ClassRange(path) {
    var node = path.node;


    if (node.from.codePoint === node.to.codePoint) {

      path.replace(node.from);
    } else if (node.from.codePoint === node.to.codePoint - 1) {

      path.getParent().insertChildAt(node.to, path.index + 1);
      path.replace(node.from);
    }
  }
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to replace standard character classes with
 * their meta symbols equivalents.
 */

function _toConsumableArray$6(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var charClassToMetaTransform = {
  _hasIFlag: false,
  _hasUFlag: false,
  init: function init(ast) {
    this._hasIFlag = ast.flags.includes('i');
    this._hasUFlag = ast.flags.includes('u');
  },
  CharacterClass: function CharacterClass(path) {
    // [0-9] -> \d
    rewriteNumberRanges(path);

    // [a-zA-Z_0-9] -> \w
    rewriteWordRanges(path, this._hasIFlag, this._hasUFlag);

    // [ \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff] -> \s
    rewriteWhitespaceRanges(path);
  }
};

/**
 * Rewrites number ranges: [0-9] -> \d
 */
function rewriteNumberRanges(path) {
  var node = path.node;


  node.expressions.forEach(function (expression, i) {
    if (isFullNumberRange(expression)) {
      path.getChild(i).replace({
        type: 'Char',
        value: '\\d',
        kind: 'meta'
      });
    }
  });
}

/**
 * Rewrites word ranges: [a-zA-Z_0-9] -> \w
 * Thus, the ranges may go in any order, and other symbols/ranges
 * are kept untouched, e.g. [a-z_\dA-Z$] -> [\w$]
 */
function rewriteWordRanges(path, hasIFlag, hasUFlag) {
  var node = path.node;


  var numberPath = null;
  var lowerCasePath = null;
  var upperCasePath = null;
  var underscorePath = null;
  var u017fPath = null;
  var u212aPath = null;

  node.expressions.forEach(function (expression, i) {
    // \d
    if (isMetaChar(expression, '\\d')) {
      numberPath = path.getChild(i);
    }

    // a-z
    else if (isLowerCaseRange(expression)) {
        lowerCasePath = path.getChild(i);
      }

      // A-Z
      else if (isUpperCaseRange(expression)) {
          upperCasePath = path.getChild(i);
        }

        // _
        else if (isUnderscore(expression)) {
            underscorePath = path.getChild(i);
          } else if (hasIFlag && hasUFlag && isCodePoint(expression, 0x017f)) {
            u017fPath = path.getChild(i);
          } else if (hasIFlag && hasUFlag && isCodePoint(expression, 0x212a)) {
            u212aPath = path.getChild(i);
          }
  });

  // If we found the whole pattern, replace it.
  if (numberPath && (lowerCasePath && upperCasePath || hasIFlag && (lowerCasePath || upperCasePath)) && underscorePath && (!hasUFlag || !hasIFlag || u017fPath && u212aPath)) {
    // Put \w in place of \d.
    numberPath.replace({
      type: 'Char',
      value: '\\w',
      kind: 'meta'
    });

    // Other paths are removed.
    if (lowerCasePath) {
      lowerCasePath.remove();
    }
    if (upperCasePath) {
      upperCasePath.remove();
    }
    underscorePath.remove();
    if (u017fPath) {
      u017fPath.remove();
    }
    if (u212aPath) {
      u212aPath.remove();
    }
  }
}

/**
 * Rewrites whitespace ranges: [ \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff] -> \s.
 */
var whitespaceRangeTests = [function (node) {
  return isChar(node, ' ');
}].concat(_toConsumableArray$6(['\\f', '\\n', '\\r', '\\t', '\\v'].map(function (char) {
  return function (node) {
    return isMetaChar(node, char);
  };
})), _toConsumableArray$6([0x00a0, 0x1680, 0x2028, 0x2029, 0x202f, 0x205f, 0x3000, 0xfeff].map(function (codePoint) {
  return function (node) {
    return isCodePoint(node, codePoint);
  };
})), [function (node) {
  return node.type === 'ClassRange' && isCodePoint(node.from, 0x2000) && isCodePoint(node.to, 0x200a);
}]);

function rewriteWhitespaceRanges(path) {
  var node = path.node;


  if (node.expressions.length < whitespaceRangeTests.length || !whitespaceRangeTests.every(function (test) {
    return node.expressions.some(function (expression) {
      return test(expression);
    });
  })) {
    return;
  }

  // If we found the whole pattern, replace it.

  // Put \s in place of \n.
  var nNode = node.expressions.find(function (expression) {
    return isMetaChar(expression, '\\n');
  });
  nNode.value = '\\s';
  nNode.symbol = undefined;
  nNode.codePoint = NaN;

  // Other paths are removed.
  node.expressions.map(function (expression, i) {
    return whitespaceRangeTests.some(function (test) {
      return test(expression);
    }) ? path.getChild(i) : undefined;
  }).filter(Boolean).forEach(function (path) {
    return path.remove();
  });
}

function isFullNumberRange(node) {
  return node.type === 'ClassRange' && node.from.value === '0' && node.to.value === '9';
}

function isChar(node, value) {
  var kind = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'simple';

  return node.type === 'Char' && node.value === value && node.kind === kind;
}

function isMetaChar(node, value) {
  return isChar(node, value, 'meta');
}

function isLowerCaseRange(node) {
  return node.type === 'ClassRange' && node.from.value === 'a' && node.to.value === 'z';
}

function isUpperCaseRange(node) {
  return node.type === 'ClassRange' && node.from.value === 'A' && node.to.value === 'Z';
}

function isUnderscore(node) {
  return node.type === 'Char' && node.value === '_' && node.kind === 'simple';
}

function isCodePoint(node, codePoint) {
  return node.type === 'Char' && node.kind === 'unicode' && node.codePoint === codePoint;
}

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to replace single char character classes with
 * just that character.
 *
 * [\d] -> \d, [^\w] -> \W
 */

var charClassToSingleCharTransform = {
  CharacterClass: function CharacterClass(path) {
    var node = path.node;


    if (node.expressions.length !== 1 || !hasAppropriateSiblings$1(path) || !isAppropriateChar(node.expressions[0])) {
      return;
    }

    var _node$expressions$ = node.expressions[0],
        value = _node$expressions$.value,
        kind = _node$expressions$.kind,
        escaped = _node$expressions$.escaped;


    if (node.negative) {
      // For negative can extract only meta chars like [^\w] -> \W
      // cannot do for [^a] -> a (wrong).
      if (!isMeta$1(value)) {
        return;
      }

      value = getInverseMeta(value);
    }

    path.replace({
      type: 'Char',
      value: value,
      kind: kind,
      escaped: escaped || shouldEscape(value)
    });
  }
};

function isAppropriateChar(node) {
  return node.type === 'Char' &&
  // We don't extract [\b] (backspace) since \b has different
  // semantics (word boundary).
  node.value !== '\\b';
}

function isMeta$1(value) {
  return (/^\\[dwsDWS]$/.test(value)
  );
}

function getInverseMeta(value) {
  return (/[dws]/.test(value) ? value.toUpperCase() : value.toLowerCase()
  );
}

function hasAppropriateSiblings$1(path) {
  var parent = path.parent,
      index = path.index;


  if (parent.type !== 'Alternative') {
    return true;
  }

  var previousNode = parent.expressions[index - 1];
  if (previousNode == null) {
    return true;
  }

  // Don't optimized \1[0] to \10
  if (previousNode.type === 'Backreference' && previousNode.kind === 'number') {
    return false;
  }

  // Don't optimized \2[0] to \20
  if (previousNode.type === 'Char' && previousNode.kind === 'decimal') {
    return false;
  }

  return true;
}

// Note: \{ and \} are always preserved to avoid `a[{]2[}]` turning
// into `a{2}`.
function shouldEscape(value) {
  return (/[*[()+?$./{}|]/.test(value)
  );
}

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to remove unnecessary escape.
 *
 * \e -> e
 *
 * [\(] -> [(]
 */

var charEscapeUnescapeTransform = {
  _hasXFlag: false,
  init: function init(ast) {
    this._hasXFlag = ast.flags.includes('x');
  },
  Char: function Char(path) {
    var node = path.node;


    if (!node.escaped) {
      return;
    }

    if (shouldUnescape(path, this._hasXFlag)) {
      delete node.escaped;
    }
  }
};

function shouldUnescape(path, hasXFlag) {
  var value = path.node.value,
      index = path.index,
      parent = path.parent;

  // In char class (, etc are allowed.

  if (parent.type !== 'CharacterClass' && parent.type !== 'ClassRange') {
    return !preservesEscape(value, index, parent, hasXFlag);
  }

  return !preservesInCharClass(value, index, parent);
}

/**
 * \], \\, \^, \-
 */
function preservesInCharClass(value, index, parent) {
  if (value === '^') {
    // Avoid [\^a] turning into [^a]
    return index === 0 && !parent.negative;
  }
  if (value === '-') {
    // Avoid [a\-z] turning into [a-z]
    return true;
  }
  return (/[\]\\]/.test(value)
  );
}

function preservesEscape(value, index, parent, hasXFlag) {
  if (value === '{') {
    return preservesOpeningCurlyBraceEscape(index, parent);
  }

  if (value === '}') {
    return preservesClosingCurlyBraceEscape(index, parent);
  }

  if (hasXFlag && /[ #]/.test(value)) {
    return true;
  }

  return (/[*[()+?^$./\\|]/.test(value)
  );
}

function consumeNumbers(startIndex, parent, rtl) {
  var i = startIndex;
  var siblingNode = (rtl ? i >= 0 : i < parent.expressions.length) && parent.expressions[i];

  while (siblingNode && siblingNode.type === 'Char' && siblingNode.kind === 'simple' && !siblingNode.escaped && /\d/.test(siblingNode.value)) {
    rtl ? i-- : i++;
    siblingNode = (rtl ? i >= 0 : i < parent.expressions.length) && parent.expressions[i];
  }

  return Math.abs(startIndex - i);
}

function isSimpleChar(node, value) {
  return node && node.type === 'Char' && node.kind === 'simple' && !node.escaped && node.value === value;
}

function preservesOpeningCurlyBraceEscape(index, parent) {
  // (?:\{) -> (?:{)
  if (index == null) {
    return false;
  }

  var nbFollowingNumbers = consumeNumbers(index + 1, parent);
  var i = index + nbFollowingNumbers + 1;
  var nextSiblingNode = i < parent.expressions.length && parent.expressions[i];

  if (nbFollowingNumbers) {
    // Avoid \{3} turning into {3}
    if (isSimpleChar(nextSiblingNode, '}')) {
      return true;
    }

    if (isSimpleChar(nextSiblingNode, ',')) {
      nbFollowingNumbers = consumeNumbers(i + 1, parent);
      i = i + nbFollowingNumbers + 1;
      nextSiblingNode = i < parent.expressions.length && parent.expressions[i];

      // Avoid \{3,} turning into {3,}
      return isSimpleChar(nextSiblingNode, '}');
    }
  }
  return false;
}

function preservesClosingCurlyBraceEscape(index, parent) {
  // (?:\{) -> (?:{)
  if (index == null) {
    return false;
  }

  var nbPrecedingNumbers = consumeNumbers(index - 1, parent, true);
  var i = index - nbPrecedingNumbers - 1;
  var previousSiblingNode = i >= 0 && parent.expressions[i];

  // Avoid {3\} turning into {3}
  if (nbPrecedingNumbers && isSimpleChar(previousSiblingNode, '{')) {
    return true;
  }

  if (isSimpleChar(previousSiblingNode, ',')) {
    nbPrecedingNumbers = consumeNumbers(i - 1, parent, true);
    i = i - nbPrecedingNumbers - 1;
    previousSiblingNode = i < parent.expressions.length && parent.expressions[i];

    // Avoid {3,\} turning into {3,}
    return nbPrecedingNumbers && isSimpleChar(previousSiblingNode, '{');
  }
  return false;
}

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to merge class ranges.
 *
 * [a-ec] -> [a-e]
 * [a-ec-e] -> [a-e]
 * [\w\da-f] -> [\w]
 * [abcdef] -> [a-f]
 */

var charClassClassrangesMergeTransform = {
  _hasIUFlags: false,
  init: function init(ast) {
    this._hasIUFlags = ast.flags.includes('i') && ast.flags.includes('u');
  },
  CharacterClass: function CharacterClass(path) {
    var node = path.node;

    var expressions = node.expressions;

    var metas = [];
    // Extract metas
    expressions.forEach(function (expression) {
      if (isMeta(expression)) {
        metas.push(expression.value);
      }
    });

    expressions.sort(sortCharClass);

    for (var i = 0; i < expressions.length; i++) {
      var expression = expressions[i];
      if (fitsInMetas(expression, metas, this._hasIUFlags) || combinesWithPrecedingClassRange(expression, expressions[i - 1]) || combinesWithFollowingClassRange(expression, expressions[i + 1])) {
        expressions.splice(i, 1);
        i--;
      } else {
        var nbMergedChars = charCombinesWithPrecedingChars(expression, i, expressions);
        expressions.splice(i - nbMergedChars + 1, nbMergedChars);
        i -= nbMergedChars;
      }
    }
  }
};

/**
 * Sorts expressions in char class in the following order:
 * - meta chars, ordered alphabetically by value
 * - chars (except `control` kind) and class ranges, ordered alphabetically (`from` char is used for class ranges)
 * - if ambiguous, class range comes before char
 * - if ambiguous between two class ranges, orders alphabetically by `to` char
 * - control chars, ordered alphabetically by value
 * @param {Object} a - Left Char or ClassRange node
 * @param {Object} b - Right Char or ClassRange node
 * @returns {number}
 */
function sortCharClass(a, b) {
  var aValue = getSortValue(a);
  var bValue = getSortValue(b);

  if (aValue === bValue) {
    // We want ClassRange before Char
    // [bb-d] -> [b-db]
    if (a.type === 'ClassRange' && b.type !== 'ClassRange') {
      return -1;
    }
    if (b.type === 'ClassRange' && a.type !== 'ClassRange') {
      return 1;
    }
    if (a.type === 'ClassRange' && b.type === 'ClassRange') {
      return getSortValue(a.to) - getSortValue(b.to);
    }
    if (isMeta(a) && isMeta(b) || isControl(a) && isControl(b)) {
      return a.value < b.value ? -1 : 1;
    }
  }
  return aValue - bValue;
}

/**
 * @param {Object} expression - Char or ClassRange node
 * @returns {number}
 */
function getSortValue(expression) {
  if (expression.type === 'Char') {
    if (expression.value === '-') {
      return Infinity;
    }
    if (expression.kind === 'control') {
      return Infinity;
    }
    if (expression.kind === 'meta' && isNaN(expression.codePoint)) {
      return -1;
    }
    return expression.codePoint;
  }
  // ClassRange
  return expression.from.codePoint;
}

/**
 * Checks if a node is a meta char from the set \d\w\s\D\W\S
 * @param {Object} expression - Char or ClassRange node
 * @param {?string} value
 * @returns {boolean}
 */
function isMeta(expression) {
  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  return expression.type === 'Char' && expression.kind === 'meta' && (value ? expression.value === value : /^\\[dws]$/i.test(expression.value));
}

/**
 * @param {Object} expression - Char or ClassRange node
 * @returns {boolean}
 */
function isControl(expression) {
  return expression.type === 'Char' && expression.kind === 'control';
}

/**
 * @param {Object} expression - Char or ClassRange node
 * @param {string[]} metas - Array of meta chars, e.g. ["\\w", "\\s"]
 * @param {boolean} hasIUFlags
 * @returns {boolean}
 */
function fitsInMetas(expression, metas, hasIUFlags) {
  for (var i = 0; i < metas.length; i++) {
    if (fitsInMeta(expression, metas[i], hasIUFlags)) {
      return true;
    }
  }
  return false;
}

/**
 * @param {Object} expression - Char or ClassRange node
 * @param {string} meta - e.g. "\\w"
 * @param {boolean} hasIUFlags
 * @returns {boolean}
 */
function fitsInMeta(expression, meta, hasIUFlags) {
  if (expression.type === 'ClassRange') {
    return fitsInMeta(expression.from, meta, hasIUFlags) && fitsInMeta(expression.to, meta, hasIUFlags);
  }

  // Special cases:
  // \S contains \w and \d
  if (meta === '\\S' && (isMeta(expression, '\\w') || isMeta(expression, '\\d'))) {
    return true;
  }
  // \D contains \W and \s
  if (meta === '\\D' && (isMeta(expression, '\\W') || isMeta(expression, '\\s'))) {
    return true;
  }
  // \w contains \d
  if (meta === '\\w' && isMeta(expression, '\\d')) {
    return true;
  }
  // \W contains \s
  if (meta === '\\W' && isMeta(expression, '\\s')) {
    return true;
  }

  if (expression.type !== 'Char' || isNaN(expression.codePoint)) {
    return false;
  }

  if (meta === '\\s') {
    return fitsInMetaS(expression);
  }
  if (meta === '\\S') {
    return !fitsInMetaS(expression);
  }
  if (meta === '\\d') {
    return fitsInMetaD(expression);
  }
  if (meta === '\\D') {
    return !fitsInMetaD(expression);
  }
  if (meta === '\\w') {
    return fitsInMetaW(expression, hasIUFlags);
  }
  if (meta === '\\W') {
    return !fitsInMetaW(expression, hasIUFlags);
  }
  return false;
}

/**
 * @param {Object} expression - Char node with codePoint
 * @returns {boolean}
 */
function fitsInMetaS(expression) {
  return expression.codePoint === 0x0009 || // \t
  expression.codePoint === 0x000a || // \n
  expression.codePoint === 0x000b || // \v
  expression.codePoint === 0x000c || // \f
  expression.codePoint === 0x000d || // \r
  expression.codePoint === 0x0020 || // space
  expression.codePoint === 0x00a0 || // nbsp
  expression.codePoint === 0x1680 || // part of Zs
  expression.codePoint >= 0x2000 && expression.codePoint <= 0x200a || // part of Zs
  expression.codePoint === 0x2028 || // line separator
  expression.codePoint === 0x2029 || // paragraph separator
  expression.codePoint === 0x202f || // part of Zs
  expression.codePoint === 0x205f || // part of Zs
  expression.codePoint === 0x3000 || // part of Zs
  expression.codePoint === 0xfeff; // zwnbsp
}

/**
 * @param {Object} expression - Char node with codePoint
 * @returns {boolean}
 */
function fitsInMetaD(expression) {
  return expression.codePoint >= 0x30 && expression.codePoint <= 0x39; // 0-9
}

/**
 * @param {Object} expression - Char node with codePoint
 * @param {boolean} hasIUFlags
 * @returns {boolean}
 */
function fitsInMetaW(expression, hasIUFlags) {
  return fitsInMetaD(expression) || expression.codePoint >= 0x41 && expression.codePoint <= 0x5a || // A-Z
  expression.codePoint >= 0x61 && expression.codePoint <= 0x7a || // a-z
  expression.value === '_' || hasIUFlags && (expression.codePoint === 0x017f || expression.codePoint === 0x212a);
}

/**
 * @param {Object} expression - Char or ClassRange node
 * @param {Object} classRange - Char or ClassRange node
 * @returns {boolean}
 */
function combinesWithPrecedingClassRange(expression, classRange) {
  if (classRange && classRange.type === 'ClassRange') {
    if (fitsInClassRange(expression, classRange)) {
      // [a-gc] -> [a-g]
      // [a-gc-e] -> [a-g]
      return true;
    } else if (
    // We only want \w chars or char codes to keep readability
    isMetaWCharOrCode(expression) && classRange.to.codePoint === expression.codePoint - 1) {
      // [a-de] -> [a-e]
      classRange.to = expression;
      return true;
    } else if (expression.type === 'ClassRange' && expression.from.codePoint <= classRange.to.codePoint + 1 && expression.to.codePoint >= classRange.from.codePoint - 1) {
      // [a-db-f] -> [a-f]
      // [b-fa-d] -> [a-f]
      // [a-cd-f] -> [a-f]
      if (expression.from.codePoint < classRange.from.codePoint) {
        classRange.from = expression.from;
      }
      if (expression.to.codePoint > classRange.to.codePoint) {
        classRange.to = expression.to;
      }
      return true;
    }
  }
  return false;
}

/**
 * @param {Object} expression - Char or ClassRange node
 * @param {Object} classRange - Char or ClassRange node
 * @returns {boolean}
 */
function combinesWithFollowingClassRange(expression, classRange) {
  if (classRange && classRange.type === 'ClassRange') {
    // Considering the elements were ordered alphabetically,
    // there is only one case to handle
    // [ab-e] -> [a-e]
    if (
    // We only want \w chars or char codes to keep readability
    isMetaWCharOrCode(expression) && classRange.from.codePoint === expression.codePoint + 1) {
      classRange.from = expression;
      return true;
    }
  }

  return false;
}

/**
 * @param {Object} expression - Char or ClassRange node
 * @param {Object} classRange - ClassRange node
 * @returns {boolean}
 */
function fitsInClassRange(expression, classRange) {
  if (expression.type === 'Char' && isNaN(expression.codePoint)) {
    return false;
  }
  if (expression.type === 'ClassRange') {
    return fitsInClassRange(expression.from, classRange) && fitsInClassRange(expression.to, classRange);
  }
  return expression.codePoint >= classRange.from.codePoint && expression.codePoint <= classRange.to.codePoint;
}

/**
 * @param {Object} expression - Char or ClassRange node
 * @param {Number} index
 * @param {Object[]} expressions - expressions in CharClass
 * @returns {number} - Number of characters combined with expression
 */
function charCombinesWithPrecedingChars(expression, index, expressions) {
  // We only want \w chars or char codes to keep readability
  if (!isMetaWCharOrCode(expression)) {
    return 0;
  }
  var nbMergedChars = 0;
  while (index > 0) {
    var currentExpression = expressions[index];
    var precedingExpresion = expressions[index - 1];
    if (isMetaWCharOrCode(precedingExpresion) && precedingExpresion.codePoint === currentExpression.codePoint - 1) {
      nbMergedChars++;
      index--;
    } else {
      break;
    }
  }

  if (nbMergedChars > 1) {
    expressions[index] = {
      type: 'ClassRange',
      from: expressions[index],
      to: expression
    };
    return nbMergedChars;
  }
  return 0;
}

function isMetaWCharOrCode(expression) {
  return expression && expression.type === 'Char' && !isNaN(expression.codePoint) && (fitsInMetaW(expression, false) || expression.kind === 'unicode' || expression.kind === 'hex' || expression.kind === 'oct' || expression.kind === 'decimal');
}

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var NodePath$1 = nodePath;

var _require$7 = utils,
    disjunctionToList = _require$7.disjunctionToList,
    listToDisjunction = _require$7.listToDisjunction;

/**
 * Removes duplicates from a disjunction sequence:
 *
 * /(ab|bc|ab)+(xy|xy)+/ -> /(ab|bc)+(xy)+/
 */


var disjunctionRemoveDuplicatesTransform = {
  Disjunction: function Disjunction(path) {
    var node = path.node;

    // Make unique nodes.

    var uniqueNodesMap = {};

    var parts = disjunctionToList(node).filter(function (part) {
      var encoded = part ? NodePath$1.getForNode(part).jsonEncode() : 'null';

      // Already recorded this part, filter out.
      if (uniqueNodesMap.hasOwnProperty(encoded)) {
        return false;
      }

      uniqueNodesMap[encoded] = part;
      return true;
    });

    // Replace with the optimized disjunction.
    path.replace(listToDisjunction(parts));
  }
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to replace single char group disjunction to char group
 *
 * a|b|c -> [abc]
 * [12]|3|4 -> [1234]
 * (a|b|c) -> ([abc])
 * (?:a|b|c) -> [abc]
 */

var groupSingleCharsToCharClass = {
  Disjunction: function Disjunction(path) {
    var node = path.node,
        parent = path.parent;


    if (!handlers[parent.type]) {
      return;
    }

    var charset = new Map();

    if (!shouldProcess(node, charset) || !charset.size) {
      return;
    }

    var characterClass = {
      type: 'CharacterClass',
      expressions: Array.from(charset.keys()).sort().map(function (key) {
        return charset.get(key);
      })
    };

    handlers[parent.type](path.getParent(), characterClass);
  }
};

var handlers = {
  RegExp: function RegExp(path, characterClass) {
    var node = path.node;


    node.body = characterClass;
  },
  Group: function Group(path, characterClass) {
    var node = path.node;


    if (node.capturing) {
      node.expression = characterClass;
    } else {
      path.replace(characterClass);
    }
  }
};

function shouldProcess(expression, charset) {
  if (!expression) {
    // Abort on empty disjunction part
    return false;
  }

  var type = expression.type;


  if (type === 'Disjunction') {
    var left = expression.left,
        right = expression.right;


    return shouldProcess(left, charset) && shouldProcess(right, charset);
  } else if (type === 'Char') {
    if (expression.kind === 'meta' && expression.symbol === '.') {
      return false;
    }

    var value = expression.value;


    charset.set(value, expression);

    return true;
  } else if (type === 'CharacterClass' && !expression.negative) {
    return expression.expressions.every(function (expression) {
      return shouldProcess(expression, charset);
    });
  }

  return false;
}

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to remove non-capturing empty groups.
 *
 * /(?:)a/ -> /a/
 * /a|(?:)/ -> /a|/
 */

var removeEmptyGroupTransform = {
  Group: function Group(path) {
    var node = path.node,
        parent = path.parent;

    var childPath = path.getChild();

    if (node.capturing || childPath) {
      return;
    }

    if (parent.type === 'Repetition') {

      path.getParent().replace(node);
    } else if (parent.type !== 'RegExp') {

      path.remove();
    }
  }
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to remove unnecessary groups.
 *
 * /(?:a)/ -> /a/
 */

function _toConsumableArray$5(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var ungroupTransform = {
  Group: function Group(path) {
    var node = path.node,
        parent = path.parent;

    var childPath = path.getChild();

    if (node.capturing || !childPath) {
      return;
    }

    // Don't optimize \1(?:0) to \10
    if (!hasAppropriateSiblings(path)) {
      return;
    }

    // Don't optimize /a(?:b|c)/ to /ab|c/
    // but /(?:b|c)/ to /b|c/ is ok
    if (childPath.node.type === 'Disjunction' && parent.type !== 'RegExp') {
      return;
    }

    // Don't optimize /(?:ab)+/ to /ab+/
    // but /(?:a)+/ to /a+/ is ok
    // and /(?:[a-d])+/ to /[a-d]+/ is ok too
    if (parent.type === 'Repetition' && childPath.node.type !== 'Char' && childPath.node.type !== 'CharacterClass') {
      return;
    }

    if (childPath.node.type === 'Alternative') {
      var parentPath = path.getParent();
      if (parentPath.node.type === 'Alternative') {
        // /abc(?:def)ghi/ When (?:def) is ungrouped its content must be merged with parent alternative

        parentPath.replace({
          type: 'Alternative',
          expressions: [].concat(_toConsumableArray$5(parent.expressions.slice(0, path.index)), _toConsumableArray$5(childPath.node.expressions), _toConsumableArray$5(parent.expressions.slice(path.index + 1)))
        });
      }
    } else {
      path.replace(childPath.node);
    }
  }
};

function hasAppropriateSiblings(path) {
  var parent = path.parent,
      index = path.index;


  if (parent.type !== 'Alternative') {
    return true;
  }

  var previousNode = parent.expressions[index - 1];
  if (previousNode == null) {
    return true;
  }

  // Don't optimized \1(?:0) to \10
  if (previousNode.type === 'Backreference' && previousNode.kind === 'number') {
    return false;
  }

  // Don't optimized \2(?:0) to \20
  if (previousNode.type === 'Char' && previousNode.kind === 'decimal') {
    return false;
  }

  return true;
}

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

function _toConsumableArray$4(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var NodePath = nodePath;

var _require$6 = utils,
    increaseQuantifierByOne = _require$6.increaseQuantifierByOne;

/**
 * A regexp-tree plugin to combine repeating patterns.
 *
 * /^abcabcabc/ -> /^abc{3}/
 * /^(?:abc){2}abc/ -> /^(?:abc){3}/
 * /^abc(?:abc){2}/ -> /^(?:abc){3}/
 */

var combineRepeatingPatternsTransform = {
  Alternative: function Alternative(path) {
    var node = path.node;

    // We can skip the first child

    var index = 1;
    while (index < node.expressions.length) {
      var child = path.getChild(index);
      index = Math.max(1, combineRepeatingPatternLeft(path, child, index));

      if (index >= node.expressions.length) {
        break;
      }

      child = path.getChild(index);
      index = Math.max(1, combineWithPreviousRepetition(path, child, index));

      if (index >= node.expressions.length) {
        break;
      }

      child = path.getChild(index);
      index = Math.max(1, combineRepetitionWithPrevious(path, child, index));

      index++;
    }
  }
};

// abcabc -> (?:abc){2}
function combineRepeatingPatternLeft(alternative, child, index) {
  var node = alternative.node;


  var nbPossibleLengths = Math.ceil(index / 2);
  var i = 0;

  while (i < nbPossibleLengths) {
    var startIndex = index - 2 * i - 1;
    var right = void 0,
        left = void 0;

    if (i === 0) {
      right = child;
      left = alternative.getChild(startIndex);
    } else {
      right = NodePath.getForNode({
        type: 'Alternative',
        expressions: [].concat(_toConsumableArray$4(node.expressions.slice(index - i, index)), [child.node])
      });

      left = NodePath.getForNode({
        type: 'Alternative',
        expressions: [].concat(_toConsumableArray$4(node.expressions.slice(startIndex, index - i)))
      });
    }

    if (right.hasEqualSource(left)) {
      for (var j = 0; j < 2 * i + 1; j++) {
        alternative.getChild(startIndex).remove();
      }

      child.replace({
        type: 'Repetition',
        expression: i === 0 && right.node.type !== 'Repetition' ? right.node : {
          type: 'Group',
          capturing: false,
          expression: right.node
        },
        quantifier: {
          type: 'Quantifier',
          kind: 'Range',
          from: 2,
          to: 2,
          greedy: true
        }
      });
      return startIndex;
    }

    i++;
  }

  return index;
}

// (?:abc){2}abc -> (?:abc){3}
function combineWithPreviousRepetition(alternative, child, index) {
  var node = alternative.node;


  var i = 0;
  while (i < index) {
    var previousChild = alternative.getChild(i);

    if (previousChild.node.type === 'Repetition' && previousChild.node.quantifier.greedy) {
      var left = previousChild.getChild();
      var right = void 0;

      if (left.node.type === 'Group' && !left.node.capturing) {
        left = left.getChild();
      }

      if (i + 1 === index) {
        right = child;
        if (right.node.type === 'Group' && !right.node.capturing) {
          right = right.getChild();
        }
      } else {
        right = NodePath.getForNode({
          type: 'Alternative',
          expressions: [].concat(_toConsumableArray$4(node.expressions.slice(i + 1, index + 1)))
        });
      }

      if (left.hasEqualSource(right)) {
        for (var j = i; j < index; j++) {
          alternative.getChild(i + 1).remove();
        }

        increaseQuantifierByOne(previousChild.node.quantifier);

        return i;
      }
    }

    i++;
  }
  return index;
}

// abc(?:abc){2} -> (?:abc){3}
function combineRepetitionWithPrevious(alternative, child, index) {
  var node = alternative.node;


  if (child.node.type === 'Repetition' && child.node.quantifier.greedy) {
    var right = child.getChild();
    var left = void 0;

    if (right.node.type === 'Group' && !right.node.capturing) {
      right = right.getChild();
    }

    var rightLength = void 0;
    if (right.node.type === 'Alternative') {
      rightLength = right.node.expressions.length;
      left = NodePath.getForNode({
        type: 'Alternative',
        expressions: [].concat(_toConsumableArray$4(node.expressions.slice(index - rightLength, index)))
      });
    } else {
      rightLength = 1;
      left = alternative.getChild(index - 1);
      if (left.node.type === 'Group' && !left.node.capturing) {
        left = left.getChild();
      }
    }

    if (left.hasEqualSource(right)) {
      for (var j = index - rightLength; j < index; j++) {
        alternative.getChild(index - rightLength).remove();
      }

      increaseQuantifierByOne(child.node.quantifier);

      return index - rightLength;
    }
  }
  return index;
}

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var transforms = new Map([
// \ud83d\ude80 -> \u{1f680}
['charSurrogatePairToSingleUnicode', charSurrogatePairToSingleUnicodeTransform],

// \u0061 -> a
['charCodeToSimpleChar', charCodeToSimpleCharTransform],

// /Aa/i -> /aa/i
['charCaseInsensitiveLowerCaseTransform', charCaseInsensitiveLowercaseTransform],

// [\d\d] -> [\d]
['charClassRemoveDuplicates', charClassRemoveDuplicatesTransform],

// a{1,2}a{2,3} -> a{3,5}
['quantifiersMerge', quantifiersMergeTransform],

// a{1,} -> a+, a{3,3} -> a{3}, a{1} -> a
['quantifierRangeToSymbol', quantifierRangeToSymbolTransform],

// [a-a] -> [a], [a-b] -> [ab]
['charClassClassrangesToChars', charClassClassrangesToCharsTransform],

// [0-9] -> [\d]
['charClassToMeta', charClassToMetaTransform],

// [\d] -> \d, [^\w] -> \W
['charClassToSingleChar', charClassToSingleCharTransform],

// \e -> e
['charEscapeUnescape', charEscapeUnescapeTransform],

// [a-de-f] -> [a-f]
['charClassClassrangesMerge', charClassClassrangesMergeTransform],

// (ab|ab) -> (ab)
['disjunctionRemoveDuplicates', disjunctionRemoveDuplicatesTransform],

// (a|b|c) -> [abc]
['groupSingleCharsToCharClass', groupSingleCharsToCharClass],

// (?:)a -> a
['removeEmptyGroup', removeEmptyGroupTransform],

// (?:a) -> a
['ungroup', ungroupTransform],

// abcabcabc -> (?:abc){3}
['combineRepeatingPatterns', combineRepeatingPatternsTransform]]);

transforms.default;

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var clone = clone$1;
var parser$2 = parser$4;
var transform$2 = transform$3;
var optimizationTransforms = transforms;

var optimizer$1 = {
  /**
   * Optimizer transforms a regular expression into an optimized version,
   * replacing some sub-expressions with their idiomatic patterns.
   *
   * @param string | RegExp | AST - a regexp to optimize.
   *
   * @return TransformResult - an optimized regexp.
   *
   * Example:
   *
   *   /[a-zA-Z_0-9][a-zA-Z_0-9]*\e{1,}/
   *
   * Optimized to:
   *
   *   /\w+e+/
   */
  optimize: function optimize(regexp) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$whitelist = _ref.whitelist,
        whitelist = _ref$whitelist === undefined ? [] : _ref$whitelist,
        _ref$blacklist = _ref.blacklist,
        blacklist = _ref$blacklist === undefined ? [] : _ref$blacklist;

    var transformsRaw = whitelist.length > 0 ? whitelist : Array.from(optimizationTransforms.keys());

    var transformToApply = transformsRaw.filter(function (transform) {
      return !blacklist.includes(transform);
    });

    var ast = regexp;
    if (regexp instanceof RegExp) {
      regexp = '' + regexp;
    }

    if (typeof regexp === 'string') {
      ast = parser$2.parse(regexp);
    }

    var result = new transform$2.TransformResult(ast);
    var prevResultString = void 0;

    do {
      // Get a copy of the current state here so
      // we can compare it with the state at the
      // end of the loop.
      prevResultString = result.toString();
      ast = clone(result.getAST());

      transformToApply.forEach(function (transformName) {
        if (!optimizationTransforms.has(transformName)) {
          throw new Error('Unknown optimization-transform: ' + transformName + '. ' + 'Available transforms are: ' + Array.from(optimizationTransforms.keys()).join(', '));
        }

        var transformer = optimizationTransforms.get(transformName);

        // Don't override result just yet since we
        // might want to rollback the transform
        var newResult = transform$2.transform(ast, transformer);

        if (newResult.toString() !== result.toString()) {
          if (newResult.toString().length <= result.toString().length) {
            result = newResult;
          } else {
            // Result has changed but is not shorter:
            // restore ast to its previous state.

            ast = clone(result.getAST());
          }
        }
      });

      // Keep running the optimizer until it stops
      // making any change to the regexp.
    } while (result.toString() !== prevResultString);

    return result;
  }
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * Epsilon, the empty string.
 */

var EPSILON$3 = 'ε';

/**
 * Epsilon-closure.
 */
var EPSILON_CLOSURE$2 = EPSILON$3 + '*';

var specialSymbols = {
  EPSILON: EPSILON$3,
  EPSILON_CLOSURE: EPSILON_CLOSURE$2
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var _slicedToArray$1 = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass$4 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray$3(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck$4(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require$5 = specialSymbols,
    EPSILON$2 = _require$5.EPSILON,
    EPSILON_CLOSURE$1 = _require$5.EPSILON_CLOSURE;

/**
 * NFA fragment.
 *
 * NFA sub-fragments can be combined to a larger NFAs building
 * the resulting machine. Combining the fragments is done by patching
 * edges of the in- and out-states.
 *
 * 2-states implementation, `in`, and `out`. Eventually all transitions
 * go to the same `out`, which can further be connected via ε-transition
 * with other fragment.
 */


var NFA$2 = function () {
  function NFA(inState, outState) {
    _classCallCheck$4(this, NFA);

    this.in = inState;
    this.out = outState;
  }

  /**
   * Tries to recognize a string based on this NFA fragment.
   */


  _createClass$4(NFA, [{
    key: 'matches',
    value: function matches(string) {
      return this.in.matches(string);
    }

    /**
     * Returns an alphabet for this NFA.
     */

  }, {
    key: 'getAlphabet',
    value: function getAlphabet() {
      if (!this._alphabet) {
        this._alphabet = new Set();
        var table = this.getTransitionTable();
        for (var state in table) {
          var transitions = table[state];
          for (var symbol in transitions) {
            if (symbol !== EPSILON_CLOSURE$1) {
              this._alphabet.add(symbol);
            }
          }
        }
      }
      return this._alphabet;
    }

    /**
     * Returns set of accepting states.
     */

  }, {
    key: 'getAcceptingStates',
    value: function getAcceptingStates() {
      if (!this._acceptingStates) {
        // States are determined during table construction.
        this.getTransitionTable();
      }
      return this._acceptingStates;
    }

    /**
     * Returns accepting state numbers.
     */

  }, {
    key: 'getAcceptingStateNumbers',
    value: function getAcceptingStateNumbers() {
      if (!this._acceptingStateNumbers) {
        this._acceptingStateNumbers = new Set();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.getAcceptingStates()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var acceptingState = _step.value;

            this._acceptingStateNumbers.add(acceptingState.number);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
      return this._acceptingStateNumbers;
    }

    /**
     * Builds and returns transition table.
     */

  }, {
    key: 'getTransitionTable',
    value: function getTransitionTable() {
      var _this = this;

      if (!this._transitionTable) {
        this._transitionTable = {};
        this._acceptingStates = new Set();

        var visited = new Set();
        var symbols = new Set();

        var visitState = function visitState(state) {
          if (visited.has(state)) {
            return;
          }

          visited.add(state);
          state.number = visited.size;
          _this._transitionTable[state.number] = {};

          if (state.accepting) {
            _this._acceptingStates.add(state);
          }

          var transitions = state.getTransitions();

          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = transitions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var _ref = _step2.value;

              var _ref2 = _slicedToArray$1(_ref, 2);

              var symbol = _ref2[0];
              var symbolTransitions = _ref2[1];

              var combinedState = [];
              symbols.add(symbol);
              var _iteratorNormalCompletion3 = true;
              var _didIteratorError3 = false;
              var _iteratorError3 = undefined;

              try {
                for (var _iterator3 = symbolTransitions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  var nextState = _step3.value;

                  visitState(nextState);
                  combinedState.push(nextState.number);
                }
              } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                  }
                } finally {
                  if (_didIteratorError3) {
                    throw _iteratorError3;
                  }
                }
              }

              _this._transitionTable[state.number][symbol] = combinedState;
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        };

        // Traverse the graph starting from the `in`.
        visitState(this.in);

        // Append epsilon-closure column.
        visited.forEach(function (state) {
          delete _this._transitionTable[state.number][EPSILON$2];
          _this._transitionTable[state.number][EPSILON_CLOSURE$1] = [].concat(_toConsumableArray$3(state.getEpsilonClosure())).map(function (s) {
            return s.number;
          });
        });
      }

      return this._transitionTable;
    }
  }]);

  return NFA;
}();

var nfa = NFA$2;

nfa.default;

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

// DFA minization.

/**
 * Map from state to current set it goes.
 */

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _toConsumableArray$2(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var currentTransitionMap = null;

/**
 * Takes a DFA, and returns a minimized version of it
 * compressing some states to groups (using standard, 0-, 1-,
 * 2-, ... N-equivalence algorithm).
 */
function minimize(dfa) {
  var table = dfa.getTransitionTable();
  var allStates = Object.keys(table);
  var alphabet = dfa.getAlphabet();
  var accepting = dfa.getAcceptingStateNumbers();

  currentTransitionMap = {};

  var nonAccepting = new Set();

  allStates.forEach(function (state) {
    state = Number(state);
    var isAccepting = accepting.has(state);

    if (isAccepting) {
      currentTransitionMap[state] = accepting;
    } else {
      nonAccepting.add(state);
      currentTransitionMap[state] = nonAccepting;
    }
  });

  // ---------------------------------------------------------------------------
  // Step 1: build equivalent sets.

  // All [1..N] equivalent sets.
  var all = [
  // 0-equivalent sets.
  [nonAccepting, accepting].filter(function (set) {
    return set.size > 0;
  })];

  var current = void 0;
  var previous = void 0;

  // Top of the stack is the current list of sets to analyze.
  current = all[all.length - 1];

  // Previous set (to check whether we need to stop).
  previous = all[all.length - 2];

  // Until we'll not have the same N and N-1 equivalent rows.

  var _loop = function _loop() {
    var newTransitionMap = {};

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = current[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var _set = _step3.value;

        // Handled states for this set.
        var handledStates = {};

        var _set2 = _toArray(_set),
            first = _set2[0],
            rest = _set2.slice(1);

        handledStates[first] = new Set([first]);

        // Have to compare each from the rest states with
        // the already handled states, and see if they are equivalent.
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          restSets: for (var _iterator4 = rest[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var state = _step4.value;
            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
              for (var _iterator5 = Object.keys(handledStates)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var handledState = _step5.value;

                // This and some previously handled state are equivalent --
                // just append this state to the same set.
                if (areEquivalent(state, handledState, table, alphabet)) {
                  handledStates[handledState].add(state);
                  handledStates[state] = handledStates[handledState];
                  continue restSets;
                }
              }
              // Else, this state is not equivalent to any of the
              // handled states -- allocate a new set for it.
            } catch (err) {
              _didIteratorError5 = true;
              _iteratorError5 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion5 && _iterator5.return) {
                  _iterator5.return();
                }
              } finally {
                if (_didIteratorError5) {
                  throw _iteratorError5;
                }
              }
            }

            handledStates[state] = new Set([state]);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        // Add these handled states to all states map.


        Object.assign(newTransitionMap, handledStates);
      }

      // Update current transition map for the handled row.
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    currentTransitionMap = newTransitionMap;

    var newSets = new Set(Object.keys(newTransitionMap).map(function (state) {
      return newTransitionMap[state];
    }));

    all.push([].concat(_toConsumableArray$2(newSets)));

    // Top of the stack is the current.
    current = all[all.length - 1];

    // Previous set.
    previous = all[all.length - 2];
  };

  while (!sameRow(current, previous)) {
    _loop();
  }

  // ---------------------------------------------------------------------------
  // Step 2: build minimized table from the equivalent sets.

  // Remap state numbers from sets to index-based.
  var remaped = new Map();
  var idx = 1;
  current.forEach(function (set) {
    return remaped.set(set, idx++);
  });

  // Build the minimized table from the calculated equivalent sets.
  var minimizedTable = {};

  var minimizedAcceptingStates = new Set();

  var updateAcceptingStates = function updateAcceptingStates(set, idx) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = set[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var state = _step.value;

        if (accepting.has(state)) {
          minimizedAcceptingStates.add(idx);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  };

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = remaped.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _ref = _step2.value;

      var _ref2 = _slicedToArray(_ref, 2);

      var set = _ref2[0];
      var _idx = _ref2[1];

      minimizedTable[_idx] = {};
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = alphabet[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var symbol = _step6.value;

          updateAcceptingStates(set, _idx);

          // Determine original transition for this symbol from the set.
          var originalTransition = void 0;
          var _iteratorNormalCompletion7 = true;
          var _didIteratorError7 = false;
          var _iteratorError7 = undefined;

          try {
            for (var _iterator7 = set[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
              var originalState = _step7.value;

              originalTransition = table[originalState][symbol];
              if (originalTransition) {
                break;
              }
            }
          } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion7 && _iterator7.return) {
                _iterator7.return();
              }
            } finally {
              if (_didIteratorError7) {
                throw _iteratorError7;
              }
            }
          }

          if (originalTransition) {
            minimizedTable[_idx][symbol] = remaped.get(currentTransitionMap[originalTransition]);
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }
    }

    // Update the table, and accepting states on the original DFA.
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  dfa.setTransitionTable(minimizedTable);
  dfa.setAcceptingStateNumbers(minimizedAcceptingStates);

  return dfa;
}

function sameRow(r1, r2) {
  if (!r2) {
    return false;
  }

  if (r1.length !== r2.length) {
    return false;
  }

  for (var i = 0; i < r1.length; i++) {
    var s1 = r1[i];
    var s2 = r2[i];

    if (s1.size !== s2.size) {
      return false;
    }

    if ([].concat(_toConsumableArray$2(s1)).sort().join(',') !== [].concat(_toConsumableArray$2(s2)).sort().join(',')) {
      return false;
    }
  }

  return true;
}

/**
 * Checks whether two states are N-equivalent, i.e. whether they go
 * to the same set on a symbol.
 */
function areEquivalent(s1, s2, table, alphabet) {
  var _iteratorNormalCompletion8 = true;
  var _didIteratorError8 = false;
  var _iteratorError8 = undefined;

  try {
    for (var _iterator8 = alphabet[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
      var symbol = _step8.value;

      if (!goToSameSet(s1, s2, table, symbol)) {
        return false;
      }
    }
  } catch (err) {
    _didIteratorError8 = true;
    _iteratorError8 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion8 && _iterator8.return) {
        _iterator8.return();
      }
    } finally {
      if (_didIteratorError8) {
        throw _iteratorError8;
      }
    }
  }

  return true;
}

/**
 * Checks whether states go to the same set.
 */
function goToSameSet(s1, s2, table, symbol) {
  if (!currentTransitionMap[s1] || !currentTransitionMap[s2]) {
    return false;
  }

  var originalTransitionS1 = table[s1][symbol];
  var originalTransitionS2 = table[s2][symbol];

  // If no actual transition on this symbol, treat it as positive.
  if (!originalTransitionS1 && !originalTransitionS2) {
    return true;
  }

  // Otherwise, check if they are in the same sets.
  return currentTransitionMap[s1].has(originalTransitionS1) && currentTransitionMap[s2].has(originalTransitionS2);
}

var dfaMinimizer = {
  minimize: minimize
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var _createClass$3 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DFAMinimizer = dfaMinimizer;

var _require$4 = specialSymbols,
    EPSILON_CLOSURE = _require$4.EPSILON_CLOSURE;

/**
 * DFA is build by converting from NFA (subset construction).
 */


var DFA$1 = function () {
  function DFA(nfa) {
    _classCallCheck$3(this, DFA);

    this._nfa = nfa;
  }

  /**
   * Minimizes DFA.
   */


  _createClass$3(DFA, [{
    key: 'minimize',
    value: function minimize() {
      this.getTransitionTable();

      this._originalAcceptingStateNumbers = this._acceptingStateNumbers;
      this._originalTransitionTable = this._transitionTable;

      DFAMinimizer.minimize(this);
    }

    /**
     * Returns alphabet for this DFA.
     */

  }, {
    key: 'getAlphabet',
    value: function getAlphabet() {
      return this._nfa.getAlphabet();
    }

    /**
     * Returns accepting states.
     */

  }, {
    key: 'getAcceptingStateNumbers',
    value: function getAcceptingStateNumbers() {
      if (!this._acceptingStateNumbers) {
        // Accepting states are determined during table construction.
        this.getTransitionTable();
      }

      return this._acceptingStateNumbers;
    }

    /**
     * Returns original accepting states.
     */

  }, {
    key: 'getOriginaAcceptingStateNumbers',
    value: function getOriginaAcceptingStateNumbers() {
      if (!this._originalAcceptingStateNumbers) {
        // Accepting states are determined during table construction.
        this.getTransitionTable();
      }

      return this._originalAcceptingStateNumbers;
    }

    /**
     * Sets transition table.
     */

  }, {
    key: 'setTransitionTable',
    value: function setTransitionTable(table) {
      this._transitionTable = table;
    }

    /**
     * Sets accepting states.
     */

  }, {
    key: 'setAcceptingStateNumbers',
    value: function setAcceptingStateNumbers(stateNumbers) {
      this._acceptingStateNumbers = stateNumbers;
    }

    /**
     * DFA transition table is built from NFA table.
     */

  }, {
    key: 'getTransitionTable',
    value: function getTransitionTable() {
      var _this = this;

      if (this._transitionTable) {
        return this._transitionTable;
      }

      // Calculate from NFA transition table.
      var nfaTable = this._nfa.getTransitionTable();
      var nfaStates = Object.keys(nfaTable);

      this._acceptingStateNumbers = new Set();

      // Start state of DFA is E(S[nfa])
      var startState = nfaTable[nfaStates[0]][EPSILON_CLOSURE];

      // Init the worklist (states which should be in the DFA).
      var worklist = [startState];

      var alphabet = this.getAlphabet();
      var nfaAcceptingStates = this._nfa.getAcceptingStateNumbers();

      var dfaTable = {};

      // Determine whether the combined DFA state is accepting.
      var updateAcceptingStates = function updateAcceptingStates(states) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = nfaAcceptingStates[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var nfaAcceptingState = _step.value;

            // If any of the states from NFA is accepting, DFA's
            // state is accepting as well.
            if (states.indexOf(nfaAcceptingState) !== -1) {
              _this._acceptingStateNumbers.add(states.join(','));
              break;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      };

      while (worklist.length > 0) {
        var states = worklist.shift();
        var dfaStateLabel = states.join(',');
        dfaTable[dfaStateLabel] = {};

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = alphabet[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var symbol = _step2.value;

            var onSymbol = [];

            // Determine whether the combined state is accepting.
            updateAcceptingStates(states);

            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = states[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var state = _step3.value;

                var nfaStatesOnSymbol = nfaTable[state][symbol];
                if (!nfaStatesOnSymbol) {
                  continue;
                }

                var _iteratorNormalCompletion4 = true;
                var _didIteratorError4 = false;
                var _iteratorError4 = undefined;

                try {
                  for (var _iterator4 = nfaStatesOnSymbol[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    var nfaStateOnSymbol = _step4.value;

                    if (!nfaTable[nfaStateOnSymbol]) {
                      continue;
                    }
                    onSymbol.push.apply(onSymbol, _toConsumableArray$1(nfaTable[nfaStateOnSymbol][EPSILON_CLOSURE]));
                  }
                } catch (err) {
                  _didIteratorError4 = true;
                  _iteratorError4 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                      _iterator4.return();
                    }
                  } finally {
                    if (_didIteratorError4) {
                      throw _iteratorError4;
                    }
                  }
                }
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }

            var dfaStatesOnSymbolSet = new Set(onSymbol);
            var dfaStatesOnSymbol = [].concat(_toConsumableArray$1(dfaStatesOnSymbolSet));

            if (dfaStatesOnSymbol.length > 0) {
              var dfaOnSymbolStr = dfaStatesOnSymbol.join(',');

              dfaTable[dfaStateLabel][symbol] = dfaOnSymbolStr;

              if (!dfaTable.hasOwnProperty(dfaOnSymbolStr)) {
                worklist.unshift(dfaStatesOnSymbol);
              }
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }

      return this._transitionTable = this._remapStateNumbers(dfaTable);
    }

    /**
     * Remaps state numbers in the resulting table:
     * combined states '1,2,3' -> 1, '3,4' -> 2, etc.
     */

  }, {
    key: '_remapStateNumbers',
    value: function _remapStateNumbers(calculatedDFATable) {
      var newStatesMap = {};

      this._originalTransitionTable = calculatedDFATable;
      var transitionTable = {};

      Object.keys(calculatedDFATable).forEach(function (originalNumber, newNumber) {
        newStatesMap[originalNumber] = newNumber + 1;
      });

      for (var originalNumber in calculatedDFATable) {
        var originalRow = calculatedDFATable[originalNumber];
        var row = {};

        for (var symbol in originalRow) {
          row[symbol] = newStatesMap[originalRow[symbol]];
        }

        transitionTable[newStatesMap[originalNumber]] = row;
      }

      // Remap accepting states.
      this._originalAcceptingStateNumbers = this._acceptingStateNumbers;
      this._acceptingStateNumbers = new Set();

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this._originalAcceptingStateNumbers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _originalNumber = _step5.value;

          this._acceptingStateNumbers.add(newStatesMap[_originalNumber]);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return transitionTable;
    }

    /**
     * Returns original DFA table, where state numbers
     * are combined numbers from NFA.
     */

  }, {
    key: 'getOriginalTransitionTable',
    value: function getOriginalTransitionTable() {
      if (!this._originalTransitionTable) {
        // Original table is determined during table construction.
        this.getTransitionTable();
      }
      return this._originalTransitionTable;
    }

    /**
     * Checks whether this DFA accepts a string.
     */

  }, {
    key: 'matches',
    value: function matches(string) {
      var state = 1;
      var i = 0;
      var table = this.getTransitionTable();

      while (string[i]) {
        state = table[state][string[i++]];
        if (!state) {
          return false;
        }
      }

      if (!this.getAcceptingStateNumbers().has(state)) {
        return false;
      }

      return true;
    }
  }]);

  return DFA;
}();

var dfa = DFA$1;

dfa.default;

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A generic FA State class (base for NFA and DFA).
 *
 * Maintains the transition map, and the flag whether
 * the state is accepting.
 */

var _createClass$2 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var State$1 = function () {
  function State() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$accepting = _ref.accepting,
        accepting = _ref$accepting === undefined ? false : _ref$accepting;

    _classCallCheck$2(this, State);

    /**
     * Outgoing transitions to other states.
     */
    this._transitions = new Map();

    /**
     * Whether the state is accepting.
     */
    this.accepting = accepting;
  }

  /**
   * Returns transitions for this state.
   */


  _createClass$2(State, [{
    key: 'getTransitions',
    value: function getTransitions() {
      return this._transitions;
    }

    /**
     * Creates a transition on symbol.
     */

  }, {
    key: 'addTransition',
    value: function addTransition(symbol, toState) {
      this.getTransitionsOnSymbol(symbol).add(toState);
      return this;
    }

    /**
     * Returns transitions set on symbol.
     */

  }, {
    key: 'getTransitionsOnSymbol',
    value: function getTransitionsOnSymbol(symbol) {
      var transitions = this._transitions.get(symbol);

      if (!transitions) {
        transitions = new Set();
        this._transitions.set(symbol, transitions);
      }

      return transitions;
    }
  }]);

  return State;
}();

var state = State$1;

state.default;

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var _createClass$1 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var State = state;

var _require$3 = specialSymbols,
    EPSILON$1 = _require$3.EPSILON;

/**
 * NFA state.
 *
 * Allows nondeterministic transitions to several states on the
 * same symbol, and also epsilon-transitions.
 */


var NFAState$1 = function (_State) {
  _inherits(NFAState, _State);

  function NFAState() {
    _classCallCheck$1(this, NFAState);

    return _possibleConstructorReturn(this, (NFAState.__proto__ || Object.getPrototypeOf(NFAState)).apply(this, arguments));
  }

  _createClass$1(NFAState, [{
    key: 'matches',


    /**
     * Whether this state matches a string.
     *
     * We maintain set of visited epsilon-states to avoid infinite loops
     * when an epsilon-transition goes eventually to itself.
     *
     * NOTE: this function is rather "educational", since we use DFA for strings
     * matching. DFA is built on top of NFA, and uses fast transition table.
     */
    value: function matches(string) {
      var visited = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();

      // An epsilon-state has been visited, stop to avoid infinite loop.
      if (visited.has(this)) {
        return false;
      }

      visited.add(this);

      // No symbols left..
      if (string.length === 0) {
        // .. and we're in the accepting state.
        if (this.accepting) {
          return true;
        }

        // Check if we can reach any accepting state from
        // on the epsilon transitions.
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.getTransitionsOnSymbol(EPSILON$1)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var nextState = _step.value;

            if (nextState.matches('', visited)) {
              return true;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return false;
      }

      // Else, we get some symbols.
      var symbol = string[0];
      var rest = string.slice(1);

      var symbolTransitions = this.getTransitionsOnSymbol(symbol);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = symbolTransitions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _nextState = _step2.value;

          if (_nextState.matches(rest)) {
            return true;
          }
        }

        // If we couldn't match on symbol, check still epsilon-transitions
        // without consuming the symbol (i.e. continue from `string`, not `rest`).
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.getTransitionsOnSymbol(EPSILON$1)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _nextState2 = _step3.value;

          if (_nextState2.matches(string, visited)) {
            return true;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return false;
    }

    /**
     * Returns an ε-closure for this state:
     * self + all states following ε-transitions.
     */

  }, {
    key: 'getEpsilonClosure',
    value: function getEpsilonClosure() {
      var _this2 = this;

      if (!this._epsilonClosure) {
        (function () {
          var epsilonTransitions = _this2.getTransitionsOnSymbol(EPSILON$1);
          var closure = _this2._epsilonClosure = new Set();
          closure.add(_this2);
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = epsilonTransitions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var nextState = _step4.value;

              if (!closure.has(nextState)) {
                closure.add(nextState);
                var nextClosure = nextState.getEpsilonClosure();
                nextClosure.forEach(function (state) {
                  return closure.add(state);
                });
              }
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
        })();
      }

      return this._epsilonClosure;
    }
  }]);

  return NFAState;
}(State);

var nfaState = NFAState$1;

nfaState.default;

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var NFA$1 = nfa;
var NFAState = nfaState;

var _require$2 = specialSymbols,
    EPSILON = _require$2.EPSILON;

// -----------------------------------------------------------------------------
// Char NFA fragment: `c`

/**
 * Char factory.
 *
 * Creates an NFA fragment for a single char.
 *
 * [in] --c--> [out]
 */


function char$1(c) {
  var inState = new NFAState();
  var outState = new NFAState({
    accepting: true
  });

  return new NFA$1(inState.addTransition(c, outState), outState);
}

// -----------------------------------------------------------------------------
// Epsilon NFA fragment

/**
 * Epsilon factory.
 *
 * Creates an NFA fragment for ε (recognizes an empty string).
 *
 * [in] --ε--> [out]
 */
function e() {
  return char$1(EPSILON);
}

// -----------------------------------------------------------------------------
// Alteration NFA fragment: `abc`

/**
 * Creates a connection between two NFA fragments on epsilon transition.
 *
 * [in-a] --a--> [out-a] --ε--> [in-b] --b--> [out-b]
 */
function altPair(first, second) {
  first.out.accepting = false;
  second.out.accepting = true;

  first.out.addTransition(EPSILON, second.in);

  return new NFA$1(first.in, second.out);
}

/**
 * Alteration factory.
 *
 * Creates a alteration NFA for (at least) two NFA-fragments.
 */
function alt$1(first) {
  for (var _len = arguments.length, fragments = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    fragments[_key - 1] = arguments[_key];
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = fragments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var fragment = _step.value;

      first = altPair(first, fragment);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return first;
}

// -----------------------------------------------------------------------------
// Disjunction NFA fragment: `a|b`

/**
 * Creates a disjunction choice between two fragments.
 */
function orPair(first, second) {
  var inState = new NFAState();
  var outState = new NFAState();

  inState.addTransition(EPSILON, first.in);
  inState.addTransition(EPSILON, second.in);

  outState.accepting = true;
  first.out.accepting = false;
  second.out.accepting = false;

  first.out.addTransition(EPSILON, outState);
  second.out.addTransition(EPSILON, outState);

  return new NFA$1(inState, outState);
}

/**
 * Disjunction factory.
 *
 * Creates a disjunction NFA for (at least) two NFA-fragments.
 */
function or$1(first) {
  for (var _len2 = arguments.length, fragments = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    fragments[_key2 - 1] = arguments[_key2];
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = fragments[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var fragment = _step2.value;

      first = orPair(first, fragment);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return first;
}

// -----------------------------------------------------------------------------
// Kleene-closure

/**
 * Kleene star/closure.
 *
 * a*
 */
function repExplicit(fragment) {
  var inState = new NFAState();
  var outState = new NFAState({
    accepting: true
  });

  // 0 or more.
  inState.addTransition(EPSILON, fragment.in);
  inState.addTransition(EPSILON, outState);

  fragment.out.accepting = false;
  fragment.out.addTransition(EPSILON, outState);
  outState.addTransition(EPSILON, fragment.in);

  return new NFA$1(inState, outState);
}

/**
 * Optimized Kleene-star: just adds ε-transitions from
 * input to the output, and back.
 */
function rep$1(fragment) {
  fragment.in.addTransition(EPSILON, fragment.out);
  fragment.out.addTransition(EPSILON, fragment.in);
  return fragment;
}

/**
 * Optimized Plus: just adds ε-transitions from
 * the output to the input.
 */
function plusRep$1(fragment) {
  fragment.out.addTransition(EPSILON, fragment.in);
  return fragment;
}

/**
 * Optimized ? repetition: just adds ε-transitions from
 * the input to the output.
 */
function questionRep$1(fragment) {
  fragment.in.addTransition(EPSILON, fragment.out);
  return fragment;
}

var builders$1 = {
  alt: alt$1,
  char: char$1,
  e: e,
  or: or$1,
  rep: rep$1,
  repExplicit: repExplicit,
  plusRep: plusRep$1,
  questionRep: questionRep$1
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var parser$1 = parser$4;

var _require$1 = builders$1,
    alt = _require$1.alt,
    char = _require$1.char,
    or = _require$1.or,
    rep = _require$1.rep,
    plusRep = _require$1.plusRep,
    questionRep = _require$1.questionRep;

/**
 * Helper `gen` function calls node type handler.
 */


function gen(node) {
  if (node && !generator$1[node.type]) {
    throw new Error(node.type + ' is not supported in NFA/DFA interpreter.');
  }

  return node ? generator$1[node.type](node) : '';
}

/**
 * AST handler.
 */
var generator$1 = {
  RegExp: function RegExp(node) {
    if (node.flags !== '') {
      throw new Error('NFA/DFA: Flags are not supported yet.');
    }

    return gen(node.body);
  },
  Alternative: function Alternative(node) {
    var fragments = (node.expressions || []).map(gen);
    return alt.apply(undefined, _toConsumableArray(fragments));
  },
  Disjunction: function Disjunction(node) {
    return or(gen(node.left), gen(node.right));
  },
  Repetition: function Repetition(node) {
    switch (node.quantifier.kind) {
      case '*':
        return rep(gen(node.expression));
      case '+':
        return plusRep(gen(node.expression));
      case '?':
        return questionRep(gen(node.expression));
      default:
        throw new Error('Unknown repeatition: ' + node.quantifier.kind + '.');
    }
  },
  Char: function Char(node) {
    if (node.kind !== 'simple') {
      throw new Error('NFA/DFA: Only simple chars are supported yet.');
    }

    return char(node.value);
  },
  Group: function Group(node) {
    return gen(node.expression);
  }
};

var nfaFromRegexp = {
  /**
   * Builds an NFA from the passed regexp.
   */
  build: function build(regexp) {
    var ast = regexp;

    if (regexp instanceof RegExp) {
      regexp = '' + regexp;
    }

    if (typeof regexp === 'string') {
      ast = parser$1.parse(regexp, {
        captureLocations: true
      });
    }

    return gen(ast);
  }
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var NFA = nfa;
var DFA = dfa;

var nfaFromRegExp = nfaFromRegexp;
var builders = builders$1;

var finiteAutomaton = {

  /**
   * Export NFA and DFA classes.
   */
  NFA: NFA,
  DFA: DFA,

  /**
   * Expose builders.
   */
  builders: builders,

  /**
   * Builds an NFA for the passed regexp.
   *
   * @param string | AST | RegExp:
   *
   *   a regular expression in different representations: a string,
   *   a RegExp object, or an AST.
   */
  toNFA: function toNFA(regexp) {
    return nfaFromRegExp.build(regexp);
  },


  /**
   * Builds DFA for the passed regexp.
   *
   * @param string | AST | RegExp:
   *
   *   a regular expression in different representations: a string,
   *   a RegExp object, or an AST.
   */
  toDFA: function toDFA(regexp) {
    return new DFA(this.toNFA(regexp));
  },


  /**
   * Returns true if regexp accepts the string.
   */
  test: function test(regexp, string) {
    return this.toDFA(regexp).matches(string);
  }
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * The `RegExpTree` class provides runtime support for `compat-transpiler`
 * module from `regexp-tree`.
 *
 * E.g. it tracks names of the capturing groups, in order to access the
 * names on the matched result.
 *
 * It's a thin-wrapper on top of original regexp.
 */

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RegExpTree$1 = function () {
  /**
   * Initializes a `RegExpTree` instance.
   *
   * @param RegExp - a regular expression
   *
   * @param Object state:
   *
   *   An extra state which may store any related to transformation
   *   data, for example, names of the groups.
   *
   *   - flags - original flags
   *   - groups - names of the groups, and their indices
   *   - source - original source
   */
  function RegExpTree(re, _ref) {
    var flags = _ref.flags,
        groups = _ref.groups,
        source = _ref.source;

    _classCallCheck(this, RegExpTree);

    this._re = re;
    this._groups = groups;

    // Original props.
    this.flags = flags;
    this.source = source || re.source;
    this.dotAll = flags.includes('s');

    // Inherited directly from `re`.
    this.global = re.global;
    this.ignoreCase = re.ignoreCase;
    this.multiline = re.multiline;
    this.sticky = re.sticky;
    this.unicode = re.unicode;
  }

  /**
   * Facade wrapper for RegExp `test` method.
   */


  _createClass(RegExpTree, [{
    key: 'test',
    value: function test(string) {
      return this._re.test(string);
    }

    /**
     * Facade wrapper for RegExp `compile` method.
     */

  }, {
    key: 'compile',
    value: function compile(string) {
      return this._re.compile(string);
    }

    /**
     * Facade wrapper for RegExp `toString` method.
     */

  }, {
    key: 'toString',
    value: function toString() {
      if (!this._toStringResult) {
        this._toStringResult = '/' + this.source + '/' + this.flags;
      }
      return this._toStringResult;
    }

    /**
     * Facade wrapper for RegExp `exec` method.
     */

  }, {
    key: 'exec',
    value: function exec(string) {
      var result = this._re.exec(string);

      if (!this._groups || !result) {
        return result;
      }

      result.groups = {};

      for (var group in this._groups) {
        var groupNumber = this._groups[group];
        result.groups[group] = result[groupNumber];
      }

      return result;
    }
  }]);

  return RegExpTree;
}();

var runtime = {
  RegExpTree: RegExpTree$1
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var compatTranspiler = compatTranspiler$1;
var generator = generator_1;
var optimizer = optimizer$1;
var parser = parser$4;
var _transform = transform$3;
var _traverse = traverse$3;
var fa = finiteAutomaton;

var _require = runtime,
    RegExpTree = _require.RegExpTree;

/**
 * An API object for RegExp processing (parsing/transform/generation).
 */


var regexpTree$3 = {
  /**
   * Parser module exposed.
   */
  parser: parser,

  /**
   * Expose finite-automaton module.
   */
  fa: fa,

  /**
   * `TransformResult` exposed.
   */
  TransformResult: _transform.TransformResult,

  /**
   * Parses a regexp string, producing an AST.
   *
   * @param string regexp
   *
   *   a regular expression in different formats: string, AST, RegExp.
   *
   * @param Object options
   *
   *   parsing options for this parse call. Default are:
   *
   *     - captureLocations: boolean
   *     - any other custom options
   *
   * @return Object AST
   */
  parse: function parse(regexp, options) {
    return parser.parse('' + regexp, options);
  },


  /**
   * Traverses a RegExp AST.
   *
   * @param Object ast
   * @param Object | Array<Object> handlers
   *
   * Each `handler` is an object containing handler function for needed
   * node types. Example:
   *
   *   regexpTree.traverse(ast, {
   *     onChar(node) {
   *       ...
   *     },
   *   });
   *
   * The value for a node type may also be an object with functions pre and post.
   * This enables more context-aware analyses, e.g. measuring star height.
   */
  traverse: function traverse(ast, handlers, options) {
    return _traverse.traverse(ast, handlers, options);
  },


  /**
   * Transforms a regular expression.
   *
   * A regexp can be passed in different formats (string, regexp or AST),
   * applying a set of transformations. It is a convenient wrapper
   * on top of "parse-traverse-generate" tool chain.
   *
   * @param string | AST | RegExp regexp - a regular expression;
   * @param Object | Array<Object> handlers - a list of handlers.
   *
   * @return TransformResult - a transformation result.
   */
  transform: function transform(regexp, handlers) {
    return _transform.transform(regexp, handlers);
  },


  /**
   * Generates a RegExp string from an AST.
   *
   * @param Object ast
   *
   * Invariant:
   *
   *   regexpTree.generate(regexpTree.parse('/[a-z]+/i')); // '/[a-z]+/i'
   */
  generate: function generate(ast) {
    return generator.generate(ast);
  },


  /**
   * Creates a RegExp object from a regexp string.
   *
   * @param string regexp
   */
  toRegExp: function toRegExp(regexp) {
    var compat = this.compatTranspile(regexp);
    return new RegExp(compat.getSource(), compat.getFlags());
  },


  /**
   * Optimizes a regular expression by replacing some
   * sub-expressions with their idiomatic patterns.
   *
   * @param string regexp
   *
   * @return TransformResult object
   */
  optimize: function optimize(regexp, whitelist) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        blacklist = _ref.blacklist;

    return optimizer.optimize(regexp, { whitelist: whitelist, blacklist: blacklist });
  },


  /**
   * Translates a regular expression in new syntax or in new format
   * into equivalent expressions in old syntax.
   *
   * @param string regexp
   *
   * @return TransformResult object
   */
  compatTranspile: function compatTranspile(regexp, whitelist) {
    return compatTranspiler.transform(regexp, whitelist);
  },


  /**
   * Executes a regular expression on a string.
   *
   * @param RegExp|string re - a regular expression.
   * @param string string - a testing string.
   */
  exec: function exec(re, string) {
    if (typeof re === 'string') {
      var compat = this.compatTranspile(re);
      var extra = compat.getExtra();

      if (extra.namedCapturingGroups) {
        re = new RegExpTree(compat.toRegExp(), {
          flags: compat.getFlags(),
          source: compat.getSource(),
          groups: extra.namedCapturingGroups
        });
      } else {
        re = compat.toRegExp();
      }
    }

    return re.exec(string);
  }
};

var regexpTree_1 = regexpTree$3;

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var regexpTree$2 = regexpTree_1;

const regexpTree$1 = regexpTree$2;

const notSimpleChar = ({type, kind}) => type !== 'Char' || kind !== 'simple';

var isSimpleRegexp = (regexp) => {
    let containsMoreThenSimpleChars = false;
    const ast = regexpTree$1.parse(regexp);
    
    if (ast.body.type !== 'Alternative')
        return false;
    
    regexpTree$1.traverse(ast, {
        RegExp({node}) {
            const {expressions} = node.body;
            containsMoreThenSimpleChars = Boolean(expressions.find(notSimpleChar));
        },
    });
    
    return !containsMoreThenSimpleChars;
};

isSimpleRegexp.default;

var transformRegexp = {};

const regexpTree = regexpTree$2;

transformRegexp.transformRegExp = (str, {report, traverse, fix}) => {
    const ast = regexpTree.parse(str, {
        captureLocations: true,
    });
    
    const places = [];
    const push = (path) => {
        const {start} = (path.path || path).node.loc;
        
        places.push({
            position: start,
            message: report(path),
        });
        
        fix(path);
    };
    
    regexpTree.traverse(ast, traverse({
        push,
    }));
    
    return [
        regexpTree.generate(ast),
        places,
    ];
};

const isSimpleRegExp = isSimpleRegexp;
const {transformRegExp} = transformRegexp;

var regexp = {
    isSimpleRegExp,
    transformRegExp,
};

var addArgs = {};

const {compareAny} = compare$5;
const {template: template$1} = parser$5;
const {types: types$3} = bundle;
const {
    isBlockStatement,
    isFunction,
    isLabeledStatement,
    isObjectPattern,
    isCallExpression,
    objectPattern,
    objectProperty,
} = types$3;

const {entries: entries$1} = Object;
const SHORTHAND = true;

const isCallOrStatement = (path) => path.isCallExpression() || path.isStatement();

const isCall = (path) => {
    return isCallExpression(path.find(isCallOrStatement));
};

const report$2 = ({name}) => `Argument '${name}' is missing`;

addArgs.addArgs = (args) => ({
    report: report$2,
    fix: fix$2,
    traverse: traverse$1(args),
});

const fix$2 = ({declaration, path, pattern, params, index}) => {
    const declarationNode = template$1.ast.fresh(declaration);
    
    if (isBlockStatement(declarationNode)) {
        const prop = createProperty(declarationNode.body[0]);
        pattern.properties.push(prop);
        
        if (!isObjectPattern(params[index]))
            return params.push(pattern);
        
        return;
    }
    
    path.scope.block.params = [
        declarationNode,
    ];
};

const traverse$1 = (args) => ({push, options}) => {
    const allArgs = {
        ...options.args,
        ...args,
    };
    
    return {
        ReferencedIdentifier(path) {
            for (const [name, [declaration, pattern, exclude]] of entries$1(allArgs)) {
                if (path.node.name !== name)
                    continue;
                
                if (path.scope.hasBinding(name))
                    continue;
                
                if (!isCall(path))
                    continue;
                
                const fnPath = path.find(isFunction);
                
                if (!fnPath)
                    continue;
                
                const {block} = fnPath.scope;
                
                if (!compareAny(path.scope.path, pattern))
                    continue;
                
                if (compareAny(path.scope.path, exclude))
                    continue;
                
                const {params} = block;
                const [index, lastParam] = getObjectPattern(params);
                
                if (isObjectPattern(lastParam)) {
                    push({
                        name,
                        index,
                        declaration,
                        path,
                        params,
                        pattern: lastParam,
                    });
                    return;
                }
                
                if (params.length >= 3)
                    return;
                
                push({
                    name,
                    index,
                    declaration,
                    path,
                    params,
                    pattern: objectPattern([]),
                });
            }
        },
    };
};

function createProperty(node) {
    if (!isLabeledStatement(node)) {
        const {expression} = node;
        return objectProperty(expression, expression, false, SHORTHAND);
    }
    
    const {label, body} = node;
    
    return objectProperty(label, body.expression, false, SHORTHAND);
}

function getObjectPattern(params) {
    for (const [i, param] of params.entries()) {
        if (isObjectPattern(param))
            return [i, param];
    }
    
    return [
        -1,
        null,
    ];
}

var keyword = {};

const moduleDeclarations = [
    'import',
    'export',
];

const declarations = [
    'const',
    'var',
    'let',
];

const conditions = ['if'];

const typescript = [
    'readonly',
    'implements',
    'declare',
    'module',
    'type',
];

const typescriptReserved = [
    'interface',
    'static',
];

const expressions = [
    'as',
    'await',
    'new',
    'yield',
    'typeof',
    'function',
];

const statements = [
    ...conditions,
    ...declarations,
    ...moduleDeclarations,
    ...typescriptReserved,
    'async',
    'break',
    'continue',
    'for',
    'else',
    'from',
    'return',
    'throw',
    'of',
    'while',
    'class',
    'extends',
    'default',
];

const keywords = [
    ...statements,
    ...expressions,
];

keyword.isKeyword = (name) => {
    return keywords.includes(name);
};

keyword.isDeclarationKeyword = (name) => {
    return declarations.includes(name);
};

keyword.isModuleDeclarationKeyword = (name) => {
    return moduleDeclarations.includes(name);
};

keyword.isConditionKeyword = (name) => {
    return conditions.includes(name);
};

keyword.isStatementKeyword = (name) => {
    return statements.includes(name);
};

keyword.isTSKeyword = (name) => {
    const ts = typescript.includes(name);
    const tsReserved = typescriptReserved.includes(name);
    
    return ts || tsReserved;
};

var matchFiles = {};

const {relative} = require$$0$1;
const ignore$1 = require$$1$1;

const isNegative = (a) => !a.indexOf('!');
const positive = (a) => a.replace(/^!/, '');

var ignores$2 = (dirOpt, resolvedName, options = {}) => {
    const relativeName = relative(dirOpt, resolvedName);
    const ignorer = ignore$1();
    const ignoreList = mergeIgnores(options.ignore || []);
    
    ignorer.add(ignoreList);
    
    return dirOpt && ignorer.ignores(relativeName);
};

function mergeIgnores(ignores) {
    for (const [i, str] of ignores.entries()) {
        const positiveIndex = ignores.indexOf(positive(str));
        
        if (isNegative(str) && positiveIndex > i)
            ignores[positiveIndex] = str;
    }
    
    const noDuplicates = new Set(ignores);
    
    return Array.from(noDuplicates);
}

ignores$2.default;

const path = require$$0$1;

const {parse: parse$2, print: print$1} = parser$5;
const {transform: transform$1} = transform$5;
const {findPlaces: findPlaces$1} = findPlaces$2;
const ignores$1 = ignores$2;

const {toJS, fromJS} = json;

const {
    readFileContent: readFileContent$1,
    findFile: findFile$1,
    writeFileContent,
    getFilename: getFilename$1,
    createFile,
    removeFile,
    getParentDirectory: getParentDirectory$1,
} = filesystem;

const {join: join$1} = path;

const isObject = (a) => a && typeof a === 'object';
const {entries} = Object;
const report$1 = (path, {message}) => message;

matchFiles.matchFiles = (options) => {
    const {filename} = options;
    const files = options.files ?? options;
    const exclude = options.exclude ?? [];
    
    check$1(files);
    
    const scan = createScan({
        defaultFilename: filename,
        files,
        exclude,
    });
    
    return {
        fix: fix$1,
        scan,
        report: report$1,
    };
};

function fix$1(inputFile, {dirPath, matchInputFilename, outputFilename, matchedJS, matchedAST, options}) {
    transform$1(matchedAST, matchedJS, options);
    
    const matchedJSON = magicPrint(outputFilename, matchedAST);
    const outputFile = getOutputFile({
        dirPath,
        matchInputFilename,
        outputFilename,
        inputFile,
    });
    
    writeFileContent(outputFile, matchedJSON);
    
    if (inputFile !== outputFile)
        removeFile(inputFile);
}

const createScan = ({files, exclude, defaultFilename}) => (mainPath, {push, progress, options}) => {
    const allFiles = [];
    const cwd = getFilename$1(mainPath);
    
    options.filename = options.filename ?? defaultFilename;
    
    for (const [filename, rawOptions] of entries(files)) {
        const [matchInputFilenameMask] = parseMatcher(filename, options);
        const inputFiles = findFile$1(mainPath, matchInputFilenameMask, exclude);
        
        for (const inputFile of inputFiles) {
            const dirPath = getParentDirectory$1(inputFile);
            const inputFilename = getFilename$1(inputFile);
            
            const [matchInputFilename, outputFilename = matchInputFilename] = parseMatcher(filename, {
                filename: inputFilename,
            });
            
            if (ignores$1(cwd, inputFilename, options))
                continue;
            
            allFiles.push({
                dirPath,
                matchInputFilename,
                rawOptions,
                inputFile,
                inputFilename,
                outputFilename,
            });
        }
    }
    
    const n = allFiles.length;
    
    for (const [i, current] of allFiles.entries()) {
        const {
            dirPath,
            matchInputFilename,
            inputFile,
            inputFilename,
            outputFilename,
            rawOptions,
        } = current;
        
        progress({
            i,
            n,
        });
        
        const fileContent = readFileContent$1(inputFile) || '{}';
        const [matchedJS, matchedAST] = magicParse(inputFilename, fileContent);
        
        const options = parseOptions(inputFilename, rawOptions);
        const places = findPlaces$1(matchedAST, matchedJS, options);
        
        if (!places.length)
            continue;
        
        const {message} = places[0];
        
        push(inputFile, {
            dirPath,
            matchInputFilename,
            
            outputFilename,
            message,
            options,
            
            matchedAST,
            matchedJS,
        });
    }
};

function magicParse(name, content) {
    if (/\.json$/.test(name)) {
        const js = toJS(content);
        const ast = parse$2(js);
        
        return [js, ast];
    }
    
    if (/\.(c|m)?ts(x)?$/.test(name)) {
        const ast = parse$2(content, {
            isTS: true,
        });
        
        return [content, ast];
    }
    
    return [content, parse$2(content)];
}

function magicPrint(name, ast) {
    if (/\.json$/.test(name)) {
        const js = print$1(ast);
        
        return fromJS(js);
    }
    
    return print$1(ast);
}

function check$1(files) {
    for (const [, plugin] of entries(files)) {
        if (!isObject(plugin))
            throw Error(`☝️ Looks like provided to 'matchFiles()' typeof of plugin is not an 'object' but '${typeof plugin}'`);
    }
}

function getOutputFile({dirPath, matchInputFilename, outputFilename, inputFile}) {
    if (matchInputFilename === outputFilename)
        return inputFile;
    
    const name = join$1(getFilename$1(dirPath), outputFilename);
    const [outputFile] = findFile$1(dirPath, name);
    
    if (outputFile)
        return outputFile;
    
    return createFile(dirPath, outputFilename);
}

function parseMatcher(matcher, options) {
    const {filename} = options;
    
    if (!filename)
        return matcher.split(' -> ');
    
    const {ext, name} = path.parse(filename);
    
    matcher = matcher.replaceAll(`__name`, name);
    matcher = matcher.replaceAll(`__ext`, ext);
    
    return matcher.split(' -> ');
}

function parseOptions(inputFilename, rawOptions) {
    if (rawOptions.plugins)
        return rawOptions;
    
    const name = `match-file: ${inputFilename}`;
    
    const plugins = [
        [name, rawOptions],
    ];
    
    return {
        plugins,
    };
}

var renameFiles = {};

const {join} = require$$0$1;

const {
    getParentDirectory,
    getFilename,
    readFileContent,
    findFile,
    renameFile,
} = filesystem;

const {parse: parse$1} = JSON;

renameFiles.renameFiles = ({type, mask, rename}) => ({
    report,
    fix,
    scan: scan({
        type,
        mask,
        rename,
    }),
});

const report = (file, {from, to}) => `Rename '${from}' to '${to}'`;

const fix = (file, {to}) => {
    renameFile(file, to);
};

const scan = ({type, mask, rename}) => (path, {push, trackFile}) => {
    for (const file of trackFile(path, mask)) {
        if (type && !checkType(type, file))
            continue;
        
        const from = getFilename(file);
        const to = rename(from);
        
        push(file, {
            from,
            to,
        });
    }
};

function checkType(type, file) {
    const packagePath = findUpPackage(file);
    
    if (type === 'commonjs' && !packagePath)
        return true;
    
    if (!packagePath)
        return false;
    
    const packageContent = readFileContent(packagePath);
    
    if (!packageContent)
        return false;
    
    const info = parse$1(packageContent);
    const infoType = info.type || 'commonjs';
    
    return infoType === type;
}

function findUpPackage(file) {
    let packageJSON;
    let dirPath = getParentDirectory(file);
    
    do {
        const dir = getFilename(dirPath);
        [packageJSON] = findFile(dirPath, join(dir, 'package.json'));
    } while (!packageJSON && (dirPath = getParentDirectory(dirPath)));
    
    return packageJSON;
}

var ignore = {};

const {types: types$2} = bundle;
const {traverseProperties} = operate;
const {stringLiteral} = types$2;
const getValue = ({value}) => value;

ignore.ignore = (type, {name, property, list}) => {
    const [, collector] = type.split(/\(|\)/);
    
    return {
        report: createReport(name),
        match: createMatch({
            type,
            property,
            collector,
            list,
        }),
        replace: createReplace({
            type,
            property,
            collector,
            list,
        }),
    };
};

const createReport = (name) => () => `Add dotfiles to '${name}'`;

const createMatch = ({type, property, collector, list}) => ({options}) => {
    const {dismiss = []} = options;
    const newNames = filterNames(list, dismiss);
    
    return {
        [type]: (vars) => {
            const elements = parseElements(vars, {
                property,
                collector,
            });
            
            if (!elements)
                return false;
            
            const list = elements.map(getValue);
            
            for (const name of newNames) {
                if (!list.includes(name))
                    return true;
            }
            
            return false;
        },
    };
};

const createReplace = ({type, property, collector, list}) => ({options}) => {
    const {dismiss = []} = options;
    const newNames = filterNames(list, dismiss);
    
    return {
        [type]: (vars, path) => {
            const elements = parseElements(vars, {
                property,
                collector,
            });
            
            const list = elements.map(getValue);
            
            for (const name of newNames) {
                if (!list.includes(name))
                    elements.push(stringLiteral(name));
            }
            
            return path;
        },
    };
};

function filterNames(names, dismiss) {
    const newNames = [];
    
    for (const name of names) {
        if (dismiss.includes(name))
            continue;
        
        newNames.push(name);
    }
    
    return newNames;
}

function parseElements(vars, {property, collector}) {
    const node = vars[collector];
    
    if (!property)
        return node.elements;
    
    const [prop] = traverseProperties(node, property);
    
    if (!prop)
        return null;
    
    return prop.node.value.elements;
}

var parens = {};

const {types: types$1} = bundle;
const {
    parenthesizedExpression,
    tsParenthesizedType,
} = types$1;

parens.hasParens = hasParens;

parens.addParens = (path) => {
    const printer = getPrinter(path);
    
    if (hasParens(path, printer))
        return path;
    
    if (printer !== 'babel') {
        const {extra = {}} = path.node;
        
        extra.parenthesized = true;
        path.node.extra = extra;
        
        return path;
    }
    
    const {node} = path;
    
    if (path.type.startsWith('TS'))
        return path.replaceWith(tsParenthesizedType(node));
    
    path.replaceWith(parenthesizedExpression(node));
    
    return path;
};

parens.removeParens = (path) => {
    const printer = getPrinter(path);
    
    if (!hasParens(path, printer))
        return path;
    
    if (printer !== 'babel') {
        path.node.extra.parenthesized = false;
        return path;
    }
    
    const {node} = path;
    path.parentPath.replaceWith(node);
    
    return path;
};

function getPrinter(path) {
    const scope = path.scope.getProgramParent();
    const programPath = scope.path;
    
    return programPath.node.extra.__putout_printer;
}

function hasParens(path, printer = getPrinter(path)) {
    if (printer !== 'babel')
        return path.node.extra?.parenthesized;
    
    const {type} = path.parentPath;
    
    return /^(TS)?Parenthesized(Expression|Type)?$/.test(type);
}

const {codeFrameColumns} = bundle;

var codeframe$1 = ({source, error, highlightCode = true}) => {
    const {message, loc} = error;
    
    if (!loc)
        return message;
    
    const location = {
        start: loc,
    };
    
    return codeFrameColumns(source, location, {
        highlightCode,
        message,
    });
};

codeframe$1.default;

const {traverse, types} = bundle;
const {
    parse,
    print,
    generate,
    template,
} = parser$5;

const {cutShebang, mergeShebang} = shebang;
const {defaultOptions} = defaultOptions$4;
const {transform, transformAsync} = transform$5;

const {
    findPlaces,
    findPlacesAsync,
} = findPlaces$2;

const isString = (a) => typeof a === 'string';

putout$1.exports = putout;
var putout_2 = putout$1.exports.putout = putout;

function putout(source, opts) {
    check(source);
    opts = defaultOptions(opts);
    
    const {
        parser,
        isTS,
        isJSX,
        printer,
    } = opts;
    
    const [clearSource, shebang] = cutShebang(source);
    
    const ast = parse(clearSource, {
        parser,
        isTS,
        isJSX,
        printer,
    });
    
    const places = transform(ast, source, opts);
    
    if (!opts.fix)
        return {
            code: source,
            places,
        };
    
    const printed = print(ast, {
        printer,
        source,
    });
    
    const code = mergeShebang(shebang, printed);
    
    return {
        code,
        places,
    };
}

var putoutAsync = putout$1.exports.putoutAsync = async (source, opts) => {
    check(source);
    opts = defaultOptions(opts);
    
    const {
        parser,
        isTS,
        isJSX,
        printer,
    } = opts;
    
    const [clearSource, shebang] = cutShebang(source);
    
    const ast = parse(clearSource, {
        parser,
        isTS,
        isJSX,
        printer,
    });
    
    const places = await transformAsync(ast, source, opts);
    
    if (!opts.fix)
        return {
            code: source,
            places,
        };
    
    const printed = print(ast, {
        printer,
    });
    
    const code = mergeShebang(shebang, printed);
    
    return {
        code,
        places,
    };
};

var transform_1 = putout$1.exports.transform = transform;
var transformAsync_1 = putout$1.exports.transformAsync = transformAsync;

var findPlaces_1 = putout$1.exports.findPlaces = findPlaces;
var findPlacesAsync_1 = putout$1.exports.findPlacesAsync = findPlacesAsync;

var parse_1 = putout$1.exports.parse = parse;
var print_1 = putout$1.exports.print = print;
var traverse_1 = putout$1.exports.traverse = traverse;
var types_1 = putout$1.exports.types = types;
var template_1 = putout$1.exports.template = template;
var generate_1 = putout$1.exports.generate = generate;
var initReport = putout$1.exports.initReport = report$3;

var operator = putout$1.exports.operator = {
    ...operate,
    ...compare$5,
    ...traverse$5,
    ...json,
    ...jsx,
    ...declare$1,
    ...regexp,
    ...addArgs,
    ...filesystem,
    ...keyword,
    ...matchFiles,
    ...renameFiles,
    ...ignore,
    ...parens,
};

var ignores = putout$1.exports.ignores = ignores$2;
var codeframe = putout$1.exports.codeframe = codeframe$1;

function check(source) {
    if (!isString(source))
        throw Error(`☝️ Looks like 'source' has type '${typeof source}', expected: 'string'`);
}

var putoutExports = putout$1.exports;

export { codeframe, putoutExports as default, findPlaces_1 as findPlaces, findPlacesAsync_1 as findPlacesAsync, generate_1 as generate, ignores, initReport, operator, parse_1 as parse, print_1 as print, putout_2 as putout, putoutAsync, template_1 as template, transform_1 as transform, transformAsync_1 as transformAsync, traverse_1 as traverse, types_1 as types };
