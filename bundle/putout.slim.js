function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, '__esModule')) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			var isInstance = false;
      try {
        isInstance = this instanceof a;
      } catch {}
			if (isInstance) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var fullstore = (value) => {
    const data = {
        value,
    };
    
    return (...args) => {
        const [value] = args;
        
        if (!args.length)
            return data.value;
        
        data.value = value;
        
        return value;
    };
};

var fullstore$1 = fullstore.default;

var global$1 = (typeof global !== "undefined" ? global :
  typeof self !== "undefined" ? self :
  typeof window !== "undefined" ? window : {});

var platform = 'browser';
var env = {};
var argv = [];

// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
var performance = global$1.performance || {};
performance.now        ||
  performance.mozNow     ||
  performance.msNow      ||
  performance.oNow       ||
  performance.webkitNow  ||
  function(){ return (new Date()).getTime() };

var browser$1 = {
  env: env,
  argv: argv,
  platform: platform};

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;
function init$3 () {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
}

function toByteArray (b64) {
  if (!inited) {
    init$3();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = (tmp >> 16) & 0xFF;
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
    output.push(tripletToBase64(tmp));
  }
  return output.join('')
}

function fromByteArray (uint8) {
  if (!inited) {
    init$3();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[(tmp << 4) & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
    output += lookup[tmp >> 10];
    output += lookup[(tmp >> 4) & 0x3F];
    output += lookup[(tmp << 2) & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('')
}

function read (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? (nBytes - 1) : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

function write (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
  var i = isLE ? 0 : (nBytes - 1);
  var d = isLE ? 1 : -1;
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
}

var toString = {}.toString;

var isArray$d = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */


var INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
  ? global$1.TYPED_ARRAY_SUPPORT
  : true;

/*
 * Export kMaxLength after typed array support is determined.
 */
kMaxLength();

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr
};

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) ;
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
};

function allocUnsafe (that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
};

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that
}

function fromObject (that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len);
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray$d(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}
Buffer.isBuffer = isBuffer;
function internalIsBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
};

Buffer.concat = function concat (list, length) {
  if (!isArray$d(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer
};

function byteLength (string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString (encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Array.isArray` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap (b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this
};

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this
};

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this
};

Buffer.prototype.toString = function toString () {
  var length = this.length | 0;
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
};

Buffer.prototype.equals = function equals (b) {
  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
};

Buffer.prototype.inspect = function inspect () {
  var str = '';
  var max = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>'
};

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1);
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (internalIsBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
};

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
};

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
};

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed;
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
};

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf)
  } else {
    return fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val
};

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val
};

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset]
};

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | (this[offset + 1] << 8)
};

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return (this[offset] << 8) | this[offset + 1]
};

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
};

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
};

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
};

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | (this[offset + 1] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | (this[offset] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
};

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
};

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4)
};

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4)
};

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8)
};

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8)
};

function checkInt (buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = (value & 0xff);
  return offset + 1
};

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24);
    this[offset + 2] = (value >>> 16);
    this[offset + 1] = (value >>> 8);
    this[offset] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = (value & 0xff);
  return offset + 1
};

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
    this[offset + 2] = (value >>> 16);
    this[offset + 3] = (value >>> 24);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
};

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
};

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    );
  }

  return len
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        }

        // valid lead
        leadSurrogate = codePoint;

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray
}


function base64ToBytes (str) {
  return toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i];
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}


// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
}

function isFastBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
}

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;

var __commonJS = (cb, mod) => function __require() {
    return (mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
        exports: {},
    }).exports, mod), mod.exports);
};

var __export = (target, all) => {
    for (var name in all)    __defProp(target, name, {
        get: all[name],
        enumerable: true,
    });
};

var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === 'object' || typeof from === 'function') {
        for (let key of __getOwnPropNames(from))
            if (!__hasOwnProp.call(to, key) && key !== except)
                __defProp(to, key, {
                    get: () => from[key],
                    enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,
                });
    }
    
    return to;
};

var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
// file that has been converted to a CommonJS file using a Babel-
// compatible transform (i.e. "__esModule" has not been set), then set
// "default" to the CommonJS "module.exports" for node compatibility.
__defProp(target, 'default', {
    value: mod,
    enumerable: true,
}) , mod));

// ../babel-babel/node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS({
    '../babel-babel/node_modules/picocolors/picocolors.js'(exports$1, module) {
        var p = browser$1 || {};
        var argv = p.argv || [];
        var env = p.env || {};
        var isColorSupported2 = !(!!env.NO_COLOR || argv.includes('--no-color'))
            && (!!env.FORCE_COLOR
            || argv.includes('--color')
            || p.platform === 'win32'
            || (p.stdout || {}).isTTY
            && env.TERM !== 'dumb'
            || !!env.CI);
        
        var formatter = (open, close, replace = open) => (input) => {
            let string = '' + input, index2 = string.indexOf(close, open.length);
            return ~index2 ? open + replaceClose(string, close, replace, index2) + close : open + string + close;
        };
        
        var replaceClose = (string, close, replace, index2) => {
            let result = '', cursor = 0;
            
            do {
                result += string.substring(cursor, index2) + replace;
                cursor = index2 + close.length;
                index2 = string.indexOf(close, cursor);
            } while (~index2)
            
            return result + string.substring(cursor);
        };
        
        var createColors2 = (enabled2 = isColorSupported2) => {
            let f = enabled2 ? formatter : () => String;
            
            return {
                isColorSupported: enabled2,
                reset: f('\x1B[0m', '\x1B[0m'),
                bold: f('\x1B[1m', '\x1B[22m', '\x1B[22m\x1B[1m'),
                dim: f('\x1B[2m', '\x1B[22m', '\x1B[22m\x1B[2m'),
                italic: f('\x1B[3m', '\x1B[23m'),
                underline: f('\x1B[4m', '\x1B[24m'),
                inverse: f('\x1B[7m', '\x1B[27m'),
                hidden: f('\x1B[8m', '\x1B[28m'),
                strikethrough: f('\x1B[9m', '\x1B[29m'),
                black: f('\x1B[30m', '\x1B[39m'),
                red: f('\x1B[31m', '\x1B[39m'),
                green: f('\x1B[32m', '\x1B[39m'),
                yellow: f('\x1B[33m', '\x1B[39m'),
                blue: f('\x1B[34m', '\x1B[39m'),
                magenta: f('\x1B[35m', '\x1B[39m'),
                cyan: f('\x1B[36m', '\x1B[39m'),
                white: f('\x1B[37m', '\x1B[39m'),
                gray: f('\x1B[90m', '\x1B[39m'),
                bgBlack: f('\x1B[40m', '\x1B[49m'),
                bgRed: f('\x1B[41m', '\x1B[49m'),
                bgGreen: f('\x1B[42m', '\x1B[49m'),
                bgYellow: f('\x1B[43m', '\x1B[49m'),
                bgBlue: f('\x1B[44m', '\x1B[49m'),
                bgMagenta: f('\x1B[45m', '\x1B[49m'),
                bgCyan: f('\x1B[46m', '\x1B[49m'),
                bgWhite: f('\x1B[47m', '\x1B[49m'),
                blackBright: f('\x1B[90m', '\x1B[39m'),
                redBright: f('\x1B[91m', '\x1B[39m'),
                greenBright: f('\x1B[92m', '\x1B[39m'),
                yellowBright: f('\x1B[93m', '\x1B[39m'),
                blueBright: f('\x1B[94m', '\x1B[39m'),
                magentaBright: f('\x1B[95m', '\x1B[39m'),
                cyanBright: f('\x1B[96m', '\x1B[39m'),
                whiteBright: f('\x1B[97m', '\x1B[39m'),
                bgBlackBright: f('\x1B[100m', '\x1B[49m'),
                bgRedBright: f('\x1B[101m', '\x1B[49m'),
                bgGreenBright: f('\x1B[102m', '\x1B[49m'),
                bgYellowBright: f('\x1B[103m', '\x1B[49m'),
                bgBlueBright: f('\x1B[104m', '\x1B[49m'),
                bgMagentaBright: f('\x1B[105m', '\x1B[49m'),
                bgCyanBright: f('\x1B[106m', '\x1B[49m'),
                bgWhiteBright: f('\x1B[107m', '\x1B[49m'),
            };
        };
        
        module.exports = createColors2();
        module.exports.createColors = createColors2;
    },
});

// ../babel-babel/node_modules/jsesc/jsesc.js
var require_jsesc = __commonJS({
    '../babel-babel/node_modules/jsesc/jsesc.js'(exports$1, module) {
        
        var object = {};
        var hasOwnProperty = object.hasOwnProperty;
        var forOwn = (object2, callback) => {
            for (const key in object2) {
                if (hasOwnProperty.call(object2, key)) {
                    callback(key, object2[key]);
                }
            }
        };
        
        var extend = (destination, source) => {
            if (!source) {
                return destination;
            }
            
            forOwn(source, (key, value) => {
                destination[key] = value;
            });
            return destination;
        };
        
        var forEach = (array, callback) => {
            const length = array.length;
            let index2 = -1;
            
            while (++index2 < length) {
                callback(array[index2]);
            }
        };
        
        var fourHexEscape = (hex) => {
            return '\\u' + ('0000' + hex).slice(-4);
        };
        
        var hexadecimal = (code2, lowercase) => {
            let hexadecimal2 = code2.toString(16);
            
            if (lowercase)
                return hexadecimal2;
            
            return hexadecimal2.toUpperCase();
        };
        
        var toString = object.toString;
        var isArray = Array.isArray;
        
        var isBuffer = (value) => {
            return typeof Buffer === 'function' && Array.isArray(value);
        };
        
        var isObject = (value) => {
            return toString.call(value) == '[object Object]';
        };
        
        var isString = (value) => {
            return typeof value == 'string' || toString.call(value) == '[object String]';
        };
        
        var isNumber2 = (value) => {
            return typeof value == 'number' || toString.call(value) == '[object Number]';
        };
        
        var isFunction5 = (value) => {
            return typeof value == 'function';
        };
        
        var isMap = (value) => {
            return toString.call(value) == '[object Map]';
        };
        
        var isSet = (value) => {
            return toString.call(value) == '[object Set]';
        };
        
        var singleEscapes = {
            '\\': '\\\\',
            '\b': '\\b',
            '\f': '\\f',
            '\n': '\\n',
            '\r': '\\r',
            '	': '\\t',
            // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.

            // '\v': '\\x0B'
        };
        
        var regexSingleEscape = /[\\\b\f\n\r\t]/;
        var regexDigit = /[0-9]/;
        var regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
        var escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g;
        var escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g;
        
        var jsesc2 = (argument, options) => {
            const increaseIndentation = () => {
                oldIndent = indent;
                ++options.indentLevel;
                indent = options.indent.repeat(options.indentLevel);
            };
            
            const defaults = {
                'escapeEverything': false,
                'minimal': false,
                'isScriptContext': false,
                'quotes': 'single',
                'wrap': false,
                'es6': false,
                'json': false,
                'compact': true,
                'lowercaseHex': false,
                'numbers': 'decimal',
                'indent': '	',
                'indentLevel': 0,
                '__inline1__': false,
                '__inline2__': false,
            };
            
            const json = options && options.json;
            
            if (json) {
                defaults.quotes = 'double';
                defaults.wrap = true;
            }
            
            options = extend(defaults, options);
            
            if (options.quotes != 'single' && options.quotes != 'double' && options.quotes != 'backtick') {
                options.quotes = 'single';
            }
            
            const quote = options.quotes == 'double' ? '"' : options.quotes == 'backtick' ? '`' : '\'';
            const compact = options.compact;
            const lowercaseHex = options.lowercaseHex;
            let indent = options.indent.repeat(options.indentLevel);
            let oldIndent = '';
            const inline1 = options.__inline1__;
            const inline2 = options.__inline2__;
            const newLine = compact ? '' : '\n';
            let result;
            let isEmpty = true;
            const useBinNumbers = options.numbers == 'binary';
            const useOctNumbers = options.numbers == 'octal';
            const useDecNumbers = options.numbers == 'decimal';
            const useHexNumbers = options.numbers == 'hexadecimal';
            
            if (json && argument && isFunction5(argument.toJSON)) {
                argument = argument.toJSON();
            }
            
            if (!isString(argument)) {
                if (isMap(argument)) {
                    if (argument.size == 0) {
                        return 'new Map()';
                    }
                    
                    if (!compact) {
                        options.__inline1__ = true;
                        options.__inline2__ = false;
                    }
                    
                    return 'new Map(' + jsesc2(Array.from(argument), options) + ')';
                }
                
                if (isSet(argument)) {
                    if (argument.size == 0) {
                        return 'new Set()';
                    }
                    
                    return 'new Set(' + jsesc2(Array.from(argument), options) + ')';
                }
                
                if (isBuffer(argument)) {
                    if (argument.length == 0) {
                        return 'Buffer.from([])';
                    }
                    
                    return 'Buffer.from(' + jsesc2(Array.from(argument), options) + ')';
                }
                
                if (isArray(argument)) {
                    result = [];
                    options.wrap = true;
                    
                    if (inline1) {
                        options.__inline1__ = false;
                        options.__inline2__ = true;
                    }
                    
                    if (!inline2) {
                        increaseIndentation();
                    }
                    
                    forEach(argument, (value) => {
                        isEmpty = false;
                        
                        if (inline2) {
                            options.__inline2__ = false;
                        }
                        
                        result.push((compact || inline2 ? '' : indent) + jsesc2(value, options));
                    });
                    
                    if (isEmpty) {
                        return '[]';
                    }
                    
                    if (inline2) {
                        return '[' + result.join(', ') + ']';
                    }
                    
                    return '[' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + ']';
                } else if (isNumber2(argument)) {
                    if (json) {
                        return JSON.stringify(argument);
                    }
                    
                    if (useDecNumbers) {
                        return String(argument);
                    }
                    
                    if (useHexNumbers) {
                        let hexadecimal2 = argument.toString(16);
                        
                        if (!lowercaseHex) {
                            hexadecimal2 = hexadecimal2.toUpperCase();
                        }
                        
                        return '0x' + hexadecimal2;
                    }
                    
                    if (useBinNumbers) {
                        return '0b' + argument.toString(2);
                    }
                    
                    if (useOctNumbers) {
                        return '0o' + argument.toString(8);
                    }
                } else if (!isObject(argument)) {
                    if (json) {
                        return JSON.stringify(argument) || 'null';
                    }
                    
                    return String(argument);
                } else {
                    result = [];
                    options.wrap = true;
                    increaseIndentation();
                    forOwn(argument, (key, value) => {
                        isEmpty = false;
                        result.push((compact ? '' : indent) + jsesc2(key, options) + ':' + (compact ? '' : ' ') + jsesc2(value, options));
                    });
                    
                    if (isEmpty) {
                        return '{}';
                    }
                    
                    return '{' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + '}';
                }

            }
            
            const regex = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
            
            result = argument.replace(regex, (char, pair, lone, quoteChar, index2, string) => {
                if (pair) {
                    if (options.minimal)
                        return pair;
                    
                    const first = pair.charCodeAt(0);
                    const second = pair.charCodeAt(1);
                    
                    if (options.es6) {
                        const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
                        const hex2 = hexadecimal(codePoint, lowercaseHex);
                        
                        return '\\u{' + hex2 + '}';
                    }
                    
                    return fourHexEscape(hexadecimal(
                        first,
                        lowercaseHex,
                    )) + fourHexEscape(hexadecimal(
                        second,
                        lowercaseHex,
                    ));
                }
                
                if (lone) {
                    return fourHexEscape(hexadecimal(
                        lone.charCodeAt(0),
                        lowercaseHex,
                    ));
                }
                
                if (char == '\0' && !json && !regexDigit.test(string.charAt(index2 + 1))) {
                    return '\\0';
                }
                
                if (quoteChar) {
                    if (quoteChar == quote || options.escapeEverything) {
                        return '\\' + quoteChar;
                    }
                    
                    return quoteChar;
                }
                
                if (regexSingleEscape.test(char)) {
                    return singleEscapes[char];
                }
                
                if (options.minimal && !regexWhitespace.test(char)) {
                    return char;
                }
                
                const hex = hexadecimal(char.charCodeAt(0), lowercaseHex);
                
                if (json || hex.length > 2) {
                    return fourHexEscape(hex);
                }
                
                return '\\x' + ('00' + hex).slice(-2);
            });
            
            if (quote == '`') {
                result = result.replace(/\$\{/g, '\\${');
            }
            
            if (options.isScriptContext) {
                result = result
                    .replace(/<\/(script|style)/gi, '<\\/$1')
                    .replace(/<!--/g, json ? '\\u003C!--' : '\\x3C!--');
            }
            
            if (options.wrap) {
                result = quote + result + quote;
            }
            
            return result;
        };
        
        jsesc2.version = '3.0.2';
        module.exports = jsesc2;
    },
});

// ../babel-babel/packages/babel-types/lib/index.js
var lib_exports = {};

__export(lib_exports, {
    ACCESSOR_TYPES: () => ACCESSOR_TYPES,
    ALIAS_KEYS: () => ALIAS_KEYS,
    ASSIGNMENT_OPERATORS: () => ASSIGNMENT_OPERATORS,
    AnyTypeAnnotation: () => AnyTypeAnnotation,
    ArgumentPlaceholder: () => ArgumentPlaceholder,
    ArrayExpression: () => ArrayExpression$1,
    ArrayPattern: () => ArrayPattern$1,
    ArrayTypeAnnotation: () => ArrayTypeAnnotation,
    ArrowFunctionExpression: () => ArrowFunctionExpression$1,
    AssignmentExpression: () => AssignmentExpression$1,
    AssignmentPattern: () => AssignmentPattern$1,
    AwaitExpression: () => AwaitExpression$1,
    BINARY_OPERATORS: () => BINARY_OPERATORS,
    BINARY_TYPES: () => BINARY_TYPES,
    BLOCKPARENT_TYPES: () => BLOCKPARENT_TYPES,
    BLOCK_TYPES: () => BLOCK_TYPES,
    BOOLEAN_BINARY_OPERATORS: () => BOOLEAN_BINARY_OPERATORS,
    BOOLEAN_NUMBER_BINARY_OPERATORS: () => BOOLEAN_NUMBER_BINARY_OPERATORS,
    BOOLEAN_UNARY_OPERATORS: () => BOOLEAN_UNARY_OPERATORS,
    BUILDER_KEYS: () => BUILDER_KEYS,
    BigIntLiteral: () => BigIntLiteral$1,
    BinaryExpression: () => BinaryExpression$1,
    BindExpression: () => BindExpression,
    BlockStatement: () => BlockStatement$1,
    BooleanLiteral: () => BooleanLiteral$1,
    BooleanLiteralTypeAnnotation: () => BooleanLiteralTypeAnnotation,
    BooleanTypeAnnotation: () => BooleanTypeAnnotation,
    BreakStatement: () => BreakStatement$1,
    CLASS_TYPES: () => CLASS_TYPES,
    COMMENT_KEYS: () => COMMENT_KEYS,
    COMPARISON_BINARY_OPERATORS: () => COMPARISON_BINARY_OPERATORS,
    COMPLETIONSTATEMENT_TYPES: () => COMPLETIONSTATEMENT_TYPES,
    CONDITIONAL_TYPES: () => CONDITIONAL_TYPES,
    CallExpression: () => CallExpression$1,
    CatchClause: () => CatchClause$1,
    ClassAccessorProperty: () => ClassAccessorProperty$1,
    ClassBody: () => ClassBody,
    ClassDeclaration: () => ClassDeclaration$1,
    ClassExpression: () => ClassExpression$1,
    ClassImplements: () => ClassImplements,
    ClassMethod: () => ClassMethod$1,
    ClassPrivateMethod: () => ClassPrivateMethod$1,
    ClassPrivateProperty: () => ClassPrivateProperty$1,
    ClassProperty: () => ClassProperty$1,
    ConditionalExpression: () => ConditionalExpression$1,
    ContinueStatement: () => ContinueStatement$1,
    DECLARATION_TYPES: () => DECLARATION_TYPES,
    DEPRECATED_ALIASES: () => DEPRECATED_ALIASES,
    DEPRECATED_KEYS: () => DEPRECATED_KEYS,
    DebuggerStatement: () => DebuggerStatement$1,
    DeclareClass: () => DeclareClass,
    DeclareExportAllDeclaration: () => DeclareExportAllDeclaration,
    DeclareExportDeclaration: () => DeclareExportDeclaration,
    DeclareFunction: () => DeclareFunction,
    DeclareInterface: () => DeclareInterface,
    DeclareModule: () => DeclareModule,
    DeclareModuleExports: () => DeclareModuleExports,
    DeclareOpaqueType: () => DeclareOpaqueType,
    DeclareTypeAlias: () => DeclareTypeAlias,
    DeclareVariable: () => DeclareVariable,
    DeclaredPredicate: () => DeclaredPredicate,
    Decorator: () => Decorator$1,
    Directive: () => Directive$1,
    DirectiveLiteral: () => DirectiveLiteral$1,
    DoExpression: () => DoExpression,
    DoWhileStatement: () => DoWhileStatement$1,
    ENUMBODY_TYPES: () => ENUMBODY_TYPES,
    ENUMMEMBER_TYPES: () => ENUMMEMBER_TYPES,
    EQUALITY_BINARY_OPERATORS: () => EQUALITY_BINARY_OPERATORS,
    EXPORTDECLARATION_TYPES: () => EXPORTDECLARATION_TYPES,
    EXPRESSIONWRAPPER_TYPES: () => EXPRESSIONWRAPPER_TYPES,
    EXPRESSION_TYPES: () => EXPRESSION_TYPES,
    EmptyStatement: () => EmptyStatement$1,
    EmptyTypeAnnotation: () => EmptyTypeAnnotation,
    EnumBooleanBody: () => EnumBooleanBody,
    EnumBooleanMember: () => EnumBooleanMember,
    EnumDeclaration: () => EnumDeclaration,
    EnumDefaultedMember: () => EnumDefaultedMember,
    EnumNumberBody: () => EnumNumberBody,
    EnumNumberMember: () => EnumNumberMember,
    EnumStringBody: () => EnumStringBody,
    EnumStringMember: () => EnumStringMember,
    EnumSymbolBody: () => EnumSymbolBody,
    ExistsTypeAnnotation: () => ExistsTypeAnnotation,
    ExportAllDeclaration: () => ExportAllDeclaration$1,
    ExportDefaultDeclaration: () => ExportDefaultDeclaration$1,
    ExportDefaultSpecifier: () => ExportDefaultSpecifier$1,
    ExportNamedDeclaration: () => ExportNamedDeclaration$1,
    ExportNamespaceSpecifier: () => ExportNamespaceSpecifier$1,
    ExportSpecifier: () => ExportSpecifier$1,
    ExpressionStatement: () => ExpressionStatement$1,
    FLATTENABLE_KEYS: () => FLATTENABLE_KEYS,
    FLIPPED_ALIAS_KEYS: () => FLIPPED_ALIAS_KEYS,
    FLOWBASEANNOTATION_TYPES: () => FLOWBASEANNOTATION_TYPES,
    FLOWDECLARATION_TYPES: () => FLOWDECLARATION_TYPES,
    FLOWPREDICATE_TYPES: () => FLOWPREDICATE_TYPES,
    FLOWTYPE_TYPES: () => FLOWTYPE_TYPES,
    FLOW_TYPES: () => FLOW_TYPES,
    FORXSTATEMENT_TYPES: () => FORXSTATEMENT_TYPES,
    FOR_INIT_KEYS: () => FOR_INIT_KEYS,
    FOR_TYPES: () => FOR_TYPES,
    FUNCTIONPARAMETER_TYPES: () => FUNCTIONPARAMETER_TYPES,
    FUNCTIONPARENT_TYPES: () => FUNCTIONPARENT_TYPES,
    FUNCTION_TYPES: () => FUNCTION_TYPES,
    File: () => File,
    ForInStatement: () => ForInStatement$1,
    ForOfStatement: () => ForOfStatement$1,
    ForStatement: () => ForStatement$1,
    FunctionDeclaration: () => FunctionDeclaration$1,
    FunctionExpression: () => FunctionExpression$1,
    FunctionTypeAnnotation: () => FunctionTypeAnnotation,
    FunctionTypeParam: () => FunctionTypeParam,
    GenericTypeAnnotation: () => GenericTypeAnnotation,
    IMMUTABLE_TYPES: () => IMMUTABLE_TYPES,
    IMPORTOREXPORTDECLARATION_TYPES: () => IMPORTOREXPORTDECLARATION_TYPES,
    INHERIT_KEYS: () => INHERIT_KEYS,
    Identifier: () => Identifier$1,
    IfStatement: () => IfStatement$1,
    Import: () => Import,
    ImportAttribute: () => ImportAttribute$1,
    ImportDeclaration: () => ImportDeclaration$1,
    ImportDefaultSpecifier: () => ImportDefaultSpecifier,
    ImportExpression: () => ImportExpression$1,
    ImportNamespaceSpecifier: () => ImportNamespaceSpecifier,
    ImportSpecifier: () => ImportSpecifier,
    IndexedAccessType: () => IndexedAccessType,
    InferredPredicate: () => InferredPredicate,
    InterfaceDeclaration: () => InterfaceDeclaration,
    InterfaceExtends: () => InterfaceExtends,
    InterfaceTypeAnnotation: () => InterfaceTypeAnnotation,
    InterpreterDirective: () => InterpreterDirective$1,
    IntersectionTypeAnnotation: () => IntersectionTypeAnnotation,
    JSXAttribute: () => JSXAttribute$1,
    JSXClosingElement: () => JSXClosingElement$1,
    JSXClosingFragment: () => JSXClosingFragment$1,
    JSXElement: () => JSXElement$1,
    JSXEmptyExpression: () => JSXEmptyExpression$1,
    JSXExpressionContainer: () => JSXExpressionContainer$1,
    JSXFragment: () => JSXFragment$1,
    JSXIdentifier: () => JSXIdentifier$1,
    JSXMemberExpression: () => JSXMemberExpression$1,
    JSXNamespacedName: () => JSXNamespacedName,
    JSXOpeningElement: () => JSXOpeningElement$1,
    JSXOpeningFragment: () => JSXOpeningFragment$1,
    JSXSpreadAttribute: () => JSXSpreadAttribute$1,
    JSXSpreadChild: () => JSXSpreadChild,
    JSXText: () => JSXText$1,
    JSX_TYPES: () => JSX_TYPES,
    LITERAL_TYPES: () => LITERAL_TYPES,
    LOGICAL_OPERATORS: () => LOGICAL_OPERATORS,
    LOOP_TYPES: () => LOOP_TYPES,
    LVAL_TYPES: () => LVAL_TYPES,
    LabeledStatement: () => LabeledStatement$1,
    LogicalExpression: () => LogicalExpression$1,
    METHOD_TYPES: () => METHOD_TYPES,
    MISCELLANEOUS_TYPES: () => MISCELLANEOUS_TYPES,
    MODULEDECLARATION_TYPES: () => MODULEDECLARATION_TYPES,
    MODULESPECIFIER_TYPES: () => MODULESPECIFIER_TYPES,
    MemberExpression: () => MemberExpression$1,
    MetaProperty: () => MetaProperty$1,
    MixedTypeAnnotation: () => MixedTypeAnnotation,
    ModuleExpression: () => ModuleExpression,
    NODE_FIELDS: () => NODE_FIELDS$1,
    NODE_PARENT_VALIDATIONS: () => NODE_PARENT_VALIDATIONS,
    NODE_UNION_SHAPES__PRIVATE: () => NODE_UNION_SHAPES__PRIVATE,
    NUMBER_BINARY_OPERATORS: () => NUMBER_BINARY_OPERATORS,
    NUMBER_UNARY_OPERATORS: () => NUMBER_UNARY_OPERATORS,
    NewExpression: () => NewExpression$1,
    NullLiteral: () => NullLiteral$1,
    NullLiteralTypeAnnotation: () => NullLiteralTypeAnnotation,
    NullableTypeAnnotation: () => NullableTypeAnnotation,
    NumberLiteralTypeAnnotation: () => NumberLiteralTypeAnnotation,
    NumberTypeAnnotation: () => NumberTypeAnnotation,
    NumericLiteral: () => NumericLiteral$1,
    OBJECTMEMBER_TYPES: () => OBJECTMEMBER_TYPES,
    ObjectExpression: () => ObjectExpression$1,
    ObjectMethod: () => ObjectMethod$1,
    ObjectPattern: () => ObjectPattern$1,
    ObjectProperty: () => ObjectProperty$1,
    ObjectTypeAnnotation: () => ObjectTypeAnnotation,
    ObjectTypeCallProperty: () => ObjectTypeCallProperty,
    ObjectTypeIndexer: () => ObjectTypeIndexer,
    ObjectTypeInternalSlot: () => ObjectTypeInternalSlot,
    ObjectTypeProperty: () => ObjectTypeProperty,
    ObjectTypeSpreadProperty: () => ObjectTypeSpreadProperty,
    OpaqueType: () => OpaqueType,
    OptionalCallExpression: () => OptionalCallExpression$1,
    OptionalIndexedAccessType: () => OptionalIndexedAccessType,
    OptionalMemberExpression: () => OptionalMemberExpression$1,
    PATTERNLIKE_TYPES: () => PATTERNLIKE_TYPES,
    PATTERN_TYPES: () => PATTERN_TYPES,
    PLACEHOLDERS: () => PLACEHOLDERS,
    PLACEHOLDERS_ALIAS: () => PLACEHOLDERS_ALIAS,
    PLACEHOLDERS_FLIPPED_ALIAS: () => PLACEHOLDERS_FLIPPED_ALIAS,
    PRIVATE_TYPES: () => PRIVATE_TYPES,
    PROPERTY_TYPES: () => PROPERTY_TYPES,
    PUREISH_TYPES: () => PUREISH_TYPES,
    ParenthesizedExpression: () => ParenthesizedExpression$1,
    PipelineBareFunction: () => PipelineBareFunction,
    PipelinePrimaryTopicReference: () => PipelinePrimaryTopicReference,
    PipelineTopicExpression: () => PipelineTopicExpression,
    Placeholder: () => Placeholder,
    PrivateName: () => PrivateName$1,
    Program: () => Program$1,
    QualifiedTypeIdentifier: () => QualifiedTypeIdentifier,
    RegExpLiteral: () => RegExpLiteral$1,
    RestElement: () => RestElement$1,
    ReturnStatement: () => ReturnStatement$1,
    SCOPABLE_TYPES: () => SCOPABLE_TYPES,
    STANDARDIZED_TYPES: () => STANDARDIZED_TYPES,
    STATEMENT_OR_BLOCK_KEYS: () => STATEMENT_OR_BLOCK_KEYS,
    STATEMENT_TYPES: () => STATEMENT_TYPES,
    STRING_UNARY_OPERATORS: () => STRING_UNARY_OPERATORS,
    SequenceExpression: () => SequenceExpression$1,
    SpreadElement: () => SpreadElement$1,
    StaticBlock: () => StaticBlock$1,
    StringLiteral: () => StringLiteral$1,
    StringLiteralTypeAnnotation: () => StringLiteralTypeAnnotation,
    StringTypeAnnotation: () => StringTypeAnnotation,
    Super: () => Super$1,
    SwitchCase: () => SwitchCase,
    SwitchStatement: () => SwitchStatement$1,
    SymbolTypeAnnotation: () => SymbolTypeAnnotation,
    TERMINATORLESS_TYPES: () => TERMINATORLESS_TYPES,
    TSAnyKeyword: () => TSAnyKeyword$1,
    TSArrayType: () => TSArrayType$1,
    TSAsExpression: () => TSAsExpression$1,
    TSBASETYPE_TYPES: () => TSBASETYPE_TYPES,
    TSBigIntKeyword: () => TSBigIntKeyword$1,
    TSBooleanKeyword: () => TSBooleanKeyword$1,
    TSCallSignatureDeclaration: () => TSCallSignatureDeclaration$1,
    TSClassImplements: () => TSClassImplements$1,
    TSConditionalType: () => TSConditionalType$1,
    TSConstructSignatureDeclaration: () => TSConstructSignatureDeclaration$1,
    TSConstructorType: () => TSConstructorType$1,
    TSDeclareFunction: () => TSDeclareFunction$1,
    TSDeclareMethod: () => TSDeclareMethod$1,
    TSENTITYNAME_TYPES: () => TSENTITYNAME_TYPES,
    TSEnumBody: () => TSEnumBody,
    TSEnumDeclaration: () => TSEnumDeclaration$1,
    TSEnumMember: () => TSEnumMember$1,
    TSExportAssignment: () => TSExportAssignment$1,
    TSExternalModuleReference: () => TSExternalModuleReference$1,
    TSFunctionType: () => TSFunctionType$1,
    TSImportEqualsDeclaration: () => TSImportEqualsDeclaration$1,
    TSImportType: () => TSImportType$1,
    TSIndexSignature: () => TSIndexSignature$1,
    TSIndexedAccessType: () => TSIndexedAccessType$1,
    TSInferType: () => TSInferType$1,
    TSInstantiationExpression: () => TSInstantiationExpression$1,
    TSInterfaceBody: () => TSInterfaceBody$1,
    TSInterfaceDeclaration: () => TSInterfaceDeclaration$1,
    TSInterfaceHeritage: () => TSInterfaceHeritage$1,
    TSIntersectionType: () => TSIntersectionType$1,
    TSIntrinsicKeyword: () => TSIntrinsicKeyword,
    TSLiteralType: () => TSLiteralType$1,
    TSMappedType: () => TSMappedType$1,
    TSMethodSignature: () => TSMethodSignature$1,
    TSModuleBlock: () => TSModuleBlock$1,
    TSModuleDeclaration: () => TSModuleDeclaration$1,
    TSNamedTupleMember: () => TSNamedTupleMember$1,
    TSNamespaceExportDeclaration: () => TSNamespaceExportDeclaration,
    TSNeverKeyword: () => TSNeverKeyword$1,
    TSNonNullExpression: () => TSNonNullExpression$1,
    TSNullKeyword: () => TSNullKeyword$1,
    TSNumberKeyword: () => TSNumberKeyword$1,
    TSObjectKeyword: () => TSObjectKeyword$1,
    TSOptionalType: () => TSOptionalType$1,
    TSParameterProperty: () => TSParameterProperty$1,
    TSParenthesizedType: () => TSParenthesizedType$1,
    TSPropertySignature: () => TSPropertySignature$1,
    TSQualifiedName: () => TSQualifiedName$1,
    TSRestType: () => TSRestType$1,
    TSSatisfiesExpression: () => TSSatisfiesExpression$1,
    TSStringKeyword: () => TSStringKeyword$1,
    TSSymbolKeyword: () => TSSymbolKeyword$1,
    TSTYPEELEMENT_TYPES: () => TSTYPEELEMENT_TYPES,
    TSTYPE_TYPES: () => TSTYPE_TYPES,
    TSTemplateLiteralType: () => TSTemplateLiteralType$1,
    TSThisType: () => TSThisType$1,
    TSTupleType: () => TSTupleType$1,
    TSTypeAliasDeclaration: () => TSTypeAliasDeclaration$1,
    TSTypeAnnotation: () => TSTypeAnnotation$1,
    TSTypeAssertion: () => TSTypeAssertion$1,
    TSTypeLiteral: () => TSTypeLiteral$1,
    TSTypeOperator: () => TSTypeOperator$1,
    TSTypeParameter: () => TSTypeParameter$1,
    TSTypeParameterDeclaration: () => TSTypeParameterDeclaration$1,
    TSTypeParameterInstantiation: () => TSTypeParameterInstantiation$1,
    TSTypePredicate: () => TSTypePredicate$1,
    TSTypeQuery: () => TSTypeQuery$1,
    TSTypeReference: () => TSTypeReference$1,
    TSUndefinedKeyword: () => TSUndefinedKeyword$1,
    TSUnionType: () => TSUnionType$1,
    TSUnknownKeyword: () => TSUnknownKeyword$1,
    TSVoidKeyword: () => TSVoidKeyword$1,
    TYPES: () => TYPES$4,
    TYPESCRIPT_TYPES: () => TYPESCRIPT_TYPES,
    TaggedTemplateExpression: () => TaggedTemplateExpression$1,
    TemplateElement: () => TemplateElement,
    TemplateLiteral: () => TemplateLiteral$1,
    ThisExpression: () => ThisExpression$1,
    ThisTypeAnnotation: () => ThisTypeAnnotation,
    ThrowStatement: () => ThrowStatement$1,
    TopicReference: () => TopicReference,
    TryStatement: () => TryStatement$1,
    TupleTypeAnnotation: () => TupleTypeAnnotation,
    TypeAlias: () => TypeAlias,
    TypeAnnotation: () => TypeAnnotation,
    TypeCastExpression: () => TypeCastExpression,
    TypeParameter: () => TypeParameter,
    TypeParameterDeclaration: () => TypeParameterDeclaration,
    TypeParameterInstantiation: () => TypeParameterInstantiation,
    TypeofTypeAnnotation: () => TypeofTypeAnnotation,
    UNARYLIKE_TYPES: () => UNARYLIKE_TYPES,
    UNARY_OPERATORS: () => UNARY_OPERATORS,
    UPDATE_OPERATORS: () => UPDATE_OPERATORS,
    USERWHITESPACABLE_TYPES: () => USERWHITESPACABLE_TYPES,
    UnaryExpression: () => UnaryExpression$1,
    UnionTypeAnnotation: () => UnionTypeAnnotation,
    UpdateExpression: () => UpdateExpression$1,
    V8IntrinsicIdentifier: () => V8IntrinsicIdentifier,
    VISITOR_KEYS: () => VISITOR_KEYS,
    VariableDeclaration: () => VariableDeclaration$1,
    VariableDeclarator: () => VariableDeclarator,
    Variance: () => Variance,
    VoidPattern: () => VoidPattern$1,
    VoidTypeAnnotation: () => VoidTypeAnnotation,
    WHILE_TYPES: () => WHILE_TYPES,
    WhileStatement: () => WhileStatement$1,
    WithStatement: () => WithStatement$1,
    YieldExpression: () => YieldExpression$1,
    __internal__deprecationWarning: () => deprecationWarning,
    addComment: () => addComment,
    addComments: () => addComments,
    anyTypeAnnotation: () => anyTypeAnnotation,
    appendToMemberExpression: () => appendToMemberExpression,
    argumentPlaceholder: () => argumentPlaceholder,
    arrayExpression: () => arrayExpression$3,
    arrayPattern: () => arrayPattern,
    arrayTypeAnnotation: () => arrayTypeAnnotation,
    arrowFunctionExpression: () => arrowFunctionExpression,
    assertAccessor: () => assertAccessor,
    assertAnyTypeAnnotation: () => assertAnyTypeAnnotation,
    assertArgumentPlaceholder: () => assertArgumentPlaceholder,
    assertArrayExpression: () => assertArrayExpression,
    assertArrayPattern: () => assertArrayPattern,
    assertArrayTypeAnnotation: () => assertArrayTypeAnnotation,
    assertArrowFunctionExpression: () => assertArrowFunctionExpression,
    assertAssignmentExpression: () => assertAssignmentExpression,
    assertAssignmentPattern: () => assertAssignmentPattern,
    assertAwaitExpression: () => assertAwaitExpression,
    assertBigIntLiteral: () => assertBigIntLiteral,
    assertBinary: () => assertBinary,
    assertBinaryExpression: () => assertBinaryExpression,
    assertBindExpression: () => assertBindExpression,
    assertBlock: () => assertBlock,
    assertBlockParent: () => assertBlockParent,
    assertBlockStatement: () => assertBlockStatement,
    assertBooleanLiteral: () => assertBooleanLiteral,
    assertBooleanLiteralTypeAnnotation: () => assertBooleanLiteralTypeAnnotation,
    assertBooleanTypeAnnotation: () => assertBooleanTypeAnnotation,
    assertBreakStatement: () => assertBreakStatement,
    assertCallExpression: () => assertCallExpression,
    assertCatchClause: () => assertCatchClause,
    assertClass: () => assertClass,
    assertClassAccessorProperty: () => assertClassAccessorProperty,
    assertClassBody: () => assertClassBody,
    assertClassDeclaration: () => assertClassDeclaration,
    assertClassExpression: () => assertClassExpression,
    assertClassImplements: () => assertClassImplements,
    assertClassMethod: () => assertClassMethod,
    assertClassPrivateMethod: () => assertClassPrivateMethod,
    assertClassPrivateProperty: () => assertClassPrivateProperty,
    assertClassProperty: () => assertClassProperty,
    assertCompletionStatement: () => assertCompletionStatement,
    assertConditional: () => assertConditional,
    assertConditionalExpression: () => assertConditionalExpression,
    assertContinueStatement: () => assertContinueStatement,
    assertDebuggerStatement: () => assertDebuggerStatement,
    assertDeclaration: () => assertDeclaration,
    assertDeclareClass: () => assertDeclareClass,
    assertDeclareExportAllDeclaration: () => assertDeclareExportAllDeclaration,
    assertDeclareExportDeclaration: () => assertDeclareExportDeclaration,
    assertDeclareFunction: () => assertDeclareFunction,
    assertDeclareInterface: () => assertDeclareInterface,
    assertDeclareModule: () => assertDeclareModule,
    assertDeclareModuleExports: () => assertDeclareModuleExports,
    assertDeclareOpaqueType: () => assertDeclareOpaqueType,
    assertDeclareTypeAlias: () => assertDeclareTypeAlias,
    assertDeclareVariable: () => assertDeclareVariable,
    assertDeclaredPredicate: () => assertDeclaredPredicate,
    assertDecorator: () => assertDecorator,
    assertDirective: () => assertDirective,
    assertDirectiveLiteral: () => assertDirectiveLiteral,
    assertDoExpression: () => assertDoExpression,
    assertDoWhileStatement: () => assertDoWhileStatement,
    assertEmptyStatement: () => assertEmptyStatement,
    assertEmptyTypeAnnotation: () => assertEmptyTypeAnnotation,
    assertEnumBody: () => assertEnumBody,
    assertEnumBooleanBody: () => assertEnumBooleanBody,
    assertEnumBooleanMember: () => assertEnumBooleanMember,
    assertEnumDeclaration: () => assertEnumDeclaration,
    assertEnumDefaultedMember: () => assertEnumDefaultedMember,
    assertEnumMember: () => assertEnumMember,
    assertEnumNumberBody: () => assertEnumNumberBody,
    assertEnumNumberMember: () => assertEnumNumberMember,
    assertEnumStringBody: () => assertEnumStringBody,
    assertEnumStringMember: () => assertEnumStringMember,
    assertEnumSymbolBody: () => assertEnumSymbolBody,
    assertExistsTypeAnnotation: () => assertExistsTypeAnnotation,
    assertExportAllDeclaration: () => assertExportAllDeclaration,
    assertExportDeclaration: () => assertExportDeclaration,
    assertExportDefaultDeclaration: () => assertExportDefaultDeclaration,
    assertExportDefaultSpecifier: () => assertExportDefaultSpecifier,
    assertExportNamedDeclaration: () => assertExportNamedDeclaration,
    assertExportNamespaceSpecifier: () => assertExportNamespaceSpecifier,
    assertExportSpecifier: () => assertExportSpecifier,
    assertExpression: () => assertExpression,
    assertExpressionStatement: () => assertExpressionStatement,
    assertExpressionWrapper: () => assertExpressionWrapper,
    assertFile: () => assertFile,
    assertFlow: () => assertFlow,
    assertFlowBaseAnnotation: () => assertFlowBaseAnnotation,
    assertFlowDeclaration: () => assertFlowDeclaration,
    assertFlowPredicate: () => assertFlowPredicate,
    assertFlowType: () => assertFlowType,
    assertFor: () => assertFor,
    assertForInStatement: () => assertForInStatement,
    assertForOfStatement: () => assertForOfStatement,
    assertForStatement: () => assertForStatement,
    assertForXStatement: () => assertForXStatement,
    assertFunction: () => assertFunction,
    assertFunctionDeclaration: () => assertFunctionDeclaration,
    assertFunctionExpression: () => assertFunctionExpression,
    assertFunctionParameter: () => assertFunctionParameter,
    assertFunctionParent: () => assertFunctionParent,
    assertFunctionTypeAnnotation: () => assertFunctionTypeAnnotation,
    assertFunctionTypeParam: () => assertFunctionTypeParam,
    assertGenericTypeAnnotation: () => assertGenericTypeAnnotation,
    assertIdentifier: () => assertIdentifier,
    assertIfStatement: () => assertIfStatement,
    assertImmutable: () => assertImmutable,
    assertImport: () => assertImport,
    assertImportAttribute: () => assertImportAttribute,
    assertImportDeclaration: () => assertImportDeclaration,
    assertImportDefaultSpecifier: () => assertImportDefaultSpecifier,
    assertImportExpression: () => assertImportExpression,
    assertImportNamespaceSpecifier: () => assertImportNamespaceSpecifier,
    assertImportOrExportDeclaration: () => assertImportOrExportDeclaration,
    assertImportSpecifier: () => assertImportSpecifier,
    assertIndexedAccessType: () => assertIndexedAccessType,
    assertInferredPredicate: () => assertInferredPredicate,
    assertInterfaceDeclaration: () => assertInterfaceDeclaration,
    assertInterfaceExtends: () => assertInterfaceExtends,
    assertInterfaceTypeAnnotation: () => assertInterfaceTypeAnnotation,
    assertInterpreterDirective: () => assertInterpreterDirective,
    assertIntersectionTypeAnnotation: () => assertIntersectionTypeAnnotation,
    assertJSX: () => assertJSX,
    assertJSXAttribute: () => assertJSXAttribute,
    assertJSXClosingElement: () => assertJSXClosingElement,
    assertJSXClosingFragment: () => assertJSXClosingFragment,
    assertJSXElement: () => assertJSXElement,
    assertJSXEmptyExpression: () => assertJSXEmptyExpression,
    assertJSXExpressionContainer: () => assertJSXExpressionContainer,
    assertJSXFragment: () => assertJSXFragment,
    assertJSXIdentifier: () => assertJSXIdentifier,
    assertJSXMemberExpression: () => assertJSXMemberExpression,
    assertJSXNamespacedName: () => assertJSXNamespacedName,
    assertJSXOpeningElement: () => assertJSXOpeningElement,
    assertJSXOpeningFragment: () => assertJSXOpeningFragment,
    assertJSXSpreadAttribute: () => assertJSXSpreadAttribute,
    assertJSXSpreadChild: () => assertJSXSpreadChild,
    assertJSXText: () => assertJSXText,
    assertLVal: () => assertLVal,
    assertLabeledStatement: () => assertLabeledStatement,
    assertLiteral: () => assertLiteral,
    assertLogicalExpression: () => assertLogicalExpression,
    assertLoop: () => assertLoop,
    assertMemberExpression: () => assertMemberExpression,
    assertMetaProperty: () => assertMetaProperty,
    assertMethod: () => assertMethod,
    assertMiscellaneous: () => assertMiscellaneous,
    assertMixedTypeAnnotation: () => assertMixedTypeAnnotation,
    assertModuleDeclaration: () => assertModuleDeclaration,
    assertModuleExpression: () => assertModuleExpression,
    assertModuleSpecifier: () => assertModuleSpecifier,
    assertNewExpression: () => assertNewExpression,
    assertNode: () => assertNode,
    assertNullLiteral: () => assertNullLiteral,
    assertNullLiteralTypeAnnotation: () => assertNullLiteralTypeAnnotation,
    assertNullableTypeAnnotation: () => assertNullableTypeAnnotation,
    assertNumberLiteral: () => assertNumberLiteral,
    assertNumberLiteralTypeAnnotation: () => assertNumberLiteralTypeAnnotation,
    assertNumberTypeAnnotation: () => assertNumberTypeAnnotation,
    assertNumericLiteral: () => assertNumericLiteral,
    assertObjectExpression: () => assertObjectExpression,
    assertObjectMember: () => assertObjectMember,
    assertObjectMethod: () => assertObjectMethod,
    assertObjectPattern: () => assertObjectPattern,
    assertObjectProperty: () => assertObjectProperty,
    assertObjectTypeAnnotation: () => assertObjectTypeAnnotation,
    assertObjectTypeCallProperty: () => assertObjectTypeCallProperty,
    assertObjectTypeIndexer: () => assertObjectTypeIndexer,
    assertObjectTypeInternalSlot: () => assertObjectTypeInternalSlot,
    assertObjectTypeProperty: () => assertObjectTypeProperty,
    assertObjectTypeSpreadProperty: () => assertObjectTypeSpreadProperty,
    assertOpaqueType: () => assertOpaqueType,
    assertOptionalCallExpression: () => assertOptionalCallExpression,
    assertOptionalIndexedAccessType: () => assertOptionalIndexedAccessType,
    assertOptionalMemberExpression: () => assertOptionalMemberExpression,
    assertParenthesizedExpression: () => assertParenthesizedExpression,
    assertPattern: () => assertPattern,
    assertPatternLike: () => assertPatternLike,
    assertPipelineBareFunction: () => assertPipelineBareFunction,
    assertPipelinePrimaryTopicReference: () => assertPipelinePrimaryTopicReference,
    assertPipelineTopicExpression: () => assertPipelineTopicExpression,
    assertPlaceholder: () => assertPlaceholder,
    assertPrivate: () => assertPrivate,
    assertPrivateName: () => assertPrivateName,
    assertProgram: () => assertProgram,
    assertProperty: () => assertProperty,
    assertPureish: () => assertPureish,
    assertQualifiedTypeIdentifier: () => assertQualifiedTypeIdentifier,
    assertRegExpLiteral: () => assertRegExpLiteral,
    assertRegexLiteral: () => assertRegexLiteral,
    assertRestElement: () => assertRestElement,
    assertRestProperty: () => assertRestProperty,
    assertReturnStatement: () => assertReturnStatement,
    assertScopable: () => assertScopable,
    assertSequenceExpression: () => assertSequenceExpression,
    assertSpreadElement: () => assertSpreadElement,
    assertSpreadProperty: () => assertSpreadProperty,
    assertStandardized: () => assertStandardized,
    assertStatement: () => assertStatement,
    assertStaticBlock: () => assertStaticBlock,
    assertStringLiteral: () => assertStringLiteral,
    assertStringLiteralTypeAnnotation: () => assertStringLiteralTypeAnnotation,
    assertStringTypeAnnotation: () => assertStringTypeAnnotation,
    assertSuper: () => assertSuper,
    assertSwitchCase: () => assertSwitchCase,
    assertSwitchStatement: () => assertSwitchStatement,
    assertSymbolTypeAnnotation: () => assertSymbolTypeAnnotation,
    assertTSAnyKeyword: () => assertTSAnyKeyword,
    assertTSArrayType: () => assertTSArrayType,
    assertTSAsExpression: () => assertTSAsExpression,
    assertTSBaseType: () => assertTSBaseType,
    assertTSBigIntKeyword: () => assertTSBigIntKeyword,
    assertTSBooleanKeyword: () => assertTSBooleanKeyword,
    assertTSCallSignatureDeclaration: () => assertTSCallSignatureDeclaration,
    assertTSClassImplements: () => assertTSClassImplements,
    assertTSConditionalType: () => assertTSConditionalType,
    assertTSConstructSignatureDeclaration: () => assertTSConstructSignatureDeclaration,
    assertTSConstructorType: () => assertTSConstructorType,
    assertTSDeclareFunction: () => assertTSDeclareFunction,
    assertTSDeclareMethod: () => assertTSDeclareMethod,
    assertTSEntityName: () => assertTSEntityName,
    assertTSEnumBody: () => assertTSEnumBody,
    assertTSEnumDeclaration: () => assertTSEnumDeclaration,
    assertTSEnumMember: () => assertTSEnumMember,
    assertTSExportAssignment: () => assertTSExportAssignment,
    assertTSExternalModuleReference: () => assertTSExternalModuleReference,
    assertTSFunctionType: () => assertTSFunctionType,
    assertTSImportEqualsDeclaration: () => assertTSImportEqualsDeclaration,
    assertTSImportType: () => assertTSImportType,
    assertTSIndexSignature: () => assertTSIndexSignature,
    assertTSIndexedAccessType: () => assertTSIndexedAccessType,
    assertTSInferType: () => assertTSInferType,
    assertTSInstantiationExpression: () => assertTSInstantiationExpression,
    assertTSInterfaceBody: () => assertTSInterfaceBody,
    assertTSInterfaceDeclaration: () => assertTSInterfaceDeclaration,
    assertTSInterfaceHeritage: () => assertTSInterfaceHeritage,
    assertTSIntersectionType: () => assertTSIntersectionType,
    assertTSIntrinsicKeyword: () => assertTSIntrinsicKeyword,
    assertTSLiteralType: () => assertTSLiteralType,
    assertTSMappedType: () => assertTSMappedType,
    assertTSMethodSignature: () => assertTSMethodSignature,
    assertTSModuleBlock: () => assertTSModuleBlock,
    assertTSModuleDeclaration: () => assertTSModuleDeclaration,
    assertTSNamedTupleMember: () => assertTSNamedTupleMember,
    assertTSNamespaceExportDeclaration: () => assertTSNamespaceExportDeclaration,
    assertTSNeverKeyword: () => assertTSNeverKeyword,
    assertTSNonNullExpression: () => assertTSNonNullExpression,
    assertTSNullKeyword: () => assertTSNullKeyword,
    assertTSNumberKeyword: () => assertTSNumberKeyword,
    assertTSObjectKeyword: () => assertTSObjectKeyword,
    assertTSOptionalType: () => assertTSOptionalType,
    assertTSParameterProperty: () => assertTSParameterProperty,
    assertTSParenthesizedType: () => assertTSParenthesizedType,
    assertTSPropertySignature: () => assertTSPropertySignature,
    assertTSQualifiedName: () => assertTSQualifiedName,
    assertTSRestType: () => assertTSRestType,
    assertTSSatisfiesExpression: () => assertTSSatisfiesExpression,
    assertTSStringKeyword: () => assertTSStringKeyword,
    assertTSSymbolKeyword: () => assertTSSymbolKeyword,
    assertTSTemplateLiteralType: () => assertTSTemplateLiteralType,
    assertTSThisType: () => assertTSThisType,
    assertTSTupleType: () => assertTSTupleType,
    assertTSType: () => assertTSType,
    assertTSTypeAliasDeclaration: () => assertTSTypeAliasDeclaration,
    assertTSTypeAnnotation: () => assertTSTypeAnnotation,
    assertTSTypeAssertion: () => assertTSTypeAssertion,
    assertTSTypeElement: () => assertTSTypeElement,
    assertTSTypeLiteral: () => assertTSTypeLiteral,
    assertTSTypeOperator: () => assertTSTypeOperator,
    assertTSTypeParameter: () => assertTSTypeParameter,
    assertTSTypeParameterDeclaration: () => assertTSTypeParameterDeclaration,
    assertTSTypeParameterInstantiation: () => assertTSTypeParameterInstantiation,
    assertTSTypePredicate: () => assertTSTypePredicate,
    assertTSTypeQuery: () => assertTSTypeQuery,
    assertTSTypeReference: () => assertTSTypeReference,
    assertTSUndefinedKeyword: () => assertTSUndefinedKeyword,
    assertTSUnionType: () => assertTSUnionType,
    assertTSUnknownKeyword: () => assertTSUnknownKeyword,
    assertTSVoidKeyword: () => assertTSVoidKeyword,
    assertTaggedTemplateExpression: () => assertTaggedTemplateExpression,
    assertTemplateElement: () => assertTemplateElement,
    assertTemplateLiteral: () => assertTemplateLiteral,
    assertTerminatorless: () => assertTerminatorless,
    assertThisExpression: () => assertThisExpression,
    assertThisTypeAnnotation: () => assertThisTypeAnnotation,
    assertThrowStatement: () => assertThrowStatement,
    assertTopicReference: () => assertTopicReference,
    assertTryStatement: () => assertTryStatement,
    assertTupleTypeAnnotation: () => assertTupleTypeAnnotation,
    assertTypeAlias: () => assertTypeAlias,
    assertTypeAnnotation: () => assertTypeAnnotation,
    assertTypeCastExpression: () => assertTypeCastExpression,
    assertTypeParameter: () => assertTypeParameter,
    assertTypeParameterDeclaration: () => assertTypeParameterDeclaration,
    assertTypeParameterInstantiation: () => assertTypeParameterInstantiation,
    assertTypeScript: () => assertTypeScript,
    assertTypeofTypeAnnotation: () => assertTypeofTypeAnnotation,
    assertUnaryExpression: () => assertUnaryExpression,
    assertUnaryLike: () => assertUnaryLike,
    assertUnionTypeAnnotation: () => assertUnionTypeAnnotation,
    assertUpdateExpression: () => assertUpdateExpression,
    assertUserWhitespacable: () => assertUserWhitespacable,
    assertV8IntrinsicIdentifier: () => assertV8IntrinsicIdentifier,
    assertVariableDeclaration: () => assertVariableDeclaration,
    assertVariableDeclarator: () => assertVariableDeclarator,
    assertVariance: () => assertVariance,
    assertVoidPattern: () => assertVoidPattern,
    assertVoidTypeAnnotation: () => assertVoidTypeAnnotation,
    assertWhile: () => assertWhile,
    assertWhileStatement: () => assertWhileStatement,
    assertWithStatement: () => assertWithStatement,
    assertYieldExpression: () => assertYieldExpression,
    assignmentExpression: () => assignmentExpression,
    assignmentPattern: () => assignmentPattern,
    awaitExpression: () => awaitExpression,
    bigIntLiteral: () => bigIntLiteral,
    binaryExpression: () => binaryExpression,
    bindExpression: () => bindExpression,
    blockStatement: () => blockStatement$1,
    booleanLiteral: () => booleanLiteral,
    booleanLiteralTypeAnnotation: () => booleanLiteralTypeAnnotation,
    booleanTypeAnnotation: () => booleanTypeAnnotation,
    breakStatement: () => breakStatement,
    buildMatchMemberExpression: () => buildMatchMemberExpression,
    buildUndefinedNode: () => buildUndefinedNode,
    callExpression: () => callExpression,
    catchClause: () => catchClause,
    classAccessorProperty: () => classAccessorProperty,
    classBody: () => classBody,
    classDeclaration: () => classDeclaration,
    classExpression: () => classExpression,
    classImplements: () => classImplements,
    classMethod: () => classMethod$1,
    classPrivateMethod: () => classPrivateMethod$1,
    classPrivateProperty: () => classPrivateProperty,
    classProperty: () => classProperty,
    clone: () => clone,
    cloneDeep: () => cloneDeep,
    cloneDeepWithoutLoc: () => cloneDeepWithoutLoc,
    cloneNode: () => cloneNode,
    cloneWithoutLoc: () => cloneWithoutLoc,
    conditionalExpression: () => conditionalExpression,
    continueStatement: () => continueStatement,
    createFlowUnionType: () => createFlowUnionType,
    createTSUnionType: () => createTSUnionType,
    createTypeAnnotationBasedOnTypeof: () => createTypeAnnotationBasedOnTypeof,
    createUnionTypeAnnotation: () => createFlowUnionType,
    debuggerStatement: () => debuggerStatement,
    declareClass: () => declareClass,
    declareExportAllDeclaration: () => declareExportAllDeclaration,
    declareExportDeclaration: () => declareExportDeclaration,
    declareFunction: () => declareFunction,
    declareInterface: () => declareInterface,
    declareModule: () => declareModule,
    declareModuleExports: () => declareModuleExports,
    declareOpaqueType: () => declareOpaqueType,
    declareTypeAlias: () => declareTypeAlias,
    declareVariable: () => declareVariable,
    declaredPredicate: () => declaredPredicate,
    decorator: () => decorator,
    directive: () => directive$1,
    directiveLiteral: () => directiveLiteral$1,
    doExpression: () => doExpression,
    doWhileStatement: () => doWhileStatement,
    emptyStatement: () => emptyStatement,
    emptyTypeAnnotation: () => emptyTypeAnnotation,
    ensureBlock: () => ensureBlock,
    enumBooleanBody: () => enumBooleanBody,
    enumBooleanMember: () => enumBooleanMember,
    enumDeclaration: () => enumDeclaration,
    enumDefaultedMember: () => enumDefaultedMember,
    enumNumberBody: () => enumNumberBody,
    enumNumberMember: () => enumNumberMember,
    enumStringBody: () => enumStringBody,
    enumStringMember: () => enumStringMember,
    enumSymbolBody: () => enumSymbolBody,
    existsTypeAnnotation: () => existsTypeAnnotation,
    exportAllDeclaration: () => exportAllDeclaration,
    exportDefaultDeclaration: () => exportDefaultDeclaration,
    exportDefaultSpecifier: () => exportDefaultSpecifier,
    exportNamedDeclaration: () => exportNamedDeclaration,
    exportNamespaceSpecifier: () => exportNamespaceSpecifier,
    exportSpecifier: () => exportSpecifier,
    expressionStatement: () => expressionStatement$4,
    file: () => file$1,
    forInStatement: () => forInStatement,
    forOfStatement: () => forOfStatement,
    forStatement: () => forStatement,
    functionDeclaration: () => functionDeclaration,
    functionExpression: () => functionExpression,
    functionTypeAnnotation: () => functionTypeAnnotation,
    functionTypeParam: () => functionTypeParam,
    genericTypeAnnotation: () => genericTypeAnnotation,
    getAssignmentIdentifiers: () => getAssignmentIdentifiers,
    getBindingIdentifiers: () => getBindingIdentifiers,
    getFunctionName: () => getFunctionName,
    getOuterBindingIdentifiers: () => getOuterBindingIdentifiers,
    identifier: () => identifier$2,
    ifStatement: () => ifStatement,
    import: () => _import,
    importAttribute: () => importAttribute,
    importDeclaration: () => importDeclaration,
    importDefaultSpecifier: () => importDefaultSpecifier,
    importExpression: () => importExpression,
    importNamespaceSpecifier: () => importNamespaceSpecifier,
    importSpecifier: () => importSpecifier,
    indexedAccessType: () => indexedAccessType,
    inferredPredicate: () => inferredPredicate,
    inheritInnerComments: () => inheritInnerComments,
    inheritLeadingComments: () => inheritLeadingComments,
    inheritTrailingComments: () => inheritTrailingComments,
    inherits: () => inherits,
    inheritsComments: () => inheritsComments,
    interfaceDeclaration: () => interfaceDeclaration,
    interfaceExtends: () => interfaceExtends,
    interfaceTypeAnnotation: () => interfaceTypeAnnotation,
    interpreterDirective: () => interpreterDirective,
    intersectionTypeAnnotation: () => intersectionTypeAnnotation,
    is: () => is$1,
    isAccessor: () => isAccessor,
    isAnyTypeAnnotation: () => isAnyTypeAnnotation,
    isArgumentPlaceholder: () => isArgumentPlaceholder,
    isArrayExpression: () => isArrayExpression$a,
    isArrayPattern: () => isArrayPattern,
    isArrayTypeAnnotation: () => isArrayTypeAnnotation,
    isArrowFunctionExpression: () => isArrowFunctionExpression$3,
    isAssignmentExpression: () => isAssignmentExpression$4,
    isAssignmentPattern: () => isAssignmentPattern$3,
    isAwaitExpression: () => isAwaitExpression$1,
    isBigIntLiteral: () => isBigIntLiteral,
    isBinary: () => isBinary,
    isBinaryExpression: () => isBinaryExpression$2,
    isBindExpression: () => isBindExpression,
    isBinding: () => isBinding$1,
    isBlock: () => isBlock$1,
    isBlockParent: () => isBlockParent,
    isBlockScoped: () => isBlockScoped,
    isBlockStatement: () => isBlockStatement$7,
    isBooleanLiteral: () => isBooleanLiteral$2,
    isBooleanLiteralTypeAnnotation: () => isBooleanLiteralTypeAnnotation,
    isBooleanTypeAnnotation: () => isBooleanTypeAnnotation,
    isBreakStatement: () => isBreakStatement,
    isCallExpression: () => isCallExpression$a,
    isCatchClause: () => isCatchClause,
    isClass: () => isClass,
    isClassAccessorProperty: () => isClassAccessorProperty,
    isClassBody: () => isClassBody$2,
    isClassDeclaration: () => isClassDeclaration,
    isClassExpression: () => isClassExpression,
    isClassImplements: () => isClassImplements,
    isClassMethod: () => isClassMethod$2,
    isClassPrivateMethod: () => isClassPrivateMethod,
    isClassPrivateProperty: () => isClassPrivateProperty,
    isClassProperty: () => isClassProperty$1,
    isCompletionStatement: () => isCompletionStatement,
    isConditional: () => isConditional,
    isConditionalExpression: () => isConditionalExpression,
    isContinueStatement: () => isContinueStatement$1,
    isDebuggerStatement: () => isDebuggerStatement,
    isDeclaration: () => isDeclaration,
    isDeclareClass: () => isDeclareClass,
    isDeclareExportAllDeclaration: () => isDeclareExportAllDeclaration,
    isDeclareExportDeclaration: () => isDeclareExportDeclaration,
    isDeclareFunction: () => isDeclareFunction,
    isDeclareInterface: () => isDeclareInterface,
    isDeclareModule: () => isDeclareModule,
    isDeclareModuleExports: () => isDeclareModuleExports,
    isDeclareOpaqueType: () => isDeclareOpaqueType,
    isDeclareTypeAlias: () => isDeclareTypeAlias,
    isDeclareVariable: () => isDeclareVariable,
    isDeclaredPredicate: () => isDeclaredPredicate,
    isDecorator: () => isDecorator$2,
    isDirective: () => isDirective,
    isDirectiveLiteral: () => isDirectiveLiteral,
    isDoExpression: () => isDoExpression,
    isDoWhileStatement: () => isDoWhileStatement$1,
    isEmptyStatement: () => isEmptyStatement,
    isEmptyTypeAnnotation: () => isEmptyTypeAnnotation,
    isEnumBody: () => isEnumBody,
    isEnumBooleanBody: () => isEnumBooleanBody,
    isEnumBooleanMember: () => isEnumBooleanMember,
    isEnumDeclaration: () => isEnumDeclaration,
    isEnumDefaultedMember: () => isEnumDefaultedMember,
    isEnumMember: () => isEnumMember,
    isEnumNumberBody: () => isEnumNumberBody,
    isEnumNumberMember: () => isEnumNumberMember,
    isEnumStringBody: () => isEnumStringBody,
    isEnumStringMember: () => isEnumStringMember,
    isEnumSymbolBody: () => isEnumSymbolBody,
    isExistsTypeAnnotation: () => isExistsTypeAnnotation,
    isExportAllDeclaration: () => isExportAllDeclaration,
    isExportDeclaration: () => isExportDeclaration$5,
    isExportDefaultDeclaration: () => isExportDefaultDeclaration$1,
    isExportDefaultSpecifier: () => isExportDefaultSpecifier$1,
    isExportNamedDeclaration: () => isExportNamedDeclaration$3,
    isExportNamespaceSpecifier: () => isExportNamespaceSpecifier$1,
    isExportSpecifier: () => isExportSpecifier$1,
    isExpression: () => isExpression$2,
    isExpressionStatement: () => isExpressionStatement$a,
    isExpressionWrapper: () => isExpressionWrapper,
    isFile: () => isFile$2,
    isFlow: () => isFlow,
    isFlowBaseAnnotation: () => isFlowBaseAnnotation,
    isFlowDeclaration: () => isFlowDeclaration,
    isFlowPredicate: () => isFlowPredicate,
    isFlowType: () => isFlowType,
    isFor: () => isFor,
    isForInStatement: () => isForInStatement,
    isForOfStatement: () => isForOfStatement$2,
    isForStatement: () => isForStatement,
    isForXStatement: () => isForXStatement,
    isFunction: () => isFunction$8,
    isFunctionDeclaration: () => isFunctionDeclaration$3,
    isFunctionExpression: () => isFunctionExpression$1,
    isFunctionParameter: () => isFunctionParameter,
    isFunctionParent: () => isFunctionParent,
    isFunctionTypeAnnotation: () => isFunctionTypeAnnotation,
    isFunctionTypeParam: () => isFunctionTypeParam,
    isGenericTypeAnnotation: () => isGenericTypeAnnotation,
    isIdentifier: () => isIdentifier$h,
    isIfStatement: () => isIfStatement$3,
    isImmutable: () => isImmutable,
    isImport: () => isImport,
    isImportAttribute: () => isImportAttribute,
    isImportDeclaration: () => isImportDeclaration$2,
    isImportDefaultSpecifier: () => isImportDefaultSpecifier$1,
    isImportExpression: () => isImportExpression,
    isImportNamespaceSpecifier: () => isImportNamespaceSpecifier,
    isImportOrExportDeclaration: () => isImportOrExportDeclaration,
    isImportSpecifier: () => isImportSpecifier,
    isIndexedAccessType: () => isIndexedAccessType,
    isInferredPredicate: () => isInferredPredicate,
    isInterfaceDeclaration: () => isInterfaceDeclaration,
    isInterfaceExtends: () => isInterfaceExtends,
    isInterfaceTypeAnnotation: () => isInterfaceTypeAnnotation,
    isInterpreterDirective: () => isInterpreterDirective,
    isIntersectionTypeAnnotation: () => isIntersectionTypeAnnotation,
    isJSX: () => isJSX,
    isJSXAttribute: () => isJSXAttribute$3,
    isJSXClosingElement: () => isJSXClosingElement,
    isJSXClosingFragment: () => isJSXClosingFragment,
    isJSXElement: () => isJSXElement$5,
    isJSXEmptyExpression: () => isJSXEmptyExpression,
    isJSXExpressionContainer: () => isJSXExpressionContainer$1,
    isJSXFragment: () => isJSXFragment,
    isJSXIdentifier: () => isJSXIdentifier$3,
    isJSXMemberExpression: () => isJSXMemberExpression,
    isJSXNamespacedName: () => isJSXNamespacedName,
    isJSXOpeningElement: () => isJSXOpeningElement,
    isJSXOpeningFragment: () => isJSXOpeningFragment,
    isJSXSpreadAttribute: () => isJSXSpreadAttribute$1,
    isJSXSpreadChild: () => isJSXSpreadChild,
    isJSXText: () => isJSXText$4,
    isLVal: () => isLVal,
    isLabeledStatement: () => isLabeledStatement$2,
    isLet: () => isLet,
    isLiteral: () => isLiteral$4,
    isLogicalExpression: () => isLogicalExpression$1,
    isLoop: () => isLoop,
    isMemberExpression: () => isMemberExpression$9,
    isMetaProperty: () => isMetaProperty,
    isMethod: () => isMethod,
    isMiscellaneous: () => isMiscellaneous,
    isMixedTypeAnnotation: () => isMixedTypeAnnotation,
    isModuleDeclaration: () => isModuleDeclaration,
    isModuleExpression: () => isModuleExpression,
    isModuleSpecifier: () => isModuleSpecifier,
    isNewExpression: () => isNewExpression,
    isNode: () => isNode,
    isNodesEquivalent: () => isNodesEquivalent,
    isNullLiteral: () => isNullLiteral$1,
    isNullLiteralTypeAnnotation: () => isNullLiteralTypeAnnotation,
    isNullableTypeAnnotation: () => isNullableTypeAnnotation,
    isNumberLiteral: () => isNumberLiteral,
    isNumberLiteralTypeAnnotation: () => isNumberLiteralTypeAnnotation,
    isNumberTypeAnnotation: () => isNumberTypeAnnotation,
    isNumericLiteral: () => isNumericLiteral,
    isObjectExpression: () => isObjectExpression$a,
    isObjectMember: () => isObjectMember,
    isObjectMethod: () => isObjectMethod$1,
    isObjectPattern: () => isObjectPattern$3,
    isObjectProperty: () => isObjectProperty$3,
    isObjectTypeAnnotation: () => isObjectTypeAnnotation,
    isObjectTypeCallProperty: () => isObjectTypeCallProperty,
    isObjectTypeIndexer: () => isObjectTypeIndexer,
    isObjectTypeInternalSlot: () => isObjectTypeInternalSlot,
    isObjectTypeProperty: () => isObjectTypeProperty,
    isObjectTypeSpreadProperty: () => isObjectTypeSpreadProperty,
    isOpaqueType: () => isOpaqueType,
    isOptionalCallExpression: () => isOptionalCallExpression,
    isOptionalIndexedAccessType: () => isOptionalIndexedAccessType,
    isOptionalMemberExpression: () => isOptionalMemberExpression$1,
    isParenthesizedExpression: () => isParenthesizedExpression,
    isPattern: () => isPattern,
    isPatternLike: () => isPatternLike,
    isPipelineBareFunction: () => isPipelineBareFunction,
    isPipelinePrimaryTopicReference: () => isPipelinePrimaryTopicReference,
    isPipelineTopicExpression: () => isPipelineTopicExpression,
    isPlaceholder: () => isPlaceholder,
    isPlaceholderType: () => isPlaceholderType,
    isPrivate: () => isPrivate,
    isPrivateName: () => isPrivateName,
    isProgram: () => isProgram$5,
    isProperty: () => isProperty$1,
    isPureish: () => isPureish,
    isQualifiedTypeIdentifier: () => isQualifiedTypeIdentifier,
    isReferenced: () => isReferenced,
    isRegExpLiteral: () => isRegExpLiteral$2,
    isRegexLiteral: () => isRegexLiteral,
    isRestElement: () => isRestElement,
    isRestProperty: () => isRestProperty,
    isReturnStatement: () => isReturnStatement$4,
    isScopable: () => isScopable,
    isScope: () => isScope,
    isSequenceExpression: () => isSequenceExpression$2,
    isSpecifierDefault: () => isSpecifierDefault,
    isSpreadElement: () => isSpreadElement$3,
    isSpreadProperty: () => isSpreadProperty,
    isStandardized: () => isStandardized,
    isStatement: () => isStatement$7,
    isStaticBlock: () => isStaticBlock,
    isStringLiteral: () => isStringLiteral$a,
    isStringLiteralTypeAnnotation: () => isStringLiteralTypeAnnotation,
    isStringTypeAnnotation: () => isStringTypeAnnotation,
    isSuper: () => isSuper,
    isSwitchCase: () => isSwitchCase,
    isSwitchStatement: () => isSwitchStatement,
    isSymbolTypeAnnotation: () => isSymbolTypeAnnotation,
    isTSAnyKeyword: () => isTSAnyKeyword,
    isTSArrayType: () => isTSArrayType,
    isTSAsExpression: () => isTSAsExpression$1,
    isTSBaseType: () => isTSBaseType,
    isTSBigIntKeyword: () => isTSBigIntKeyword,
    isTSBooleanKeyword: () => isTSBooleanKeyword,
    isTSCallSignatureDeclaration: () => isTSCallSignatureDeclaration,
    isTSClassImplements: () => isTSClassImplements,
    isTSConditionalType: () => isTSConditionalType$1,
    isTSConstructSignatureDeclaration: () => isTSConstructSignatureDeclaration,
    isTSConstructorType: () => isTSConstructorType,
    isTSDeclareFunction: () => isTSDeclareFunction,
    isTSDeclareMethod: () => isTSDeclareMethod,
    isTSEntityName: () => isTSEntityName,
    isTSEnumBody: () => isTSEnumBody,
    isTSEnumDeclaration: () => isTSEnumDeclaration,
    isTSEnumMember: () => isTSEnumMember,
    isTSExportAssignment: () => isTSExportAssignment,
    isTSExternalModuleReference: () => isTSExternalModuleReference$1,
    isTSFunctionType: () => isTSFunctionType,
    isTSImportEqualsDeclaration: () => isTSImportEqualsDeclaration,
    isTSImportType: () => isTSImportType,
    isTSIndexSignature: () => isTSIndexSignature,
    isTSIndexedAccessType: () => isTSIndexedAccessType,
    isTSInferType: () => isTSInferType,
    isTSInstantiationExpression: () => isTSInstantiationExpression,
    isTSInterfaceBody: () => isTSInterfaceBody,
    isTSInterfaceDeclaration: () => isTSInterfaceDeclaration,
    isTSInterfaceHeritage: () => isTSInterfaceHeritage,
    isTSIntersectionType: () => isTSIntersectionType,
    isTSIntrinsicKeyword: () => isTSIntrinsicKeyword,
    isTSLiteralType: () => isTSLiteralType,
    isTSMappedType: () => isTSMappedType,
    isTSMethodSignature: () => isTSMethodSignature,
    isTSModuleBlock: () => isTSModuleBlock$4,
    isTSModuleDeclaration: () => isTSModuleDeclaration,
    isTSNamedTupleMember: () => isTSNamedTupleMember,
    isTSNamespaceExportDeclaration: () => isTSNamespaceExportDeclaration,
    isTSNeverKeyword: () => isTSNeverKeyword,
    isTSNonNullExpression: () => isTSNonNullExpression,
    isTSNullKeyword: () => isTSNullKeyword,
    isTSNumberKeyword: () => isTSNumberKeyword,
    isTSObjectKeyword: () => isTSObjectKeyword,
    isTSOptionalType: () => isTSOptionalType,
    isTSParameterProperty: () => isTSParameterProperty,
    isTSParenthesizedType: () => isTSParenthesizedType,
    isTSPropertySignature: () => isTSPropertySignature$1,
    isTSQualifiedName: () => isTSQualifiedName,
    isTSRestType: () => isTSRestType,
    isTSSatisfiesExpression: () => isTSSatisfiesExpression,
    isTSStringKeyword: () => isTSStringKeyword,
    isTSSymbolKeyword: () => isTSSymbolKeyword,
    isTSTemplateLiteralType: () => isTSTemplateLiteralType,
    isTSThisType: () => isTSThisType,
    isTSTupleType: () => isTSTupleType,
    isTSType: () => isTSType,
    isTSTypeAliasDeclaration: () => isTSTypeAliasDeclaration$1,
    isTSTypeAnnotation: () => isTSTypeAnnotation,
    isTSTypeAssertion: () => isTSTypeAssertion,
    isTSTypeElement: () => isTSTypeElement,
    isTSTypeLiteral: () => isTSTypeLiteral,
    isTSTypeOperator: () => isTSTypeOperator,
    isTSTypeParameter: () => isTSTypeParameter$1,
    isTSTypeParameterDeclaration: () => isTSTypeParameterDeclaration$1,
    isTSTypeParameterInstantiation: () => isTSTypeParameterInstantiation,
    isTSTypePredicate: () => isTSTypePredicate,
    isTSTypeQuery: () => isTSTypeQuery,
    isTSTypeReference: () => isTSTypeReference$3,
    isTSUndefinedKeyword: () => isTSUndefinedKeyword,
    isTSUnionType: () => isTSUnionType$1,
    isTSUnknownKeyword: () => isTSUnknownKeyword,
    isTSVoidKeyword: () => isTSVoidKeyword,
    isTaggedTemplateExpression: () => isTaggedTemplateExpression,
    isTemplateElement: () => isTemplateElement$4,
    isTemplateLiteral: () => isTemplateLiteral$4,
    isTerminatorless: () => isTerminatorless,
    isThisExpression: () => isThisExpression,
    isThisTypeAnnotation: () => isThisTypeAnnotation,
    isThrowStatement: () => isThrowStatement,
    isTopicReference: () => isTopicReference,
    isTryStatement: () => isTryStatement,
    isTupleTypeAnnotation: () => isTupleTypeAnnotation,
    isType: () => isType,
    isTypeAlias: () => isTypeAlias,
    isTypeAnnotation: () => isTypeAnnotation,
    isTypeCastExpression: () => isTypeCastExpression,
    isTypeParameter: () => isTypeParameter,
    isTypeParameterDeclaration: () => isTypeParameterDeclaration,
    isTypeParameterInstantiation: () => isTypeParameterInstantiation,
    isTypeScript: () => isTypeScript,
    isTypeofTypeAnnotation: () => isTypeofTypeAnnotation,
    isUnaryExpression: () => isUnaryExpression$1,
    isUnaryLike: () => isUnaryLike,
    isUnionTypeAnnotation: () => isUnionTypeAnnotation,
    isUpdateExpression: () => isUpdateExpression,
    isUserWhitespacable: () => isUserWhitespacable,
    isV8IntrinsicIdentifier: () => isV8IntrinsicIdentifier,
    isValidES3Identifier: () => isValidES3Identifier,
    isValidIdentifier: () => isValidIdentifier,
    isVar: () => isVar,
    isVariableDeclaration: () => isVariableDeclaration$5,
    isVariableDeclarator: () => isVariableDeclarator$4,
    isVariance: () => isVariance,
    isVoidPattern: () => isVoidPattern,
    isVoidTypeAnnotation: () => isVoidTypeAnnotation,
    isWhile: () => isWhile,
    isWhileStatement: () => isWhileStatement,
    isWithStatement: () => isWithStatement,
    isYieldExpression: () => isYieldExpression,
    jsxAttribute: () => jsxAttribute$1,
    jsxClosingElement: () => jsxClosingElement,
    jsxClosingFragment: () => jsxClosingFragment,
    jsxElement: () => jsxElement,
    jsxEmptyExpression: () => jsxEmptyExpression,
    jsxExpressionContainer: () => jsxExpressionContainer,
    jsxFragment: () => jsxFragment,
    jsxIdentifier: () => jsxIdentifier$1,
    jsxMemberExpression: () => jsxMemberExpression,
    jsxNamespacedName: () => jsxNamespacedName,
    jsxOpeningElement: () => jsxOpeningElement,
    jsxOpeningFragment: () => jsxOpeningFragment,
    jsxSpreadAttribute: () => jsxSpreadAttribute,
    jsxSpreadChild: () => jsxSpreadChild,
    jsxText: () => jsxText,
    labeledStatement: () => labeledStatement,
    logicalExpression: () => logicalExpression,
    matchesPattern: () => matchesPattern$1,
    memberExpression: () => memberExpression,
    metaProperty: () => metaProperty,
    mixedTypeAnnotation: () => mixedTypeAnnotation,
    moduleExpression: () => moduleExpression,
    newExpression: () => newExpression,
    nullLiteral: () => nullLiteral,
    nullLiteralTypeAnnotation: () => nullLiteralTypeAnnotation,
    nullableTypeAnnotation: () => nullableTypeAnnotation,
    numberLiteral: () => NumberLiteral,
    numberLiteralTypeAnnotation: () => numberLiteralTypeAnnotation,
    numberTypeAnnotation: () => numberTypeAnnotation,
    numericLiteral: () => numericLiteral,
    objectExpression: () => objectExpression$2,
    objectMethod: () => objectMethod$1,
    objectPattern: () => objectPattern$1,
    objectProperty: () => objectProperty$3,
    objectTypeAnnotation: () => objectTypeAnnotation,
    objectTypeCallProperty: () => objectTypeCallProperty,
    objectTypeIndexer: () => objectTypeIndexer,
    objectTypeInternalSlot: () => objectTypeInternalSlot,
    objectTypeProperty: () => objectTypeProperty,
    objectTypeSpreadProperty: () => objectTypeSpreadProperty,
    opaqueType: () => opaqueType,
    optionalCallExpression: () => optionalCallExpression,
    optionalIndexedAccessType: () => optionalIndexedAccessType,
    optionalMemberExpression: () => optionalMemberExpression,
    parenthesizedExpression: () => parenthesizedExpression$1,
    pipelineBareFunction: () => pipelineBareFunction,
    pipelinePrimaryTopicReference: () => pipelinePrimaryTopicReference,
    pipelineTopicExpression: () => pipelineTopicExpression,
    placeholder: () => placeholder,
    prependToMemberExpression: () => prependToMemberExpression,
    privateName: () => privateName$1,
    program: () => program$1,
    qualifiedTypeIdentifier: () => qualifiedTypeIdentifier,
    react: () => react,
    regExpLiteral: () => regExpLiteral,
    regexLiteral: () => RegexLiteral,
    removeComments: () => removeComments,
    removeProperties: () => removeProperties,
    removePropertiesDeep: () => removePropertiesDeep,
    removeTypeDuplicates: () => removeTypeDuplicates$1,
    restElement: () => restElement,
    restProperty: () => RestProperty,
    returnStatement: () => returnStatement,
    sequenceExpression: () => sequenceExpression,
    shallowEqual: () => shallowEqual,
    spreadElement: () => spreadElement,
    spreadProperty: () => SpreadProperty,
    staticBlock: () => staticBlock,
    stringLiteral: () => stringLiteral$5,
    stringLiteralTypeAnnotation: () => stringLiteralTypeAnnotation,
    stringTypeAnnotation: () => stringTypeAnnotation,
    super: () => _super,
    switchCase: () => switchCase,
    switchStatement: () => switchStatement,
    symbolTypeAnnotation: () => symbolTypeAnnotation,
    taggedTemplateExpression: () => taggedTemplateExpression,
    templateElement: () => templateElement$1,
    templateLiteral: () => templateLiteral,
    thisExpression: () => thisExpression,
    thisTypeAnnotation: () => thisTypeAnnotation,
    throwStatement: () => throwStatement,
    toBindingIdentifierName: () => toBindingIdentifierName,
    toBlock: () => toBlock,
    toComputedKey: () => toComputedKey,
    toExpression: () => toExpression$1,
    toIdentifier: () => toIdentifier,
    toKeyAlias: () => toKeyAlias,
    toStatement: () => toStatement$1,
    topicReference: () => topicReference,
    traverse: () => traverse$2,
    traverseFast: () => traverseFast,
    tryStatement: () => tryStatement,
    tsAnyKeyword: () => tsAnyKeyword,
    tsArrayType: () => tsArrayType,
    tsAsExpression: () => tsAsExpression,
    tsBigIntKeyword: () => tsBigIntKeyword,
    tsBooleanKeyword: () => tsBooleanKeyword,
    tsCallSignatureDeclaration: () => tsCallSignatureDeclaration,
    tsClassImplements: () => tsClassImplements,
    tsConditionalType: () => tsConditionalType,
    tsConstructSignatureDeclaration: () => tsConstructSignatureDeclaration,
    tsConstructorType: () => tsConstructorType,
    tsDeclareFunction: () => tsDeclareFunction,
    tsDeclareMethod: () => tsDeclareMethod,
    tsEnumBody: () => tsEnumBody,
    tsEnumDeclaration: () => tsEnumDeclaration,
    tsEnumMember: () => tsEnumMember,
    tsExportAssignment: () => tsExportAssignment,
    tsExternalModuleReference: () => tsExternalModuleReference,
    tsFunctionType: () => tsFunctionType,
    tsImportEqualsDeclaration: () => tsImportEqualsDeclaration,
    tsImportType: () => tsImportType,
    tsIndexSignature: () => tsIndexSignature,
    tsIndexedAccessType: () => tsIndexedAccessType,
    tsInferType: () => tsInferType,
    tsInstantiationExpression: () => tsInstantiationExpression,
    tsInterfaceBody: () => tsInterfaceBody,
    tsInterfaceDeclaration: () => tsInterfaceDeclaration,
    tsInterfaceHeritage: () => tsInterfaceHeritage,
    tsIntersectionType: () => tsIntersectionType,
    tsIntrinsicKeyword: () => tsIntrinsicKeyword,
    tsLiteralType: () => tsLiteralType,
    tsMappedType: () => tsMappedType,
    tsMethodSignature: () => tsMethodSignature,
    tsModuleBlock: () => tsModuleBlock,
    tsModuleDeclaration: () => tsModuleDeclaration,
    tsNamedTupleMember: () => tsNamedTupleMember,
    tsNamespaceExportDeclaration: () => tsNamespaceExportDeclaration,
    tsNeverKeyword: () => tsNeverKeyword,
    tsNonNullExpression: () => tsNonNullExpression,
    tsNullKeyword: () => tsNullKeyword,
    tsNumberKeyword: () => tsNumberKeyword,
    tsObjectKeyword: () => tsObjectKeyword,
    tsOptionalType: () => tsOptionalType,
    tsParameterProperty: () => tsParameterProperty,
    tsParenthesizedType: () => tsParenthesizedType$1,
    tsPropertySignature: () => tsPropertySignature,
    tsQualifiedName: () => tsQualifiedName,
    tsRestType: () => tsRestType,
    tsSatisfiesExpression: () => tsSatisfiesExpression,
    tsStringKeyword: () => tsStringKeyword,
    tsSymbolKeyword: () => tsSymbolKeyword,
    tsTemplateLiteralType: () => tsTemplateLiteralType,
    tsThisType: () => tsThisType,
    tsTupleType: () => tsTupleType,
    tsTypeAliasDeclaration: () => tsTypeAliasDeclaration,
    tsTypeAnnotation: () => tsTypeAnnotation,
    tsTypeAssertion: () => tsTypeAssertion,
    tsTypeLiteral: () => tsTypeLiteral,
    tsTypeOperator: () => tsTypeOperator,
    tsTypeParameter: () => tsTypeParameter,
    tsTypeParameterDeclaration: () => tsTypeParameterDeclaration,
    tsTypeParameterInstantiation: () => tsTypeParameterInstantiation,
    tsTypePredicate: () => tsTypePredicate,
    tsTypeQuery: () => tsTypeQuery,
    tsTypeReference: () => tsTypeReference,
    tsUndefinedKeyword: () => tsUndefinedKeyword,
    tsUnionType: () => tsUnionType,
    tsUnknownKeyword: () => tsUnknownKeyword,
    tsVoidKeyword: () => tsVoidKeyword,
    tupleTypeAnnotation: () => tupleTypeAnnotation,
    typeAlias: () => typeAlias,
    typeAnnotation: () => typeAnnotation,
    typeCastExpression: () => typeCastExpression,
    typeParameter: () => typeParameter,
    typeParameterDeclaration: () => typeParameterDeclaration,
    typeParameterInstantiation: () => typeParameterInstantiation,
    typeofTypeAnnotation: () => typeofTypeAnnotation,
    unaryExpression: () => unaryExpression$1,
    unionTypeAnnotation: () => unionTypeAnnotation,
    updateExpression: () => updateExpression,
    v8IntrinsicIdentifier: () => v8IntrinsicIdentifier,
    validate: () => validate$1$1,
    valueToNode: () => valueToNode,
    variableDeclaration: () => variableDeclaration,
    variableDeclarator: () => variableDeclarator,
    variance: () => variance,
    voidPattern: () => voidPattern,
    voidTypeAnnotation: () => voidTypeAnnotation,
    whileStatement: () => whileStatement,
    withStatement: () => withStatement,
    yieldExpression: () => yieldExpression,
});

// ../babel-babel/packages/babel-helper-validator-identifier/lib/index.js
var nonASCIIidentifierStartChars = '\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088F\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5C\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDC-\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7DC\uA7F1-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC';
var nonASCIIidentifierChars = '\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ADD\u1AE0-\u1AEB\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65';
var nonASCIIidentifierStart = new RegExp('[' + nonASCIIidentifierStartChars + ']');
var nonASCIIidentifier = new RegExp('[' + nonASCIIidentifierStartChars + nonASCIIidentifierChars + ']');

nonASCIIidentifierStartChars =
nonASCIIidentifierChars = null;
var astralIdentifierStartCodes = [
    0,
    11,
    2,
    25,
    2,
    18,
    2,
    1,
    2,
    14,
    3,
    13,
    35,
    122,
    70,
    52,
    268,
    28,
    4,
    48,
    48,
    31,
    14,
    29,
    6,
    37,
    11,
    29,
    3,
    35,
    5,
    7,
    2,
    4,
    43,
    157,
    19,
    35,
    5,
    35,
    5,
    39,
    9,
    51,
    13,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    2,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    4,
    51,
    13,
    310,
    10,
    21,
    11,
    7,
    25,
    5,
    2,
    41,
    2,
    8,
    70,
    5,
    3,
    0,
    2,
    43,
    2,
    1,
    4,
    0,
    3,
    22,
    11,
    22,
    10,
    30,
    66,
    18,
    2,
    1,
    11,
    21,
    11,
    25,
    7,
    25,
    39,
    55,
    7,
    1,
    65,
    0,
    16,
    3,
    2,
    2,
    2,
    28,
    43,
    28,
    4,
    28,
    36,
    7,
    2,
    27,
    28,
    53,
    11,
    21,
    11,
    18,
    14,
    17,
    111,
    72,
    56,
    50,
    14,
    50,
    14,
    35,
    39,
    27,
    10,
    22,
    251,
    41,
    7,
    1,
    17,
    5,
    57,
    28,
    11,
    0,
    9,
    21,
    43,
    17,
    47,
    20,
    28,
    22,
    13,
    52,
    58,
    1,
    3,
    0,
    14,
    44,
    33,
    24,
    27,
    35,
    30,
    0,
    3,
    0,
    9,
    34,
    4,
    0,
    13,
    47,
    15,
    3,
    22,
    0,
    2,
    0,
    36,
    17,
    2,
    24,
    20,
    1,
    64,
    6,
    2,
    0,
    2,
    3,
    2,
    14,
    2,
    9,
    8,
    46,
    39,
    7,
    3,
    1,
    3,
    21,
    2,
    6,
    2,
    1,
    2,
    4,
    4,
    0,
    19,
    0,
    13,
    4,
    31,
    9,
    2,
    0,
    3,
    0,
    2,
    37,
    2,
    0,
    26,
    0,
    2,
    0,
    45,
    52,
    19,
    3,
    21,
    2,
    31,
    47,
    21,
    1,
    2,
    0,
    185,
    46,
    42,
    3,
    37,
    47,
    21,
    0,
    60,
    42,
    14,
    0,
    72,
    26,
    38,
    6,
    186,
    43,
    117,
    63,
    32,
    7,
    3,
    0,
    3,
    7,
    2,
    1,
    2,
    23,
    16,
    0,
    2,
    0,
    95,
    7,
    3,
    38,
    17,
    0,
    2,
    0,
    29,
    0,
    11,
    39,
    8,
    0,
    22,
    0,
    12,
    45,
    20,
    0,
    19,
    72,
    200,
    32,
    32,
    8,
    2,
    36,
    18,
    0,
    50,
    29,
    113,
    6,
    2,
    1,
    2,
    37,
    22,
    0,
    26,
    5,
    2,
    1,
    2,
    31,
    15,
    0,
    24,
    43,
    261,
    18,
    16,
    0,
    2,
    12,
    2,
    33,
    125,
    0,
    80,
    921,
    103,
    110,
    18,
    195,
    2637,
    96,
    16,
    1071,
    18,
    5,
    26,
    3994,
    6,
    582,
    6842,
    29,
    1763,
    568,
    8,
    30,
    18,
    78,
    18,
    29,
    19,
    47,
    17,
    3,
    32,
    20,
    6,
    18,
    433,
    44,
    212,
    63,
    33,
    24,
    3,
    24,
    45,
    74,
    6,
    0,
    67,
    12,
    65,
    1,
    2,
    0,
    15,
    4,
    10,
    7381,
    42,
    31,
    98,
    114,
    8702,
    3,
    2,
    6,
    2,
    1,
    2,
    290,
    16,
    0,
    30,
    2,
    3,
    0,
    15,
    3,
    9,
    395,
    2309,
    106,
    6,
    12,
    4,
    8,
    8,
    9,
    5991,
    84,
    2,
    70,
    2,
    1,
    3,
    0,
    3,
    1,
    3,
    3,
    2,
    11,
    2,
    0,
    2,
    6,
    2,
    64,
    2,
    3,
    3,
    7,
    2,
    6,
    2,
    27,
    2,
    3,
    2,
    4,
    2,
    0,
    4,
    6,
    2,
    339,
    3,
    24,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    7,
    1845,
    30,
    7,
    5,
    262,
    61,
    147,
    44,
    11,
    6,
    17,
    0,
    322,
    29,
    19,
    43,
    485,
    27,
    229,
    29,
    3,
    0,
    208,
    30,
    2,
    2,
    2,
    1,
    2,
    6,
    3,
    4,
    10,
    1,
    225,
    6,
    2,
    3,
    2,
    1,
    2,
    14,
    2,
    196,
    60,
    67,
    8,
    0,
    1205,
    3,
    2,
    26,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    9,
    2,
    3,
    2,
    0,
    2,
    0,
    7,
    0,
    5,
    0,
    2,
    0,
    2,
    0,
    2,
    2,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    1,
    2,
    0,
    3,
    3,
    2,
    6,
    2,
    3,
    2,
    3,
    2,
    0,
    2,
    9,
    2,
    16,
    6,
    2,
    2,
    4,
    2,
    16,
    4421,
    42719,
    33,
    4381,
    3,
    5773,
    3,
    7472,
    16,
    621,
    2467,
    541,
    1507,
    4938,
    6,
    8489,
];
var astralIdentifierCodes = [
    509,
    0,
    227,
    0,
    150,
    4,
    294,
    9,
    1368,
    2,
    2,
    1,
    6,
    3,
    41,
    2,
    5,
    0,
    166,
    1,
    574,
    3,
    9,
    9,
    7,
    9,
    32,
    4,
    318,
    1,
    78,
    5,
    71,
    10,
    50,
    3,
    123,
    2,
    54,
    14,
    32,
    10,
    3,
    1,
    11,
    3,
    46,
    10,
    8,
    0,
    46,
    9,
    7,
    2,
    37,
    13,
    2,
    9,
    6,
    1,
    45,
    0,
    13,
    2,
    49,
    13,
    9,
    3,
    2,
    11,
    83,
    11,
    7,
    0,
    3,
    0,
    158,
    11,
    6,
    9,
    7,
    3,
    56,
    1,
    2,
    6,
    3,
    1,
    3,
    2,
    10,
    0,
    11,
    1,
    3,
    6,
    4,
    4,
    68,
    8,
    2,
    0,
    3,
    0,
    2,
    3,
    2,
    4,
    2,
    0,
    15,
    1,
    83,
    17,
    10,
    9,
    5,
    0,
    82,
    19,
    13,
    9,
    214,
    6,
    3,
    8,
    28,
    1,
    83,
    16,
    16,
    9,
    82,
    12,
    9,
    9,
    7,
    19,
    58,
    14,
    5,
    9,
    243,
    14,
    166,
    9,
    71,
    5,
    2,
    1,
    3,
    3,
    2,
    0,
    2,
    1,
    13,
    9,
    120,
    6,
    3,
    6,
    4,
    0,
    29,
    9,
    41,
    6,
    2,
    3,
    9,
    0,
    10,
    10,
    47,
    15,
    199,
    7,
    137,
    9,
    54,
    7,
    2,
    7,
    17,
    9,
    57,
    21,
    2,
    13,
    123,
    5,
    4,
    0,
    2,
    1,
    2,
    6,
    2,
    0,
    9,
    9,
    49,
    4,
    2,
    1,
    2,
    4,
    9,
    9,
    55,
    9,
    266,
    3,
    10,
    1,
    2,
    0,
    49,
    6,
    4,
    4,
    14,
    10,
    5350,
    0,
    7,
    14,
    11465,
    27,
    2343,
    9,
    87,
    9,
    39,
    4,
    60,
    6,
    26,
    9,
    535,
    9,
    470,
    0,
    2,
    54,
    8,
    3,
    82,
    0,
    12,
    1,
    19628,
    1,
    4178,
    9,
    519,
    45,
    3,
    22,
    543,
    4,
    4,
    5,
    9,
    7,
    3,
    6,
    31,
    3,
    149,
    2,
    1418,
    49,
    513,
    54,
    5,
    49,
    9,
    0,
    15,
    0,
    23,
    4,
    2,
    14,
    1361,
    6,
    2,
    16,
    3,
    6,
    2,
    1,
    2,
    4,
    101,
    0,
    161,
    6,
    10,
    9,
    357,
    0,
    62,
    13,
    499,
    13,
    245,
    1,
    2,
    9,
    233,
    0,
    3,
    0,
    8,
    1,
    6,
    0,
    475,
    6,
    110,
    6,
    6,
    9,
    4759,
    9,
    787719,
    239,
];

function isInAstralSet(code2, set) {
    let pos = 65536;
    
    for (let i = 0, length = set.length; i < length; i += 2) {
        pos += set[i];
        
        if (pos > code2)
            return false;
        
        pos += set[i + 1];
        
        if (pos >= code2)
            return true;
    }
    
    return false;
}

function isIdentifierStart(code2) {
    if (code2 < 65)
        return code2 === 36;
    
    if (code2 <= 90)
        return true;
    
    if (code2 < 97)
        return code2 === 95;
    
    if (code2 <= 122)
        return true;
    
    if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
    }
    
    return isInAstralSet(code2, astralIdentifierStartCodes);
}

function isIdentifierChar(code2) {
    if (code2 < 48)
        return code2 === 36;
    
    if (code2 < 58)
        return true;
    
    if (code2 < 65)
        return false;
    
    if (code2 <= 90)
        return true;
    
    if (code2 < 97)
        return code2 === 95;
    
    if (code2 <= 122)
        return true;
    
    if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
    }
    
    return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
}

function isIdentifierName(name) {
    let isFirst = true;
    
    for (let i = 0; i < name.length; i++) {
        let cp = name.charCodeAt(i);
        
        if ((cp & 64512) === 55296 && i + 1 < name.length) {
            const trail = name.charCodeAt(++i);
            
            if ((trail & 64512) === 56320) {
                cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
            }
        }
        
        if (isFirst) {
            isFirst = false;
            
            if (!isIdentifierStart(cp)) {
                return false;
            }
        } else if (!isIdentifierChar(cp)) {
            return false;
        }
    }
    
    return !isFirst;
}

var reservedWords = {
    keyword: [
        'break',
        'case',
        'catch',
        'continue',
        'debugger',
        'default',
        'do',
        'else',
        'finally',
        'for',
        'function',
        'if',
        'return',
        'switch',
        'throw',
        'try',
        'var',
        'const',
        'while',
        'with',
        'new',
        'this',
        'super',
        'class',
        'extends',
        'export',
        'import',
        'null',
        'true',
        'false',
        'in',
        'instanceof',
        'typeof',
        'void',
        'delete',
    ],
    strict: [
        'implements',
        'interface',
        'let',
        'package',
        'private',
        'protected',
        'public',
        'static',
        'yield',
    ]};

var keywords$1 = new Set(reservedWords.keyword);
var reservedWordsStrictSet = new Set(reservedWords.strict);

function isReservedWord(word, inModule) {
    return inModule && word === 'await' || word === 'enum';
}

function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
}

function isKeyword$1(word) {
    return keywords$1.has(word);
}

// ../babel-babel/packages/babel-helper-string-parser/lib/index.js
var _isDigit = function isDigit(code2) {
    return code2 >= 48 && code2 <= 57;
};

function readStringContents(type, input, pos, lineStart, curLine, errors) {
    const initialPos = pos;
    const initialLineStart = lineStart;
    const initialCurLine = curLine;
    let out = '';
    let firstInvalidLoc = null;
    let chunkStart = pos;
    
    const {length} = input;
    
    for (;;) {
        if (pos >= length) {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
            out += input.slice(chunkStart, pos);
            break;
        }
        
        const ch = input.charCodeAt(pos);
        
        if (isStringEnd(type, ch, input, pos)) {
            out += input.slice(chunkStart, pos);
            break;
        }
        
        if (ch === 92) {
            out += input.slice(chunkStart, pos);
            const res = readEscapedChar(input, pos, lineStart, curLine, type === 'template', errors);
            
            if (res.ch === null && !firstInvalidLoc) {
                firstInvalidLoc = {
                    pos,
                    lineStart,
                    curLine,
                };
            } else {
                out += res.ch;
            }
            
            ({
                pos,
                lineStart,
                curLine,
            } = res);
            chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
            ++pos;
            ++curLine;
            lineStart = pos;
        } else if (ch === 10 || ch === 13) {
            {
                out += input.slice(chunkStart, pos) + '\n';
                ++pos;
                
                if (ch === 13 && input.charCodeAt(pos) === 10) {
                    ++pos;
                }
                
                ++curLine;
                chunkStart =
                lineStart = pos;
            }
        } else {
            ++pos;
        }

    }
    
    return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
    };
}

function isStringEnd(type, ch, input, pos) {
    {
        return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
    }
}

function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
    const throwOnInvalid = false;
    pos++;
    const res = (ch2) => ({
        pos,
        ch: ch2,
        lineStart,
        curLine,
    });
    
    const ch = input.charCodeAt(pos++);
    
    switch(ch) {
    case 110:
        return res('\n');
    
    case 114:
        return res('\r');
    
    case 120: {
        let code2;
        
        ({
            code: code2,
            pos,
        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
        return res(code2 === null ? null : String.fromCharCode(code2));
    }
    
    case 117: {
        let code2;
        
        ({
            code: code2,
            pos,
        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
        return res(code2 === null ? null : String.fromCodePoint(code2));
    }
    
    case 116:
        return res('	');
    
    case 98:
        return res('\b');
    
    case 118:
        return res('\v');
    
    case 102:
        return res('\f');
    
    case 13:
        if (input.charCodeAt(pos) === 10) {
            ++pos;
        }
    
    case 10:
        lineStart = pos;
        ++curLine;
    
    case 8232:    
    case 8233:
        return res('');
    
    case 56:    
    case 57:
        {
            return res(null);
        }
    
    default:
        if (ch >= 48 && ch <= 55) {
            const startPos = pos - 1;
            const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
            let octalStr = match[0];
            let octal = parseInt(octalStr, 8);
            
            if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
            }
            
            pos += octalStr.length - 1;
            const next = input.charCodeAt(pos);
            
            if (octalStr !== '0' || next === 56 || next === 57) {
                {
                    return res(null);
                }
            }
            
            return res(String.fromCharCode(octal));
        }
        
        return res(String.fromCharCode(ch));
    }
}

function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
    const initialPos = pos;
    let n2;
    
    ({n: n2, pos} = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, true));
    
    if (n2 === null) {
        {
            pos = initialPos - 1;
        }
    }
    
    return {
        code: n2,
        pos,
    };
}

function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
    const start = pos;
    let invalid = false;
    let total = 0;
    
    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        const code2 = input.charCodeAt(pos);
        let val;
        
        if (code2 === 95 && allowNumSeparator !== 'bail') {
            input.charCodeAt(pos - 1);
            input.charCodeAt(pos + 1);
            
            {
                return {
                        n: null,
                        pos,
                    };
            }
        }
        
        if (code2 >= 97) {
            val = code2 - 97 + 10;
        } else if (code2 >= 65) {
            val = code2 - 65 + 10;
        } else if (_isDigit(code2)) {
            val = code2 - 48;
        } else {
            val = Infinity;
        }
        
        if (val >= radix) {
            if (val <= 9 && bailOnError) {
                return {
                    n: null,
                    pos,
                };
            } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
                val = 0;
            } else if (forceLen) {
                val = 0;
                invalid = true;
            } else {
                break;
            }

        }
        
        ++pos;
        total = total * radix + val;
    }
    
    if (pos === start || len != null && pos - start !== len || invalid) {
        return {
            n: null,
            pos,
        };
    }
    
    return {
        n: total,
        pos,
    };
}

function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
    const ch = input.charCodeAt(pos);
    let code2;
    
    if (ch === 123) {
        ++pos;
        ({
            code: code2,
            pos,
        } = readHexChar(input, pos, lineStart, curLine, input.indexOf('}', pos) - pos, true, throwOnInvalid, errors));
        ++pos;
        
        if (code2 !== null && code2 > 1114111) {
            {
                return {
                    code: null,
                    pos,
                };
            }
        }
    } else {
        ({
            code: code2,
            pos,
        } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
    }
    
    return {
        code: code2,
        pos,
    };
}

// ../babel-babel/packages/babel-types/lib/index.js
function shallowEqual(actual, expected) {
    const keys2 = Object.keys(expected);
    
    for (const key of keys2) {
        if (actual[key] !== expected[key]) {
            return false;
        }
    }
    
    return true;
}

var warnings = /* @__PURE__ */new Set();

function deprecationWarning(oldName, newName, prefix2 = '', cacheKey = oldName) {
    if (warnings.has(cacheKey))
        return;
    
    warnings.add(cacheKey);
    const {internal, trace} = captureShortStackTrace(1, 2);
    
    if (internal) {
        return;
    }
    
    console.warn(`${prefix2}\`${oldName}\` has been deprecated, please migrate to \`${newName}\`
${trace}`);
}

function captureShortStackTrace(skip2, length) {
    const {
        stackTraceLimit,
        prepareStackTrace,
    } = Error;
    
    let stackTrace;
    
    Error.stackTraceLimit = 1 + skip2 + length;
    Error.prepareStackTrace = function(err, stack) {
        stackTrace = stack;
    };
    new Error().stack;
    Error.stackTraceLimit = stackTraceLimit;
    Error.prepareStackTrace = prepareStackTrace;
    
    if (!stackTrace)
        return {
            internal: false,
            trace: '',
        };
    
    const shortStackTrace = stackTrace.slice(1 + skip2, 1 + skip2 + length);
    
    return {
        internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
        trace: shortStackTrace
            .map((frame) => `    at ${frame}`)
            .join('\n'),
    };
}

function isArrayExpression$a(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ArrayExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isAssignmentExpression$4(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'AssignmentExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isBinaryExpression$2(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'BinaryExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isInterpreterDirective(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'InterpreterDirective')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDirective(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'Directive')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDirectiveLiteral(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DirectiveLiteral')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isBlockStatement$7(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'BlockStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isBreakStatement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'BreakStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isCallExpression$a(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'CallExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isCatchClause(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'CatchClause')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isConditionalExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ConditionalExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isContinueStatement$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ContinueStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDebuggerStatement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DebuggerStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDoWhileStatement$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DoWhileStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isEmptyStatement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'EmptyStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isExpressionStatement$a(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ExpressionStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isFile$2(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'File')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isForInStatement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ForInStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isForStatement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ForStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isFunctionDeclaration$3(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'FunctionDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isFunctionExpression$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'FunctionExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isIdentifier$h(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'Identifier')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isIfStatement$3(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'IfStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isLabeledStatement$2(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'LabeledStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isStringLiteral$a(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'StringLiteral')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isNumericLiteral(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'NumericLiteral')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isNullLiteral$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'NullLiteral')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isBooleanLiteral$2(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'BooleanLiteral')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isRegExpLiteral$2(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'RegExpLiteral')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isLogicalExpression$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'LogicalExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isMemberExpression$9(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'MemberExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isNewExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'NewExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isProgram$5(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'Program')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isObjectExpression$a(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ObjectExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isObjectMethod$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ObjectMethod')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isObjectProperty$3(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ObjectProperty')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isRestElement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'RestElement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isReturnStatement$4(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ReturnStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isSequenceExpression$2(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'SequenceExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isParenthesizedExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ParenthesizedExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isSwitchCase(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'SwitchCase')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isSwitchStatement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'SwitchStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isThisExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ThisExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isThrowStatement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ThrowStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTryStatement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TryStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isUnaryExpression$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'UnaryExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isUpdateExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'UpdateExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isVariableDeclaration$5(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'VariableDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isVariableDeclarator$4(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'VariableDeclarator')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isWhileStatement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'WhileStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isWithStatement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'WithStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isAssignmentPattern$3(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'AssignmentPattern')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isArrayPattern(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ArrayPattern')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isArrowFunctionExpression$3(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ArrowFunctionExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isClassBody$2(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ClassBody')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isClassExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ClassExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isClassDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ClassDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isExportAllDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ExportAllDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isExportDefaultDeclaration$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ExportDefaultDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isExportNamedDeclaration$3(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ExportNamedDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isExportSpecifier$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ExportSpecifier')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isForOfStatement$2(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ForOfStatement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isImportDeclaration$2(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ImportDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isImportDefaultSpecifier$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ImportDefaultSpecifier')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isImportNamespaceSpecifier(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ImportNamespaceSpecifier')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isImportSpecifier(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ImportSpecifier')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isImportExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ImportExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isMetaProperty(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'MetaProperty')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isClassMethod$2(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ClassMethod')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isObjectPattern$3(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ObjectPattern')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isSpreadElement$3(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'SpreadElement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isSuper(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'Super')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTaggedTemplateExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TaggedTemplateExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTemplateElement$4(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TemplateElement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTemplateLiteral$4(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TemplateLiteral')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isYieldExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'YieldExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isAwaitExpression$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'AwaitExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isImport(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'Import')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isBigIntLiteral(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'BigIntLiteral')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isExportNamespaceSpecifier$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ExportNamespaceSpecifier')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isOptionalMemberExpression$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'OptionalMemberExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isOptionalCallExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'OptionalCallExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isClassProperty$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ClassProperty')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isClassAccessorProperty(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ClassAccessorProperty')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isClassPrivateProperty(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ClassPrivateProperty')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isClassPrivateMethod(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ClassPrivateMethod')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isPrivateName(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'PrivateName')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isStaticBlock(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'StaticBlock')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isImportAttribute(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ImportAttribute')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isAnyTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'AnyTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isArrayTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ArrayTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isBooleanTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'BooleanTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isBooleanLiteralTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'BooleanLiteralTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isNullLiteralTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'NullLiteralTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isClassImplements(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ClassImplements')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclareClass(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DeclareClass')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclareFunction(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DeclareFunction')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclareInterface(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DeclareInterface')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclareModule(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DeclareModule')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclareModuleExports(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DeclareModuleExports')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclareTypeAlias(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DeclareTypeAlias')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclareOpaqueType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DeclareOpaqueType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclareVariable(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DeclareVariable')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclareExportDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DeclareExportDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclareExportAllDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DeclareExportAllDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclaredPredicate(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DeclaredPredicate')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isExistsTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ExistsTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isFunctionTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'FunctionTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isFunctionTypeParam(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'FunctionTypeParam')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isGenericTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'GenericTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isInferredPredicate(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'InferredPredicate')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isInterfaceExtends(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'InterfaceExtends')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isInterfaceDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'InterfaceDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isInterfaceTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'InterfaceTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isIntersectionTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'IntersectionTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isMixedTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'MixedTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isEmptyTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'EmptyTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isNullableTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'NullableTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isNumberLiteralTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'NumberLiteralTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isNumberTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'NumberTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isObjectTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ObjectTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isObjectTypeInternalSlot(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ObjectTypeInternalSlot')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isObjectTypeCallProperty(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ObjectTypeCallProperty')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isObjectTypeIndexer(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ObjectTypeIndexer')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isObjectTypeProperty(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ObjectTypeProperty')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isObjectTypeSpreadProperty(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ObjectTypeSpreadProperty')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isOpaqueType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'OpaqueType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isQualifiedTypeIdentifier(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'QualifiedTypeIdentifier')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isStringLiteralTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'StringLiteralTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isStringTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'StringTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isSymbolTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'SymbolTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isThisTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ThisTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTupleTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TupleTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTypeofTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TypeofTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTypeAlias(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TypeAlias')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTypeCastExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TypeCastExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTypeParameter(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TypeParameter')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTypeParameterDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TypeParameterDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTypeParameterInstantiation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TypeParameterInstantiation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isUnionTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'UnionTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isVariance(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'Variance')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isVoidTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'VoidTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isEnumDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'EnumDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isEnumBooleanBody(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'EnumBooleanBody')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isEnumNumberBody(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'EnumNumberBody')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isEnumStringBody(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'EnumStringBody')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isEnumSymbolBody(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'EnumSymbolBody')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isEnumBooleanMember(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'EnumBooleanMember')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isEnumNumberMember(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'EnumNumberMember')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isEnumStringMember(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'EnumStringMember')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isEnumDefaultedMember(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'EnumDefaultedMember')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isIndexedAccessType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'IndexedAccessType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isOptionalIndexedAccessType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'OptionalIndexedAccessType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXAttribute$3(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXAttribute')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXClosingElement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXClosingElement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXElement$5(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXElement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXEmptyExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXEmptyExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXExpressionContainer$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXExpressionContainer')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXSpreadChild(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXSpreadChild')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXIdentifier$3(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXIdentifier')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXMemberExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXMemberExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXNamespacedName(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXNamespacedName')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXOpeningElement(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXOpeningElement')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXSpreadAttribute$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXSpreadAttribute')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXText$4(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXText')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXFragment(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXFragment')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXOpeningFragment(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXOpeningFragment')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isJSXClosingFragment(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'JSXClosingFragment')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isPlaceholder(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'Placeholder')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isV8IntrinsicIdentifier(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'V8IntrinsicIdentifier')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isArgumentPlaceholder(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ArgumentPlaceholder')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isBindExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'BindExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDecorator$2(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'Decorator')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isDoExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'DoExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isExportDefaultSpecifier$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ExportDefaultSpecifier')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isModuleExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'ModuleExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTopicReference(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TopicReference')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isPipelineTopicExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'PipelineTopicExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isPipelineBareFunction(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'PipelineBareFunction')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isPipelinePrimaryTopicReference(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'PipelinePrimaryTopicReference')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isVoidPattern(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'VoidPattern')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSParameterProperty(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSParameterProperty')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSDeclareFunction(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSDeclareFunction')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSDeclareMethod(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSDeclareMethod')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSQualifiedName(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSQualifiedName')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSCallSignatureDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSCallSignatureDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSConstructSignatureDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSConstructSignatureDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSPropertySignature$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSPropertySignature')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSMethodSignature(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSMethodSignature')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSIndexSignature(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSIndexSignature')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSAnyKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSAnyKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSBooleanKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSBooleanKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSBigIntKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSBigIntKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSIntrinsicKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSIntrinsicKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSNeverKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSNeverKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSNullKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSNullKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSNumberKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSNumberKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSObjectKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSObjectKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSStringKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSStringKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSSymbolKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSSymbolKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSUndefinedKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSUndefinedKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSUnknownKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSUnknownKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSVoidKeyword(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSVoidKeyword')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSThisType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSThisType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSFunctionType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSFunctionType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSConstructorType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSConstructorType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypeReference$3(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTypeReference')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypePredicate(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTypePredicate')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypeQuery(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTypeQuery')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypeLiteral(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTypeLiteral')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSArrayType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSArrayType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTupleType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTupleType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSOptionalType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSOptionalType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSRestType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSRestType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSNamedTupleMember(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSNamedTupleMember')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSUnionType$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSUnionType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSIntersectionType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSIntersectionType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSConditionalType$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSConditionalType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSInferType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSInferType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSParenthesizedType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSParenthesizedType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypeOperator(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTypeOperator')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSIndexedAccessType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSIndexedAccessType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSMappedType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSMappedType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTemplateLiteralType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTemplateLiteralType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSLiteralType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSLiteralType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSClassImplements(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSClassImplements')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSInterfaceHeritage(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSInterfaceHeritage')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSInterfaceDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSInterfaceDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSInterfaceBody(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSInterfaceBody')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypeAliasDeclaration$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTypeAliasDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSInstantiationExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSInstantiationExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSAsExpression$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSAsExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSSatisfiesExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSSatisfiesExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypeAssertion(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTypeAssertion')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSEnumBody(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSEnumBody')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSEnumDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSEnumDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSEnumMember(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSEnumMember')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSModuleDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSModuleDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSModuleBlock$4(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSModuleBlock')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSImportType(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSImportType')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSImportEqualsDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSImportEqualsDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSExternalModuleReference$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSExternalModuleReference')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSNonNullExpression(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSNonNullExpression')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSExportAssignment(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSExportAssignment')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSNamespaceExportDeclaration(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSNamespaceExportDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypeAnnotation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTypeAnnotation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypeParameterInstantiation(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTypeParameterInstantiation')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypeParameterDeclaration$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTypeParameterDeclaration')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypeParameter$1(node, opts) {
    if (!node)
        return false;
    
    if (node.type !== 'TSTypeParameter')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isStandardized(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ArrayExpression':    
    case 'AssignmentExpression':    
    case 'BinaryExpression':    
    case 'InterpreterDirective':    
    case 'Directive':    
    case 'DirectiveLiteral':    
    case 'BlockStatement':    
    case 'BreakStatement':    
    case 'CallExpression':    
    case 'CatchClause':    
    case 'ConditionalExpression':    
    case 'ContinueStatement':    
    case 'DebuggerStatement':    
    case 'DoWhileStatement':    
    case 'EmptyStatement':    
    case 'ExpressionStatement':    
    case 'File':    
    case 'ForInStatement':    
    case 'ForStatement':    
    case 'FunctionDeclaration':    
    case 'FunctionExpression':    
    case 'Identifier':    
    case 'IfStatement':    
    case 'LabeledStatement':    
    case 'StringLiteral':    
    case 'NumericLiteral':    
    case 'NullLiteral':    
    case 'BooleanLiteral':    
    case 'RegExpLiteral':    
    case 'LogicalExpression':    
    case 'MemberExpression':    
    case 'NewExpression':    
    case 'Program':    
    case 'ObjectExpression':    
    case 'ObjectMethod':    
    case 'ObjectProperty':    
    case 'RestElement':    
    case 'ReturnStatement':    
    case 'SequenceExpression':    
    case 'ParenthesizedExpression':    
    case 'SwitchCase':    
    case 'SwitchStatement':    
    case 'ThisExpression':    
    case 'ThrowStatement':    
    case 'TryStatement':    
    case 'UnaryExpression':    
    case 'UpdateExpression':    
    case 'VariableDeclaration':    
    case 'VariableDeclarator':    
    case 'WhileStatement':    
    case 'WithStatement':    
    case 'AssignmentPattern':    
    case 'ArrayPattern':    
    case 'ArrowFunctionExpression':    
    case 'ClassBody':    
    case 'ClassExpression':    
    case 'ClassDeclaration':    
    case 'ExportAllDeclaration':    
    case 'ExportDefaultDeclaration':    
    case 'ExportNamedDeclaration':    
    case 'ExportSpecifier':    
    case 'ForOfStatement':    
    case 'ImportDeclaration':    
    case 'ImportDefaultSpecifier':    
    case 'ImportNamespaceSpecifier':    
    case 'ImportSpecifier':    
    case 'ImportExpression':    
    case 'MetaProperty':    
    case 'ClassMethod':    
    case 'ObjectPattern':    
    case 'SpreadElement':    
    case 'Super':    
    case 'TaggedTemplateExpression':    
    case 'TemplateElement':    
    case 'TemplateLiteral':    
    case 'YieldExpression':    
    case 'AwaitExpression':    
    case 'Import':    
    case 'BigIntLiteral':    
    case 'ExportNamespaceSpecifier':    
    case 'OptionalMemberExpression':    
    case 'OptionalCallExpression':    
    case 'ClassProperty':    
    case 'ClassAccessorProperty':    
    case 'ClassPrivateProperty':    
    case 'ClassPrivateMethod':    
    case 'PrivateName':    
    case 'StaticBlock':    
    case 'ImportAttribute':
        break;
    
    case 'Placeholder':
        switch(node.expectedNode) {
        case 'Identifier':        
        case 'StringLiteral':        
        case 'BlockStatement':        
        case 'ClassBody':
            break;
        
        default:
            return false;
        }
        
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isExpression$2(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ArrayExpression':    
    case 'AssignmentExpression':    
    case 'BinaryExpression':    
    case 'CallExpression':    
    case 'ConditionalExpression':    
    case 'FunctionExpression':    
    case 'Identifier':    
    case 'StringLiteral':    
    case 'NumericLiteral':    
    case 'NullLiteral':    
    case 'BooleanLiteral':    
    case 'RegExpLiteral':    
    case 'LogicalExpression':    
    case 'MemberExpression':    
    case 'NewExpression':    
    case 'ObjectExpression':    
    case 'SequenceExpression':    
    case 'ParenthesizedExpression':    
    case 'ThisExpression':    
    case 'UnaryExpression':    
    case 'UpdateExpression':    
    case 'ArrowFunctionExpression':    
    case 'ClassExpression':    
    case 'ImportExpression':    
    case 'MetaProperty':    
    case 'TaggedTemplateExpression':    
    case 'TemplateLiteral':    
    case 'YieldExpression':    
    case 'AwaitExpression':    
    case 'Import':    
    case 'BigIntLiteral':    
    case 'OptionalMemberExpression':    
    case 'OptionalCallExpression':    
    case 'TypeCastExpression':    
    case 'JSXElement':    
    case 'JSXFragment':    
    case 'BindExpression':    
    case 'DoExpression':    
    case 'ModuleExpression':    
    case 'TopicReference':    
    case 'PipelineTopicExpression':    
    case 'PipelineBareFunction':    
    case 'PipelinePrimaryTopicReference':    
    case 'TSInstantiationExpression':    
    case 'TSAsExpression':    
    case 'TSSatisfiesExpression':    
    case 'TSTypeAssertion':    
    case 'TSNonNullExpression':
        break;
    
    case 'Placeholder':
        switch(node.expectedNode) {
        case 'Expression':        
        case 'Identifier':        
        case 'StringLiteral':
            break;
        
        default:
            return false;
        }
        
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isBinary(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'BinaryExpression':    
    case 'LogicalExpression':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isScopable(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'BlockStatement':    
    case 'CatchClause':    
    case 'DoWhileStatement':    
    case 'ForInStatement':    
    case 'ForStatement':    
    case 'FunctionDeclaration':    
    case 'FunctionExpression':    
    case 'Program':    
    case 'ObjectMethod':    
    case 'SwitchStatement':    
    case 'WhileStatement':    
    case 'ArrowFunctionExpression':    
    case 'ClassExpression':    
    case 'ClassDeclaration':    
    case 'ForOfStatement':    
    case 'ClassMethod':    
    case 'ClassPrivateMethod':    
    case 'StaticBlock':    
    case 'TSModuleBlock':
        break;
    
    case 'Placeholder':
        if (node.expectedNode === 'BlockStatement')
            break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isBlockParent(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'BlockStatement':    
    case 'CatchClause':    
    case 'DoWhileStatement':    
    case 'ForInStatement':    
    case 'ForStatement':    
    case 'FunctionDeclaration':    
    case 'FunctionExpression':    
    case 'Program':    
    case 'ObjectMethod':    
    case 'SwitchStatement':    
    case 'WhileStatement':    
    case 'ArrowFunctionExpression':    
    case 'ForOfStatement':    
    case 'ClassMethod':    
    case 'ClassPrivateMethod':    
    case 'StaticBlock':    
    case 'TSModuleBlock':
        break;
    
    case 'Placeholder':
        if (node.expectedNode === 'BlockStatement')
            break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isBlock$1(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'BlockStatement':    
    case 'Program':    
    case 'TSModuleBlock':
        break;
    
    case 'Placeholder':
        if (node.expectedNode === 'BlockStatement')
            break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isStatement$7(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'BlockStatement':    
    case 'BreakStatement':    
    case 'ContinueStatement':    
    case 'DebuggerStatement':    
    case 'DoWhileStatement':    
    case 'EmptyStatement':    
    case 'ExpressionStatement':    
    case 'ForInStatement':    
    case 'ForStatement':    
    case 'FunctionDeclaration':    
    case 'IfStatement':    
    case 'LabeledStatement':    
    case 'ReturnStatement':    
    case 'SwitchStatement':    
    case 'ThrowStatement':    
    case 'TryStatement':    
    case 'VariableDeclaration':    
    case 'WhileStatement':    
    case 'WithStatement':    
    case 'ClassDeclaration':    
    case 'ExportAllDeclaration':    
    case 'ExportDefaultDeclaration':    
    case 'ExportNamedDeclaration':    
    case 'ForOfStatement':    
    case 'ImportDeclaration':    
    case 'DeclareClass':    
    case 'DeclareFunction':    
    case 'DeclareInterface':    
    case 'DeclareModule':    
    case 'DeclareModuleExports':    
    case 'DeclareTypeAlias':    
    case 'DeclareOpaqueType':    
    case 'DeclareVariable':    
    case 'DeclareExportDeclaration':    
    case 'DeclareExportAllDeclaration':    
    case 'InterfaceDeclaration':    
    case 'OpaqueType':    
    case 'TypeAlias':    
    case 'EnumDeclaration':    
    case 'TSDeclareFunction':    
    case 'TSInterfaceDeclaration':    
    case 'TSTypeAliasDeclaration':    
    case 'TSEnumDeclaration':    
    case 'TSModuleDeclaration':    
    case 'TSImportEqualsDeclaration':    
    case 'TSExportAssignment':    
    case 'TSNamespaceExportDeclaration':
        break;
    
    case 'Placeholder':
        switch(node.expectedNode) {
        case 'Statement':        
        case 'Declaration':        
        case 'BlockStatement':
            break;
        
        default:
            return false;
        }
        
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isTerminatorless(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'BreakStatement':    
    case 'ContinueStatement':    
    case 'ReturnStatement':    
    case 'ThrowStatement':    
    case 'YieldExpression':    
    case 'AwaitExpression':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isCompletionStatement(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'BreakStatement':    
    case 'ContinueStatement':    
    case 'ReturnStatement':    
    case 'ThrowStatement':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isConditional(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ConditionalExpression':    
    case 'IfStatement':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isLoop(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'DoWhileStatement':    
    case 'ForInStatement':    
    case 'ForStatement':    
    case 'WhileStatement':    
    case 'ForOfStatement':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isWhile(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'DoWhileStatement':    
    case 'WhileStatement':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isExpressionWrapper(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ExpressionStatement':    
    case 'ParenthesizedExpression':    
    case 'TypeCastExpression':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isFor(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ForInStatement':    
    case 'ForStatement':    
    case 'ForOfStatement':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isForXStatement(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ForInStatement':    
    case 'ForOfStatement':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isFunction$8(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'FunctionDeclaration':    
    case 'FunctionExpression':    
    case 'ObjectMethod':    
    case 'ArrowFunctionExpression':    
    case 'ClassMethod':    
    case 'ClassPrivateMethod':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isFunctionParent(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'FunctionDeclaration':    
    case 'FunctionExpression':    
    case 'ObjectMethod':    
    case 'ArrowFunctionExpression':    
    case 'ClassMethod':    
    case 'ClassPrivateMethod':    
    case 'StaticBlock':    
    case 'TSModuleBlock':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isPureish(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'FunctionDeclaration':    
    case 'FunctionExpression':    
    case 'StringLiteral':    
    case 'NumericLiteral':    
    case 'NullLiteral':    
    case 'BooleanLiteral':    
    case 'RegExpLiteral':    
    case 'ArrowFunctionExpression':    
    case 'BigIntLiteral':
        break;
    
    case 'Placeholder':
        if (node.expectedNode === 'StringLiteral')
            break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isDeclaration(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'FunctionDeclaration':    
    case 'VariableDeclaration':    
    case 'ClassDeclaration':    
    case 'ExportAllDeclaration':    
    case 'ExportDefaultDeclaration':    
    case 'ExportNamedDeclaration':    
    case 'ImportDeclaration':    
    case 'DeclareClass':    
    case 'DeclareFunction':    
    case 'DeclareInterface':    
    case 'DeclareModule':    
    case 'DeclareModuleExports':    
    case 'DeclareTypeAlias':    
    case 'DeclareOpaqueType':    
    case 'DeclareVariable':    
    case 'DeclareExportDeclaration':    
    case 'DeclareExportAllDeclaration':    
    case 'InterfaceDeclaration':    
    case 'OpaqueType':    
    case 'TypeAlias':    
    case 'EnumDeclaration':    
    case 'TSDeclareFunction':    
    case 'TSInterfaceDeclaration':    
    case 'TSTypeAliasDeclaration':    
    case 'TSEnumDeclaration':    
    case 'TSModuleDeclaration':    
    case 'TSImportEqualsDeclaration':
        break;
    
    case 'Placeholder':
        if (node.expectedNode === 'Declaration')
            break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isFunctionParameter(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'Identifier':    
    case 'RestElement':    
    case 'AssignmentPattern':    
    case 'ArrayPattern':    
    case 'ObjectPattern':    
    case 'VoidPattern':
        break;
    
    case 'Placeholder':
        if (node.expectedNode === 'Identifier')
            break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isPatternLike(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'Identifier':    
    case 'MemberExpression':    
    case 'RestElement':    
    case 'AssignmentPattern':    
    case 'ArrayPattern':    
    case 'ObjectPattern':    
    case 'VoidPattern':    
    case 'TSAsExpression':    
    case 'TSSatisfiesExpression':    
    case 'TSTypeAssertion':    
    case 'TSNonNullExpression':
        break;
    
    case 'Placeholder':
        switch(node.expectedNode) {
        case 'Pattern':        
        case 'Identifier':
            break;
        
        default:
            return false;
        }
        
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isLVal(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'Identifier':    
    case 'MemberExpression':    
    case 'ArrayPattern':    
    case 'ObjectPattern':    
    case 'TSAsExpression':    
    case 'TSSatisfiesExpression':    
    case 'TSTypeAssertion':    
    case 'TSNonNullExpression':
        break;
    
    case 'Placeholder':
        switch(node.expectedNode) {
        case 'Pattern':        
        case 'Identifier':
            break;
        
        default:
            return false;
        }
        
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isTSEntityName(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'Identifier':    
    case 'ThisExpression':    
    case 'TSQualifiedName':
        break;
    
    case 'Placeholder':
        if (node.expectedNode === 'Identifier')
            break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isLiteral$4(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'StringLiteral':    
    case 'NumericLiteral':    
    case 'NullLiteral':    
    case 'BooleanLiteral':    
    case 'RegExpLiteral':    
    case 'TemplateLiteral':    
    case 'BigIntLiteral':
        break;
    
    case 'Placeholder':
        if (node.expectedNode === 'StringLiteral')
            break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isUserWhitespacable(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ObjectMethod':    
    case 'ObjectProperty':    
    case 'ObjectTypeInternalSlot':    
    case 'ObjectTypeCallProperty':    
    case 'ObjectTypeIndexer':    
    case 'ObjectTypeProperty':    
    case 'ObjectTypeSpreadProperty':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isMethod(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ObjectMethod':    
    case 'ClassMethod':    
    case 'ClassPrivateMethod':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isObjectMember(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ObjectMethod':    
    case 'ObjectProperty':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isProperty$1(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ObjectProperty':    
    case 'ClassProperty':    
    case 'ClassAccessorProperty':    
    case 'ClassPrivateProperty':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isUnaryLike(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'UnaryExpression':    
    case 'SpreadElement':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isPattern(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'AssignmentPattern':    
    case 'ArrayPattern':    
    case 'ObjectPattern':    
    case 'VoidPattern':
        break;
    
    case 'Placeholder':
        if (node.expectedNode === 'Pattern')
            break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isClass(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ClassExpression':    
    case 'ClassDeclaration':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isImportOrExportDeclaration(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ExportAllDeclaration':    
    case 'ExportDefaultDeclaration':    
    case 'ExportNamedDeclaration':    
    case 'ImportDeclaration':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isExportDeclaration$5(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ExportAllDeclaration':    
    case 'ExportDefaultDeclaration':    
    case 'ExportNamedDeclaration':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isModuleSpecifier(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ExportSpecifier':    
    case 'ImportDefaultSpecifier':    
    case 'ImportNamespaceSpecifier':    
    case 'ImportSpecifier':    
    case 'ExportNamespaceSpecifier':    
    case 'ExportDefaultSpecifier':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isAccessor(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ClassAccessorProperty':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isPrivate(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'ClassPrivateProperty':    
    case 'ClassPrivateMethod':    
    case 'PrivateName':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isFlow() {}

function isFlowType() {}

function isFlowBaseAnnotation() {}

function isFlowDeclaration() {}

function isFlowPredicate() {}

function isEnumBody(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'EnumBooleanBody':    
    case 'EnumNumberBody':    
    case 'EnumStringBody':    
    case 'EnumSymbolBody':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isEnumMember(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'EnumBooleanMember':    
    case 'EnumNumberMember':    
    case 'EnumStringMember':    
    case 'EnumDefaultedMember':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isJSX(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'JSXAttribute':    
    case 'JSXClosingElement':    
    case 'JSXElement':    
    case 'JSXEmptyExpression':    
    case 'JSXExpressionContainer':    
    case 'JSXSpreadChild':    
    case 'JSXIdentifier':    
    case 'JSXMemberExpression':    
    case 'JSXNamespacedName':    
    case 'JSXOpeningElement':    
    case 'JSXSpreadAttribute':    
    case 'JSXText':    
    case 'JSXFragment':    
    case 'JSXOpeningFragment':    
    case 'JSXClosingFragment':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isMiscellaneous(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'Placeholder':    
    case 'V8IntrinsicIdentifier':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isTypeScript(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'TSParameterProperty':    
    case 'TSDeclareFunction':    
    case 'TSDeclareMethod':    
    case 'TSQualifiedName':    
    case 'TSCallSignatureDeclaration':    
    case 'TSConstructSignatureDeclaration':    
    case 'TSPropertySignature':    
    case 'TSMethodSignature':    
    case 'TSIndexSignature':    
    case 'TSAnyKeyword':    
    case 'TSBooleanKeyword':    
    case 'TSBigIntKeyword':    
    case 'TSIntrinsicKeyword':    
    case 'TSNeverKeyword':    
    case 'TSNullKeyword':    
    case 'TSNumberKeyword':    
    case 'TSObjectKeyword':    
    case 'TSStringKeyword':    
    case 'TSSymbolKeyword':    
    case 'TSUndefinedKeyword':    
    case 'TSUnknownKeyword':    
    case 'TSVoidKeyword':    
    case 'TSThisType':    
    case 'TSFunctionType':    
    case 'TSConstructorType':    
    case 'TSTypeReference':    
    case 'TSTypePredicate':    
    case 'TSTypeQuery':    
    case 'TSTypeLiteral':    
    case 'TSArrayType':    
    case 'TSTupleType':    
    case 'TSOptionalType':    
    case 'TSRestType':    
    case 'TSNamedTupleMember':    
    case 'TSUnionType':    
    case 'TSIntersectionType':    
    case 'TSConditionalType':    
    case 'TSInferType':    
    case 'TSParenthesizedType':    
    case 'TSTypeOperator':    
    case 'TSIndexedAccessType':    
    case 'TSMappedType':    
    case 'TSTemplateLiteralType':    
    case 'TSLiteralType':    
    case 'TSClassImplements':    
    case 'TSInterfaceHeritage':    
    case 'TSInterfaceDeclaration':    
    case 'TSInterfaceBody':    
    case 'TSTypeAliasDeclaration':    
    case 'TSInstantiationExpression':    
    case 'TSAsExpression':    
    case 'TSSatisfiesExpression':    
    case 'TSTypeAssertion':    
    case 'TSEnumBody':    
    case 'TSEnumDeclaration':    
    case 'TSEnumMember':    
    case 'TSModuleDeclaration':    
    case 'TSModuleBlock':    
    case 'TSImportType':    
    case 'TSImportEqualsDeclaration':    
    case 'TSExternalModuleReference':    
    case 'TSNonNullExpression':    
    case 'TSExportAssignment':    
    case 'TSNamespaceExportDeclaration':    
    case 'TSTypeAnnotation':    
    case 'TSTypeParameterInstantiation':    
    case 'TSTypeParameterDeclaration':    
    case 'TSTypeParameter':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isTSTypeElement(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'TSCallSignatureDeclaration':    
    case 'TSConstructSignatureDeclaration':    
    case 'TSPropertySignature':    
    case 'TSMethodSignature':    
    case 'TSIndexSignature':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isTSType(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'TSAnyKeyword':    
    case 'TSBooleanKeyword':    
    case 'TSBigIntKeyword':    
    case 'TSIntrinsicKeyword':    
    case 'TSNeverKeyword':    
    case 'TSNullKeyword':    
    case 'TSNumberKeyword':    
    case 'TSObjectKeyword':    
    case 'TSStringKeyword':    
    case 'TSSymbolKeyword':    
    case 'TSUndefinedKeyword':    
    case 'TSUnknownKeyword':    
    case 'TSVoidKeyword':    
    case 'TSThisType':    
    case 'TSFunctionType':    
    case 'TSConstructorType':    
    case 'TSTypeReference':    
    case 'TSTypePredicate':    
    case 'TSTypeQuery':    
    case 'TSTypeLiteral':    
    case 'TSArrayType':    
    case 'TSTupleType':    
    case 'TSOptionalType':    
    case 'TSRestType':    
    case 'TSUnionType':    
    case 'TSIntersectionType':    
    case 'TSConditionalType':    
    case 'TSInferType':    
    case 'TSParenthesizedType':    
    case 'TSTypeOperator':    
    case 'TSIndexedAccessType':    
    case 'TSMappedType':    
    case 'TSTemplateLiteralType':    
    case 'TSLiteralType':    
    case 'TSClassImplements':    
    case 'TSInterfaceHeritage':    
    case 'TSImportType':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isTSBaseType(node, opts) {
    if (!node)
        return false;
    
    switch(node.type) {
    case 'TSAnyKeyword':    
    case 'TSBooleanKeyword':    
    case 'TSBigIntKeyword':    
    case 'TSIntrinsicKeyword':    
    case 'TSNeverKeyword':    
    case 'TSNullKeyword':    
    case 'TSNumberKeyword':    
    case 'TSObjectKeyword':    
    case 'TSStringKeyword':    
    case 'TSSymbolKeyword':    
    case 'TSUndefinedKeyword':    
    case 'TSUnknownKeyword':    
    case 'TSVoidKeyword':    
    case 'TSThisType':    
    case 'TSTemplateLiteralType':    
    case 'TSLiteralType':
        break;
    
    default:
        return false;
    }
    
    
    return opts == null || shallowEqual(node, opts);
}

function isNumberLiteral(node, opts) {
    deprecationWarning('isNumberLiteral', 'isNumericLiteral');
    
    if (!node)
        return false;
    
    if (node.type !== 'NumberLiteral')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isRegexLiteral(node, opts) {
    deprecationWarning('isRegexLiteral', 'isRegExpLiteral');
    
    if (!node)
        return false;
    
    if (node.type !== 'RegexLiteral')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isRestProperty(node, opts) {
    deprecationWarning('isRestProperty', 'isRestElement');
    
    if (!node)
        return false;
    
    if (node.type !== 'RestProperty')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isSpreadProperty(node, opts) {
    deprecationWarning('isSpreadProperty', 'isSpreadElement');
    
    if (!node)
        return false;
    
    if (node.type !== 'SpreadProperty')
        return false;
    
    return opts == null || shallowEqual(node, opts);
}

function isModuleDeclaration(node, opts) {
    deprecationWarning('isModuleDeclaration', 'isImportOrExportDeclaration');
    return isImportOrExportDeclaration(node, opts);
}

function isMemberExpressionLike(node) {
    return isMemberExpression$9(node) || isMetaProperty(node);
}

function matchesPattern$1(member, match, allowPartial) {
    if (!isMemberExpressionLike(member))
        return false;
    
    const parts = Array.isArray(match) ? match : match.split('.');
    const nodes2 = [];
    let node;
    
    for (node = member; isMemberExpressionLike(node); node = node.object ?? node.meta) {
        nodes2.push(node.property);
    }
    
    nodes2.push(node);
    
    if (nodes2.length < parts.length)
        return false;
    
    if (!allowPartial && nodes2.length > parts.length)
        return false;
    
    for (let i = 0, j = nodes2.length - 1; i < parts.length; (i++, j--)) {
        const node2 = nodes2[j];
        let value;
        
        if (isIdentifier$h(node2)) {
            value = node2.name;
        } else if (isStringLiteral$a(node2)) {
            value = node2.value;
        } else if (isThisExpression(node2)) {
            value = 'this';
        } else if (isSuper(node2)) {
            value = 'super';
        } else if (isPrivateName(node2)) {
            value = '#' + node2.id.name;
        } else {
            return false;
        }


        
        if (parts[i] !== value)
            return false;
    }
    
    return true;
}

function buildMatchMemberExpression(match, allowPartial) {
    const parts = match.split('.');
    return (member) => matchesPattern$1(member, parts, allowPartial);
}

var isReactComponent = buildMatchMemberExpression('React.Component');

function isCompatTag(tagName) {
    return !!tagName && /^[a-z]/.test(tagName);
}

function isType(nodeType, targetType) {
    if (nodeType === targetType)
        return true;
    
    if (nodeType == null)
        return false;
    
    if (ALIAS_KEYS[targetType])
        return false;
    
    const aliases = FLIPPED_ALIAS_KEYS[targetType];
    
    if (aliases?.includes(nodeType))
        return true;
    
    return false;
}

function isPlaceholderType(placeholderType, targetType) {
    if (placeholderType === targetType)
        return true;
    
    const aliases = PLACEHOLDERS_ALIAS[placeholderType];
    
    if (aliases?.includes(targetType))
        return true;
    
    return false;
}

function is$1(type, node, opts) {
    if (!node)
        return false;
    
    const matches = isType(node.type, type);
    
    if (!matches) {
        if (!opts && node.type === 'Placeholder' && type in FLIPPED_ALIAS_KEYS) {
            return isPlaceholderType(node.expectedNode, type);
        }
        
        return false;
    }
    
    if (opts === void 0) {
        return true;
    } else {
        return shallowEqual(node, opts);
    }
}

function isValidIdentifier(name, reserved = true) {
    if (typeof name !== 'string')
        return false;
    
    if (reserved) {
        if (isKeyword$1(name) || isStrictReservedWord(name, true)) {
            return false;
        }
    }
    
    return isIdentifierName(name);
}

var STATEMENT_OR_BLOCK_KEYS = [
    'consequent',
    'body',
    'alternate',
];
var FLATTENABLE_KEYS = ['body', 'expressions'];
var FOR_INIT_KEYS = [
    'left',
    'init',
];
var COMMENT_KEYS = [
    'leadingComments',
    'trailingComments',
    'innerComments',
];
var LOGICAL_OPERATORS = [
    '||',
    '&&',
    '??',
];
var UPDATE_OPERATORS = [
    '++',
    '--',
];
var BOOLEAN_NUMBER_BINARY_OPERATORS = [
    '>',
    '<',
    '>=',
    '<=',
];
var EQUALITY_BINARY_OPERATORS = [
    '==',
    '===',
    '!=',
    '!==',
];
var COMPARISON_BINARY_OPERATORS = [
    ...EQUALITY_BINARY_OPERATORS,
    'in',
    'instanceof',
];
var BOOLEAN_BINARY_OPERATORS = [
    ...COMPARISON_BINARY_OPERATORS,
    ...BOOLEAN_NUMBER_BINARY_OPERATORS,
];
var NUMBER_BINARY_OPERATORS = [
    '-',
    '/',
    '%',
    '*',
    '**',
    '&',
    '|',
    '>>',
    '>>>',
    '<<',
    '^',
];
var BINARY_OPERATORS = [
    '+',
    ...NUMBER_BINARY_OPERATORS,
    ...BOOLEAN_BINARY_OPERATORS,
    '|>',
];
var ASSIGNMENT_OPERATORS = [
    '=',
    '+=',
    ...NUMBER_BINARY_OPERATORS.map((op) => op + '='),
    ...LOGICAL_OPERATORS.map((op) => op + '='),
];
var BOOLEAN_UNARY_OPERATORS = [
    'delete',
    '!',
];
var NUMBER_UNARY_OPERATORS = [
    '+',
    '-',
    '~',
];
var STRING_UNARY_OPERATORS = ['typeof'];
var UNARY_OPERATORS = [
    'void',
    'throw',
    ...BOOLEAN_UNARY_OPERATORS,
    ...NUMBER_UNARY_OPERATORS,
    ...STRING_UNARY_OPERATORS,
];

var INHERIT_KEYS = {
    optional: [
        'typeAnnotation',
        'typeParameters',
        'returnType',
    ],
    force: [
        'start',
        'loc',
        'end',
    ],
};

var VISITOR_KEYS = {};
var ALIAS_KEYS = {};
var FLIPPED_ALIAS_KEYS = {};
var NODE_FIELDS$1 = {};
var BUILDER_KEYS = {};
var DEPRECATED_KEYS = {};
var NODE_PARENT_VALIDATIONS = {};
var NODE_UNION_SHAPES__PRIVATE = {};

function getType$1(val) {
    if (Array.isArray(val)) {
        return 'array';
    } else if (val === null) {
        return 'null';
    } else {
        return typeof val;
    }
}

function validate$2(validate4) {
    return {
        validate: validate4,
    };
}

function validateType(...typeNames) {
    return validate$2(assertNodeType(...typeNames));
}

function validateOptional(validate4) {
    return {
        validate: validate4,
        optional: true,
    };
}

function validateOptionalType(...typeNames) {
    return {
        validate: assertNodeType(...typeNames),
        optional: true,
    };
}

function arrayOf(elementType) {
    return chain$2(assertValueType('array'), assertEach(elementType));
}

function arrayOfType(...typeNames) {
    return arrayOf(assertNodeType(...typeNames));
}

function validateArrayOfType(...typeNames) {
    return validate$2(arrayOfType(...typeNames));
}

function assertEach(callback) {
    const childValidator = validateChild;
    
    function validator(node, key, val) {
        if (!Array.isArray(val))
            return;
        
        let i = 0;
        const subKey = {
            toString() {
                return `${key}[${i}]`;
            },
        };
        
        for (; i < val.length; i++) {
            const v = val[i];
            callback(node, subKey, v);
            childValidator(node, subKey, v);
        }
    }
    
    validator.each = callback;
    return validator;
}

function assertOneOf(...values) {
    function validate4(node, key, val) {
        if (!values.includes(val)) {
            throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
        }
    }
    
    validate4.oneOf = values;
    return validate4;
}

var allExpandedTypes = [];

function assertNodeType(...types2) {
    const expandedTypes =     /* @__PURE__ */new Set();
    
    allExpandedTypes.push({
        types: types2,
        set: expandedTypes,
    });
    function validate4(node, key, val) {
        const valType = val?.type;
        
        if (valType != null) {
            if (expandedTypes.has(valType)) {
                validateChild(node, key, val);
                return;
            }
            
            if (valType === 'Placeholder') {
                for (const type of types2) {
                    if (is$1(type, val)) {
                        validateChild(node, key, val);
                        return;
                    }
                }
            }
        }
        
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types2)} but instead got ${JSON.stringify(valType)}`);
    }
    
    validate4.oneOfNodeTypes = types2;
    
    return validate4;
}

function assertNodeOrValueType(...types2) {
    function validate4(node, key, val) {
        const primitiveType = getType$1(val);
        
        for (const type of types2) {
            if (primitiveType === type || is$1(type, val)) {
                validateChild(node, key, val);
                return;
            }
        }
        
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types2)} but instead got ${JSON.stringify(val?.type)}`);
    }
    
    validate4.oneOfNodeOrValueTypes = types2;
    
    return validate4;
}

function assertValueType(type) {
    function validate4(node, key, val) {
        if (getType$1(val) === type) {
            return;
        }
        
        throw new TypeError(`Property ${key} expected type of ${type} but got ${getType$1(val)}`);
    }
    
    validate4.type = type;
    
    return validate4;
}

function assertShape(shape) {
    const keys2 = Object.keys(shape);
    
    function validate4(node, key, val) {
        const errors = [];
        
        for (const property of keys2) {
            try {
                validateField(node, property, val[property], shape[property]);
            } catch(error) {
                if (error instanceof TypeError) {
                    errors.push(error.message);
                    continue;
                }
                
                throw error;
            }
        }
        
        if (errors.length) {
            throw new TypeError(`Property ${key} of ${node.type} expected to have the following:
${errors.join('\n')}`);
        }
    }
    
    validate4.shapeOf = shape;
    
    return validate4;
}

function assertOptionalChainStart() {
    function validate4(node) {
        let current = node;
        
        while (node) {
            const {type} = current;
            
            if (type === 'OptionalCallExpression') {
                if (current.optional)
                    return;
                
                current = current.callee;
                continue;
            }
            
            if (type === 'OptionalMemberExpression') {
                if (current.optional)
                    return;
                
                current = current.object;
                continue;
            }
            
            break;
        }
        
        throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${current?.type}`);
    }
    
    return validate4;
}

function chain$2(...fns) {
    function validate4(...args) {
        for (const fn of fns) {
            fn(...args);
        }
    }
    
    validate4.chainOf = fns;
    
    if (fns.length >= 2 && 'type' in fns[0] && fns[0].type === 'array' && !('each' in fns[1])) {
        throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
    }
    
    return validate4;
}

var validTypeOpts = /* @__PURE__ */new Set([
    'aliases',
    'builder',
    'deprecatedAlias',
    'fields',
    'inherits',
    'visitor',
    'validate',
    'unionShape',
]);
var validFieldKeys = /* @__PURE__ */new Set([
    'default',
    'optional',
    'deprecated',
    'validate',
]);
var store = {};

function defineAliasedType(...aliases) {
    return (type, opts = {}) => {
        let defined = opts.aliases;
        
        if (!defined) {
            if (opts.inherits)
                defined = store[opts.inherits].aliases?.slice();
            
            defined ??= [];
            opts.aliases = defined;
        }
        
        const additional = aliases.filter((a) => !defined.includes(a));
        defined.unshift(...additional);
        defineType$5(type, opts);
    };
}

function defineType$5(type, opts = {}) {
    const inherits3 = opts.inherits && store[opts.inherits] || {};
    let fields = opts.fields;
    
    if (!fields) {
        fields = {};
        
        if (inherits3.fields) {
            const keys2 = Object.getOwnPropertyNames(inherits3.fields);
            
            for (const key of keys2) {
                const field = inherits3.fields[key];
                const def = field.default;
                
                if (Array.isArray(def) ? def.length > 0 : def && typeof def === 'object') {
                    throw new Error('field defaults can only be primitives or empty arrays currently');
                }
                
                fields[key] = {
                    default: Array.isArray(def) ? [] : def,
                    optional: field.optional,
                    deprecated: field.deprecated,
                    validate: field.validate,
                };
            }
        }
    }
    
    const visitor = opts.visitor || inherits3.visitor || [];
    const aliases = opts.aliases || inherits3.aliases || [];
    const builder = opts.builder
        || inherits3.builder
        || opts.visitor
        || [];
    
    for (const k of Object.keys(opts)) {
        if (!validTypeOpts.has(k)) {
            throw new Error(`Unknown type option "${k}" on ${type}`);
        }
    }
    
    if (opts.deprecatedAlias) {
        DEPRECATED_KEYS[opts.deprecatedAlias] = type;
    }
    
    for (const key of visitor.concat(builder)) {
        fields[key] = fields[key] || {};
    }
    
    for (const key of Object.keys(fields)) {
        const field = fields[key];
        
        if (field.default !== void 0 && !builder.includes(key)) {
            field.optional = true;
        }
        
        if (field.default === void 0) {
            field.default = null;
        } else if (!field.validate && field.default != null) {
            field.validate = assertValueType(getType$1(field.default));
        }
        
        for (const k of Object.keys(field)) {
            if (!validFieldKeys.has(k)) {
                throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
            }
        }
    }
    
    VISITOR_KEYS[type] =
    opts.visitor = visitor;
    BUILDER_KEYS[type] =
    opts.builder = builder;
    NODE_FIELDS$1[type] =
    opts.fields = fields;
    ALIAS_KEYS[type] =
    opts.aliases = aliases;
    aliases.forEach((alias2) => {
        FLIPPED_ALIAS_KEYS[alias2] = FLIPPED_ALIAS_KEYS[alias2] || [];
        FLIPPED_ALIAS_KEYS[alias2].push(type);
    });
    
    if (opts.validate) {
        NODE_PARENT_VALIDATIONS[type] = opts.validate;
    }
    
    if (opts.unionShape) {
        NODE_UNION_SHAPES__PRIVATE[type] = opts.unionShape;
    }
    
    store[type] = opts;
}

var utils$1 = /* @__PURE__ */Object.freeze({
    __proto__: null,
    ALIAS_KEYS,
    BUILDER_KEYS,
    DEPRECATED_KEYS,
    FLIPPED_ALIAS_KEYS,
    NODE_FIELDS: NODE_FIELDS$1,
    NODE_PARENT_VALIDATIONS,
    NODE_UNION_SHAPES__PRIVATE,
    VISITOR_KEYS,
    allExpandedTypes,
    arrayOf,
    arrayOfType,
    assertEach,
    assertNodeOrValueType,
    assertNodeType,
    assertOneOf,
    assertOptionalChainStart,
    assertShape,
    assertValueType,
    chain: chain$2,
    default: defineType$5,
    defineAliasedType,
    validate: validate$2,
    validateArrayOfType,
    validateOptional,
    validateOptionalType,
    validateType,
});

var classMethodOrPropertyUnionShapeCommon = (allowPrivateName = false) => ({
    unionShape: {
        discriminator: 'computed',
        shapes: [{
            name: 'computed',
            value: [true],
            properties: {
                key: {
                    validate: assertNodeType('Expression'),
                },
            },
        }, {
            name: 'nonComputed',
            value: [false],
            properties: {
                key: {
                    validate: allowPrivateName ? assertNodeType('Identifier', 'StringLiteral', 'NumericLiteral', 'BigIntLiteral', 'PrivateName') : assertNodeType('Identifier', 'StringLiteral', 'NumericLiteral', 'BigIntLiteral'),
                },
            },
        }],
    },
});

var defineType$4 = defineAliasedType('Standardized');

defineType$4('ArrayExpression', {
    fields: {
        elements: {
            validate: arrayOf(assertNodeOrValueType('null', 'Expression', 'SpreadElement')),
            default: void 0,
        },
    },
    visitor: ['elements'],
    aliases: ['Expression'],
});
defineType$4('AssignmentExpression', {
    fields: {
        operator: {
            validate: Object.assign((function() {
                const identifier4 = assertOneOf(...ASSIGNMENT_OPERATORS);
                const pattern = assertOneOf('=');
                
                return function(node, key, val) {
                    const validator = is$1('Pattern', node.left) ? pattern : identifier4;
                    validator(node, key, val);
                };
            })(), {
                oneOf: ASSIGNMENT_OPERATORS,
            }),
        },
        left: {
            validate: assertNodeType('Identifier', 'MemberExpression', 'OptionalMemberExpression', 'ArrayPattern', 'ObjectPattern', 'TSAsExpression', 'TSSatisfiesExpression', 'TSTypeAssertion', 'TSNonNullExpression'),
        },
        right: {
            validate: assertNodeType('Expression'),
        },
    },
    builder: [
        'operator',
        'left',
        'right',
    ],
    visitor: ['left', 'right'],
    aliases: ['Expression'],
});
defineType$4('BinaryExpression', {
    builder: [
        'operator',
        'left',
        'right',
    ],
    fields: {
        operator: {
            validate: assertOneOf(...BINARY_OPERATORS),
        },
        left: {
            validate: (function() {
                const expression2 = assertNodeType('Expression');
                const inOp = assertNodeType('Expression', 'PrivateName');
                const validator = Object.assign(function(node, key, val) {
                    const validator2 = node.operator === 'in' ? inOp : expression2;
                    validator2(node, key, val);
                }, {
                    oneOfNodeTypes: ['Expression', 'PrivateName'],
                });
                
                return validator;
            })(),
        },
        right: {
            validate: assertNodeType('Expression'),
        },
    },
    visitor: ['left', 'right'],
    aliases: ['Binary', 'Expression'],
});
defineType$4('InterpreterDirective', {
    builder: ['value'],
    fields: {
        value: {
            validate: assertValueType('string'),
        },
    },
});
defineType$4('Directive', {
    visitor: ['value'],
    fields: {
        value: {
            validate: assertNodeType('DirectiveLiteral'),
        },
    },
});
defineType$4('DirectiveLiteral', {
    builder: ['value'],
    fields: {
        value: {
            validate: assertValueType('string'),
        },
    },
});
defineType$4('BlockStatement', {
    builder: ['body', 'directives'],
    visitor: ['directives', 'body'],
    fields: {
        directives: {
            validate: arrayOfType('Directive'),
            default: [],
        },
        body: validateArrayOfType('Statement'),
    },
    aliases: [
        'Scopable',
        'BlockParent',
        'Block',
        'Statement',
    ],
});
defineType$4('BreakStatement', {
    visitor: ['label'],
    fields: {
        label: {
            validate: assertNodeType('Identifier'),
            optional: true,
        },
    },
    aliases: [
        'Statement',
        'Terminatorless',
        'CompletionStatement',
    ],
});
defineType$4('CallExpression', {
    visitor: [
        'callee',
        'typeArguments',
        'arguments',
    ],
    builder: ['callee', 'arguments'],
    aliases: ['Expression'],
    fields: {
        callee: {
            validate: assertNodeType('Expression', 'Super', 'V8IntrinsicIdentifier'),
        },
        arguments: validateArrayOfType('Expression', 'SpreadElement', 'ArgumentPlaceholder'),
        typeArguments: {
            validate: assertNodeType('TypeParameterInstantiation', 'TSTypeParameterInstantiation'),
            optional: true,
        },
    },
});
defineType$4('CatchClause', {
    visitor: ['param', 'body'],
    fields: {
        param: {
            validate: assertNodeType('Identifier', 'ArrayPattern', 'ObjectPattern'),
            optional: true,
        },
        body: {
            validate: assertNodeType('BlockStatement'),
        },
    },
    aliases: ['Scopable', 'BlockParent'],
});
defineType$4('ConditionalExpression', {
    visitor: [
        'test',
        'consequent',
        'alternate',
    ],
    fields: {
        test: {
            validate: assertNodeType('Expression'),
        },
        consequent: {
            validate: assertNodeType('Expression'),
        },
        alternate: {
            validate: assertNodeType('Expression'),
        },
    },
    aliases: ['Expression', 'Conditional'],
});
defineType$4('ContinueStatement', {
    visitor: ['label'],
    fields: {
        label: {
            validate: assertNodeType('Identifier'),
            optional: true,
        },
    },
    aliases: [
        'Statement',
        'Terminatorless',
        'CompletionStatement',
    ],
});
defineType$4('DebuggerStatement', {
    aliases: ['Statement'],
});
defineType$4('DoWhileStatement', {
    builder: ['test', 'body'],
    visitor: ['body', 'test'],
    fields: {
        test: {
            validate: assertNodeType('Expression'),
        },
        body: {
            validate: assertNodeType('Statement'),
        },
    },
    aliases: [
        'Statement',
        'BlockParent',
        'Loop',
        'While',
        'Scopable',
    ],
});
defineType$4('EmptyStatement', {
    aliases: ['Statement'],
});
defineType$4('ExpressionStatement', {
    visitor: ['expression'],
    fields: {
        expression: {
            validate: assertNodeType('Expression'),
        },
    },
    aliases: ['Statement', 'ExpressionWrapper'],
});
defineType$4('File', {
    builder: [
        'program',
        'comments',
        'tokens',
    ],
    visitor: ['program'],
    fields: {
        program: {
            validate: assertNodeType('Program'),
        },
        comments: {
            validate: assertEach(assertNodeType('CommentBlock', 'CommentLine')),
            optional: true,
        },
        tokens: {
            validate: assertEach(Object.assign(() => {}, {
                type: 'any',
            })),
            optional: true,
        },
    },
});
defineType$4('ForInStatement', {
    visitor: [
        'left',
        'right',
        'body',
    ],
    aliases: [
        'Scopable',
        'Statement',
        'For',
        'BlockParent',
        'Loop',
        'ForXStatement',
    ],
    fields: {
        left: {
            validate: assertNodeType('VariableDeclaration', 'Identifier', 'MemberExpression', 'ArrayPattern', 'ObjectPattern', 'TSAsExpression', 'TSSatisfiesExpression', 'TSTypeAssertion', 'TSNonNullExpression'),
        },
        right: {
            validate: assertNodeType('Expression'),
        },
        body: {
            validate: assertNodeType('Statement'),
        },
    },
});
defineType$4('ForStatement', {
    visitor: [
        'init',
        'test',
        'update',
        'body',
    ],
    aliases: [
        'Scopable',
        'Statement',
        'For',
        'BlockParent',
        'Loop',
    ],
    fields: {
        init: {
            validate: assertNodeType('VariableDeclaration', 'Expression'),
            optional: true,
        },
        test: {
            validate: assertNodeType('Expression'),
            optional: true,
        },
        update: {
            validate: assertNodeType('Expression'),
            optional: true,
        },
        body: {
            validate: assertNodeType('Statement'),
        },
    },
});
var functionCommon = () => ({
    params: validateArrayOfType('FunctionParameter'),
    generator: {
        default: false,
    },
    async: {
        default: false,
    },
});

var functionTypeAnnotationCommon = () => ({
    returnType: {
        validate: assertNodeType('TypeAnnotation', 'TSTypeAnnotation'),
        optional: true,
    },
    typeParameters: {
        validate: assertNodeType('TypeParameterDeclaration', 'TSTypeParameterDeclaration'),
        optional: true,
    },
});

var functionDeclarationCommon = () => ({
    ...functionCommon(),
    declare: {
        validate: assertValueType('boolean'),
        optional: true,
    },
    id: {
        validate: assertNodeType('Identifier'),
        optional: true,
    },
});

defineType$4('FunctionDeclaration', {
    builder: [
        'id',
        'params',
        'body',
        'generator',
        'async',
    ],
    visitor: [
        'id',
        'typeParameters',
        'params',
        'predicate',
        'returnType',
        'body',
    ],
    fields: {
        ...functionDeclarationCommon(),
        ...functionTypeAnnotationCommon(),
        body: {
            validate: assertNodeType('BlockStatement'),
        },
        predicate: {
            validate: assertNodeType('DeclaredPredicate', 'InferredPredicate'),
            optional: true,
        },
    },
    aliases: [
        'Scopable',
        'Function',
        'BlockParent',
        'FunctionParent',
        'Statement',
        'Pureish',
        'Declaration',
    ],
    validate: (function() {
        const identifier4 = assertNodeType('Identifier');
        
        return function(parent, key, node) {
            if (!is$1('ExportDefaultDeclaration', parent)) {
                identifier4(node, 'id', node.id);
            }
        };
    })(),
});
defineType$4('FunctionExpression', {
    inherits: 'FunctionDeclaration',
    aliases: [
        'Scopable',
        'Function',
        'BlockParent',
        'FunctionParent',
        'Expression',
        'Pureish',
    ],
    fields: {
        ...functionCommon(),
        ...functionTypeAnnotationCommon(),
        id: {
            validate: assertNodeType('Identifier'),
            optional: true,
        },
        body: {
            validate: assertNodeType('BlockStatement'),
        },
        predicate: {
            validate: assertNodeType('DeclaredPredicate', 'InferredPredicate'),
            optional: true,
        },
    },
});
var patternLikeCommon = () => ({
    typeAnnotation: {
        validate: assertNodeType('TypeAnnotation', 'TSTypeAnnotation'),
        optional: true,
    },
    optional: {
        validate: assertValueType('boolean'),
        optional: true,
    },
    decorators: {
        validate: arrayOfType('Decorator'),
        optional: true,
    },
});

defineType$4('Identifier', {
    builder: ['name'],
    visitor: ['typeAnnotation', 'decorators'],
    aliases: [
        'Expression',
        'FunctionParameter',
        'PatternLike',
        'LVal',
        'TSEntityName',
    ],
    fields: {
        ...patternLikeCommon(),
        name: {
            validate: chain$2(assertValueType('string'), Object.assign(function(node, key, val) {
                if (!isValidIdentifier(val, false)) {
                    throw new TypeError(`"${val}" is not a valid identifier name`);
                }
            }, {
                type: 'string',
            })),
        },
    },
    validate: function(parent, key, node) {
        const match = /\.(\w+)$/.exec(key.toString());
        
        if (!match)
            return;
        
        const [, parentKey] = match;
        
        const nonComp = {
            computed: false,
        };
        
        if (parentKey === 'property') {
            if (is$1('MemberExpression', parent, nonComp))
                return;
            
            if (is$1('OptionalMemberExpression', parent, nonComp))
                return;
        } else if (parentKey === 'key') {
            if (is$1('Property', parent, nonComp))
                return;
            
            if (is$1('Method', parent, nonComp))
                return;
        } else if (parentKey === 'exported') {
            if (is$1('ExportSpecifier', parent))
                return;
        } else if (parentKey === 'imported') {
            if (is$1('ImportSpecifier', parent, {imported: node}))
                return;
        } else if (parentKey === 'meta') {
            if (is$1('MetaProperty', parent, {meta: node}))
                return;
        }


        
        if ((isKeyword$1(node.name) || isReservedWord(node.name, false)) && node.name !== 'this') {
            throw new TypeError(`"${node.name}" is not a valid identifier`);
        }
    },
});
defineType$4('IfStatement', {
    visitor: [
        'test',
        'consequent',
        'alternate',
    ],
    aliases: ['Statement', 'Conditional'],
    fields: {
        test: {
            validate: assertNodeType('Expression'),
        },
        consequent: {
            validate: assertNodeType('Statement'),
        },
        alternate: {
            optional: true,
            validate: assertNodeType('Statement'),
        },
    },
});
defineType$4('LabeledStatement', {
    visitor: ['label', 'body'],
    aliases: ['Statement'],
    fields: {
        label: {
            validate: assertNodeType('Identifier'),
        },
        body: {
            validate: assertNodeType('Statement'),
        },
    },
});
defineType$4('StringLiteral', {
    builder: ['value'],
    fields: {
        value: {
            validate: assertValueType('string'),
        },
    },
    aliases: [
        'Expression',
        'Pureish',
        'Literal',
        'Immutable',
    ],
});
defineType$4('NumericLiteral', {
    builder: ['value'],
    deprecatedAlias: 'NumberLiteral',
    fields: {
        value: {
            validate: chain$2(assertValueType('number'), Object.assign(function(node, key, val) {
                if (1 / val < 0 || !Number.isFinite(val)) {
                    const error = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${val}) instead.`);
                    
                    if (!new Error().stack.includes('regenerator')) {
                        throw error;
                    }
                }
            }, {
                type: 'number',
            })),
        },
    },
    aliases: [
        'Expression',
        'Pureish',
        'Literal',
        'Immutable',
    ],
});
defineType$4('NullLiteral', {
    aliases: [
        'Expression',
        'Pureish',
        'Literal',
        'Immutable',
    ],
});
defineType$4('BooleanLiteral', {
    builder: ['value'],
    fields: {
        value: {
            validate: assertValueType('boolean'),
        },
    },
    aliases: [
        'Expression',
        'Pureish',
        'Literal',
        'Immutable',
    ],
});
defineType$4('RegExpLiteral', {
    builder: ['pattern', 'flags'],
    deprecatedAlias: 'RegexLiteral',
    aliases: [
        'Expression',
        'Pureish',
        'Literal',
    ],
    fields: {
        pattern: {
            validate: assertValueType('string'),
        },
        flags: {
            validate: chain$2(assertValueType('string'), Object.assign(function(node, key, val) {
                const invalid = /[^dgimsuvy]/.exec(val);
                
                if (invalid) {
                    throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
                }
            }, {
                type: 'string',
            })),
            default: '',
        },
    },
});
defineType$4('LogicalExpression', {
    builder: [
        'operator',
        'left',
        'right',
    ],
    visitor: ['left', 'right'],
    aliases: ['Binary', 'Expression'],
    fields: {
        operator: {
            validate: assertOneOf(...LOGICAL_OPERATORS),
        },
        left: {
            validate: assertNodeType('Expression'),
        },
        right: {
            validate: assertNodeType('Expression'),
        },
    },
});
defineType$4('MemberExpression', {
    builder: [
        'object',
        'property',
        'computed',
        ...[],
    ],
    visitor: ['object', 'property'],
    aliases: [
        'Expression',
        'LVal',
        'PatternLike',
    ],
    unionShape: {
        discriminator: 'computed',
        shapes: [{
            name: 'computed',
            value: [true],
            properties: {
                property: {
                    validate: assertNodeType('Expression'),
                },
            },
        }, {
            name: 'nonComputed',
            value: [false],
            properties: {
                property: {
                    validate: assertNodeType('Identifier', 'PrivateName'),
                },
            },
        }],
    },
    fields: {
        object: {
            validate: assertNodeType('Expression', 'Super'),
        },
        property: {
            validate: (function() {
                const normal = assertNodeType('Identifier', 'PrivateName');
                const computed = assertNodeType('Expression');
                const validator = function(node, key, val) {
                    const validator2 = node.computed ? computed : normal;
                    validator2(node, key, val);
                };
                
                validator.oneOfNodeTypes = [
                    'Expression',
                    'Identifier',
                    'PrivateName',
                ];
                return validator;
            })(),
        },
        computed: {
            default: false,
        },
    },
});
defineType$4('NewExpression', {
    inherits: 'CallExpression',
});
defineType$4('Program', {
    visitor: ['directives', 'body'],
    builder: [
        'body',
        'directives',
        'sourceType',
        'interpreter',
    ],
    fields: {
        sourceType: {
            validate: assertOneOf('script', 'module'),
            default: 'script',
        },
        interpreter: {
            validate: assertNodeType('InterpreterDirective'),
            default: null,
            optional: true,
        },
        directives: {
            validate: arrayOfType('Directive'),
            default: [],
        },
        body: validateArrayOfType('Statement'),
    },
    aliases: [
        'Scopable',
        'BlockParent',
        'Block',
    ],
});
defineType$4('ObjectExpression', {
    visitor: ['properties'],
    aliases: ['Expression'],
    fields: {
        properties: validateArrayOfType('ObjectMethod', 'ObjectProperty', 'SpreadElement'),
    },
});
defineType$4('ObjectMethod', {
    builder: [
        'kind',
        'key',
        'params',
        'body',
        'computed',
        'generator',
        'async',
    ],
    visitor: [
        'decorators',
        'key',
        'typeParameters',
        'params',
        'returnType',
        'body',
    ],
    ...classMethodOrPropertyUnionShapeCommon(),
    fields: {
        ...functionCommon(),
        ...functionTypeAnnotationCommon(),
        kind: {
            validate: assertOneOf('method', 'get', 'set'),
        },
        computed: {
            default: false,
        },
        key: {
            validate: (function() {
                const normal = assertNodeType('Identifier', 'StringLiteral', 'NumericLiteral', 'BigIntLiteral');
                const computed = assertNodeType('Expression');
                const validator = function(node, key, val) {
                    const validator2 = node.computed ? computed : normal;
                    validator2(node, key, val);
                };
                
                validator.oneOfNodeTypes = [
                    'Expression',
                    'Identifier',
                    'StringLiteral',
                    'NumericLiteral',
                    'BigIntLiteral',
                ];
                return validator;
            })(),
        },
        decorators: {
            validate: arrayOfType('Decorator'),
            optional: true,
        },
        body: {
            validate: assertNodeType('BlockStatement'),
        },
    },
    aliases: [
        'UserWhitespacable',
        'Function',
        'Scopable',
        'BlockParent',
        'FunctionParent',
        'Method',
        'ObjectMember',
    ],
});
defineType$4('ObjectProperty', {
    builder: [
        'key',
        'value',
        'computed',
        'shorthand',
        ...[],
    ],
    unionShape: {
        discriminator: 'computed',
        shapes: [{
            name: 'computed',
            value: [true],
            properties: {
                key: {
                    validate: assertNodeType('Expression'),
                },
            },
        }, {
            name: 'nonComputed',
            value: [false],
            properties: {
                key: {
                    validate: assertNodeType('Identifier', 'StringLiteral', 'NumericLiteral', 'BigIntLiteral', 'PrivateName'),
                },
            },
        }],
    },
    fields: {
        computed: {
            default: false,
        },
        key: {
            validate: (function() {
                const normal = assertNodeType('Identifier', 'StringLiteral', 'NumericLiteral', 'BigIntLiteral', 'PrivateName');
                const computed = assertNodeType('Expression');
                const validator = Object.assign(function(node, key, val) {
                    const validator2 = node.computed ? computed : normal;
                    validator2(node, key, val);
                }, {
                    oneOfNodeTypes: [
                        'Expression',
                        'Identifier',
                        'StringLiteral',
                        'NumericLiteral',
                        'BigIntLiteral',
                        'PrivateName',
                    ],
                });
                
                return validator;
            })(),
        },
        value: {
            validate: assertNodeType('Expression', 'PatternLike'),
        },
        shorthand: {
            validate: chain$2(assertValueType('boolean'), Object.assign(function(node, key, shorthand) {
                if (!shorthand)
                    return;
                
                if (node.computed) {
                    throw new TypeError('Property shorthand of ObjectProperty cannot be true if computed is true');
                }
                
                if (!is$1('Identifier', node.key)) {
                    throw new TypeError('Property shorthand of ObjectProperty cannot be true if key is not an Identifier');
                }
            }, {
                type: 'boolean',
            })),
            default: false,
        },
        decorators: {
            validate: arrayOfType('Decorator'),
            optional: true,
        },
    },
    visitor: [
        'decorators',
        'key',
        'value',
    ],
    aliases: [
        'UserWhitespacable',
        'Property',
        'ObjectMember',
    ],
    validate: (function() {
        const pattern = assertNodeType('Identifier', 'Pattern', 'TSAsExpression', 'TSSatisfiesExpression', 'TSNonNullExpression', 'TSTypeAssertion');
        const expression2 = assertNodeType('Expression');
        
        return function(parent, key, node) {
            const validator = is$1('ObjectPattern', parent) ? pattern : expression2;
            validator(node, 'value', node.value);
        };
    })(),
});
defineType$4('RestElement', {
    visitor: ['argument', 'typeAnnotation'],
    builder: ['argument'],
    aliases: ['FunctionParameter', 'PatternLike'],
    deprecatedAlias: 'RestProperty',
    fields: {
        ...patternLikeCommon(),
        argument: {
            validate: assertNodeType('Identifier', 'ArrayPattern', 'ObjectPattern', 'MemberExpression', 'TSAsExpression', 'TSSatisfiesExpression', 'TSTypeAssertion', 'TSNonNullExpression'),
        },
    },
    validate: function(parent, key) {
        const match = /(\w+)\[(\d+)\]/.exec(key.toString());
        
        if (!match)
            throw new Error('Internal Babel error: malformed key.');
        
        const [, listKey, index2] = match;
        
        if (parent[listKey].length > +index2 + 1) {
            throw new TypeError(`RestElement must be last element of ${listKey}`);
        }
    },
});
defineType$4('ReturnStatement', {
    visitor: ['argument'],
    aliases: [
        'Statement',
        'Terminatorless',
        'CompletionStatement',
    ],
    fields: {
        argument: {
            validate: assertNodeType('Expression'),
            optional: true,
        },
    },
});
defineType$4('SequenceExpression', {
    visitor: ['expressions'],
    fields: {
        expressions: validateArrayOfType('Expression'),
    },
    aliases: ['Expression'],
});
defineType$4('ParenthesizedExpression', {
    visitor: ['expression'],
    aliases: ['Expression', 'ExpressionWrapper'],
    fields: {
        expression: {
            validate: assertNodeType('Expression'),
        },
    },
});
defineType$4('SwitchCase', {
    visitor: ['test', 'consequent'],
    fields: {
        test: {
            validate: assertNodeType('Expression'),
            optional: true,
        },
        consequent: validateArrayOfType('Statement'),
    },
});
defineType$4('SwitchStatement', {
    visitor: ['discriminant', 'cases'],
    aliases: [
        'Statement',
        'BlockParent',
        'Scopable',
    ],
    fields: {
        discriminant: {
            validate: assertNodeType('Expression'),
        },
        cases: validateArrayOfType('SwitchCase'),
    },
});
defineType$4('ThisExpression', {
    aliases: ['Expression', 'TSEntityName'],
});
defineType$4('ThrowStatement', {
    visitor: ['argument'],
    aliases: [
        'Statement',
        'Terminatorless',
        'CompletionStatement',
    ],
    fields: {
        argument: {
            validate: assertNodeType('Expression'),
        },
    },
});
defineType$4('TryStatement', {
    visitor: [
        'block',
        'handler',
        'finalizer',
    ],
    aliases: ['Statement'],
    fields: {
        block: {
            validate: chain$2(assertNodeType('BlockStatement'), Object.assign(function(node) {
                if (!node.handler && !node.finalizer) {
                    throw new TypeError('TryStatement expects either a handler or finalizer, or both');
                }
            }, {
                oneOfNodeTypes: ['BlockStatement'],
            })),
        },
        handler: {
            optional: true,
            validate: assertNodeType('CatchClause'),
        },
        finalizer: {
            optional: true,
            validate: assertNodeType('BlockStatement'),
        },
    },
});
defineType$4('UnaryExpression', {
    builder: [
        'operator',
        'argument',
        'prefix',
    ],
    fields: {
        prefix: {
            default: true,
        },
        argument: {
            validate: assertNodeType('Expression'),
        },
        operator: {
            validate: assertOneOf(...UNARY_OPERATORS),
        },
    },
    visitor: ['argument'],
    aliases: ['UnaryLike', 'Expression'],
});
defineType$4('UpdateExpression', {
    builder: [
        'operator',
        'argument',
        'prefix',
    ],
    fields: {
        prefix: {
            default: false,
        },
        argument: {
            validate: assertNodeType('Identifier', 'MemberExpression'),
        },
        operator: {
            validate: assertOneOf(...UPDATE_OPERATORS),
        },
    },
    visitor: ['argument'],
    aliases: ['Expression'],
});
defineType$4('VariableDeclaration', {
    builder: ['kind', 'declarations'],
    visitor: ['declarations'],
    aliases: ['Statement', 'Declaration'],
    fields: {
        declare: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        kind: {
            validate: assertOneOf('var', 'let', 'const', 'using', 'await using'),
        },
        declarations: validateArrayOfType('VariableDeclarator'),
    },
    validate: (() => {
        const withoutInit = assertNodeType('Identifier', 'Placeholder');
        const constOrLetOrVar = assertNodeType('Identifier', 'ArrayPattern', 'ObjectPattern', 'Placeholder');
        const usingOrAwaitUsing = assertNodeType('Identifier', 'VoidPattern', 'Placeholder');
        
        return function(parent, key, node) {
            const {kind, declarations} = node;
            
            const parentIsForX = is$1('ForXStatement', parent, {
                left: node,
            });
            
            if (parentIsForX) {
                if (declarations.length !== 1) {
                    throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
                }
            }
            
            for (const decl of declarations) {
                if (kind === 'const' || kind === 'let' || kind === 'var') {
                    if (!parentIsForX && !decl.init) {
                        withoutInit(decl, 'id', decl.id);
                    } else {
                        constOrLetOrVar(decl, 'id', decl.id);
                    }
                } else {
                    usingOrAwaitUsing(decl, 'id', decl.id);
                }
            }
        };
    })(),
});
defineType$4('VariableDeclarator', {
    visitor: ['id', 'init'],
    fields: {
        id: {
            validate: assertNodeType('Identifier', 'ArrayPattern', 'ObjectPattern', 'VoidPattern'),
        },
        definite: {
            optional: true,
            validate: assertValueType('boolean'),
        },
        init: {
            optional: true,
            validate: assertNodeType('Expression'),
        },
    },
});
defineType$4('WhileStatement', {
    visitor: ['test', 'body'],
    aliases: [
        'Statement',
        'BlockParent',
        'Loop',
        'While',
        'Scopable',
    ],
    fields: {
        test: {
            validate: assertNodeType('Expression'),
        },
        body: {
            validate: assertNodeType('Statement'),
        },
    },
});
defineType$4('WithStatement', {
    visitor: ['object', 'body'],
    aliases: ['Statement'],
    fields: {
        object: {
            validate: assertNodeType('Expression'),
        },
        body: {
            validate: assertNodeType('Statement'),
        },
    },
});
defineType$4('AssignmentPattern', {
    visitor: [
        'left',
        'right',
        'decorators',
    ],
    builder: ['left', 'right'],
    aliases: [
        'FunctionParameter',
        'Pattern',
        'PatternLike',
    ],
    fields: {
        ...patternLikeCommon(),
        left: {
            validate: assertNodeType('Identifier', 'ObjectPattern', 'ArrayPattern', 'MemberExpression', 'TSAsExpression', 'TSSatisfiesExpression', 'TSTypeAssertion', 'TSNonNullExpression'),
        },
        right: {
            validate: assertNodeType('Expression'),
        },
        decorators: {
            validate: arrayOfType('Decorator'),
            optional: true,
        },
    },
});
defineType$4('ArrayPattern', {
    visitor: ['elements', 'typeAnnotation'],
    builder: ['elements'],
    aliases: [
        'FunctionParameter',
        'Pattern',
        'PatternLike',
        'LVal',
    ],
    fields: {
        ...patternLikeCommon(),
        elements: {
            validate: chain$2(assertValueType('array'), assertEach(assertNodeOrValueType('null', 'PatternLike'))),
        },
    },
});
defineType$4('ArrowFunctionExpression', {
    builder: [
        'params',
        'body',
        'async',
    ],
    visitor: [
        'typeParameters',
        'params',
        'predicate',
        'returnType',
        'body',
    ],
    aliases: [
        'Scopable',
        'Function',
        'BlockParent',
        'FunctionParent',
        'Expression',
        'Pureish',
    ],
    fields: {
        ...functionCommon(),
        ...functionTypeAnnotationCommon(),
        expression: {
            validate: assertValueType('boolean'),
        },
        body: {
            validate: assertNodeType('BlockStatement', 'Expression'),
        },
        predicate: {
            validate: assertNodeType('DeclaredPredicate', 'InferredPredicate'),
            optional: true,
        },
    },
});
defineType$4('ClassBody', {
    visitor: ['body'],
    fields: {
        body: validateArrayOfType('ClassMethod', 'ClassPrivateMethod', 'ClassProperty', 'ClassPrivateProperty', 'ClassAccessorProperty', 'TSDeclareMethod', 'TSIndexSignature', 'StaticBlock'),
    },
});
defineType$4('ClassExpression', {
    builder: [
        'id',
        'superClass',
        'body',
        'decorators',
    ],
    visitor: [
        'decorators',
        'id',
        'typeParameters',
        'superClass',
        'superTypeArguments',
        'mixins',
        'implements',
        'body',
    ],
    aliases: [
        'Scopable',
        'Class',
        'Expression',
    ],
    fields: {
        id: {
            validate: assertNodeType('Identifier'),
            optional: true,
        },
        typeParameters: {
            validate: assertNodeType('TypeParameterDeclaration', 'TSTypeParameterDeclaration'),
            optional: true,
        },
        body: {
            validate: assertNodeType('ClassBody'),
        },
        superClass: {
            optional: true,
            validate: assertNodeType('Expression'),
        },
        ['superTypeArguments']: {
            validate: assertNodeType('TypeParameterInstantiation', 'TSTypeParameterInstantiation'),
            optional: true,
        },
        implements: {
            validate: arrayOfType('TSClassImplements', 'ClassImplements'),
            optional: true,
        },
        decorators: {
            validate: arrayOfType('Decorator'),
            optional: true,
        },
        mixins: {
            validate: assertNodeType('InterfaceExtends'),
            optional: true,
        },
    },
});
defineType$4('ClassDeclaration', {
    inherits: 'ClassExpression',
    aliases: [
        'Scopable',
        'Class',
        'Statement',
        'Declaration',
    ],
    fields: {
        id: {
            validate: assertNodeType('Identifier'),
            optional: true,
        },
        typeParameters: {
            validate: assertNodeType('TypeParameterDeclaration', 'TSTypeParameterDeclaration'),
            optional: true,
        },
        body: {
            validate: assertNodeType('ClassBody'),
        },
        superClass: {
            optional: true,
            validate: assertNodeType('Expression'),
        },
        ['superTypeArguments']: {
            validate: assertNodeType('TypeParameterInstantiation', 'TSTypeParameterInstantiation'),
            optional: true,
        },
        implements: {
            validate: arrayOfType('TSClassImplements', 'ClassImplements'),
            optional: true,
        },
        decorators: {
            validate: arrayOfType('Decorator'),
            optional: true,
        },
        mixins: {
            validate: assertNodeType('InterfaceExtends'),
            optional: true,
        },
        declare: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        abstract: {
            validate: assertValueType('boolean'),
            optional: true,
        },
    },
    validate: (function() {
        const identifier4 = assertNodeType('Identifier');
        
        return function(parent, key, node) {
            if (!is$1('ExportDefaultDeclaration', parent)) {
                identifier4(node, 'id', node.id);
            }
        };
    })(),
});
var importAttributes = {
    attributes: {
        optional: true,
        validate: arrayOfType('ImportAttribute'),
    },
};

defineType$4('ExportAllDeclaration', {
    builder: ['source'],
    visitor: [
        'source',
        'attributes',
        'assertions',
    ],
    aliases: [
        'Statement',
        'Declaration',
        'ImportOrExportDeclaration',
        'ExportDeclaration',
    ],
    fields: {
        source: {
            validate: assertNodeType('StringLiteral'),
        },
        exportKind: validateOptional(assertOneOf('type', 'value')),
        ...importAttributes,
    },
});
defineType$4('ExportDefaultDeclaration', {
    visitor: ['declaration'],
    aliases: [
        'Statement',
        'Declaration',
        'ImportOrExportDeclaration',
        'ExportDeclaration',
    ],
    fields: {
        declaration: validateType('TSDeclareFunction', 'FunctionDeclaration', 'ClassDeclaration', 'Expression'),
        exportKind: validateOptional(assertOneOf('value')),
    },
});
defineType$4('ExportNamedDeclaration', {
    builder: [
        'declaration',
        'specifiers',
        'source',
    ],
    visitor: [
        'declaration',
        'specifiers',
        'source',
        'attributes',
    ],
    aliases: [
        'Statement',
        'Declaration',
        'ImportOrExportDeclaration',
        'ExportDeclaration',
    ],
    fields: {
        declaration: {
            optional: true,
            validate: chain$2(assertNodeType('Declaration'), Object.assign(function(node, key, val) {
                if (val && node.specifiers.length) {
                    throw new TypeError('Only declaration or specifiers is allowed on ExportNamedDeclaration');
                }
                
                if (val && node.source) {
                    throw new TypeError('Cannot export a declaration from a source');
                }
            }, {
                oneOfNodeTypes: ['Declaration'],
            })),
        },
        ...importAttributes,
        specifiers: {
            default: [],
            validate: arrayOf((function() {
                const sourced = assertNodeType('ExportSpecifier', 'ExportDefaultSpecifier', 'ExportNamespaceSpecifier');
                const sourceless = assertNodeType('ExportSpecifier');
                
                return Object.assign(function(node, key, val) {
                    const validator = node.source ? sourced : sourceless;
                    validator(node, key, val);
                }, {
                    oneOfNodeTypes: [
                        'ExportSpecifier',
                        'ExportDefaultSpecifier',
                        'ExportNamespaceSpecifier',
                    ],
                });
            })()),
        },
        source: {
            validate: assertNodeType('StringLiteral'),
            optional: true,
        },
        exportKind: validateOptional(assertOneOf('type', 'value')),
    },
});
defineType$4('ExportSpecifier', {
    visitor: ['local', 'exported'],
    aliases: ['ModuleSpecifier'],
    fields: {
        local: {
            validate: assertNodeType('Identifier'),
        },
        exported: {
            validate: assertNodeType('Identifier', 'StringLiteral'),
        },
        exportKind: {
            validate: assertOneOf('type', 'value'),
            optional: true,
        },
    },
});
defineType$4('ForOfStatement', {
    visitor: [
        'left',
        'right',
        'body',
    ],
    builder: [
        'left',
        'right',
        'body',
        'await',
    ],
    aliases: [
        'Scopable',
        'Statement',
        'For',
        'BlockParent',
        'Loop',
        'ForXStatement',
    ],
    fields: {
        left: {
            validate: (function() {
                const declaration = assertNodeType('VariableDeclaration');
                const lval = assertNodeType('Identifier', 'MemberExpression', 'ArrayPattern', 'ObjectPattern', 'TSAsExpression', 'TSSatisfiesExpression', 'TSTypeAssertion', 'TSNonNullExpression');
                
                return Object.assign(function(node, key, val) {
                    if (is$1('VariableDeclaration', val)) {
                        declaration(node, key, val);
                    } else {
                        lval(node, key, val);
                    }
                }, {
                    oneOfNodeTypes: [
                        'VariableDeclaration',
                        'Identifier',
                        'MemberExpression',
                        'ArrayPattern',
                        'ObjectPattern',
                        'TSAsExpression',
                        'TSSatisfiesExpression',
                        'TSTypeAssertion',
                        'TSNonNullExpression',
                    ],
                });
            })(),
        },
        right: {
            validate: assertNodeType('Expression'),
        },
        body: {
            validate: assertNodeType('Statement'),
        },
        await: {
            default: false,
        },
    },
});
defineType$4('ImportDeclaration', {
    builder: ['specifiers', 'source'],
    visitor: [
        'specifiers',
        'source',
        'attributes',
    ],
    aliases: [
        'Statement',
        'Declaration',
        'ImportOrExportDeclaration',
    ],
    fields: {
        ...importAttributes,
        module: {
            optional: true,
            validate: assertValueType('boolean'),
        },
        phase: {
            default: null,
            validate: assertOneOf('source', 'defer'),
        },
        specifiers: validateArrayOfType('ImportSpecifier', 'ImportDefaultSpecifier', 'ImportNamespaceSpecifier'),
        source: {
            validate: assertNodeType('StringLiteral'),
        },
        importKind: {
            validate: assertOneOf('type', 'typeof', 'value'),
            optional: true,
        },
    },
});
defineType$4('ImportDefaultSpecifier', {
    visitor: ['local'],
    aliases: ['ModuleSpecifier'],
    fields: {
        local: {
            validate: assertNodeType('Identifier'),
        },
    },
});
defineType$4('ImportNamespaceSpecifier', {
    visitor: ['local'],
    aliases: ['ModuleSpecifier'],
    fields: {
        local: {
            validate: assertNodeType('Identifier'),
        },
    },
});
defineType$4('ImportSpecifier', {
    visitor: ['imported', 'local'],
    builder: ['local', 'imported'],
    aliases: ['ModuleSpecifier'],
    fields: {
        local: {
            validate: assertNodeType('Identifier'),
        },
        imported: {
            validate: assertNodeType('Identifier', 'StringLiteral'),
        },
        importKind: {
            validate: assertOneOf('type', 'typeof', 'value'),
            optional: true,
        },
    },
});
defineType$4('ImportExpression', {
    visitor: ['source', 'options'],
    aliases: ['Expression'],
    fields: {
        phase: {
            default: null,
            validate: assertOneOf('source', 'defer'),
        },
        source: {
            validate: assertNodeType('Expression'),
        },
        options: {
            validate: assertNodeType('Expression'),
            optional: true,
        },
    },
});
defineType$4('MetaProperty', {
    visitor: ['meta', 'property'],
    aliases: ['Expression'],
    fields: {
        meta: {
            validate: chain$2(assertNodeType('Identifier'), Object.assign(function(node, key, val) {
                let property;
                
                switch(val.name) {
                case 'function':
                    property = 'sent';
                    break;
                
                case 'new':
                    property = 'target';
                    break;
                
                case 'import':
                    property = 'meta';
                    break;
                }
                
                if (!is$1('Identifier', node.property, {name: property})) {
                    throw new TypeError('Unrecognised MetaProperty');
                }
            }, {
                oneOfNodeTypes: ['Identifier'],
            })),
        },
        property: {
            validate: assertNodeType('Identifier'),
        },
    },
});
var classMethodOrPropertyCommon = () => ({
    abstract: {
        validate: assertValueType('boolean'),
        optional: true,
    },
    accessibility: {
        validate: assertOneOf('public', 'private', 'protected'),
        optional: true,
    },
    static: {
        default: false,
    },
    override: {
        default: false,
    },
    computed: {
        default: false,
    },
    optional: {
        validate: assertValueType('boolean'),
        optional: true,
    },
    key: {
        validate: chain$2((function() {
            const normal = assertNodeType('Identifier', 'StringLiteral', 'NumericLiteral', 'BigIntLiteral');
            const computed = assertNodeType('Expression');
            
            return function(node, key, val) {
                const validator = node.computed ? computed : normal;
                validator(node, key, val);
            };
        })(), assertNodeType('Identifier', 'StringLiteral', 'NumericLiteral', 'BigIntLiteral', 'Expression')),
    },
});

var classMethodOrDeclareMethodCommon = () => ({
    ...functionCommon(),
    ...classMethodOrPropertyCommon(),
    params: validateArrayOfType('FunctionParameter', 'TSParameterProperty'),
    kind: {
        validate: assertOneOf('get', 'set', 'method', 'constructor'),
        default: 'method',
    },
    access: {
        validate: chain$2(assertValueType('string'), assertOneOf('public', 'private', 'protected')),
        optional: true,
    },
    decorators: {
        validate: arrayOfType('Decorator'),
        optional: true,
    },
});

defineType$4('ClassMethod', {
    aliases: [
        'Function',
        'Scopable',
        'BlockParent',
        'FunctionParent',
        'Method',
    ],
    builder: [
        'kind',
        'key',
        'params',
        'body',
        'computed',
        'static',
        'generator',
        'async',
    ],
    visitor: [
        'decorators',
        'key',
        'typeParameters',
        'params',
        'returnType',
        'body',
    ],
    ...classMethodOrPropertyUnionShapeCommon(),
    fields: {
        ...classMethodOrDeclareMethodCommon(),
        ...functionTypeAnnotationCommon(),
        body: {
            validate: assertNodeType('BlockStatement'),
        },
    },
});
defineType$4('ObjectPattern', {
    visitor: [
        'decorators',
        'properties',
        'typeAnnotation',
    ],
    builder: ['properties'],
    aliases: [
        'FunctionParameter',
        'Pattern',
        'PatternLike',
        'LVal',
    ],
    fields: {
        ...patternLikeCommon(),
        properties: validateArrayOfType('RestElement', 'ObjectProperty'),
    },
});
defineType$4('SpreadElement', {
    visitor: ['argument'],
    aliases: ['UnaryLike'],
    deprecatedAlias: 'SpreadProperty',
    fields: {
        argument: {
            validate: assertNodeType('Expression'),
        },
    },
});
defineType$4('Super', void 0);
defineType$4('TaggedTemplateExpression', {
    visitor: [
        'tag',
        'typeArguments',
        'quasi',
    ],
    builder: ['tag', 'quasi'],
    aliases: ['Expression'],
    fields: {
        tag: {
            validate: assertNodeType('Expression'),
        },
        quasi: {
            validate: assertNodeType('TemplateLiteral'),
        },
        ['typeArguments']: {
            validate: assertNodeType('TypeParameterInstantiation', 'TSTypeParameterInstantiation'),
            optional: true,
        },
    },
});
defineType$4('TemplateElement', {
    builder: ['value', 'tail'],
    fields: {
        value: {
            validate: chain$2(assertShape({
                raw: {
                    validate: assertValueType('string'),
                },
                cooked: {
                    validate: assertValueType('string'),
                    optional: true,
                },
            }), function templateElementCookedValidator(node) {
                const raw = node.value.raw;
                let unterminatedCalled = false;
                const error = () => {
                    throw new Error('Internal @babel/types error.');
                };
                
                const {
                    str,
                    firstInvalidLoc,
                } = readStringContents('template', raw, 0, 0, 0, {
                    unterminated() {
                        unterminatedCalled = true;
                    },
                    strictNumericEscape: error,
                    invalidEscapeSequence: error,
                    numericSeparatorInEscapeSequence: error,
                    unexpectedNumericSeparator: error,
                    invalidDigit: error,
                    invalidCodePoint: error,
                });
                
                if (!unterminatedCalled)
                    throw new Error('Invalid raw');
                
                node.value.cooked = firstInvalidLoc ? null : str;
            }),
        },
        tail: {
            default: false,
        },
    },
});
defineType$4('TemplateLiteral', {
    visitor: ['quasis', 'expressions'],
    aliases: ['Expression', 'Literal'],
    fields: {
        quasis: validateArrayOfType('TemplateElement'),
        expressions: {
            validate: chain$2(assertValueType('array'), assertEach(assertNodeType('Expression', 'TSType')), function(node, key, val) {
                if (node.quasis.length !== val.length + 1) {
                    throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.
Expected ${val.length + 1} quasis but got ${node.quasis.length}`);
                }
            }),
        },
    },
});
defineType$4('YieldExpression', {
    builder: ['argument', 'delegate'],
    visitor: ['argument'],
    aliases: ['Expression', 'Terminatorless'],
    fields: {
        delegate: {
            validate: chain$2(assertValueType('boolean'), Object.assign(function(node, key, val) {
                if (val && !node.argument) {
                    throw new TypeError('Property delegate of YieldExpression cannot be true if there is no argument');
                }
            }, {
                type: 'boolean',
            })),
            default: false,
        },
        argument: {
            optional: true,
            validate: assertNodeType('Expression'),
        },
    },
});
defineType$4('AwaitExpression', {
    builder: ['argument'],
    visitor: ['argument'],
    aliases: ['Expression', 'Terminatorless'],
    fields: {
        argument: {
            validate: assertNodeType('Expression'),
        },
    },
});
defineType$4('Import', {
    aliases: ['Expression'],
});
defineType$4('BigIntLiteral', {
    builder: ['value'],
    fields: {
        value: {
            validate: assertValueType('bigint'),
        },
    },
    aliases: [
        'Expression',
        'Pureish',
        'Literal',
        'Immutable',
    ],
});
defineType$4('ExportNamespaceSpecifier', {
    visitor: ['exported'],
    aliases: ['ModuleSpecifier'],
    fields: {
        exported: {
            validate: assertNodeType('Identifier'),
        },
    },
});
defineType$4('OptionalMemberExpression', {
    builder: [
        'object',
        'property',
        'computed',
        'optional',
    ],
    visitor: ['object', 'property'],
    aliases: ['Expression'],
    fields: {
        object: {
            validate: assertNodeType('Expression'),
        },
        property: {
            validate: (function() {
                const normal = assertNodeType('Identifier');
                const computed = assertNodeType('Expression');
                const validator = Object.assign(function(node, key, val) {
                    const validator2 = node.computed ? computed : normal;
                    validator2(node, key, val);
                }, {
                    oneOfNodeTypes: ['Expression', 'Identifier'],
                });
                
                return validator;
            })(),
        },
        computed: {
            default: false,
        },
        optional: {
            validate: chain$2(assertValueType('boolean'), assertOptionalChainStart()),
        },
    },
});
defineType$4('OptionalCallExpression', {
    visitor: [
        'callee',
        'typeArguments',
        'arguments',
    ],
    builder: [
        'callee',
        'arguments',
        'optional',
    ],
    aliases: ['Expression'],
    fields: {
        callee: {
            validate: assertNodeType('Expression'),
        },
        arguments: validateArrayOfType('Expression', 'SpreadElement', 'ArgumentPlaceholder'),
        optional: {
            validate: chain$2(assertValueType('boolean'), assertOptionalChainStart()),
        },
        typeArguments: {
            validate: assertNodeType('TypeParameterInstantiation', 'TSTypeParameterInstantiation'),
            optional: true,
        },
    },
});
defineType$4('ClassProperty', {
    visitor: [
        'decorators',
        'variance',
        'key',
        'typeAnnotation',
        'value',
    ],
    builder: [
        'key',
        'value',
        'typeAnnotation',
        'decorators',
        'computed',
        'static',
    ],
    aliases: ['Property'],
    ...classMethodOrPropertyUnionShapeCommon(),
    fields: {
        ...classMethodOrPropertyCommon(),
        value: {
            validate: assertNodeType('Expression'),
            optional: true,
        },
        definite: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        typeAnnotation: {
            validate: assertNodeType('TypeAnnotation', 'TSTypeAnnotation'),
            optional: true,
        },
        decorators: {
            validate: arrayOfType('Decorator'),
            optional: true,
        },
        readonly: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        declare: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        variance: {
            validate: assertNodeType('Variance'),
            optional: true,
        },
    },
});
defineType$4('ClassAccessorProperty', {
    visitor: [
        'decorators',
        'key',
        'typeAnnotation',
        'value',
    ],
    builder: [
        'key',
        'value',
        'typeAnnotation',
        'decorators',
        'computed',
        'static',
    ],
    aliases: ['Property', 'Accessor'],
    ...classMethodOrPropertyUnionShapeCommon(true),
    fields: {
        ...classMethodOrPropertyCommon(),
        key: {
            validate: chain$2((function() {
                const normal = assertNodeType('Identifier', 'StringLiteral', 'NumericLiteral', 'BigIntLiteral', 'PrivateName');
                const computed = assertNodeType('Expression');
                
                return function(node, key, val) {
                    const validator = node.computed ? computed : normal;
                    validator(node, key, val);
                };
            })(), assertNodeType('Identifier', 'StringLiteral', 'NumericLiteral', 'BigIntLiteral', 'Expression', 'PrivateName')),
        },
        value: {
            validate: assertNodeType('Expression'),
            optional: true,
        },
        definite: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        typeAnnotation: {
            validate: assertNodeType('TypeAnnotation', 'TSTypeAnnotation'),
            optional: true,
        },
        decorators: {
            validate: arrayOfType('Decorator'),
            optional: true,
        },
        readonly: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        declare: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        variance: {
            validate: assertNodeType('Variance'),
            optional: true,
        },
    },
});
defineType$4('ClassPrivateProperty', {
    visitor: [
        'decorators',
        'variance',
        'key',
        'typeAnnotation',
        'value',
    ],
    builder: [
        'key',
        'value',
        'decorators',
        'static',
    ],
    aliases: ['Property', 'Private'],
    fields: {
        key: {
            validate: assertNodeType('PrivateName'),
        },
        value: {
            validate: assertNodeType('Expression'),
            optional: true,
        },
        typeAnnotation: {
            validate: assertNodeType('TypeAnnotation', 'TSTypeAnnotation'),
            optional: true,
        },
        decorators: {
            validate: arrayOfType('Decorator'),
            optional: true,
        },
        static: {
            validate: assertValueType('boolean'),
            default: false,
        },
        readonly: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        optional: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        definite: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        variance: {
            validate: assertNodeType('Variance'),
            optional: true,
        },
    },
});
defineType$4('ClassPrivateMethod', {
    builder: [
        'kind',
        'key',
        'params',
        'body',
        'static',
    ],
    visitor: [
        'decorators',
        'key',
        'typeParameters',
        'params',
        'returnType',
        'body',
    ],
    aliases: [
        'Function',
        'Scopable',
        'BlockParent',
        'FunctionParent',
        'Method',
        'Private',
    ],
    fields: {
        ...classMethodOrDeclareMethodCommon(),
        ...functionTypeAnnotationCommon(),
        kind: {
            validate: assertOneOf('get', 'set', 'method'),
            default: 'method',
        },
        key: {
            validate: assertNodeType('PrivateName'),
        },
        body: {
            validate: assertNodeType('BlockStatement'),
        },
    },
});
defineType$4('PrivateName', {
    visitor: ['id'],
    aliases: ['Private'],
    fields: {
        id: {
            validate: assertNodeType('Identifier'),
        },
    },
});
defineType$4('StaticBlock', {
    visitor: ['body'],
    fields: {
        body: validateArrayOfType('Statement'),
    },
    aliases: [
        'Scopable',
        'BlockParent',
        'FunctionParent',
    ],
});
defineType$4('ImportAttribute', {
    visitor: ['key', 'value'],
    fields: {
        key: {
            validate: assertNodeType('Identifier', 'StringLiteral'),
        },
        value: {
            validate: assertNodeType('StringLiteral'),
        },
    },
});
var defineType$3 = defineAliasedType('Flow');

var defineInterfaceishType = (name) => {
    const isDeclareClass2 = name === 'DeclareClass';
    
    defineType$3(name, {
        builder: [
            'id',
            'typeParameters',
            'extends',
            'body',
        ],
        visitor: [
            'id',
            'typeParameters',
            'extends',
            ...isDeclareClass2 ? [
                'mixins',
                'implements',
            ] : [],
            'body',
        ],
        aliases: [
            'FlowDeclaration',
            'Statement',
            'Declaration',
        ],
        fields: {
            id: validateType('Identifier'),
            typeParameters: validateOptionalType('TypeParameterDeclaration'),
            extends: validateOptional(arrayOfType('InterfaceExtends')),
            ...isDeclareClass2 ? {
                mixins: validateOptional(arrayOfType('InterfaceExtends')),
                implements: validateOptional(arrayOfType('ClassImplements')),
            } : {},
            body: validateType('ObjectTypeAnnotation'),
        },
    });
};

defineType$3('AnyTypeAnnotation', {
    aliases: ['FlowType', 'FlowBaseAnnotation'],
});
defineType$3('ArrayTypeAnnotation', {
    visitor: ['elementType'],
    aliases: ['FlowType'],
    fields: {
        elementType: validateType('FlowType'),
    },
});
defineType$3('BooleanTypeAnnotation', {
    aliases: ['FlowType', 'FlowBaseAnnotation'],
});
defineType$3('BooleanLiteralTypeAnnotation', {
    builder: ['value'],
    aliases: ['FlowType'],
    fields: {
        value: validate$2(assertValueType('boolean')),
    },
});
defineType$3('NullLiteralTypeAnnotation', {
    aliases: ['FlowType', 'FlowBaseAnnotation'],
});
defineType$3('ClassImplements', {
    visitor: ['id', 'typeParameters'],
    fields: {
        id: validateType('Identifier'),
        typeParameters: validateOptionalType('TypeParameterInstantiation'),
    },
});
defineInterfaceishType('DeclareClass');
defineType$3('DeclareFunction', {
    builder: ['id'],
    visitor: ['id', 'predicate'],
    aliases: [
        'FlowDeclaration',
        'Statement',
        'Declaration',
    ],
    fields: {
        id: validateType('Identifier'),
        predicate: validateOptionalType('DeclaredPredicate'),
    },
});
defineInterfaceishType('DeclareInterface');
defineType$3('DeclareModule', {
    builder: ['id', 'body', 'kind'],
    visitor: ['id', 'body'],
    aliases: [
        'FlowDeclaration',
        'Statement',
        'Declaration',
    ],
    fields: {
        id: validateType('Identifier', 'StringLiteral'),
        body: validateType('BlockStatement'),
        kind: validateOptional(assertOneOf('CommonJS', 'ES')),
    },
});
defineType$3('DeclareModuleExports', {
    visitor: ['typeAnnotation'],
    aliases: [
        'FlowDeclaration',
        'Statement',
        'Declaration',
    ],
    fields: {
        typeAnnotation: validateType('TypeAnnotation'),
    },
});
defineType$3('DeclareTypeAlias', {
    visitor: [
        'id',
        'typeParameters',
        'right',
    ],
    aliases: [
        'FlowDeclaration',
        'Statement',
        'Declaration',
    ],
    fields: {
        id: validateType('Identifier'),
        typeParameters: validateOptionalType('TypeParameterDeclaration'),
        right: validateType('FlowType'),
    },
});
defineType$3('DeclareOpaqueType', {
    visitor: [
        'id',
        'typeParameters',
        'supertype',
    ],
    aliases: [
        'FlowDeclaration',
        'Statement',
        'Declaration',
    ],
    fields: {
        id: validateType('Identifier'),
        typeParameters: validateOptionalType('TypeParameterDeclaration'),
        supertype: validateOptionalType('FlowType'),
        impltype: validateOptionalType('FlowType'),
    },
});
defineType$3('DeclareVariable', {
    visitor: ['id'],
    aliases: [
        'FlowDeclaration',
        'Statement',
        'Declaration',
    ],
    fields: {
        id: validateType('Identifier'),
    },
});
defineType$3('DeclareExportDeclaration', {
    visitor: [
        'declaration',
        'specifiers',
        'source',
        'attributes',
    ],
    aliases: [
        'FlowDeclaration',
        'Statement',
        'Declaration',
    ],
    fields: {
        declaration: validateOptionalType('Flow'),
        specifiers: validateOptional(arrayOfType('ExportSpecifier', 'ExportNamespaceSpecifier')),
        source: validateOptionalType('StringLiteral'),
        default: validateOptional(assertValueType('boolean')),
        ...importAttributes,
    },
});
defineType$3('DeclareExportAllDeclaration', {
    visitor: ['source', 'attributes'],
    aliases: [
        'FlowDeclaration',
        'Statement',
        'Declaration',
    ],
    fields: {
        source: validateType('StringLiteral'),
        exportKind: validateOptional(assertOneOf('type', 'value')),
        ...importAttributes,
    },
});
defineType$3('DeclaredPredicate', {
    visitor: ['value'],
    aliases: ['FlowPredicate'],
    fields: {
        value: validateType('Flow'),
    },
});
defineType$3('ExistsTypeAnnotation', {
    aliases: ['FlowType'],
});
defineType$3('FunctionTypeAnnotation', {
    builder: [
        'typeParameters',
        'params',
        'rest',
        'returnType',
    ],
    visitor: [
        'typeParameters',
        'this',
        'params',
        'rest',
        'returnType',
    ],
    aliases: ['FlowType'],
    fields: {
        typeParameters: validateOptionalType('TypeParameterDeclaration'),
        params: validateArrayOfType('FunctionTypeParam'),
        rest: validateOptionalType('FunctionTypeParam'),
        this: validateOptionalType('FunctionTypeParam'),
        returnType: validateType('FlowType'),
    },
});
defineType$3('FunctionTypeParam', {
    visitor: ['name', 'typeAnnotation'],
    fields: {
        name: validateOptionalType('Identifier'),
        typeAnnotation: validateType('FlowType'),
        optional: validateOptional(assertValueType('boolean')),
    },
});
defineType$3('GenericTypeAnnotation', {
    visitor: ['id', 'typeParameters'],
    aliases: ['FlowType'],
    fields: {
        id: validateType('Identifier', 'QualifiedTypeIdentifier'),
        typeParameters: validateOptionalType('TypeParameterInstantiation'),
    },
});
defineType$3('InferredPredicate', {
    aliases: ['FlowPredicate'],
});
defineType$3('InterfaceExtends', {
    visitor: ['id', 'typeParameters'],
    fields: {
        id: validateType('Identifier', 'QualifiedTypeIdentifier'),
        typeParameters: validateOptionalType('TypeParameterInstantiation'),
    },
});
defineInterfaceishType('InterfaceDeclaration');
defineType$3('InterfaceTypeAnnotation', {
    visitor: ['extends', 'body'],
    aliases: ['FlowType'],
    fields: {
        extends: validateOptional(arrayOfType('InterfaceExtends')),
        body: validateType('ObjectTypeAnnotation'),
    },
});
defineType$3('IntersectionTypeAnnotation', {
    visitor: ['types'],
    aliases: ['FlowType'],
    fields: {
        types: validate$2(arrayOfType('FlowType')),
    },
});
defineType$3('MixedTypeAnnotation', {
    aliases: ['FlowType', 'FlowBaseAnnotation'],
});
defineType$3('EmptyTypeAnnotation', {
    aliases: ['FlowType', 'FlowBaseAnnotation'],
});
defineType$3('NullableTypeAnnotation', {
    visitor: ['typeAnnotation'],
    aliases: ['FlowType'],
    fields: {
        typeAnnotation: validateType('FlowType'),
    },
});
defineType$3('NumberLiteralTypeAnnotation', {
    builder: ['value'],
    aliases: ['FlowType'],
    fields: {
        value: validate$2(assertValueType('number')),
    },
});
defineType$3('NumberTypeAnnotation', {
    aliases: ['FlowType', 'FlowBaseAnnotation'],
});
defineType$3('ObjectTypeAnnotation', {
    visitor: [
        'properties',
        'indexers',
        'callProperties',
        'internalSlots',
    ],
    aliases: ['FlowType'],
    builder: [
        'properties',
        'indexers',
        'callProperties',
        'internalSlots',
        'exact',
    ],
    fields: {
        properties: validate$2(arrayOfType('ObjectTypeProperty', 'ObjectTypeSpreadProperty')),
        indexers: {
            validate: arrayOfType('ObjectTypeIndexer'),
            optional: false,
            default: [],
        },
        callProperties: {
            validate: arrayOfType('ObjectTypeCallProperty'),
            optional: false,
            default: [],
        },
        internalSlots: {
            validate: arrayOfType('ObjectTypeInternalSlot'),
            optional: false,
            default: [],
        },
        exact: {
            validate: assertValueType('boolean'),
            default: false,
        },
        inexact: validateOptional(assertValueType('boolean')),
    },
});
defineType$3('ObjectTypeInternalSlot', {
    visitor: ['id', 'value'],
    builder: [
        'id',
        'value',
        'optional',
        'static',
        'method',
    ],
    aliases: ['UserWhitespacable'],
    fields: {
        id: validateType('Identifier'),
        value: validateType('FlowType'),
        optional: validate$2(assertValueType('boolean')),
        static: validate$2(assertValueType('boolean')),
        method: validate$2(assertValueType('boolean')),
    },
});
defineType$3('ObjectTypeCallProperty', {
    visitor: ['value'],
    aliases: ['UserWhitespacable'],
    fields: {
        value: validateType('FlowType'),
        static: validate$2(assertValueType('boolean')),
    },
});
defineType$3('ObjectTypeIndexer', {
    visitor: [
        'variance',
        'id',
        'key',
        'value',
    ],
    builder: [
        'id',
        'key',
        'value',
        'variance',
    ],
    aliases: ['UserWhitespacable'],
    fields: {
        id: validateOptionalType('Identifier'),
        key: validateType('FlowType'),
        value: validateType('FlowType'),
        static: validate$2(assertValueType('boolean')),
        variance: validateOptionalType('Variance'),
    },
});
defineType$3('ObjectTypeProperty', {
    visitor: [
        'key',
        'value',
        'variance',
    ],
    aliases: ['UserWhitespacable'],
    fields: {
        key: validateType('Identifier', 'StringLiteral'),
        value: validateType('FlowType'),
        kind: validate$2(assertOneOf('init', 'get', 'set')),
        static: validate$2(assertValueType('boolean')),
        proto: validate$2(assertValueType('boolean')),
        optional: validate$2(assertValueType('boolean')),
        variance: validateOptionalType('Variance'),
        method: validate$2(assertValueType('boolean')),
    },
});
defineType$3('ObjectTypeSpreadProperty', {
    visitor: ['argument'],
    aliases: ['UserWhitespacable'],
    fields: {
        argument: validateType('FlowType'),
    },
});
defineType$3('OpaqueType', {
    visitor: [
        'id',
        'typeParameters',
        'supertype',
        'impltype',
    ],
    aliases: [
        'FlowDeclaration',
        'Statement',
        'Declaration',
    ],
    fields: {
        id: validateType('Identifier'),
        typeParameters: validateOptionalType('TypeParameterDeclaration'),
        supertype: validateOptionalType('FlowType'),
        impltype: validateType('FlowType'),
    },
});
defineType$3('QualifiedTypeIdentifier', {
    visitor: ['qualification', 'id'],
    builder: ['id', 'qualification'],
    fields: {
        id: validateType('Identifier'),
        qualification: validateType('Identifier', 'QualifiedTypeIdentifier'),
    },
});
defineType$3('StringLiteralTypeAnnotation', {
    builder: ['value'],
    aliases: ['FlowType'],
    fields: {
        value: validate$2(assertValueType('string')),
    },
});
defineType$3('StringTypeAnnotation', {
    aliases: ['FlowType', 'FlowBaseAnnotation'],
});
defineType$3('SymbolTypeAnnotation', {
    aliases: ['FlowType', 'FlowBaseAnnotation'],
});
defineType$3('ThisTypeAnnotation', {
    aliases: ['FlowType', 'FlowBaseAnnotation'],
});
defineType$3('TupleTypeAnnotation', {
    visitor: ['types'],
    aliases: ['FlowType'],
    fields: {
        types: validate$2(arrayOfType('FlowType')),
    },
});
defineType$3('TypeofTypeAnnotation', {
    visitor: ['argument'],
    aliases: ['FlowType'],
    fields: {
        argument: validateType('FlowType'),
    },
});
defineType$3('TypeAlias', {
    visitor: [
        'id',
        'typeParameters',
        'right',
    ],
    aliases: [
        'FlowDeclaration',
        'Statement',
        'Declaration',
    ],
    fields: {
        id: validateType('Identifier'),
        typeParameters: validateOptionalType('TypeParameterDeclaration'),
        right: validateType('FlowType'),
    },
});
defineType$3('TypeAnnotation', {
    visitor: ['typeAnnotation'],
    fields: {
        typeAnnotation: validateType('FlowType'),
    },
});
defineType$3('TypeCastExpression', {
    visitor: ['expression', 'typeAnnotation'],
    aliases: ['ExpressionWrapper', 'Expression'],
    fields: {
        expression: validateType('Expression'),
        typeAnnotation: validateType('TypeAnnotation'),
    },
});
defineType$3('TypeParameter', {
    visitor: [
        'bound',
        'default',
        'variance',
    ],
    fields: {
        name: validate$2(assertValueType('string')),
        bound: validateOptionalType('TypeAnnotation'),
        default: validateOptionalType('FlowType'),
        variance: validateOptionalType('Variance'),
    },
});
defineType$3('TypeParameterDeclaration', {
    visitor: ['params'],
    fields: {
        params: validate$2(arrayOfType('TypeParameter')),
    },
});
defineType$3('TypeParameterInstantiation', {
    visitor: ['params'],
    fields: {
        params: validate$2(arrayOfType('FlowType')),
    },
});
defineType$3('UnionTypeAnnotation', {
    visitor: ['types'],
    aliases: ['FlowType'],
    fields: {
        types: validate$2(arrayOfType('FlowType')),
    },
});
defineType$3('Variance', {
    builder: ['kind'],
    fields: {
        kind: validate$2(assertOneOf('minus', 'plus')),
    },
});
defineType$3('VoidTypeAnnotation', {
    aliases: ['FlowType', 'FlowBaseAnnotation'],
});
defineType$3('EnumDeclaration', {
    aliases: ['Statement', 'Declaration'],
    visitor: ['id', 'body'],
    fields: {
        id: validateType('Identifier'),
        body: validateType('EnumBooleanBody', 'EnumNumberBody', 'EnumStringBody', 'EnumSymbolBody'),
    },
});
defineType$3('EnumBooleanBody', {
    aliases: ['EnumBody'],
    visitor: ['members'],
    fields: {
        explicitType: validate$2(assertValueType('boolean')),
        members: validateArrayOfType('EnumBooleanMember'),
        hasUnknownMembers: validate$2(assertValueType('boolean')),
    },
});
defineType$3('EnumNumberBody', {
    aliases: ['EnumBody'],
    visitor: ['members'],
    fields: {
        explicitType: validate$2(assertValueType('boolean')),
        members: validateArrayOfType('EnumNumberMember'),
        hasUnknownMembers: validate$2(assertValueType('boolean')),
    },
});
defineType$3('EnumStringBody', {
    aliases: ['EnumBody'],
    visitor: ['members'],
    fields: {
        explicitType: validate$2(assertValueType('boolean')),
        members: validateArrayOfType('EnumStringMember', 'EnumDefaultedMember'),
        hasUnknownMembers: validate$2(assertValueType('boolean')),
    },
});
defineType$3('EnumSymbolBody', {
    aliases: ['EnumBody'],
    visitor: ['members'],
    fields: {
        members: validateArrayOfType('EnumDefaultedMember'),
        hasUnknownMembers: validate$2(assertValueType('boolean')),
    },
});
defineType$3('EnumBooleanMember', {
    aliases: ['EnumMember'],
    builder: ['id'],
    visitor: ['id', 'init'],
    fields: {
        id: validateType('Identifier'),
        init: validateType('BooleanLiteral'),
    },
});
defineType$3('EnumNumberMember', {
    aliases: ['EnumMember'],
    visitor: ['id', 'init'],
    fields: {
        id: validateType('Identifier'),
        init: validateType('NumericLiteral'),
    },
});
defineType$3('EnumStringMember', {
    aliases: ['EnumMember'],
    visitor: ['id', 'init'],
    fields: {
        id: validateType('Identifier'),
        init: validateType('StringLiteral'),
    },
});
defineType$3('EnumDefaultedMember', {
    aliases: ['EnumMember'],
    visitor: ['id'],
    fields: {
        id: validateType('Identifier'),
    },
});
defineType$3('IndexedAccessType', {
    visitor: ['objectType', 'indexType'],
    aliases: ['FlowType'],
    fields: {
        objectType: validateType('FlowType'),
        indexType: validateType('FlowType'),
    },
});
defineType$3('OptionalIndexedAccessType', {
    visitor: ['objectType', 'indexType'],
    aliases: ['FlowType'],
    fields: {
        objectType: validateType('FlowType'),
        indexType: validateType('FlowType'),
        optional: validate$2(assertValueType('boolean')),
    },
});
var defineType$2 = defineAliasedType('JSX');

defineType$2('JSXAttribute', {
    visitor: ['name', 'value'],
    aliases: ['Immutable'],
    fields: {
        name: {
            validate: assertNodeType('JSXIdentifier', 'JSXNamespacedName'),
        },
        value: {
            optional: true,
            validate: assertNodeType('JSXElement', 'JSXFragment', 'StringLiteral', 'JSXExpressionContainer'),
        },
    },
});
defineType$2('JSXClosingElement', {
    visitor: ['name'],
    aliases: ['Immutable'],
    fields: {
        name: {
            validate: assertNodeType('JSXIdentifier', 'JSXMemberExpression', 'JSXNamespacedName'),
        },
    },
});
defineType$2('JSXElement', {
    builder: [
        'openingElement',
        'closingElement',
        'children',
    ],
    visitor: [
        'openingElement',
        'children',
        'closingElement',
    ],
    aliases: ['Immutable', 'Expression'],
    fields: {
        openingElement: {
            validate: assertNodeType('JSXOpeningElement'),
        },
        closingElement: {
            optional: true,
            validate: assertNodeType('JSXClosingElement'),
        },
        children: validateArrayOfType('JSXText', 'JSXExpressionContainer', 'JSXSpreadChild', 'JSXElement', 'JSXFragment'),
    },
});
defineType$2('JSXEmptyExpression', {});
defineType$2('JSXExpressionContainer', {
    visitor: ['expression'],
    aliases: ['Immutable'],
    fields: {
        expression: {
            validate: assertNodeType('Expression', 'JSXEmptyExpression'),
        },
    },
});
defineType$2('JSXSpreadChild', {
    visitor: ['expression'],
    aliases: ['Immutable'],
    fields: {
        expression: {
            validate: assertNodeType('Expression'),
        },
    },
});
defineType$2('JSXIdentifier', {
    builder: ['name'],
    fields: {
        name: {
            validate: assertValueType('string'),
        },
    },
});
defineType$2('JSXMemberExpression', {
    visitor: ['object', 'property'],
    fields: {
        object: {
            validate: assertNodeType('JSXMemberExpression', 'JSXIdentifier'),
        },
        property: {
            validate: assertNodeType('JSXIdentifier'),
        },
    },
});
defineType$2('JSXNamespacedName', {
    visitor: ['namespace', 'name'],
    fields: {
        namespace: {
            validate: assertNodeType('JSXIdentifier'),
        },
        name: {
            validate: assertNodeType('JSXIdentifier'),
        },
    },
});
defineType$2('JSXOpeningElement', {
    builder: [
        'name',
        'attributes',
        'selfClosing',
    ],
    visitor: [
        'name',
        'typeArguments',
        'attributes',
    ],
    aliases: ['Immutable'],
    fields: {
        name: {
            validate: assertNodeType('JSXIdentifier', 'JSXMemberExpression', 'JSXNamespacedName'),
        },
        selfClosing: {
            default: false,
        },
        attributes: validateArrayOfType('JSXAttribute', 'JSXSpreadAttribute'),
        typeArguments: {
            validate: assertNodeType('TypeParameterInstantiation', 'TSTypeParameterInstantiation'),
            optional: true,
        },
    },
});
defineType$2('JSXSpreadAttribute', {
    visitor: ['argument'],
    fields: {
        argument: {
            validate: assertNodeType('Expression'),
        },
    },
});
defineType$2('JSXText', {
    aliases: ['Immutable'],
    builder: ['value'],
    fields: {
        value: {
            validate: assertValueType('string'),
        },
    },
});
defineType$2('JSXFragment', {
    builder: [
        'openingFragment',
        'closingFragment',
        'children',
    ],
    visitor: [
        'openingFragment',
        'children',
        'closingFragment',
    ],
    aliases: ['Immutable', 'Expression'],
    fields: {
        openingFragment: {
            validate: assertNodeType('JSXOpeningFragment'),
        },
        closingFragment: {
            validate: assertNodeType('JSXClosingFragment'),
        },
        children: validateArrayOfType('JSXText', 'JSXExpressionContainer', 'JSXSpreadChild', 'JSXElement', 'JSXFragment'),
    },
});
defineType$2('JSXOpeningFragment', {
    aliases: ['Immutable'],
});
defineType$2('JSXClosingFragment', {
    aliases: ['Immutable'],
});
var PLACEHOLDERS = [
    'Identifier',
    'StringLiteral',
    'Expression',
    'Statement',
    'Declaration',
    'BlockStatement',
    'ClassBody',
    'Pattern',
];

var PLACEHOLDERS_ALIAS = {
    Declaration: ['Statement'],
    Pattern: ['PatternLike', 'LVal'],
};

for (const type of PLACEHOLDERS) {
    const alias2 = ALIAS_KEYS[type];
    
    if (alias2?.length)
        PLACEHOLDERS_ALIAS[type] = alias2;
}

var PLACEHOLDERS_FLIPPED_ALIAS = {};

Object
    .keys(PLACEHOLDERS_ALIAS)
    .forEach((type) => {
        PLACEHOLDERS_ALIAS[type].forEach((alias2) => {
            if (!Object.hasOwn(PLACEHOLDERS_FLIPPED_ALIAS, alias2)) {
                PLACEHOLDERS_FLIPPED_ALIAS[alias2] = [];
            }
            
            PLACEHOLDERS_FLIPPED_ALIAS[alias2].push(type);
        });
    });
var defineType$1 = defineAliasedType('Miscellaneous');

defineType$1('Placeholder', {
    visitor: [],
    builder: ['expectedNode', 'name'],
    fields: {
        name: {
            validate: assertNodeType('Identifier'),
        },
        expectedNode: {
            validate: assertOneOf(...PLACEHOLDERS),
        },
        ...patternLikeCommon(),
    },
});
defineType$1('V8IntrinsicIdentifier', {
    builder: ['name'],
    fields: {
        name: {
            validate: assertValueType('string'),
        },
    },
});
defineType$5('ArgumentPlaceholder', {});
defineType$5('BindExpression', {
    visitor: ['object', 'callee'],
    aliases: ['Expression'],
    fields: {
        object: {
            validate: assertNodeType('Expression'),
        },
        callee: {
            validate: assertNodeType('Expression'),
        },
    },
});
defineType$5('Decorator', {
    visitor: ['expression'],
    fields: {
        expression: {
            validate: assertNodeType('Expression'),
        },
    },
});
defineType$5('DoExpression', {
    visitor: ['body'],
    builder: ['body', 'async'],
    aliases: ['Expression'],
    fields: {
        body: {
            validate: assertNodeType('BlockStatement'),
        },
        async: {
            validate: assertValueType('boolean'),
            default: false,
        },
    },
});
defineType$5('ExportDefaultSpecifier', {
    visitor: ['exported'],
    aliases: ['ModuleSpecifier'],
    fields: {
        exported: {
            validate: assertNodeType('Identifier'),
        },
    },
});
defineType$5('ModuleExpression', {
    visitor: ['body'],
    fields: {
        body: {
            validate: assertNodeType('Program'),
        },
    },
    aliases: ['Expression'],
});
defineType$5('TopicReference', {
    aliases: ['Expression'],
});
defineType$5('PipelineTopicExpression', {
    builder: ['expression'],
    visitor: ['expression'],
    fields: {
        expression: {
            validate: assertNodeType('Expression'),
        },
    },
    aliases: ['Expression'],
});
defineType$5('PipelineBareFunction', {
    builder: ['callee'],
    visitor: ['callee'],
    fields: {
        callee: {
            validate: assertNodeType('Expression'),
        },
    },
    aliases: ['Expression'],
});
defineType$5('PipelinePrimaryTopicReference', {
    aliases: ['Expression'],
});
defineType$5('VoidPattern', {
    aliases: [
        'Pattern',
        'PatternLike',
        'FunctionParameter',
    ],
});
var defineType = defineAliasedType('TypeScript');
var bool = assertValueType('boolean');

var tSFunctionTypeAnnotationCommon = () => ({
    returnType: {
        validate: assertNodeType('TSTypeAnnotation'),
        optional: true,
    },
    typeParameters: {
        validate: assertNodeType('TSTypeParameterDeclaration'),
        optional: true,
    },
});

defineType('TSParameterProperty', {
    aliases: [],
    visitor: ['parameter'],
    fields: {
        accessibility: {
            validate: assertOneOf('public', 'private', 'protected'),
            optional: true,
        },
        readonly: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        parameter: {
            validate: assertNodeType('Identifier', 'AssignmentPattern'),
        },
        override: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        decorators: {
            validate: arrayOfType('Decorator'),
            optional: true,
        },
    },
});
defineType('TSDeclareFunction', {
    aliases: ['Statement', 'Declaration'],
    visitor: [
        'id',
        'typeParameters',
        'params',
        'returnType',
    ],
    fields: {
        ...functionDeclarationCommon(),
        ...tSFunctionTypeAnnotationCommon(),
    },
});
defineType('TSDeclareMethod', {
    visitor: [
        'decorators',
        'key',
        'typeParameters',
        'params',
        'returnType',
    ],
    ...classMethodOrPropertyUnionShapeCommon(),
    fields: {
        ...classMethodOrDeclareMethodCommon(),
        ...tSFunctionTypeAnnotationCommon(),
    },
});
defineType('TSQualifiedName', {
    aliases: ['TSEntityName'],
    visitor: ['left', 'right'],
    fields: {
        left: validateType('TSEntityName'),
        right: validateType('Identifier'),
    },
});
var signatureDeclarationCommon = () => ({
    typeParameters: validateOptionalType('TSTypeParameterDeclaration'),
    ['params']: validateArrayOfType('ArrayPattern', 'Identifier', 'ObjectPattern', 'RestElement'),
    ['returnType']: validateOptionalType('TSTypeAnnotation'),
});

var callConstructSignatureDeclaration = {
    aliases: ['TSTypeElement'],
    visitor: [
        'typeParameters',
        'params',
        'returnType',
    ],
    fields: signatureDeclarationCommon(),
};

defineType('TSCallSignatureDeclaration', callConstructSignatureDeclaration);
defineType('TSConstructSignatureDeclaration', callConstructSignatureDeclaration);
var namedTypeElementCommon = () => ({
    key: validateType('Expression'),
    computed: {
        default: false,
    },
    optional: validateOptional(bool),
});

defineType('TSPropertySignature', {
    aliases: ['TSTypeElement'],
    visitor: ['key', 'typeAnnotation'],
    fields: {
        ...namedTypeElementCommon(),
        readonly: validateOptional(bool),
        typeAnnotation: validateOptionalType('TSTypeAnnotation'),
        kind: {
            optional: true,
            validate: assertOneOf('get', 'set'),
        },
    },
});
defineType('TSMethodSignature', {
    aliases: ['TSTypeElement'],
    visitor: [
        'key',
        'typeParameters',
        'params',
        'returnType',
    ],
    fields: {
        ...signatureDeclarationCommon(),
        ...namedTypeElementCommon(),
        kind: {
            validate: assertOneOf('method', 'get', 'set'),
        },
    },
});
defineType('TSIndexSignature', {
    aliases: ['TSTypeElement'],
    visitor: ['parameters', 'typeAnnotation'],
    fields: {
        readonly: validateOptional(bool),
        static: validateOptional(bool),
        parameters: validateArrayOfType('Identifier'),
        typeAnnotation: validateOptionalType('TSTypeAnnotation'),
    },
});
var tsKeywordTypes = [
    'TSAnyKeyword',
    'TSBooleanKeyword',
    'TSBigIntKeyword',
    'TSIntrinsicKeyword',
    'TSNeverKeyword',
    'TSNullKeyword',
    'TSNumberKeyword',
    'TSObjectKeyword',
    'TSStringKeyword',
    'TSSymbolKeyword',
    'TSUndefinedKeyword',
    'TSUnknownKeyword',
    'TSVoidKeyword',
];

for (const type of tsKeywordTypes) {
    defineType(type, {
        aliases: ['TSType', 'TSBaseType'],
        visitor: [],
        fields: {},
    });
}

defineType('TSThisType', {
    aliases: ['TSType', 'TSBaseType'],
    visitor: [],
    fields: {},
});

var fnOrCtrBase = {
    aliases: ['TSType'],
    visitor: [
        'typeParameters',
        'params',
        'returnType',
    ],
};

defineType('TSFunctionType', {
    ...fnOrCtrBase,
    fields: signatureDeclarationCommon(),
});
defineType('TSConstructorType', {
    ...fnOrCtrBase,
    fields: {
        ...signatureDeclarationCommon(),
        abstract: validateOptional(bool),
    },
});
defineType('TSTypeReference', {
    aliases: ['TSType'],
    visitor: ['typeName', 'typeArguments'],
    fields: {
        typeName: validateType('TSEntityName'),
        ['typeArguments']: validateOptionalType('TSTypeParameterInstantiation'),
    },
});
defineType('TSTypePredicate', {
    aliases: ['TSType'],
    visitor: ['parameterName', 'typeAnnotation'],
    builder: [
        'parameterName',
        'typeAnnotation',
        'asserts',
    ],
    fields: {
        parameterName: validateType('Identifier', 'TSThisType'),
        typeAnnotation: validateOptionalType('TSTypeAnnotation'),
        asserts: validateOptional(bool),
    },
});
defineType('TSTypeQuery', {
    aliases: ['TSType'],
    visitor: ['exprName', 'typeArguments'],
    fields: {
        exprName: validateType('TSEntityName', 'TSImportType'),
        ['typeArguments']: validateOptionalType('TSTypeParameterInstantiation'),
    },
});
defineType('TSTypeLiteral', {
    aliases: ['TSType'],
    visitor: ['members'],
    fields: {
        members: validateArrayOfType('TSTypeElement'),
    },
});
defineType('TSArrayType', {
    aliases: ['TSType'],
    visitor: ['elementType'],
    fields: {
        elementType: validateType('TSType'),
    },
});
defineType('TSTupleType', {
    aliases: ['TSType'],
    visitor: ['elementTypes'],
    fields: {
        elementTypes: validateArrayOfType('TSType', 'TSNamedTupleMember'),
    },
});
defineType('TSOptionalType', {
    aliases: ['TSType'],
    visitor: ['typeAnnotation'],
    fields: {
        typeAnnotation: validateType('TSType'),
    },
});
defineType('TSRestType', {
    aliases: ['TSType'],
    visitor: ['typeAnnotation'],
    fields: {
        typeAnnotation: validateType('TSType'),
    },
});
defineType('TSNamedTupleMember', {
    visitor: ['label', 'elementType'],
    builder: [
        'label',
        'elementType',
        'optional',
    ],
    fields: {
        label: validateType('Identifier'),
        optional: {
            validate: bool,
            default: false,
        },
        elementType: validateType('TSType'),
    },
});
var unionOrIntersection = {
    aliases: ['TSType'],
    visitor: ['types'],
    fields: {
        types: validateArrayOfType('TSType'),
    },
};

defineType('TSUnionType', unionOrIntersection);
defineType('TSIntersectionType', unionOrIntersection);
defineType('TSConditionalType', {
    aliases: ['TSType'],
    visitor: [
        'checkType',
        'extendsType',
        'trueType',
        'falseType',
    ],
    fields: {
        checkType: validateType('TSType'),
        extendsType: validateType('TSType'),
        trueType: validateType('TSType'),
        falseType: validateType('TSType'),
    },
});
defineType('TSInferType', {
    aliases: ['TSType'],
    visitor: ['typeParameter'],
    fields: {
        typeParameter: validateType('TSTypeParameter'),
    },
});
defineType('TSParenthesizedType', {
    aliases: ['TSType'],
    visitor: ['typeAnnotation'],
    fields: {
        typeAnnotation: validateType('TSType'),
    },
});
defineType('TSTypeOperator', {
    aliases: ['TSType'],
    visitor: ['typeAnnotation'],
    builder: ['typeAnnotation', 'operator'],
    fields: {
        operator: {
            validate: assertOneOf('keyof', 'readonly', 'unique'),
            default: void 0,
        },
        typeAnnotation: validateType('TSType'),
    },
});
defineType('TSIndexedAccessType', {
    aliases: ['TSType'],
    visitor: ['objectType', 'indexType'],
    fields: {
        objectType: validateType('TSType'),
        indexType: validateType('TSType'),
    },
});
defineType('TSMappedType', {
    aliases: ['TSType'],
    visitor: [
        'key',
        'constraint',
        'nameType',
        'typeAnnotation',
    ],
    builder: [
        'key',
        'constraint',
        'nameType',
        'typeAnnotation',
    ],
    fields: {
        key: validateType('Identifier'),
        constraint: validateType('TSType'),
        readonly: validateOptional(assertOneOf(true, false, '+', '-')),
        optional: validateOptional(assertOneOf(true, false, '+', '-')),
        typeAnnotation: validateOptionalType('TSType'),
        nameType: validateOptionalType('TSType'),
    },
});
defineType('TSTemplateLiteralType', {
    aliases: ['TSType', 'TSBaseType'],
    visitor: ['quasis', 'types'],
    fields: {
        quasis: validateArrayOfType('TemplateElement'),
        types: {
            validate: chain$2(assertValueType('array'), assertEach(assertNodeType('TSType')), function(node, key, val) {
                if (node.quasis.length !== val.length + 1) {
                    throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of types.
Expected ${val.length + 1} quasis but got ${node.quasis.length}`);
                }
            }),
        },
    },
});
defineType('TSLiteralType', {
    aliases: ['TSType', 'TSBaseType'],
    visitor: ['literal'],
    fields: {
        literal: {
            validate: (function() {
                const unaryExpression3 = assertNodeType('NumericLiteral', 'BigIntLiteral');
                const unaryOperator = assertOneOf('-');
                const literal = assertNodeType('NumericLiteral', 'StringLiteral', 'BooleanLiteral', 'BigIntLiteral', 'TemplateLiteral');
                
                const validator = function validator2(parent, key, node) {
                    if (is$1('UnaryExpression', node)) {
                        unaryOperator(node, 'operator', node.operator);
                        unaryExpression3(node, 'argument', node.argument);
                    } else {
                        literal(parent, key, node);
                    }
                };
                
                validator.oneOfNodeTypes = [
                    'NumericLiteral',
                    'StringLiteral',
                    'BooleanLiteral',
                    'BigIntLiteral',
                    'TemplateLiteral',
                    'UnaryExpression',
                ];
                return validator;
            })(),
        },
    },
});
defineType('TSClassImplements', {
    aliases: ['TSType'],
    visitor: ['expression', 'typeArguments'],
    fields: {
        expression: validateType('Expression'),
        typeArguments: validateOptionalType('TSTypeParameterInstantiation'),
    },
});
defineType('TSInterfaceHeritage', {
    aliases: ['TSType'],
    visitor: ['expression', 'typeArguments'],
    fields: {
        expression: validateType('Expression'),
        typeArguments: validateOptionalType('TSTypeParameterInstantiation'),
    },
});
defineType('TSInterfaceDeclaration', {
    aliases: ['Statement', 'Declaration'],
    visitor: [
        'id',
        'typeParameters',
        'extends',
        'body',
    ],
    fields: {
        declare: validateOptional(bool),
        id: validateType('Identifier'),
        typeParameters: validateOptionalType('TSTypeParameterDeclaration'),
        extends: validateOptional(arrayOfType('TSClassImplements')),
        body: validateType('TSInterfaceBody'),
    },
});
defineType('TSInterfaceBody', {
    visitor: ['body'],
    fields: {
        body: validateArrayOfType('TSTypeElement'),
    },
});
defineType('TSTypeAliasDeclaration', {
    aliases: ['Statement', 'Declaration'],
    visitor: [
        'id',
        'typeParameters',
        'typeAnnotation',
    ],
    fields: {
        declare: validateOptional(bool),
        id: validateType('Identifier'),
        typeParameters: validateOptionalType('TSTypeParameterDeclaration'),
        typeAnnotation: validateType('TSType'),
    },
});
defineType('TSInstantiationExpression', {
    aliases: ['Expression'],
    visitor: ['expression', 'typeArguments'],
    fields: {
        expression: validateType('Expression'),
        ['typeArguments']: validateOptionalType('TSTypeParameterInstantiation'),
    },
});
var TSTypeExpression = {
    aliases: [
        'Expression',
        'LVal',
        'PatternLike',
    ],
    visitor: ['expression', 'typeAnnotation'],
    fields: {
        expression: validateType('Expression'),
        typeAnnotation: validateType('TSType'),
    },
};

defineType('TSAsExpression', TSTypeExpression);
defineType('TSSatisfiesExpression', TSTypeExpression);
defineType('TSTypeAssertion', {
    aliases: [
        'Expression',
        'LVal',
        'PatternLike',
    ],
    visitor: ['typeAnnotation', 'expression'],
    fields: {
        typeAnnotation: validateType('TSType'),
        expression: validateType('Expression'),
    },
});
defineType('TSEnumBody', {
    visitor: ['members'],
    fields: {
        members: validateArrayOfType('TSEnumMember'),
    },
});
defineType('TSEnumDeclaration', {
    aliases: ['Statement', 'Declaration'],
    visitor: ['id', 'body'],
    fields: {
        declare: validateOptional(bool),
        const: validateOptional(bool),
        id: validateType('Identifier'),
        body: validateType('TSEnumBody'),
    },
});
defineType('TSEnumMember', {
    visitor: ['id', 'initializer'],
    fields: {
        id: validateType('Identifier', 'StringLiteral'),
        initializer: validateOptionalType('Expression'),
    },
});
defineType('TSModuleDeclaration', {
    aliases: ['Statement', 'Declaration'],
    visitor: ['id', 'body'],
    fields: {
        kind: {
            validate: assertOneOf('global', 'module', 'namespace'),
        },
        declare: validateOptional(bool),
        id: {
            validate: chain$2(assertNodeType('TSEntityName', 'StringLiteral'), Object.assign(function(node, key, val) {
                if (node.kind === 'module' && !is$1('StringLiteral', val)) {
                    throw new TypeError(`TSModuleDeclaration of kind 'module' must have a StringLiteral id.`);
                }
                
                if (node.kind === 'namespace' && is$1('StringLiteral', val)) {
                    throw new TypeError(`TSModuleDeclaration of kind 'namespace' cannot have a StringLiteral id.`);
                }
            }, {
                oneOfNodeTypes: ['TSEntityName', 'StringLiteral'],
            })),
        },
        body: validateType('TSModuleBlock'),
    },
});
defineType('TSModuleBlock', {
    aliases: [
        'Scopable',
        'Block',
        'BlockParent',
        'FunctionParent',
    ],
    visitor: ['body'],
    fields: {
        body: validateArrayOfType('Statement'),
    },
});
defineType('TSImportType', {
    aliases: ['TSType'],
    builder: [
        'source',
        'qualifier',
        'typeArguments',
    ],
    visitor: [
        'source',
        'options',
        'qualifier',
        'typeArguments',
    ],
    fields: {
        source: validateType('StringLiteral'),
        qualifier: validateOptionalType('TSEntityName'),
        typeArguments: validateOptionalType('TSTypeParameterInstantiation'),
        options: {
            validate: assertNodeType('ObjectExpression'),
            optional: true,
        },
    },
});
defineType('TSImportEqualsDeclaration', {
    aliases: ['Statement', 'Declaration'],
    visitor: ['id', 'moduleReference'],
    fields: {
        id: validateType('Identifier'),
        moduleReference: validateType('TSEntityName', 'TSExternalModuleReference'),
        importKind: {
            validate: assertOneOf('type', 'value'),
            optional: true,
        },
    },
});
defineType('TSExternalModuleReference', {
    visitor: ['expression'],
    fields: {
        expression: validateType('StringLiteral'),
    },
});
defineType('TSNonNullExpression', {
    aliases: [
        'Expression',
        'LVal',
        'PatternLike',
    ],
    visitor: ['expression'],
    fields: {
        expression: validateType('Expression'),
    },
});
defineType('TSExportAssignment', {
    aliases: ['Statement'],
    visitor: ['expression'],
    fields: {
        expression: validateType('Expression'),
    },
});
defineType('TSNamespaceExportDeclaration', {
    aliases: ['Statement'],
    visitor: ['id'],
    fields: {
        id: validateType('Identifier'),
    },
});
defineType('TSTypeAnnotation', {
    visitor: ['typeAnnotation'],
    fields: {
        typeAnnotation: {
            validate: assertNodeType('TSType'),
        },
    },
});
defineType('TSTypeParameterInstantiation', {
    visitor: ['params'],
    fields: {
        params: validateArrayOfType('TSType'),
    },
});
defineType('TSTypeParameterDeclaration', {
    visitor: ['params'],
    fields: {
        params: validateArrayOfType('TSTypeParameter'),
    },
});
defineType('TSTypeParameter', {
    builder: [
        'constraint',
        'default',
        'name',
    ],
    visitor: [
        'name',
        'constraint',
        'default',
    ],
    fields: {
        name: {
            validate: assertNodeType('Identifier'),
        },
        in: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        out: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        const: {
            validate: assertValueType('boolean'),
            optional: true,
        },
        constraint: {
            validate: assertNodeType('TSType'),
            optional: true,
        },
        default: {
            validate: assertNodeType('TSType'),
            optional: true,
        },
    },
});
var DEPRECATED_ALIASES = {
    ModuleDeclaration: 'ImportOrExportDeclaration',
};

Object
    .keys(DEPRECATED_ALIASES)
    .forEach((deprecatedAlias) => {
        FLIPPED_ALIAS_KEYS[deprecatedAlias] = FLIPPED_ALIAS_KEYS[DEPRECATED_ALIASES[deprecatedAlias]];
    });
for (const {types: types2, set} of allExpandedTypes) {
    for (const type of types2) {
        const aliases = FLIPPED_ALIAS_KEYS[type];
        
        if (aliases) {
            aliases.forEach(set.add, set);
        } else {
            set.add(type);
        }
    }
}

var TYPES$4 = [].concat(Object.keys(VISITOR_KEYS), Object.keys(FLIPPED_ALIAS_KEYS), Object.keys(DEPRECATED_KEYS));

function validate$1$1(node, key, val) {
    if (!node)
        return;
    
    const fields = NODE_FIELDS$1[node.type];
    
    if (!fields)
        return;
    
    const field = fields[key];
    validateField(node, key, val, field);
    validateChild(node, key, val);
}

function validateInternal(field, node, key, val, maybeNode) {
    if (!field?.validate)
        return;
    
    if (field.optional && val == null)
        return;
    
    field.validate(node, key, val);
    
    if (maybeNode) {
        const type = val.type;
        
        if (type == null)
            return;
        
        NODE_PARENT_VALIDATIONS[type]?.(node, key, val);
    }
}

function validateField(node, key, val, field) {
    if (!field?.validate)
        return;
    
    if (field.optional && val == null)
        return;
    
    field.validate(node, key, val);
}

function validateChild(node, key, val) {
    const type = val?.type;
    
    if (type == null)
        return;
    
    NODE_PARENT_VALIDATIONS[type]?.(node, key, val);
}

var _validate = /* @__PURE__ */Object.freeze({
    __proto__: null,
    default: validate$1$1,
    validateChild,
    validateField,
    validateInternal,
});

var {validateInternal: validate$3} = _validate;

var {NODE_FIELDS} = utils$1;

function arrayExpression$3(elements) {
    const node = {
        type: 'ArrayExpression',
        elements,
    };
    
    const defs = NODE_FIELDS.ArrayExpression;
    validate$3(defs.elements, node, 'elements', elements, 1);
    return node;
}

function assignmentExpression(operator, left, right) {
    const node = {
        type: 'AssignmentExpression',
        operator,
        left,
        right,
    };
    
    const defs = NODE_FIELDS.AssignmentExpression;
    validate$3(defs.operator, node, 'operator', operator);
    validate$3(defs.left, node, 'left', left, 1);
    validate$3(defs.right, node, 'right', right, 1);
    return node;
}

function binaryExpression(operator, left, right) {
    const node = {
        type: 'BinaryExpression',
        operator,
        left,
        right,
    };
    
    const defs = NODE_FIELDS.BinaryExpression;
    validate$3(defs.operator, node, 'operator', operator);
    validate$3(defs.left, node, 'left', left, 1);
    validate$3(defs.right, node, 'right', right, 1);
    return node;
}

function interpreterDirective(value) {
    const node = {
        type: 'InterpreterDirective',
        value,
    };
    
    const defs = NODE_FIELDS.InterpreterDirective;
    validate$3(defs.value, node, 'value', value);
    return node;
}

function directive$1(value) {
    const node = {
        type: 'Directive',
        value,
    };
    
    const defs = NODE_FIELDS.Directive;
    validate$3(defs.value, node, 'value', value, 1);
    return node;
}

function directiveLiteral$1(value) {
    const node = {
        type: 'DirectiveLiteral',
        value,
    };
    
    const defs = NODE_FIELDS.DirectiveLiteral;
    validate$3(defs.value, node, 'value', value);
    return node;
}

function blockStatement$1(body, directives = []) {
    const node = {
        type: 'BlockStatement',
        body,
        directives,
    };
    
    const defs = NODE_FIELDS.BlockStatement;
    validate$3(defs.body, node, 'body', body, 1);
    validate$3(defs.directives, node, 'directives', directives, 1);
    return node;
}

function breakStatement(label = null) {
    const node = {
        type: 'BreakStatement',
        label,
    };
    
    const defs = NODE_FIELDS.BreakStatement;
    validate$3(defs.label, node, 'label', label, 1);
    return node;
}

function callExpression(callee, _arguments) {
    const node = {
        type: 'CallExpression',
        callee,
        arguments: _arguments,
    };
    
    const defs = NODE_FIELDS.CallExpression;
    validate$3(defs.callee, node, 'callee', callee, 1);
    validate$3(defs.arguments, node, 'arguments', _arguments, 1);
    return node;
}

function catchClause(param = null, body) {
    const node = {
        type: 'CatchClause',
        param,
        body,
    };
    
    const defs = NODE_FIELDS.CatchClause;
    validate$3(defs.param, node, 'param', param, 1);
    validate$3(defs.body, node, 'body', body, 1);
    return node;
}

function conditionalExpression(test, consequent, alternate) {
    const node = {
        type: 'ConditionalExpression',
        test,
        consequent,
        alternate,
    };
    
    const defs = NODE_FIELDS.ConditionalExpression;
    validate$3(defs.test, node, 'test', test, 1);
    validate$3(defs.consequent, node, 'consequent', consequent, 1);
    validate$3(defs.alternate, node, 'alternate', alternate, 1);
    return node;
}

function continueStatement(label = null) {
    const node = {
        type: 'ContinueStatement',
        label,
    };
    
    const defs = NODE_FIELDS.ContinueStatement;
    validate$3(defs.label, node, 'label', label, 1);
    return node;
}

function debuggerStatement() {
    return {
        type: 'DebuggerStatement',
    };
}

function doWhileStatement(test, body) {
    const node = {
        type: 'DoWhileStatement',
        test,
        body,
    };
    
    const defs = NODE_FIELDS.DoWhileStatement;
    validate$3(defs.test, node, 'test', test, 1);
    validate$3(defs.body, node, 'body', body, 1);
    return node;
}

function emptyStatement() {
    return {
        type: 'EmptyStatement',
    };
}

function expressionStatement$4(expression2) {
    const node = {
        type: 'ExpressionStatement',
        expression: expression2,
    };
    
    const defs = NODE_FIELDS.ExpressionStatement;
    validate$3(defs.expression, node, 'expression', expression2, 1);
    return node;
}

function file$1(program3, comments = null, tokens = null) {
    const node = {
        type: 'File',
        program: program3,
        comments,
        tokens,
    };
    
    const defs = NODE_FIELDS.File;
    validate$3(defs.program, node, 'program', program3, 1);
    validate$3(defs.comments, node, 'comments', comments, 1);
    validate$3(defs.tokens, node, 'tokens', tokens);
    return node;
}

function forInStatement(left, right, body) {
    const node = {
        type: 'ForInStatement',
        left,
        right,
        body,
    };
    
    const defs = NODE_FIELDS.ForInStatement;
    validate$3(defs.left, node, 'left', left, 1);
    validate$3(defs.right, node, 'right', right, 1);
    validate$3(defs.body, node, 'body', body, 1);
    return node;
}

function forStatement(init = null, test = null, update = null, body) {
    const node = {
        type: 'ForStatement',
        init,
        test,
        update,
        body,
    };
    
    const defs = NODE_FIELDS.ForStatement;
    validate$3(defs.init, node, 'init', init, 1);
    validate$3(defs.test, node, 'test', test, 1);
    validate$3(defs.update, node, 'update', update, 1);
    validate$3(defs.body, node, 'body', body, 1);
    return node;
}

function functionDeclaration(id = null, params, body, generator = false, async = false) {
    const node = {
        type: 'FunctionDeclaration',
        id,
        params,
        body,
        generator,
        async,
    };
    
    const defs = NODE_FIELDS.FunctionDeclaration;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.params, node, 'params', params, 1);
    validate$3(defs.body, node, 'body', body, 1);
    validate$3(defs.generator, node, 'generator', generator);
    validate$3(defs.async, node, 'async', async);
    return node;
}

function functionExpression(id = null, params, body, generator = false, async = false) {
    const node = {
        type: 'FunctionExpression',
        id,
        params,
        body,
        generator,
        async,
    };
    
    const defs = NODE_FIELDS.FunctionExpression;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.params, node, 'params', params, 1);
    validate$3(defs.body, node, 'body', body, 1);
    validate$3(defs.generator, node, 'generator', generator);
    validate$3(defs.async, node, 'async', async);
    return node;
}

function identifier$2(name) {
    const node = {
        type: 'Identifier',
        name,
    };
    
    const defs = NODE_FIELDS.Identifier;
    validate$3(defs.name, node, 'name', name);
    return node;
}

function ifStatement(test, consequent, alternate = null) {
    const node = {
        type: 'IfStatement',
        test,
        consequent,
        alternate,
    };
    
    const defs = NODE_FIELDS.IfStatement;
    validate$3(defs.test, node, 'test', test, 1);
    validate$3(defs.consequent, node, 'consequent', consequent, 1);
    validate$3(defs.alternate, node, 'alternate', alternate, 1);
    return node;
}

function labeledStatement(label, body) {
    const node = {
        type: 'LabeledStatement',
        label,
        body,
    };
    
    const defs = NODE_FIELDS.LabeledStatement;
    validate$3(defs.label, node, 'label', label, 1);
    validate$3(defs.body, node, 'body', body, 1);
    return node;
}

function stringLiteral$5(value) {
    const node = {
        type: 'StringLiteral',
        value,
    };
    
    const defs = NODE_FIELDS.StringLiteral;
    validate$3(defs.value, node, 'value', value);
    return node;
}

function numericLiteral(value) {
    const node = {
        type: 'NumericLiteral',
        value,
    };
    
    const defs = NODE_FIELDS.NumericLiteral;
    validate$3(defs.value, node, 'value', value);
    return node;
}

function nullLiteral() {
    return {
        type: 'NullLiteral',
    };
}

function booleanLiteral(value) {
    const node = {
        type: 'BooleanLiteral',
        value,
    };
    
    const defs = NODE_FIELDS.BooleanLiteral;
    validate$3(defs.value, node, 'value', value);
    return node;
}

function regExpLiteral(pattern, flags = '') {
    const node = {
        type: 'RegExpLiteral',
        pattern,
        flags,
    };
    
    const defs = NODE_FIELDS.RegExpLiteral;
    validate$3(defs.pattern, node, 'pattern', pattern);
    validate$3(defs.flags, node, 'flags', flags);
    return node;
}

function logicalExpression(operator, left, right) {
    const node = {
        type: 'LogicalExpression',
        operator,
        left,
        right,
    };
    
    const defs = NODE_FIELDS.LogicalExpression;
    validate$3(defs.operator, node, 'operator', operator);
    validate$3(defs.left, node, 'left', left, 1);
    validate$3(defs.right, node, 'right', right, 1);
    return node;
}

function memberExpression(object, property, computed = false) {
    const node = {
        type: 'MemberExpression',
        object,
        property,
        computed,
    };
    
    const defs = NODE_FIELDS.MemberExpression;
    validate$3(defs.object, node, 'object', object, 1);
    validate$3(defs.property, node, 'property', property, 1);
    validate$3(defs.computed, node, 'computed', computed);
    return node;
}

function newExpression(callee, _arguments) {
    const node = {
        type: 'NewExpression',
        callee,
        arguments: _arguments,
    };
    
    const defs = NODE_FIELDS.NewExpression;
    validate$3(defs.callee, node, 'callee', callee, 1);
    validate$3(defs.arguments, node, 'arguments', _arguments, 1);
    return node;
}

function program$1(body, directives = [], sourceType = 'script', interpreter = null) {
    const node = {
        type: 'Program',
        body,
        directives,
        sourceType,
        interpreter,
    };
    
    const defs = NODE_FIELDS.Program;
    validate$3(defs.body, node, 'body', body, 1);
    validate$3(defs.directives, node, 'directives', directives, 1);
    validate$3(defs.sourceType, node, 'sourceType', sourceType);
    validate$3(defs.interpreter, node, 'interpreter', interpreter, 1);
    return node;
}

function objectExpression$2(properties) {
    const node = {
        type: 'ObjectExpression',
        properties,
    };
    
    const defs = NODE_FIELDS.ObjectExpression;
    validate$3(defs.properties, node, 'properties', properties, 1);
    return node;
}

function objectMethod$1(kind, key, params, body, computed = false, generator = false, async = false) {
    const node = {
        type: 'ObjectMethod',
        kind,
        key,
        params,
        body,
        computed,
        generator,
        async,
    };
    
    const defs = NODE_FIELDS.ObjectMethod;
    validate$3(defs.kind, node, 'kind', kind);
    validate$3(defs.key, node, 'key', key, 1);
    validate$3(defs.params, node, 'params', params, 1);
    validate$3(defs.body, node, 'body', body, 1);
    validate$3(defs.computed, node, 'computed', computed);
    validate$3(defs.generator, node, 'generator', generator);
    validate$3(defs.async, node, 'async', async);
    return node;
}

function objectProperty$3(key, value, computed = false, shorthand = false) {
    const node = {
        type: 'ObjectProperty',
        key,
        value,
        computed,
        shorthand,
    };
    
    const defs = NODE_FIELDS.ObjectProperty;
    validate$3(defs.key, node, 'key', key, 1);
    validate$3(defs.value, node, 'value', value, 1);
    validate$3(defs.computed, node, 'computed', computed);
    validate$3(defs.shorthand, node, 'shorthand', shorthand);
    return node;
}

function restElement(argument) {
    const node = {
        type: 'RestElement',
        argument,
    };
    
    const defs = NODE_FIELDS.RestElement;
    validate$3(defs.argument, node, 'argument', argument, 1);
    return node;
}

function returnStatement(argument = null) {
    const node = {
        type: 'ReturnStatement',
        argument,
    };
    
    const defs = NODE_FIELDS.ReturnStatement;
    validate$3(defs.argument, node, 'argument', argument, 1);
    return node;
}

function sequenceExpression(expressions) {
    const node = {
        type: 'SequenceExpression',
        expressions,
    };
    
    const defs = NODE_FIELDS.SequenceExpression;
    validate$3(defs.expressions, node, 'expressions', expressions, 1);
    return node;
}

function parenthesizedExpression$1(expression2) {
    const node = {
        type: 'ParenthesizedExpression',
        expression: expression2,
    };
    
    const defs = NODE_FIELDS.ParenthesizedExpression;
    validate$3(defs.expression, node, 'expression', expression2, 1);
    return node;
}

function switchCase(test = null, consequent) {
    const node = {
        type: 'SwitchCase',
        test,
        consequent,
    };
    
    const defs = NODE_FIELDS.SwitchCase;
    validate$3(defs.test, node, 'test', test, 1);
    validate$3(defs.consequent, node, 'consequent', consequent, 1);
    return node;
}

function switchStatement(discriminant, cases) {
    const node = {
        type: 'SwitchStatement',
        discriminant,
        cases,
    };
    
    const defs = NODE_FIELDS.SwitchStatement;
    validate$3(defs.discriminant, node, 'discriminant', discriminant, 1);
    validate$3(defs.cases, node, 'cases', cases, 1);
    return node;
}

function thisExpression() {
    return {
        type: 'ThisExpression',
    };
}

function throwStatement(argument) {
    const node = {
        type: 'ThrowStatement',
        argument,
    };
    
    const defs = NODE_FIELDS.ThrowStatement;
    validate$3(defs.argument, node, 'argument', argument, 1);
    return node;
}

function tryStatement(block, handler = null, finalizer = null) {
    const node = {
        type: 'TryStatement',
        block,
        handler,
        finalizer,
    };
    
    const defs = NODE_FIELDS.TryStatement;
    validate$3(defs.block, node, 'block', block, 1);
    validate$3(defs.handler, node, 'handler', handler, 1);
    validate$3(defs.finalizer, node, 'finalizer', finalizer, 1);
    return node;
}

function unaryExpression$1(operator, argument, prefix2 = true) {
    const node = {
        type: 'UnaryExpression',
        operator,
        argument,
        prefix: prefix2,
    };
    
    const defs = NODE_FIELDS.UnaryExpression;
    validate$3(defs.operator, node, 'operator', operator);
    validate$3(defs.argument, node, 'argument', argument, 1);
    validate$3(defs.prefix, node, 'prefix', prefix2);
    return node;
}

function updateExpression(operator, argument, prefix2 = false) {
    const node = {
        type: 'UpdateExpression',
        operator,
        argument,
        prefix: prefix2,
    };
    
    const defs = NODE_FIELDS.UpdateExpression;
    validate$3(defs.operator, node, 'operator', operator);
    validate$3(defs.argument, node, 'argument', argument, 1);
    validate$3(defs.prefix, node, 'prefix', prefix2);
    return node;
}

function variableDeclaration(kind, declarations) {
    const node = {
        type: 'VariableDeclaration',
        kind,
        declarations,
    };
    
    const defs = NODE_FIELDS.VariableDeclaration;
    validate$3(defs.kind, node, 'kind', kind);
    validate$3(defs.declarations, node, 'declarations', declarations, 1);
    return node;
}

function variableDeclarator(id, init = null) {
    const node = {
        type: 'VariableDeclarator',
        id,
        init,
    };
    
    const defs = NODE_FIELDS.VariableDeclarator;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.init, node, 'init', init, 1);
    return node;
}

function whileStatement(test, body) {
    const node = {
        type: 'WhileStatement',
        test,
        body,
    };
    
    const defs = NODE_FIELDS.WhileStatement;
    validate$3(defs.test, node, 'test', test, 1);
    validate$3(defs.body, node, 'body', body, 1);
    return node;
}

function withStatement(object, body) {
    const node = {
        type: 'WithStatement',
        object,
        body,
    };
    
    const defs = NODE_FIELDS.WithStatement;
    validate$3(defs.object, node, 'object', object, 1);
    validate$3(defs.body, node, 'body', body, 1);
    return node;
}

function assignmentPattern(left, right) {
    const node = {
        type: 'AssignmentPattern',
        left,
        right,
    };
    
    const defs = NODE_FIELDS.AssignmentPattern;
    validate$3(defs.left, node, 'left', left, 1);
    validate$3(defs.right, node, 'right', right, 1);
    return node;
}

function arrayPattern(elements) {
    const node = {
        type: 'ArrayPattern',
        elements,
    };
    
    const defs = NODE_FIELDS.ArrayPattern;
    validate$3(defs.elements, node, 'elements', elements, 1);
    return node;
}

function arrowFunctionExpression(params, body, async = false) {
    const node = {
        type: 'ArrowFunctionExpression',
        params,
        body,
        async,
        expression: null,
    };
    
    const defs = NODE_FIELDS.ArrowFunctionExpression;
    validate$3(defs.params, node, 'params', params, 1);
    validate$3(defs.body, node, 'body', body, 1);
    validate$3(defs.async, node, 'async', async);
    return node;
}

function classBody(body) {
    const node = {
        type: 'ClassBody',
        body,
    };
    
    const defs = NODE_FIELDS.ClassBody;
    validate$3(defs.body, node, 'body', body, 1);
    return node;
}

function classExpression(id = null, superClass = null, body, decorators = null) {
    const node = {
        type: 'ClassExpression',
        id,
        superClass,
        body,
        decorators,
    };
    
    const defs = NODE_FIELDS.ClassExpression;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.superClass, node, 'superClass', superClass, 1);
    validate$3(defs.body, node, 'body', body, 1);
    validate$3(defs.decorators, node, 'decorators', decorators, 1);
    return node;
}

function classDeclaration(id = null, superClass = null, body, decorators = null) {
    const node = {
        type: 'ClassDeclaration',
        id,
        superClass,
        body,
        decorators,
    };
    
    const defs = NODE_FIELDS.ClassDeclaration;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.superClass, node, 'superClass', superClass, 1);
    validate$3(defs.body, node, 'body', body, 1);
    validate$3(defs.decorators, node, 'decorators', decorators, 1);
    return node;
}

function exportAllDeclaration(source) {
    const node = {
        type: 'ExportAllDeclaration',
        source,
        assertions: null,
    };
    
    const defs = NODE_FIELDS.ExportAllDeclaration;
    validate$3(defs.source, node, 'source', source, 1);
    return node;
}

function exportDefaultDeclaration(declaration) {
    const node = {
        type: 'ExportDefaultDeclaration',
        declaration,
    };
    
    const defs = NODE_FIELDS.ExportDefaultDeclaration;
    validate$3(defs.declaration, node, 'declaration', declaration, 1);
    return node;
}

function exportNamedDeclaration(declaration = null, specifiers = [], source = null) {
    const node = {
        type: 'ExportNamedDeclaration',
        declaration,
        specifiers,
        source,
    };
    
    const defs = NODE_FIELDS.ExportNamedDeclaration;
    validate$3(defs.declaration, node, 'declaration', declaration, 1);
    validate$3(defs.specifiers, node, 'specifiers', specifiers, 1);
    validate$3(defs.source, node, 'source', source, 1);
    return node;
}

function exportSpecifier(local, exported) {
    const node = {
        type: 'ExportSpecifier',
        local,
        exported,
    };
    
    const defs = NODE_FIELDS.ExportSpecifier;
    validate$3(defs.local, node, 'local', local, 1);
    validate$3(defs.exported, node, 'exported', exported, 1);
    return node;
}

function forOfStatement(left, right, body, _await = false) {
    const node = {
        type: 'ForOfStatement',
        left,
        right,
        body,
        await: _await,
    };
    
    const defs = NODE_FIELDS.ForOfStatement;
    validate$3(defs.left, node, 'left', left, 1);
    validate$3(defs.right, node, 'right', right, 1);
    validate$3(defs.body, node, 'body', body, 1);
    validate$3(defs.await, node, 'await', _await);
    return node;
}

function importDeclaration(specifiers, source) {
    const node = {
        type: 'ImportDeclaration',
        specifiers,
        source,
    };
    
    const defs = NODE_FIELDS.ImportDeclaration;
    validate$3(defs.specifiers, node, 'specifiers', specifiers, 1);
    validate$3(defs.source, node, 'source', source, 1);
    return node;
}

function importDefaultSpecifier(local) {
    const node = {
        type: 'ImportDefaultSpecifier',
        local,
    };
    
    const defs = NODE_FIELDS.ImportDefaultSpecifier;
    validate$3(defs.local, node, 'local', local, 1);
    return node;
}

function importNamespaceSpecifier(local) {
    const node = {
        type: 'ImportNamespaceSpecifier',
        local,
    };
    
    const defs = NODE_FIELDS.ImportNamespaceSpecifier;
    validate$3(defs.local, node, 'local', local, 1);
    return node;
}

function importSpecifier(local, imported) {
    const node = {
        type: 'ImportSpecifier',
        local,
        imported,
    };
    
    const defs = NODE_FIELDS.ImportSpecifier;
    validate$3(defs.local, node, 'local', local, 1);
    validate$3(defs.imported, node, 'imported', imported, 1);
    return node;
}

function importExpression(source, options = null) {
    const node = {
        type: 'ImportExpression',
        source,
        options,
    };
    
    const defs = NODE_FIELDS.ImportExpression;
    validate$3(defs.source, node, 'source', source, 1);
    validate$3(defs.options, node, 'options', options, 1);
    return node;
}

function metaProperty(meta, property) {
    const node = {
        type: 'MetaProperty',
        meta,
        property,
    };
    
    const defs = NODE_FIELDS.MetaProperty;
    validate$3(defs.meta, node, 'meta', meta, 1);
    validate$3(defs.property, node, 'property', property, 1);
    return node;
}

function classMethod$1(kind = 'method', key, params, body, computed = false, _static = false, generator = false, async = false) {
    const node = {
        type: 'ClassMethod',
        kind,
        key,
        params,
        body,
        computed,
        static: _static,
        generator,
        async,
    };
    
    const defs = NODE_FIELDS.ClassMethod;
    validate$3(defs.kind, node, 'kind', kind);
    validate$3(defs.key, node, 'key', key, 1);
    validate$3(defs.params, node, 'params', params, 1);
    validate$3(defs.body, node, 'body', body, 1);
    validate$3(defs.computed, node, 'computed', computed);
    validate$3(defs.static, node, 'static', _static);
    validate$3(defs.generator, node, 'generator', generator);
    validate$3(defs.async, node, 'async', async);
    return node;
}

function objectPattern$1(properties) {
    const node = {
        type: 'ObjectPattern',
        properties,
    };
    
    const defs = NODE_FIELDS.ObjectPattern;
    validate$3(defs.properties, node, 'properties', properties, 1);
    return node;
}

function spreadElement(argument) {
    const node = {
        type: 'SpreadElement',
        argument,
    };
    
    const defs = NODE_FIELDS.SpreadElement;
    validate$3(defs.argument, node, 'argument', argument, 1);
    return node;
}

function _super() {
    return {
        type: 'Super',
    };
}

function taggedTemplateExpression(tag, quasi) {
    const node = {
        type: 'TaggedTemplateExpression',
        tag,
        quasi,
    };
    
    const defs = NODE_FIELDS.TaggedTemplateExpression;
    validate$3(defs.tag, node, 'tag', tag, 1);
    validate$3(defs.quasi, node, 'quasi', quasi, 1);
    return node;
}

function templateElement$1(value, tail = false) {
    const node = {
        type: 'TemplateElement',
        value,
        tail,
    };
    
    const defs = NODE_FIELDS.TemplateElement;
    validate$3(defs.value, node, 'value', value);
    validate$3(defs.tail, node, 'tail', tail);
    return node;
}

function templateLiteral(quasis, expressions) {
    const node = {
        type: 'TemplateLiteral',
        quasis,
        expressions,
    };
    
    const defs = NODE_FIELDS.TemplateLiteral;
    validate$3(defs.quasis, node, 'quasis', quasis, 1);
    validate$3(defs.expressions, node, 'expressions', expressions, 1);
    return node;
}

function yieldExpression(argument = null, delegate = false) {
    const node = {
        type: 'YieldExpression',
        argument,
        delegate,
    };
    
    const defs = NODE_FIELDS.YieldExpression;
    validate$3(defs.argument, node, 'argument', argument, 1);
    validate$3(defs.delegate, node, 'delegate', delegate);
    return node;
}

function awaitExpression(argument) {
    const node = {
        type: 'AwaitExpression',
        argument,
    };
    
    const defs = NODE_FIELDS.AwaitExpression;
    validate$3(defs.argument, node, 'argument', argument, 1);
    return node;
}

function _import() {
    return {
        type: 'Import',
    };
}

function bigIntLiteral(value) {
    const node = {
        type: 'BigIntLiteral',
        value,
    };
    
    const defs = NODE_FIELDS.BigIntLiteral;
    validate$3(defs.value, node, 'value', value);
    return node;
}

function exportNamespaceSpecifier(exported) {
    const node = {
        type: 'ExportNamespaceSpecifier',
        exported,
    };
    
    const defs = NODE_FIELDS.ExportNamespaceSpecifier;
    validate$3(defs.exported, node, 'exported', exported, 1);
    return node;
}

function optionalMemberExpression(object, property, computed = false, optional) {
    const node = {
        type: 'OptionalMemberExpression',
        object,
        property,
        computed,
        optional,
    };
    
    const defs = NODE_FIELDS.OptionalMemberExpression;
    validate$3(defs.object, node, 'object', object, 1);
    validate$3(defs.property, node, 'property', property, 1);
    validate$3(defs.computed, node, 'computed', computed);
    validate$3(defs.optional, node, 'optional', optional);
    return node;
}

function optionalCallExpression(callee, _arguments, optional) {
    const node = {
        type: 'OptionalCallExpression',
        callee,
        arguments: _arguments,
        optional,
    };
    
    const defs = NODE_FIELDS.OptionalCallExpression;
    validate$3(defs.callee, node, 'callee', callee, 1);
    validate$3(defs.arguments, node, 'arguments', _arguments, 1);
    validate$3(defs.optional, node, 'optional', optional);
    return node;
}

function classProperty(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
    const node = {
        type: 'ClassProperty',
        key,
        value,
        typeAnnotation: typeAnnotation2,
        decorators,
        computed,
        static: _static,
    };
    
    const defs = NODE_FIELDS.ClassProperty;
    validate$3(defs.key, node, 'key', key, 1);
    validate$3(defs.value, node, 'value', value, 1);
    validate$3(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    validate$3(defs.decorators, node, 'decorators', decorators, 1);
    validate$3(defs.computed, node, 'computed', computed);
    validate$3(defs.static, node, 'static', _static);
    return node;
}

function classAccessorProperty(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
    const node = {
        type: 'ClassAccessorProperty',
        key,
        value,
        typeAnnotation: typeAnnotation2,
        decorators,
        computed,
        static: _static,
    };
    
    const defs = NODE_FIELDS.ClassAccessorProperty;
    validate$3(defs.key, node, 'key', key, 1);
    validate$3(defs.value, node, 'value', value, 1);
    validate$3(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    validate$3(defs.decorators, node, 'decorators', decorators, 1);
    validate$3(defs.computed, node, 'computed', computed);
    validate$3(defs.static, node, 'static', _static);
    return node;
}

function classPrivateProperty(key, value = null, decorators = null, _static = false) {
    const node = {
        type: 'ClassPrivateProperty',
        key,
        value,
        decorators,
        static: _static,
    };
    
    const defs = NODE_FIELDS.ClassPrivateProperty;
    validate$3(defs.key, node, 'key', key, 1);
    validate$3(defs.value, node, 'value', value, 1);
    validate$3(defs.decorators, node, 'decorators', decorators, 1);
    validate$3(defs.static, node, 'static', _static);
    return node;
}

function classPrivateMethod$1(kind = 'method', key, params, body, _static = false) {
    const node = {
        type: 'ClassPrivateMethod',
        kind,
        key,
        params,
        body,
        static: _static,
    };
    
    const defs = NODE_FIELDS.ClassPrivateMethod;
    validate$3(defs.kind, node, 'kind', kind);
    validate$3(defs.key, node, 'key', key, 1);
    validate$3(defs.params, node, 'params', params, 1);
    validate$3(defs.body, node, 'body', body, 1);
    validate$3(defs.static, node, 'static', _static);
    return node;
}

function privateName$1(id) {
    const node = {
        type: 'PrivateName',
        id,
    };
    
    const defs = NODE_FIELDS.PrivateName;
    validate$3(defs.id, node, 'id', id, 1);
    return node;
}

function staticBlock(body) {
    const node = {
        type: 'StaticBlock',
        body,
    };
    
    const defs = NODE_FIELDS.StaticBlock;
    validate$3(defs.body, node, 'body', body, 1);
    return node;
}

function importAttribute(key, value) {
    const node = {
        type: 'ImportAttribute',
        key,
        value,
    };
    
    const defs = NODE_FIELDS.ImportAttribute;
    validate$3(defs.key, node, 'key', key, 1);
    validate$3(defs.value, node, 'value', value, 1);
    return node;
}

function anyTypeAnnotation() {
    return {
        type: 'AnyTypeAnnotation',
    };
}

function arrayTypeAnnotation(elementType) {
    const node = {
        type: 'ArrayTypeAnnotation',
        elementType,
    };
    
    const defs = NODE_FIELDS.ArrayTypeAnnotation;
    validate$3(defs.elementType, node, 'elementType', elementType, 1);
    return node;
}

function booleanTypeAnnotation() {
    return {
        type: 'BooleanTypeAnnotation',
    };
}

function booleanLiteralTypeAnnotation(value) {
    const node = {
        type: 'BooleanLiteralTypeAnnotation',
        value,
    };
    
    const defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;
    validate$3(defs.value, node, 'value', value);
    return node;
}

function nullLiteralTypeAnnotation() {
    return {
        type: 'NullLiteralTypeAnnotation',
    };
}

function classImplements(id, typeParameters = null) {
    const node = {
        type: 'ClassImplements',
        id,
        typeParameters,
    };
    
    const defs = NODE_FIELDS.ClassImplements;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    return node;
}

function declareClass(id, typeParameters = null, _extends = null, body) {
    const node = {
        type: 'DeclareClass',
        id,
        typeParameters,
        extends: _extends,
        body,
    };
    
    const defs = NODE_FIELDS.DeclareClass;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$3(defs.extends, node, 'extends', _extends, 1);
    validate$3(defs.body, node, 'body', body, 1);
    return node;
}

function declareFunction(id) {
    const node = {
        type: 'DeclareFunction',
        id,
    };
    
    const defs = NODE_FIELDS.DeclareFunction;
    validate$3(defs.id, node, 'id', id, 1);
    return node;
}

function declareInterface(id, typeParameters = null, _extends = null, body) {
    const node = {
        type: 'DeclareInterface',
        id,
        typeParameters,
        extends: _extends,
        body,
    };
    
    const defs = NODE_FIELDS.DeclareInterface;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$3(defs.extends, node, 'extends', _extends, 1);
    validate$3(defs.body, node, 'body', body, 1);
    return node;
}

function declareModule(id, body, kind = null) {
    const node = {
        type: 'DeclareModule',
        id,
        body,
        kind,
    };
    
    const defs = NODE_FIELDS.DeclareModule;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.body, node, 'body', body, 1);
    validate$3(defs.kind, node, 'kind', kind);
    return node;
}

function declareModuleExports(typeAnnotation2) {
    const node = {
        type: 'DeclareModuleExports',
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.DeclareModuleExports;
    validate$3(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function declareTypeAlias(id, typeParameters = null, right) {
    const node = {
        type: 'DeclareTypeAlias',
        id,
        typeParameters,
        right,
    };
    
    const defs = NODE_FIELDS.DeclareTypeAlias;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$3(defs.right, node, 'right', right, 1);
    return node;
}

function declareOpaqueType(id, typeParameters = null, supertype = null) {
    const node = {
        type: 'DeclareOpaqueType',
        id,
        typeParameters,
        supertype,
    };
    
    const defs = NODE_FIELDS.DeclareOpaqueType;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$3(defs.supertype, node, 'supertype', supertype, 1);
    return node;
}

function declareVariable(id) {
    const node = {
        type: 'DeclareVariable',
        id,
    };
    
    const defs = NODE_FIELDS.DeclareVariable;
    validate$3(defs.id, node, 'id', id, 1);
    return node;
}

function declareExportDeclaration(declaration = null, specifiers = null, source = null, attributes = null) {
    const node = {
        type: 'DeclareExportDeclaration',
        declaration,
        specifiers,
        source,
        attributes,
    };
    
    const defs = NODE_FIELDS.DeclareExportDeclaration;
    validate$3(defs.declaration, node, 'declaration', declaration, 1);
    validate$3(defs.specifiers, node, 'specifiers', specifiers, 1);
    validate$3(defs.source, node, 'source', source, 1);
    validate$3(defs.attributes, node, 'attributes', attributes, 1);
    return node;
}

function declareExportAllDeclaration(source, attributes = null) {
    const node = {
        type: 'DeclareExportAllDeclaration',
        source,
        attributes,
    };
    
    const defs = NODE_FIELDS.DeclareExportAllDeclaration;
    validate$3(defs.source, node, 'source', source, 1);
    validate$3(defs.attributes, node, 'attributes', attributes, 1);
    return node;
}

function declaredPredicate(value) {
    const node = {
        type: 'DeclaredPredicate',
        value,
    };
    
    const defs = NODE_FIELDS.DeclaredPredicate;
    validate$3(defs.value, node, 'value', value, 1);
    return node;
}

function existsTypeAnnotation() {
    return {
        type: 'ExistsTypeAnnotation',
    };
}

function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
    const node = {
        type: 'FunctionTypeAnnotation',
        typeParameters,
        params,
        rest,
        returnType,
    };
    
    const defs = NODE_FIELDS.FunctionTypeAnnotation;
    validate$3(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$3(defs.params, node, 'params', params, 1);
    validate$3(defs.rest, node, 'rest', rest, 1);
    validate$3(defs.returnType, node, 'returnType', returnType, 1);
    return node;
}

function functionTypeParam(name = null, typeAnnotation2) {
    const node = {
        type: 'FunctionTypeParam',
        name,
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.FunctionTypeParam;
    validate$3(defs.name, node, 'name', name, 1);
    validate$3(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function genericTypeAnnotation(id, typeParameters = null) {
    const node = {
        type: 'GenericTypeAnnotation',
        id,
        typeParameters,
    };
    
    const defs = NODE_FIELDS.GenericTypeAnnotation;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    return node;
}

function inferredPredicate() {
    return {
        type: 'InferredPredicate',
    };
}

function interfaceExtends(id, typeParameters = null) {
    const node = {
        type: 'InterfaceExtends',
        id,
        typeParameters,
    };
    
    const defs = NODE_FIELDS.InterfaceExtends;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    return node;
}

function interfaceDeclaration(id, typeParameters = null, _extends = null, body) {
    const node = {
        type: 'InterfaceDeclaration',
        id,
        typeParameters,
        extends: _extends,
        body,
    };
    
    const defs = NODE_FIELDS.InterfaceDeclaration;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$3(defs.extends, node, 'extends', _extends, 1);
    validate$3(defs.body, node, 'body', body, 1);
    return node;
}

function interfaceTypeAnnotation(_extends = null, body) {
    const node = {
        type: 'InterfaceTypeAnnotation',
        extends: _extends,
        body,
    };
    
    const defs = NODE_FIELDS.InterfaceTypeAnnotation;
    validate$3(defs.extends, node, 'extends', _extends, 1);
    validate$3(defs.body, node, 'body', body, 1);
    return node;
}

function intersectionTypeAnnotation(types2) {
    const node = {
        type: 'IntersectionTypeAnnotation',
        types: types2,
    };
    
    const defs = NODE_FIELDS.IntersectionTypeAnnotation;
    validate$3(defs.types, node, 'types', types2, 1);
    return node;
}

function mixedTypeAnnotation() {
    return {
        type: 'MixedTypeAnnotation',
    };
}

function emptyTypeAnnotation() {
    return {
        type: 'EmptyTypeAnnotation',
    };
}

function nullableTypeAnnotation(typeAnnotation2) {
    const node = {
        type: 'NullableTypeAnnotation',
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.NullableTypeAnnotation;
    validate$3(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function numberLiteralTypeAnnotation(value) {
    const node = {
        type: 'NumberLiteralTypeAnnotation',
        value,
    };
    
    const defs = NODE_FIELDS.NumberLiteralTypeAnnotation;
    validate$3(defs.value, node, 'value', value);
    return node;
}

function numberTypeAnnotation() {
    return {
        type: 'NumberTypeAnnotation',
    };
}

function objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {
    const node = {
        type: 'ObjectTypeAnnotation',
        properties,
        indexers,
        callProperties,
        internalSlots,
        exact,
    };
    
    const defs = NODE_FIELDS.ObjectTypeAnnotation;
    validate$3(defs.properties, node, 'properties', properties, 1);
    validate$3(defs.indexers, node, 'indexers', indexers, 1);
    validate$3(defs.callProperties, node, 'callProperties', callProperties, 1);
    validate$3(defs.internalSlots, node, 'internalSlots', internalSlots, 1);
    validate$3(defs.exact, node, 'exact', exact);
    return node;
}

function objectTypeInternalSlot(id, value, optional, _static, method) {
    const node = {
        type: 'ObjectTypeInternalSlot',
        id,
        value,
        optional,
        static: _static,
        method,
    };
    
    const defs = NODE_FIELDS.ObjectTypeInternalSlot;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.value, node, 'value', value, 1);
    validate$3(defs.optional, node, 'optional', optional);
    validate$3(defs.static, node, 'static', _static);
    validate$3(defs.method, node, 'method', method);
    return node;
}

function objectTypeCallProperty(value) {
    const node = {
        type: 'ObjectTypeCallProperty',
        value,
        static: null,
    };
    
    const defs = NODE_FIELDS.ObjectTypeCallProperty;
    validate$3(defs.value, node, 'value', value, 1);
    return node;
}

function objectTypeIndexer(id = null, key, value, variance2 = null) {
    const node = {
        type: 'ObjectTypeIndexer',
        id,
        key,
        value,
        variance: variance2,
        static: null,
    };
    
    const defs = NODE_FIELDS.ObjectTypeIndexer;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.key, node, 'key', key, 1);
    validate$3(defs.value, node, 'value', value, 1);
    validate$3(defs.variance, node, 'variance', variance2, 1);
    return node;
}

function objectTypeProperty(key, value, variance2 = null) {
    const node = {
        type: 'ObjectTypeProperty',
        key,
        value,
        variance: variance2,
        kind: null,
        method: null,
        optional: null,
        proto: null,
        static: null,
    };
    
    const defs = NODE_FIELDS.ObjectTypeProperty;
    validate$3(defs.key, node, 'key', key, 1);
    validate$3(defs.value, node, 'value', value, 1);
    validate$3(defs.variance, node, 'variance', variance2, 1);
    return node;
}

function objectTypeSpreadProperty(argument) {
    const node = {
        type: 'ObjectTypeSpreadProperty',
        argument,
    };
    
    const defs = NODE_FIELDS.ObjectTypeSpreadProperty;
    validate$3(defs.argument, node, 'argument', argument, 1);
    return node;
}

function opaqueType(id, typeParameters = null, supertype = null, impltype) {
    const node = {
        type: 'OpaqueType',
        id,
        typeParameters,
        supertype,
        impltype,
    };
    
    const defs = NODE_FIELDS.OpaqueType;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$3(defs.supertype, node, 'supertype', supertype, 1);
    validate$3(defs.impltype, node, 'impltype', impltype, 1);
    return node;
}

function qualifiedTypeIdentifier(id, qualification) {
    const node = {
        type: 'QualifiedTypeIdentifier',
        id,
        qualification,
    };
    
    const defs = NODE_FIELDS.QualifiedTypeIdentifier;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.qualification, node, 'qualification', qualification, 1);
    return node;
}

function stringLiteralTypeAnnotation(value) {
    const node = {
        type: 'StringLiteralTypeAnnotation',
        value,
    };
    
    const defs = NODE_FIELDS.StringLiteralTypeAnnotation;
    validate$3(defs.value, node, 'value', value);
    return node;
}

function stringTypeAnnotation() {
    return {
        type: 'StringTypeAnnotation',
    };
}

function symbolTypeAnnotation() {
    return {
        type: 'SymbolTypeAnnotation',
    };
}

function thisTypeAnnotation() {
    return {
        type: 'ThisTypeAnnotation',
    };
}

function tupleTypeAnnotation(types2) {
    const node = {
        type: 'TupleTypeAnnotation',
        types: types2,
    };
    
    const defs = NODE_FIELDS.TupleTypeAnnotation;
    validate$3(defs.types, node, 'types', types2, 1);
    return node;
}

function typeofTypeAnnotation(argument) {
    const node = {
        type: 'TypeofTypeAnnotation',
        argument,
    };
    
    const defs = NODE_FIELDS.TypeofTypeAnnotation;
    validate$3(defs.argument, node, 'argument', argument, 1);
    return node;
}

function typeAlias(id, typeParameters = null, right) {
    const node = {
        type: 'TypeAlias',
        id,
        typeParameters,
        right,
    };
    
    const defs = NODE_FIELDS.TypeAlias;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$3(defs.right, node, 'right', right, 1);
    return node;
}

function typeAnnotation(typeAnnotation2) {
    const node = {
        type: 'TypeAnnotation',
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TypeAnnotation;
    validate$3(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function typeCastExpression(expression2, typeAnnotation2) {
    const node = {
        type: 'TypeCastExpression',
        expression: expression2,
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TypeCastExpression;
    validate$3(defs.expression, node, 'expression', expression2, 1);
    validate$3(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function typeParameter(bound = null, _default = null, variance2 = null) {
    const node = {
        type: 'TypeParameter',
        bound,
        default: _default,
        variance: variance2,
        name: null,
    };
    
    const defs = NODE_FIELDS.TypeParameter;
    validate$3(defs.bound, node, 'bound', bound, 1);
    validate$3(defs.default, node, 'default', _default, 1);
    validate$3(defs.variance, node, 'variance', variance2, 1);
    return node;
}

function typeParameterDeclaration(params) {
    const node = {
        type: 'TypeParameterDeclaration',
        params,
    };
    
    const defs = NODE_FIELDS.TypeParameterDeclaration;
    validate$3(defs.params, node, 'params', params, 1);
    return node;
}

function typeParameterInstantiation(params) {
    const node = {
        type: 'TypeParameterInstantiation',
        params,
    };
    
    const defs = NODE_FIELDS.TypeParameterInstantiation;
    validate$3(defs.params, node, 'params', params, 1);
    return node;
}

function unionTypeAnnotation(types2) {
    const node = {
        type: 'UnionTypeAnnotation',
        types: types2,
    };
    
    const defs = NODE_FIELDS.UnionTypeAnnotation;
    validate$3(defs.types, node, 'types', types2, 1);
    return node;
}

function variance(kind) {
    const node = {
        type: 'Variance',
        kind,
    };
    
    const defs = NODE_FIELDS.Variance;
    validate$3(defs.kind, node, 'kind', kind);
    return node;
}

function voidTypeAnnotation() {
    return {
        type: 'VoidTypeAnnotation',
    };
}

function enumDeclaration(id, body) {
    const node = {
        type: 'EnumDeclaration',
        id,
        body,
    };
    
    const defs = NODE_FIELDS.EnumDeclaration;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.body, node, 'body', body, 1);
    return node;
}

function enumBooleanBody(members) {
    const node = {
        type: 'EnumBooleanBody',
        members,
        explicitType: null,
        hasUnknownMembers: null,
    };
    
    const defs = NODE_FIELDS.EnumBooleanBody;
    validate$3(defs.members, node, 'members', members, 1);
    return node;
}

function enumNumberBody(members) {
    const node = {
        type: 'EnumNumberBody',
        members,
        explicitType: null,
        hasUnknownMembers: null,
    };
    
    const defs = NODE_FIELDS.EnumNumberBody;
    validate$3(defs.members, node, 'members', members, 1);
    return node;
}

function enumStringBody(members) {
    const node = {
        type: 'EnumStringBody',
        members,
        explicitType: null,
        hasUnknownMembers: null,
    };
    
    const defs = NODE_FIELDS.EnumStringBody;
    validate$3(defs.members, node, 'members', members, 1);
    return node;
}

function enumSymbolBody(members) {
    const node = {
        type: 'EnumSymbolBody',
        members,
        hasUnknownMembers: null,
    };
    
    const defs = NODE_FIELDS.EnumSymbolBody;
    validate$3(defs.members, node, 'members', members, 1);
    return node;
}

function enumBooleanMember(id) {
    const node = {
        type: 'EnumBooleanMember',
        id,
        init: null,
    };
    
    const defs = NODE_FIELDS.EnumBooleanMember;
    validate$3(defs.id, node, 'id', id, 1);
    return node;
}

function enumNumberMember(id, init) {
    const node = {
        type: 'EnumNumberMember',
        id,
        init,
    };
    
    const defs = NODE_FIELDS.EnumNumberMember;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.init, node, 'init', init, 1);
    return node;
}

function enumStringMember(id, init) {
    const node = {
        type: 'EnumStringMember',
        id,
        init,
    };
    
    const defs = NODE_FIELDS.EnumStringMember;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.init, node, 'init', init, 1);
    return node;
}

function enumDefaultedMember(id) {
    const node = {
        type: 'EnumDefaultedMember',
        id,
    };
    
    const defs = NODE_FIELDS.EnumDefaultedMember;
    validate$3(defs.id, node, 'id', id, 1);
    return node;
}

function indexedAccessType(objectType, indexType) {
    const node = {
        type: 'IndexedAccessType',
        objectType,
        indexType,
    };
    
    const defs = NODE_FIELDS.IndexedAccessType;
    validate$3(defs.objectType, node, 'objectType', objectType, 1);
    validate$3(defs.indexType, node, 'indexType', indexType, 1);
    return node;
}

function optionalIndexedAccessType(objectType, indexType) {
    const node = {
        type: 'OptionalIndexedAccessType',
        objectType,
        indexType,
        optional: null,
    };
    
    const defs = NODE_FIELDS.OptionalIndexedAccessType;
    validate$3(defs.objectType, node, 'objectType', objectType, 1);
    validate$3(defs.indexType, node, 'indexType', indexType, 1);
    return node;
}

function jsxAttribute$1(name, value = null) {
    const node = {
        type: 'JSXAttribute',
        name,
        value,
    };
    
    const defs = NODE_FIELDS.JSXAttribute;
    validate$3(defs.name, node, 'name', name, 1);
    validate$3(defs.value, node, 'value', value, 1);
    return node;
}

function jsxClosingElement(name) {
    const node = {
        type: 'JSXClosingElement',
        name,
    };
    
    const defs = NODE_FIELDS.JSXClosingElement;
    validate$3(defs.name, node, 'name', name, 1);
    return node;
}

function jsxElement(openingElement, closingElement = null, children) {
    const node = {
        type: 'JSXElement',
        openingElement,
        closingElement,
        children,
    };
    
    const defs = NODE_FIELDS.JSXElement;
    validate$3(defs.openingElement, node, 'openingElement', openingElement, 1);
    validate$3(defs.closingElement, node, 'closingElement', closingElement, 1);
    validate$3(defs.children, node, 'children', children, 1);
    return node;
}

function jsxEmptyExpression() {
    return {
        type: 'JSXEmptyExpression',
    };
}

function jsxExpressionContainer(expression2) {
    const node = {
        type: 'JSXExpressionContainer',
        expression: expression2,
    };
    
    const defs = NODE_FIELDS.JSXExpressionContainer;
    validate$3(defs.expression, node, 'expression', expression2, 1);
    return node;
}

function jsxSpreadChild(expression2) {
    const node = {
        type: 'JSXSpreadChild',
        expression: expression2,
    };
    
    const defs = NODE_FIELDS.JSXSpreadChild;
    validate$3(defs.expression, node, 'expression', expression2, 1);
    return node;
}

function jsxIdentifier$1(name) {
    const node = {
        type: 'JSXIdentifier',
        name,
    };
    
    const defs = NODE_FIELDS.JSXIdentifier;
    validate$3(defs.name, node, 'name', name);
    return node;
}

function jsxMemberExpression(object, property) {
    const node = {
        type: 'JSXMemberExpression',
        object,
        property,
    };
    
    const defs = NODE_FIELDS.JSXMemberExpression;
    validate$3(defs.object, node, 'object', object, 1);
    validate$3(defs.property, node, 'property', property, 1);
    return node;
}

function jsxNamespacedName(namespace, name) {
    const node = {
        type: 'JSXNamespacedName',
        namespace,
        name,
    };
    
    const defs = NODE_FIELDS.JSXNamespacedName;
    validate$3(defs.namespace, node, 'namespace', namespace, 1);
    validate$3(defs.name, node, 'name', name, 1);
    return node;
}

function jsxOpeningElement(name, attributes, selfClosing = false) {
    const node = {
        type: 'JSXOpeningElement',
        name,
        attributes,
        selfClosing,
    };
    
    const defs = NODE_FIELDS.JSXOpeningElement;
    validate$3(defs.name, node, 'name', name, 1);
    validate$3(defs.attributes, node, 'attributes', attributes, 1);
    validate$3(defs.selfClosing, node, 'selfClosing', selfClosing);
    return node;
}

function jsxSpreadAttribute(argument) {
    const node = {
        type: 'JSXSpreadAttribute',
        argument,
    };
    
    const defs = NODE_FIELDS.JSXSpreadAttribute;
    validate$3(defs.argument, node, 'argument', argument, 1);
    return node;
}

function jsxText(value) {
    const node = {
        type: 'JSXText',
        value,
    };
    
    const defs = NODE_FIELDS.JSXText;
    validate$3(defs.value, node, 'value', value);
    return node;
}

function jsxFragment(openingFragment, closingFragment, children) {
    const node = {
        type: 'JSXFragment',
        openingFragment,
        closingFragment,
        children,
    };
    
    const defs = NODE_FIELDS.JSXFragment;
    validate$3(defs.openingFragment, node, 'openingFragment', openingFragment, 1);
    validate$3(defs.closingFragment, node, 'closingFragment', closingFragment, 1);
    validate$3(defs.children, node, 'children', children, 1);
    return node;
}

function jsxOpeningFragment() {
    return {
        type: 'JSXOpeningFragment',
    };
}

function jsxClosingFragment() {
    return {
        type: 'JSXClosingFragment',
    };
}

function placeholder(expectedNode, name) {
    const node = {
        type: 'Placeholder',
        expectedNode,
        name,
    };
    
    const defs = NODE_FIELDS.Placeholder;
    validate$3(defs.expectedNode, node, 'expectedNode', expectedNode);
    validate$3(defs.name, node, 'name', name, 1);
    return node;
}

function v8IntrinsicIdentifier(name) {
    const node = {
        type: 'V8IntrinsicIdentifier',
        name,
    };
    
    const defs = NODE_FIELDS.V8IntrinsicIdentifier;
    validate$3(defs.name, node, 'name', name);
    return node;
}

function argumentPlaceholder() {
    return {
        type: 'ArgumentPlaceholder',
    };
}

function bindExpression(object, callee) {
    const node = {
        type: 'BindExpression',
        object,
        callee,
    };
    
    const defs = NODE_FIELDS.BindExpression;
    validate$3(defs.object, node, 'object', object, 1);
    validate$3(defs.callee, node, 'callee', callee, 1);
    return node;
}

function decorator(expression2) {
    const node = {
        type: 'Decorator',
        expression: expression2,
    };
    
    const defs = NODE_FIELDS.Decorator;
    validate$3(defs.expression, node, 'expression', expression2, 1);
    return node;
}

function doExpression(body, async = false) {
    const node = {
        type: 'DoExpression',
        body,
        async,
    };
    
    const defs = NODE_FIELDS.DoExpression;
    validate$3(defs.body, node, 'body', body, 1);
    validate$3(defs.async, node, 'async', async);
    return node;
}

function exportDefaultSpecifier(exported) {
    const node = {
        type: 'ExportDefaultSpecifier',
        exported,
    };
    
    const defs = NODE_FIELDS.ExportDefaultSpecifier;
    validate$3(defs.exported, node, 'exported', exported, 1);
    return node;
}

function moduleExpression(body) {
    const node = {
        type: 'ModuleExpression',
        body,
    };
    
    const defs = NODE_FIELDS.ModuleExpression;
    validate$3(defs.body, node, 'body', body, 1);
    return node;
}

function topicReference() {
    return {
        type: 'TopicReference',
    };
}

function pipelineTopicExpression(expression2) {
    const node = {
        type: 'PipelineTopicExpression',
        expression: expression2,
    };
    
    const defs = NODE_FIELDS.PipelineTopicExpression;
    validate$3(defs.expression, node, 'expression', expression2, 1);
    return node;
}

function pipelineBareFunction(callee) {
    const node = {
        type: 'PipelineBareFunction',
        callee,
    };
    
    const defs = NODE_FIELDS.PipelineBareFunction;
    validate$3(defs.callee, node, 'callee', callee, 1);
    return node;
}

function pipelinePrimaryTopicReference() {
    return {
        type: 'PipelinePrimaryTopicReference',
    };
}

function voidPattern() {
    return {
        type: 'VoidPattern',
    };
}

function tsParameterProperty(parameter) {
    const node = {
        type: 'TSParameterProperty',
        parameter,
    };
    
    const defs = NODE_FIELDS.TSParameterProperty;
    validate$3(defs.parameter, node, 'parameter', parameter, 1);
    return node;
}

function tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {
    const node = {
        type: 'TSDeclareFunction',
        id,
        typeParameters,
        params,
        returnType,
    };
    
    const defs = NODE_FIELDS.TSDeclareFunction;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$3(defs.params, node, 'params', params, 1);
    validate$3(defs.returnType, node, 'returnType', returnType, 1);
    return node;
}

function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
    const node = {
        type: 'TSDeclareMethod',
        decorators,
        key,
        typeParameters,
        params,
        returnType,
    };
    
    const defs = NODE_FIELDS.TSDeclareMethod;
    validate$3(defs.decorators, node, 'decorators', decorators, 1);
    validate$3(defs.key, node, 'key', key, 1);
    validate$3(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$3(defs.params, node, 'params', params, 1);
    validate$3(defs.returnType, node, 'returnType', returnType, 1);
    return node;
}

function tsQualifiedName(left, right) {
    const node = {
        type: 'TSQualifiedName',
        left,
        right,
    };
    
    const defs = NODE_FIELDS.TSQualifiedName;
    validate$3(defs.left, node, 'left', left, 1);
    validate$3(defs.right, node, 'right', right, 1);
    return node;
}

function tsCallSignatureDeclaration(typeParameters = null, params, returnType = null) {
    const node = {
        type: 'TSCallSignatureDeclaration',
        typeParameters,
        params,
        returnType,
    };
    
    const defs = NODE_FIELDS.TSCallSignatureDeclaration;
    validate$3(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$3(defs.params, node, 'params', params, 1);
    validate$3(defs.returnType, node, 'returnType', returnType, 1);
    return node;
}

function tsConstructSignatureDeclaration(typeParameters = null, params, returnType = null) {
    const node = {
        type: 'TSConstructSignatureDeclaration',
        typeParameters,
        params,
        returnType,
    };
    
    const defs = NODE_FIELDS.TSConstructSignatureDeclaration;
    validate$3(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$3(defs.params, node, 'params', params, 1);
    validate$3(defs.returnType, node, 'returnType', returnType, 1);
    return node;
}

function tsPropertySignature(key, typeAnnotation2 = null) {
    const node = {
        type: 'TSPropertySignature',
        key,
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TSPropertySignature;
    validate$3(defs.key, node, 'key', key, 1);
    validate$3(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function tsMethodSignature(key, typeParameters = null, params, returnType = null) {
    const node = {
        type: 'TSMethodSignature',
        key,
        typeParameters,
        params,
        returnType,
        kind: null,
    };
    
    const defs = NODE_FIELDS.TSMethodSignature;
    validate$3(defs.key, node, 'key', key, 1);
    validate$3(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$3(defs.params, node, 'params', params, 1);
    validate$3(defs.returnType, node, 'returnType', returnType, 1);
    return node;
}

function tsIndexSignature(parameters, typeAnnotation2 = null) {
    const node = {
        type: 'TSIndexSignature',
        parameters,
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TSIndexSignature;
    validate$3(defs.parameters, node, 'parameters', parameters, 1);
    validate$3(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function tsAnyKeyword() {
    return {
        type: 'TSAnyKeyword',
    };
}

function tsBooleanKeyword() {
    return {
        type: 'TSBooleanKeyword',
    };
}

function tsBigIntKeyword() {
    return {
        type: 'TSBigIntKeyword',
    };
}

function tsIntrinsicKeyword() {
    return {
        type: 'TSIntrinsicKeyword',
    };
}

function tsNeverKeyword() {
    return {
        type: 'TSNeverKeyword',
    };
}

function tsNullKeyword() {
    return {
        type: 'TSNullKeyword',
    };
}

function tsNumberKeyword() {
    return {
        type: 'TSNumberKeyword',
    };
}

function tsObjectKeyword() {
    return {
        type: 'TSObjectKeyword',
    };
}

function tsStringKeyword() {
    return {
        type: 'TSStringKeyword',
    };
}

function tsSymbolKeyword() {
    return {
        type: 'TSSymbolKeyword',
    };
}

function tsUndefinedKeyword() {
    return {
        type: 'TSUndefinedKeyword',
    };
}

function tsUnknownKeyword() {
    return {
        type: 'TSUnknownKeyword',
    };
}

function tsVoidKeyword() {
    return {
        type: 'TSVoidKeyword',
    };
}

function tsThisType() {
    return {
        type: 'TSThisType',
    };
}

function tsFunctionType(typeParameters = null, params, returnType = null) {
    const node = {
        type: 'TSFunctionType',
        typeParameters,
        params,
        returnType,
    };
    
    const defs = NODE_FIELDS.TSFunctionType;
    validate$3(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$3(defs.params, node, 'params', params, 1);
    validate$3(defs.returnType, node, 'returnType', returnType, 1);
    return node;
}

function tsConstructorType(typeParameters = null, params, returnType = null) {
    const node = {
        type: 'TSConstructorType',
        typeParameters,
        params,
        returnType,
    };
    
    const defs = NODE_FIELDS.TSConstructorType;
    validate$3(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$3(defs.params, node, 'params', params, 1);
    validate$3(defs.returnType, node, 'returnType', returnType, 1);
    return node;
}

function tsTypeReference(typeName, typeArguments = null) {
    const node = {
        type: 'TSTypeReference',
        typeName,
        typeArguments,
    };
    
    const defs = NODE_FIELDS.TSTypeReference;
    validate$3(defs.typeName, node, 'typeName', typeName, 1);
    validate$3(defs.typeArguments, node, 'typeArguments', typeArguments, 1);
    return node;
}

function tsTypePredicate(parameterName, typeAnnotation2 = null, asserts = null) {
    const node = {
        type: 'TSTypePredicate',
        parameterName,
        typeAnnotation: typeAnnotation2,
        asserts,
    };
    
    const defs = NODE_FIELDS.TSTypePredicate;
    validate$3(defs.parameterName, node, 'parameterName', parameterName, 1);
    validate$3(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    validate$3(defs.asserts, node, 'asserts', asserts);
    return node;
}

function tsTypeQuery(exprName, typeArguments = null) {
    const node = {
        type: 'TSTypeQuery',
        exprName,
        typeArguments,
    };
    
    const defs = NODE_FIELDS.TSTypeQuery;
    validate$3(defs.exprName, node, 'exprName', exprName, 1);
    validate$3(defs.typeArguments, node, 'typeArguments', typeArguments, 1);
    return node;
}

function tsTypeLiteral(members) {
    const node = {
        type: 'TSTypeLiteral',
        members,
    };
    
    const defs = NODE_FIELDS.TSTypeLiteral;
    validate$3(defs.members, node, 'members', members, 1);
    return node;
}

function tsArrayType(elementType) {
    const node = {
        type: 'TSArrayType',
        elementType,
    };
    
    const defs = NODE_FIELDS.TSArrayType;
    validate$3(defs.elementType, node, 'elementType', elementType, 1);
    return node;
}

function tsTupleType(elementTypes) {
    const node = {
        type: 'TSTupleType',
        elementTypes,
    };
    
    const defs = NODE_FIELDS.TSTupleType;
    validate$3(defs.elementTypes, node, 'elementTypes', elementTypes, 1);
    return node;
}

function tsOptionalType(typeAnnotation2) {
    const node = {
        type: 'TSOptionalType',
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TSOptionalType;
    validate$3(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function tsRestType(typeAnnotation2) {
    const node = {
        type: 'TSRestType',
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TSRestType;
    validate$3(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function tsNamedTupleMember(label, elementType, optional = false) {
    const node = {
        type: 'TSNamedTupleMember',
        label,
        elementType,
        optional,
    };
    
    const defs = NODE_FIELDS.TSNamedTupleMember;
    validate$3(defs.label, node, 'label', label, 1);
    validate$3(defs.elementType, node, 'elementType', elementType, 1);
    validate$3(defs.optional, node, 'optional', optional);
    return node;
}

function tsUnionType(types2) {
    const node = {
        type: 'TSUnionType',
        types: types2,
    };
    
    const defs = NODE_FIELDS.TSUnionType;
    validate$3(defs.types, node, 'types', types2, 1);
    return node;
}

function tsIntersectionType(types2) {
    const node = {
        type: 'TSIntersectionType',
        types: types2,
    };
    
    const defs = NODE_FIELDS.TSIntersectionType;
    validate$3(defs.types, node, 'types', types2, 1);
    return node;
}

function tsConditionalType(checkType, extendsType, trueType, falseType) {
    const node = {
        type: 'TSConditionalType',
        checkType,
        extendsType,
        trueType,
        falseType,
    };
    
    const defs = NODE_FIELDS.TSConditionalType;
    validate$3(defs.checkType, node, 'checkType', checkType, 1);
    validate$3(defs.extendsType, node, 'extendsType', extendsType, 1);
    validate$3(defs.trueType, node, 'trueType', trueType, 1);
    validate$3(defs.falseType, node, 'falseType', falseType, 1);
    return node;
}

function tsInferType(typeParameter2) {
    const node = {
        type: 'TSInferType',
        typeParameter: typeParameter2,
    };
    
    const defs = NODE_FIELDS.TSInferType;
    validate$3(defs.typeParameter, node, 'typeParameter', typeParameter2, 1);
    return node;
}

function tsParenthesizedType$1(typeAnnotation2) {
    const node = {
        type: 'TSParenthesizedType',
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TSParenthesizedType;
    validate$3(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function tsTypeOperator(typeAnnotation2, operator) {
    const node = {
        type: 'TSTypeOperator',
        typeAnnotation: typeAnnotation2,
        operator,
    };
    
    const defs = NODE_FIELDS.TSTypeOperator;
    validate$3(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    validate$3(defs.operator, node, 'operator', operator);
    return node;
}

function tsIndexedAccessType(objectType, indexType) {
    const node = {
        type: 'TSIndexedAccessType',
        objectType,
        indexType,
    };
    
    const defs = NODE_FIELDS.TSIndexedAccessType;
    validate$3(defs.objectType, node, 'objectType', objectType, 1);
    validate$3(defs.indexType, node, 'indexType', indexType, 1);
    return node;
}

function tsMappedType(key, constraint, nameType = null, typeAnnotation2 = null) {
    const node = {
        type: 'TSMappedType',
        key,
        constraint,
        nameType,
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TSMappedType;
    validate$3(defs.key, node, 'key', key, 1);
    validate$3(defs.constraint, node, 'constraint', constraint, 1);
    validate$3(defs.nameType, node, 'nameType', nameType, 1);
    validate$3(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function tsTemplateLiteralType(quasis, types2) {
    const node = {
        type: 'TSTemplateLiteralType',
        quasis,
        types: types2,
    };
    
    const defs = NODE_FIELDS.TSTemplateLiteralType;
    validate$3(defs.quasis, node, 'quasis', quasis, 1);
    validate$3(defs.types, node, 'types', types2, 1);
    return node;
}

function tsLiteralType(literal) {
    const node = {
        type: 'TSLiteralType',
        literal,
    };
    
    const defs = NODE_FIELDS.TSLiteralType;
    validate$3(defs.literal, node, 'literal', literal, 1);
    return node;
}

function tsClassImplements(expression2, typeArguments = null) {
    const node = {
        type: 'TSClassImplements',
        expression: expression2,
        typeArguments,
    };
    
    const defs = NODE_FIELDS.TSClassImplements;
    validate$3(defs.expression, node, 'expression', expression2, 1);
    validate$3(defs.typeArguments, node, 'typeArguments', typeArguments, 1);
    return node;
}

function tsInterfaceHeritage(expression2, typeArguments = null) {
    const node = {
        type: 'TSInterfaceHeritage',
        expression: expression2,
        typeArguments,
    };
    
    const defs = NODE_FIELDS.TSInterfaceHeritage;
    validate$3(defs.expression, node, 'expression', expression2, 1);
    validate$3(defs.typeArguments, node, 'typeArguments', typeArguments, 1);
    return node;
}

function tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {
    const node = {
        type: 'TSInterfaceDeclaration',
        id,
        typeParameters,
        extends: _extends,
        body,
    };
    
    const defs = NODE_FIELDS.TSInterfaceDeclaration;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$3(defs.extends, node, 'extends', _extends, 1);
    validate$3(defs.body, node, 'body', body, 1);
    return node;
}

function tsInterfaceBody(body) {
    const node = {
        type: 'TSInterfaceBody',
        body,
    };
    
    const defs = NODE_FIELDS.TSInterfaceBody;
    validate$3(defs.body, node, 'body', body, 1);
    return node;
}

function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation2) {
    const node = {
        type: 'TSTypeAliasDeclaration',
        id,
        typeParameters,
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TSTypeAliasDeclaration;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.typeParameters, node, 'typeParameters', typeParameters, 1);
    validate$3(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function tsInstantiationExpression(expression2, typeArguments = null) {
    const node = {
        type: 'TSInstantiationExpression',
        expression: expression2,
        typeArguments,
    };
    
    const defs = NODE_FIELDS.TSInstantiationExpression;
    validate$3(defs.expression, node, 'expression', expression2, 1);
    validate$3(defs.typeArguments, node, 'typeArguments', typeArguments, 1);
    return node;
}

function tsAsExpression(expression2, typeAnnotation2) {
    const node = {
        type: 'TSAsExpression',
        expression: expression2,
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TSAsExpression;
    validate$3(defs.expression, node, 'expression', expression2, 1);
    validate$3(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function tsSatisfiesExpression(expression2, typeAnnotation2) {
    const node = {
        type: 'TSSatisfiesExpression',
        expression: expression2,
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TSSatisfiesExpression;
    validate$3(defs.expression, node, 'expression', expression2, 1);
    validate$3(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function tsTypeAssertion(typeAnnotation2, expression2) {
    const node = {
        type: 'TSTypeAssertion',
        typeAnnotation: typeAnnotation2,
        expression: expression2,
    };
    
    const defs = NODE_FIELDS.TSTypeAssertion;
    validate$3(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    validate$3(defs.expression, node, 'expression', expression2, 1);
    return node;
}

function tsEnumBody(members) {
    const node = {
        type: 'TSEnumBody',
        members,
    };
    
    const defs = NODE_FIELDS.TSEnumBody;
    validate$3(defs.members, node, 'members', members, 1);
    return node;
}

function tsEnumDeclaration(id, body) {
    const node = {
        type: 'TSEnumDeclaration',
        id,
        body,
    };
    
    const defs = NODE_FIELDS.TSEnumDeclaration;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.body, node, 'body', body, 1);
    return node;
}

function tsEnumMember(id, initializer = null) {
    const node = {
        type: 'TSEnumMember',
        id,
        initializer,
    };
    
    const defs = NODE_FIELDS.TSEnumMember;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.initializer, node, 'initializer', initializer, 1);
    return node;
}

function tsModuleDeclaration(id, body) {
    const node = {
        type: 'TSModuleDeclaration',
        id,
        body,
        kind: null,
    };
    
    const defs = NODE_FIELDS.TSModuleDeclaration;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.body, node, 'body', body, 1);
    return node;
}

function tsModuleBlock(body) {
    const node = {
        type: 'TSModuleBlock',
        body,
    };
    
    const defs = NODE_FIELDS.TSModuleBlock;
    validate$3(defs.body, node, 'body', body, 1);
    return node;
}

function tsImportType(source, qualifier = null, typeArguments = null) {
    const node = {
        type: 'TSImportType',
        source,
        qualifier,
        typeArguments,
    };
    
    const defs = NODE_FIELDS.TSImportType;
    validate$3(defs.source, node, 'source', source, 1);
    validate$3(defs.qualifier, node, 'qualifier', qualifier, 1);
    validate$3(defs.typeArguments, node, 'typeArguments', typeArguments, 1);
    return node;
}

function tsImportEqualsDeclaration(id, moduleReference) {
    const node = {
        type: 'TSImportEqualsDeclaration',
        id,
        moduleReference,
    };
    
    const defs = NODE_FIELDS.TSImportEqualsDeclaration;
    validate$3(defs.id, node, 'id', id, 1);
    validate$3(defs.moduleReference, node, 'moduleReference', moduleReference, 1);
    return node;
}

function tsExternalModuleReference(expression2) {
    const node = {
        type: 'TSExternalModuleReference',
        expression: expression2,
    };
    
    const defs = NODE_FIELDS.TSExternalModuleReference;
    validate$3(defs.expression, node, 'expression', expression2, 1);
    return node;
}

function tsNonNullExpression(expression2) {
    const node = {
        type: 'TSNonNullExpression',
        expression: expression2,
    };
    
    const defs = NODE_FIELDS.TSNonNullExpression;
    validate$3(defs.expression, node, 'expression', expression2, 1);
    return node;
}

function tsExportAssignment(expression2) {
    const node = {
        type: 'TSExportAssignment',
        expression: expression2,
    };
    
    const defs = NODE_FIELDS.TSExportAssignment;
    validate$3(defs.expression, node, 'expression', expression2, 1);
    return node;
}

function tsNamespaceExportDeclaration(id) {
    const node = {
        type: 'TSNamespaceExportDeclaration',
        id,
    };
    
    const defs = NODE_FIELDS.TSNamespaceExportDeclaration;
    validate$3(defs.id, node, 'id', id, 1);
    return node;
}

function tsTypeAnnotation(typeAnnotation2) {
    const node = {
        type: 'TSTypeAnnotation',
        typeAnnotation: typeAnnotation2,
    };
    
    const defs = NODE_FIELDS.TSTypeAnnotation;
    validate$3(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation2, 1);
    return node;
}

function tsTypeParameterInstantiation(params) {
    const node = {
        type: 'TSTypeParameterInstantiation',
        params,
    };
    
    const defs = NODE_FIELDS.TSTypeParameterInstantiation;
    validate$3(defs.params, node, 'params', params, 1);
    return node;
}

function tsTypeParameterDeclaration(params) {
    const node = {
        type: 'TSTypeParameterDeclaration',
        params,
    };
    
    const defs = NODE_FIELDS.TSTypeParameterDeclaration;
    validate$3(defs.params, node, 'params', params, 1);
    return node;
}

function tsTypeParameter(constraint = null, _default = null, name) {
    const node = {
        type: 'TSTypeParameter',
        constraint,
        default: _default,
        name,
    };
    
    const defs = NODE_FIELDS.TSTypeParameter;
    validate$3(defs.constraint, node, 'constraint', constraint, 1);
    validate$3(defs.default, node, 'default', _default, 1);
    validate$3(defs.name, node, 'name', name, 1);
    return node;
}

function NumberLiteral(value) {
    deprecationWarning('NumberLiteral', 'NumericLiteral', 'The node type ');
    return numericLiteral(value);
}

function RegexLiteral(pattern, flags = '') {
    deprecationWarning('RegexLiteral', 'RegExpLiteral', 'The node type ');
    return regExpLiteral(pattern, flags);
}

function RestProperty(argument) {
    deprecationWarning('RestProperty', 'RestElement', 'The node type ');
    return restElement(argument);
}

function SpreadProperty(argument) {
    deprecationWarning('SpreadProperty', 'SpreadElement', 'The node type ');
    return spreadElement(argument);
}

var b = /* @__PURE__ */Object.freeze({
    __proto__: null,
    anyTypeAnnotation,
    argumentPlaceholder,
    arrayExpression: arrayExpression$3,
    arrayPattern,
    arrayTypeAnnotation,
    arrowFunctionExpression,
    assignmentExpression,
    assignmentPattern,
    awaitExpression,
    bigIntLiteral,
    binaryExpression,
    bindExpression,
    blockStatement: blockStatement$1,
    booleanLiteral,
    booleanLiteralTypeAnnotation,
    booleanTypeAnnotation,
    breakStatement,
    callExpression,
    catchClause,
    classAccessorProperty,
    classBody,
    classDeclaration,
    classExpression,
    classImplements,
    classMethod: classMethod$1,
    classPrivateMethod: classPrivateMethod$1,
    classPrivateProperty,
    classProperty,
    conditionalExpression,
    continueStatement,
    debuggerStatement,
    declareClass,
    declareExportAllDeclaration,
    declareExportDeclaration,
    declareFunction,
    declareInterface,
    declareModule,
    declareModuleExports,
    declareOpaqueType,
    declareTypeAlias,
    declareVariable,
    declaredPredicate,
    decorator,
    directive: directive$1,
    directiveLiteral: directiveLiteral$1,
    doExpression,
    doWhileStatement,
    emptyStatement,
    emptyTypeAnnotation,
    enumBooleanBody,
    enumBooleanMember,
    enumDeclaration,
    enumDefaultedMember,
    enumNumberBody,
    enumNumberMember,
    enumStringBody,
    enumStringMember,
    enumSymbolBody,
    existsTypeAnnotation,
    exportAllDeclaration,
    exportDefaultDeclaration,
    exportDefaultSpecifier,
    exportNamedDeclaration,
    exportNamespaceSpecifier,
    exportSpecifier,
    expressionStatement: expressionStatement$4,
    file: file$1,
    forInStatement,
    forOfStatement,
    forStatement,
    functionDeclaration,
    functionExpression,
    functionTypeAnnotation,
    functionTypeParam,
    genericTypeAnnotation,
    identifier: identifier$2,
    ifStatement,
    import: _import,
    importAttribute,
    importDeclaration,
    importDefaultSpecifier,
    importExpression,
    importNamespaceSpecifier,
    importSpecifier,
    indexedAccessType,
    inferredPredicate,
    interfaceDeclaration,
    interfaceExtends,
    interfaceTypeAnnotation,
    interpreterDirective,
    intersectionTypeAnnotation,
    jsxAttribute: jsxAttribute$1,
    jsxClosingElement,
    jsxClosingFragment,
    jsxElement,
    jsxEmptyExpression,
    jsxExpressionContainer,
    jsxFragment,
    jsxIdentifier: jsxIdentifier$1,
    jsxMemberExpression,
    jsxNamespacedName,
    jsxOpeningElement,
    jsxOpeningFragment,
    jsxSpreadAttribute,
    jsxSpreadChild,
    jsxText,
    labeledStatement,
    logicalExpression,
    memberExpression,
    metaProperty,
    mixedTypeAnnotation,
    moduleExpression,
    newExpression,
    nullLiteral,
    nullLiteralTypeAnnotation,
    nullableTypeAnnotation,
    numberLiteral: NumberLiteral,
    numberLiteralTypeAnnotation,
    numberTypeAnnotation,
    numericLiteral,
    objectExpression: objectExpression$2,
    objectMethod: objectMethod$1,
    objectPattern: objectPattern$1,
    objectProperty: objectProperty$3,
    objectTypeAnnotation,
    objectTypeCallProperty,
    objectTypeIndexer,
    objectTypeInternalSlot,
    objectTypeProperty,
    objectTypeSpreadProperty,
    opaqueType,
    optionalCallExpression,
    optionalIndexedAccessType,
    optionalMemberExpression,
    parenthesizedExpression: parenthesizedExpression$1,
    pipelineBareFunction,
    pipelinePrimaryTopicReference,
    pipelineTopicExpression,
    placeholder,
    privateName: privateName$1,
    program: program$1,
    qualifiedTypeIdentifier,
    regExpLiteral,
    regexLiteral: RegexLiteral,
    restElement,
    restProperty: RestProperty,
    returnStatement,
    sequenceExpression,
    spreadElement,
    spreadProperty: SpreadProperty,
    staticBlock,
    stringLiteral: stringLiteral$5,
    stringLiteralTypeAnnotation,
    stringTypeAnnotation,
    super: _super,
    switchCase,
    switchStatement,
    symbolTypeAnnotation,
    taggedTemplateExpression,
    templateElement: templateElement$1,
    templateLiteral,
    thisExpression,
    thisTypeAnnotation,
    throwStatement,
    topicReference,
    tryStatement,
    tsAnyKeyword,
    tsArrayType,
    tsAsExpression,
    tsBigIntKeyword,
    tsBooleanKeyword,
    tsCallSignatureDeclaration,
    tsClassImplements,
    tsConditionalType,
    tsConstructSignatureDeclaration,
    tsConstructorType,
    tsDeclareFunction,
    tsDeclareMethod,
    tsEnumBody,
    tsEnumDeclaration,
    tsEnumMember,
    tsExportAssignment,
    tsExternalModuleReference,
    tsFunctionType,
    tsImportEqualsDeclaration,
    tsImportType,
    tsIndexSignature,
    tsIndexedAccessType,
    tsInferType,
    tsInstantiationExpression,
    tsInterfaceBody,
    tsInterfaceDeclaration,
    tsInterfaceHeritage,
    tsIntersectionType,
    tsIntrinsicKeyword,
    tsLiteralType,
    tsMappedType,
    tsMethodSignature,
    tsModuleBlock,
    tsModuleDeclaration,
    tsNamedTupleMember,
    tsNamespaceExportDeclaration,
    tsNeverKeyword,
    tsNonNullExpression,
    tsNullKeyword,
    tsNumberKeyword,
    tsObjectKeyword,
    tsOptionalType,
    tsParameterProperty,
    tsParenthesizedType: tsParenthesizedType$1,
    tsPropertySignature,
    tsQualifiedName,
    tsRestType,
    tsSatisfiesExpression,
    tsStringKeyword,
    tsSymbolKeyword,
    tsTemplateLiteralType,
    tsThisType,
    tsTupleType,
    tsTypeAliasDeclaration,
    tsTypeAnnotation,
    tsTypeAssertion,
    tsTypeLiteral,
    tsTypeOperator,
    tsTypeParameter,
    tsTypeParameterDeclaration,
    tsTypeParameterInstantiation,
    tsTypePredicate,
    tsTypeQuery,
    tsTypeReference,
    tsUndefinedKeyword,
    tsUnionType,
    tsUnknownKeyword,
    tsVoidKeyword,
    tupleTypeAnnotation,
    typeAlias,
    typeAnnotation,
    typeCastExpression,
    typeParameter,
    typeParameterDeclaration,
    typeParameterInstantiation,
    typeofTypeAnnotation,
    unaryExpression: unaryExpression$1,
    unionTypeAnnotation,
    updateExpression,
    v8IntrinsicIdentifier,
    variableDeclaration,
    variableDeclarator,
    variance,
    voidPattern,
    voidTypeAnnotation,
    whileStatement,
    withStatement,
    yieldExpression,
});

function alias(lowercase) {
    return function() {
        deprecationWarning(lowercase.replace(/^(?:ts|jsx|[a-z])/, (x) => x.toUpperCase()), lowercase, 'Usage of builders starting with an uppercase letter such as ', 'uppercase builders');
        return b[lowercase](...arguments);
    };
}

var ArrayExpression$1 = alias('arrayExpression');
var AssignmentExpression$1 = alias('assignmentExpression');
var BinaryExpression$1 = alias('binaryExpression');
var InterpreterDirective$1 = alias('interpreterDirective');
var Directive$1 = alias('directive');
var DirectiveLiteral$1 = alias('directiveLiteral');
var BlockStatement$1 = alias('blockStatement');
var BreakStatement$1 = alias('breakStatement');
var CallExpression$1 = alias('callExpression');
var CatchClause$1 = alias('catchClause');
var ConditionalExpression$1 = alias('conditionalExpression');
var ContinueStatement$1 = alias('continueStatement');
var DebuggerStatement$1 = alias('debuggerStatement');
var DoWhileStatement$1 = alias('doWhileStatement');
var EmptyStatement$1 = alias('emptyStatement');
var ExpressionStatement$1 = alias('expressionStatement');
var File = alias('file');
var ForInStatement$1 = alias('forInStatement');
var ForStatement$1 = alias('forStatement');
var FunctionDeclaration$1 = alias('functionDeclaration');
var FunctionExpression$1 = alias('functionExpression');
var Identifier$1 = alias('identifier');
var IfStatement$1 = alias('ifStatement');
var LabeledStatement$1 = alias('labeledStatement');
var StringLiteral$1 = alias('stringLiteral');
var NumericLiteral$1 = alias('numericLiteral');
var NullLiteral$1 = alias('nullLiteral');
var BooleanLiteral$1 = alias('booleanLiteral');
var RegExpLiteral$1 = alias('regExpLiteral');
var LogicalExpression$1 = alias('logicalExpression');
var MemberExpression$1 = alias('memberExpression');
var NewExpression$1 = alias('newExpression');
var Program$1 = alias('program');
var ObjectExpression$1 = alias('objectExpression');
var ObjectMethod$1 = alias('objectMethod');
var ObjectProperty$1 = alias('objectProperty');
var RestElement$1 = alias('restElement');
var ReturnStatement$1 = alias('returnStatement');
var SequenceExpression$1 = alias('sequenceExpression');
var ParenthesizedExpression$1 = alias('parenthesizedExpression');
var SwitchCase = alias('switchCase');
var SwitchStatement$1 = alias('switchStatement');
var ThisExpression$1 = alias('thisExpression');
var ThrowStatement$1 = alias('throwStatement');
var TryStatement$1 = alias('tryStatement');
var UnaryExpression$1 = alias('unaryExpression');
var UpdateExpression$1 = alias('updateExpression');
var VariableDeclaration$1 = alias('variableDeclaration');
var VariableDeclarator = alias('variableDeclarator');
var WhileStatement$1 = alias('whileStatement');
var WithStatement$1 = alias('withStatement');
var AssignmentPattern$1 = alias('assignmentPattern');
var ArrayPattern$1 = alias('arrayPattern');
var ArrowFunctionExpression$1 = alias('arrowFunctionExpression');
var ClassBody = alias('classBody');
var ClassExpression$1 = alias('classExpression');
var ClassDeclaration$1 = alias('classDeclaration');
var ExportAllDeclaration$1 = alias('exportAllDeclaration');
var ExportDefaultDeclaration$1 = alias('exportDefaultDeclaration');
var ExportNamedDeclaration$1 = alias('exportNamedDeclaration');
var ExportSpecifier$1 = alias('exportSpecifier');
var ForOfStatement$1 = alias('forOfStatement');
var ImportDeclaration$1 = alias('importDeclaration');
var ImportDefaultSpecifier = alias('importDefaultSpecifier');
var ImportNamespaceSpecifier = alias('importNamespaceSpecifier');
var ImportSpecifier = alias('importSpecifier');
var ImportExpression$1 = alias('importExpression');
var MetaProperty$1 = alias('metaProperty');
var ClassMethod$1 = alias('classMethod');
var ObjectPattern$1 = alias('objectPattern');
var SpreadElement$1 = alias('spreadElement');
var Super$1 = alias('super');
var TaggedTemplateExpression$1 = alias('taggedTemplateExpression');
var TemplateElement = alias('templateElement');
var TemplateLiteral$1 = alias('templateLiteral');
var YieldExpression$1 = alias('yieldExpression');
var AwaitExpression$1 = alias('awaitExpression');
var Import = alias('import');
var BigIntLiteral$1 = alias('bigIntLiteral');
var ExportNamespaceSpecifier$1 = alias('exportNamespaceSpecifier');
var OptionalMemberExpression$1 = alias('optionalMemberExpression');
var OptionalCallExpression$1 = alias('optionalCallExpression');
var ClassProperty$1 = alias('classProperty');
var ClassAccessorProperty$1 = alias('classAccessorProperty');
var ClassPrivateProperty$1 = alias('classPrivateProperty');
var ClassPrivateMethod$1 = alias('classPrivateMethod');
var PrivateName$1 = alias('privateName');
var StaticBlock$1 = alias('staticBlock');
var ImportAttribute$1 = alias('importAttribute');
var AnyTypeAnnotation = alias('anyTypeAnnotation');
var ArrayTypeAnnotation = alias('arrayTypeAnnotation');
var BooleanTypeAnnotation = alias('booleanTypeAnnotation');
var BooleanLiteralTypeAnnotation = alias('booleanLiteralTypeAnnotation');
var NullLiteralTypeAnnotation = alias('nullLiteralTypeAnnotation');
var ClassImplements = alias('classImplements');
var DeclareClass = alias('declareClass');
var DeclareFunction = alias('declareFunction');
var DeclareInterface = alias('declareInterface');
var DeclareModule = alias('declareModule');
var DeclareModuleExports = alias('declareModuleExports');
var DeclareTypeAlias = alias('declareTypeAlias');
var DeclareOpaqueType = alias('declareOpaqueType');
var DeclareVariable = alias('declareVariable');
var DeclareExportDeclaration = alias('declareExportDeclaration');
var DeclareExportAllDeclaration = alias('declareExportAllDeclaration');
var DeclaredPredicate = alias('declaredPredicate');
var ExistsTypeAnnotation = alias('existsTypeAnnotation');
var FunctionTypeAnnotation = alias('functionTypeAnnotation');
var FunctionTypeParam = alias('functionTypeParam');
var GenericTypeAnnotation = alias('genericTypeAnnotation');
var InferredPredicate = alias('inferredPredicate');
var InterfaceExtends = alias('interfaceExtends');
var InterfaceDeclaration = alias('interfaceDeclaration');
var InterfaceTypeAnnotation = alias('interfaceTypeAnnotation');
var IntersectionTypeAnnotation = alias('intersectionTypeAnnotation');
var MixedTypeAnnotation = alias('mixedTypeAnnotation');
var EmptyTypeAnnotation = alias('emptyTypeAnnotation');
var NullableTypeAnnotation = alias('nullableTypeAnnotation');
var NumberLiteralTypeAnnotation = alias('numberLiteralTypeAnnotation');
var NumberTypeAnnotation = alias('numberTypeAnnotation');
var ObjectTypeAnnotation = alias('objectTypeAnnotation');
var ObjectTypeInternalSlot = alias('objectTypeInternalSlot');
var ObjectTypeCallProperty = alias('objectTypeCallProperty');
var ObjectTypeIndexer = alias('objectTypeIndexer');
var ObjectTypeProperty = alias('objectTypeProperty');
var ObjectTypeSpreadProperty = alias('objectTypeSpreadProperty');
var OpaqueType = alias('opaqueType');
var QualifiedTypeIdentifier = alias('qualifiedTypeIdentifier');
var StringLiteralTypeAnnotation = alias('stringLiteralTypeAnnotation');
var StringTypeAnnotation = alias('stringTypeAnnotation');
var SymbolTypeAnnotation = alias('symbolTypeAnnotation');
var ThisTypeAnnotation = alias('thisTypeAnnotation');
var TupleTypeAnnotation = alias('tupleTypeAnnotation');
var TypeofTypeAnnotation = alias('typeofTypeAnnotation');
var TypeAlias = alias('typeAlias');
var TypeAnnotation = alias('typeAnnotation');
var TypeCastExpression = alias('typeCastExpression');
var TypeParameter = alias('typeParameter');
var TypeParameterDeclaration = alias('typeParameterDeclaration');
var TypeParameterInstantiation = alias('typeParameterInstantiation');
var UnionTypeAnnotation = alias('unionTypeAnnotation');
var Variance = alias('variance');
var VoidTypeAnnotation = alias('voidTypeAnnotation');
var EnumDeclaration = alias('enumDeclaration');
var EnumBooleanBody = alias('enumBooleanBody');
var EnumNumberBody = alias('enumNumberBody');
var EnumStringBody = alias('enumStringBody');
var EnumSymbolBody = alias('enumSymbolBody');
var EnumBooleanMember = alias('enumBooleanMember');
var EnumNumberMember = alias('enumNumberMember');
var EnumStringMember = alias('enumStringMember');
var EnumDefaultedMember = alias('enumDefaultedMember');
var IndexedAccessType = alias('indexedAccessType');
var OptionalIndexedAccessType = alias('optionalIndexedAccessType');
var JSXAttribute$1 = alias('jsxAttribute');
var JSXClosingElement$1 = alias('jsxClosingElement');
var JSXElement$1 = alias('jsxElement');
var JSXEmptyExpression$1 = alias('jsxEmptyExpression');
var JSXExpressionContainer$1 = alias('jsxExpressionContainer');
var JSXSpreadChild = alias('jsxSpreadChild');
var JSXIdentifier$1 = alias('jsxIdentifier');
var JSXMemberExpression$1 = alias('jsxMemberExpression');
var JSXNamespacedName = alias('jsxNamespacedName');
var JSXOpeningElement$1 = alias('jsxOpeningElement');
var JSXSpreadAttribute$1 = alias('jsxSpreadAttribute');
var JSXText$1 = alias('jsxText');
var JSXFragment$1 = alias('jsxFragment');
var JSXOpeningFragment$1 = alias('jsxOpeningFragment');
var JSXClosingFragment$1 = alias('jsxClosingFragment');
var Placeholder = alias('placeholder');
var V8IntrinsicIdentifier = alias('v8IntrinsicIdentifier');
var ArgumentPlaceholder = alias('argumentPlaceholder');
var BindExpression = alias('bindExpression');
var Decorator$1 = alias('decorator');
var DoExpression = alias('doExpression');
var ExportDefaultSpecifier$1 = alias('exportDefaultSpecifier');
var ModuleExpression = alias('moduleExpression');
var TopicReference = alias('topicReference');
var PipelineTopicExpression = alias('pipelineTopicExpression');
var PipelineBareFunction = alias('pipelineBareFunction');
var PipelinePrimaryTopicReference = alias('pipelinePrimaryTopicReference');
var VoidPattern$1 = alias('voidPattern');
var TSParameterProperty$1 = alias('tsParameterProperty');
var TSDeclareFunction$1 = alias('tsDeclareFunction');
var TSDeclareMethod$1 = alias('tsDeclareMethod');
var TSQualifiedName$1 = alias('tsQualifiedName');
var TSCallSignatureDeclaration$1 = alias('tsCallSignatureDeclaration');
var TSConstructSignatureDeclaration$1 = alias('tsConstructSignatureDeclaration');
var TSPropertySignature$1 = alias('tsPropertySignature');
var TSMethodSignature$1 = alias('tsMethodSignature');
var TSIndexSignature$1 = alias('tsIndexSignature');
var TSAnyKeyword$1 = alias('tsAnyKeyword');
var TSBooleanKeyword$1 = alias('tsBooleanKeyword');
var TSBigIntKeyword$1 = alias('tsBigIntKeyword');
var TSIntrinsicKeyword = alias('tsIntrinsicKeyword');
var TSNeverKeyword$1 = alias('tsNeverKeyword');
var TSNullKeyword$1 = alias('tsNullKeyword');
var TSNumberKeyword$1 = alias('tsNumberKeyword');
var TSObjectKeyword$1 = alias('tsObjectKeyword');
var TSStringKeyword$1 = alias('tsStringKeyword');
var TSSymbolKeyword$1 = alias('tsSymbolKeyword');
var TSUndefinedKeyword$1 = alias('tsUndefinedKeyword');
var TSUnknownKeyword$1 = alias('tsUnknownKeyword');
var TSVoidKeyword$1 = alias('tsVoidKeyword');
var TSThisType$1 = alias('tsThisType');
var TSFunctionType$1 = alias('tsFunctionType');
var TSConstructorType$1 = alias('tsConstructorType');
var TSTypeReference$1 = alias('tsTypeReference');
var TSTypePredicate$1 = alias('tsTypePredicate');
var TSTypeQuery$1 = alias('tsTypeQuery');
var TSTypeLiteral$1 = alias('tsTypeLiteral');
var TSArrayType$1 = alias('tsArrayType');
var TSTupleType$1 = alias('tsTupleType');
var TSOptionalType$1 = alias('tsOptionalType');
var TSRestType$1 = alias('tsRestType');
var TSNamedTupleMember$1 = alias('tsNamedTupleMember');
var TSUnionType$1 = alias('tsUnionType');
var TSIntersectionType$1 = alias('tsIntersectionType');
var TSConditionalType$1 = alias('tsConditionalType');
var TSInferType$1 = alias('tsInferType');
var TSParenthesizedType$1 = alias('tsParenthesizedType');
var TSTypeOperator$1 = alias('tsTypeOperator');
var TSIndexedAccessType$1 = alias('tsIndexedAccessType');
var TSMappedType$1 = alias('tsMappedType');
var TSTemplateLiteralType$1 = alias('tsTemplateLiteralType');
var TSLiteralType$1 = alias('tsLiteralType');
var TSClassImplements$1 = alias('tsClassImplements');
var TSInterfaceHeritage$1 = alias('tsInterfaceHeritage');
var TSInterfaceDeclaration$1 = alias('tsInterfaceDeclaration');
var TSInterfaceBody$1 = alias('tsInterfaceBody');
var TSTypeAliasDeclaration$1 = alias('tsTypeAliasDeclaration');
var TSInstantiationExpression$1 = alias('tsInstantiationExpression');
var TSAsExpression$1 = alias('tsAsExpression');
var TSSatisfiesExpression$1 = alias('tsSatisfiesExpression');
var TSTypeAssertion$1 = alias('tsTypeAssertion');
var TSEnumBody = alias('tsEnumBody');
var TSEnumDeclaration$1 = alias('tsEnumDeclaration');
var TSEnumMember$1 = alias('tsEnumMember');
var TSModuleDeclaration$1 = alias('tsModuleDeclaration');
var TSModuleBlock$1 = alias('tsModuleBlock');
var TSImportType$1 = alias('tsImportType');
var TSImportEqualsDeclaration$1 = alias('tsImportEqualsDeclaration');
var TSExternalModuleReference$1 = alias('tsExternalModuleReference');
var TSNonNullExpression$1 = alias('tsNonNullExpression');
var TSExportAssignment$1 = alias('tsExportAssignment');
var TSNamespaceExportDeclaration = alias('tsNamespaceExportDeclaration');
var TSTypeAnnotation$1 = alias('tsTypeAnnotation');
var TSTypeParameterInstantiation$1 = alias('tsTypeParameterInstantiation');
var TSTypeParameterDeclaration$1 = alias('tsTypeParameterDeclaration');
var TSTypeParameter$1 = alias('tsTypeParameter');

function cleanJSXElementLiteralChild(child, args) {
    const lines = child.value.split(/\r\n|\n|\r/);
    let lastNonEmptyLine = 0;
    
    for (let i = 0; i < lines.length; i++) {
        if (/[^ \t]/.exec(lines[i])) {
            lastNonEmptyLine = i;
        }
    }
    
    let str = '';
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const isFirstLine = i === 0;
        const isLastLine = i === lines.length - 1;
        const isLastNonEmptyLine = i === lastNonEmptyLine;
        let trimmedLine = line.replace(/\t/g, ' ');
        
        if (!isFirstLine) {
            trimmedLine = trimmedLine.replace(/^ +/, '');
        }
        
        if (!isLastLine) {
            trimmedLine = trimmedLine.replace(/ +$/, '');
        }
        
        if (trimmedLine) {
            if (!isLastNonEmptyLine) {
                trimmedLine += ' ';
            }
            
            str += trimmedLine;
        }
    }
    
    if (str)
        args.push(inherits(stringLiteral$5(str), child));
}

function buildChildren(node) {
    const elements = [];
    
    for (let i = 0; i < node.children.length; i++) {
        let child = node.children[i];
        
        if (isJSXText$4(child)) {
            cleanJSXElementLiteralChild(child, elements);
            continue;
        }
        
        if (isJSXExpressionContainer$1(child))
            child = child.expression;
        
        if (isJSXEmptyExpression(child))
            continue;
        
        elements.push(child);
    }
    
    return elements;
}

function isNode(node) {
    return !!(node && VISITOR_KEYS[node.type]);
}

function assertNode(node) {
    if (!isNode(node)) {
        const type = node?.type ?? JSON.stringify(node);
        throw new TypeError(`Not a valid node of type "${type}"`);
    }
}

function assert(type, node, opts) {
    if (!is$1(type, node, opts)) {
        throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, but instead got "${node.type}".`);
    }
}

function assertArrayExpression(node, opts) {
    assert('ArrayExpression', node, opts);
}

function assertAssignmentExpression(node, opts) {
    assert('AssignmentExpression', node, opts);
}

function assertBinaryExpression(node, opts) {
    assert('BinaryExpression', node, opts);
}

function assertInterpreterDirective(node, opts) {
    assert('InterpreterDirective', node, opts);
}

function assertDirective(node, opts) {
    assert('Directive', node, opts);
}

function assertDirectiveLiteral(node, opts) {
    assert('DirectiveLiteral', node, opts);
}

function assertBlockStatement(node, opts) {
    assert('BlockStatement', node, opts);
}

function assertBreakStatement(node, opts) {
    assert('BreakStatement', node, opts);
}

function assertCallExpression(node, opts) {
    assert('CallExpression', node, opts);
}

function assertCatchClause(node, opts) {
    assert('CatchClause', node, opts);
}

function assertConditionalExpression(node, opts) {
    assert('ConditionalExpression', node, opts);
}

function assertContinueStatement(node, opts) {
    assert('ContinueStatement', node, opts);
}

function assertDebuggerStatement(node, opts) {
    assert('DebuggerStatement', node, opts);
}

function assertDoWhileStatement(node, opts) {
    assert('DoWhileStatement', node, opts);
}

function assertEmptyStatement(node, opts) {
    assert('EmptyStatement', node, opts);
}

function assertExpressionStatement(node, opts) {
    assert('ExpressionStatement', node, opts);
}

function assertFile(node, opts) {
    assert('File', node, opts);
}

function assertForInStatement(node, opts) {
    assert('ForInStatement', node, opts);
}

function assertForStatement(node, opts) {
    assert('ForStatement', node, opts);
}

function assertFunctionDeclaration(node, opts) {
    assert('FunctionDeclaration', node, opts);
}

function assertFunctionExpression(node, opts) {
    assert('FunctionExpression', node, opts);
}

function assertIdentifier(node, opts) {
    assert('Identifier', node, opts);
}

function assertIfStatement(node, opts) {
    assert('IfStatement', node, opts);
}

function assertLabeledStatement(node, opts) {
    assert('LabeledStatement', node, opts);
}

function assertStringLiteral(node, opts) {
    assert('StringLiteral', node, opts);
}

function assertNumericLiteral(node, opts) {
    assert('NumericLiteral', node, opts);
}

function assertNullLiteral(node, opts) {
    assert('NullLiteral', node, opts);
}

function assertBooleanLiteral(node, opts) {
    assert('BooleanLiteral', node, opts);
}

function assertRegExpLiteral(node, opts) {
    assert('RegExpLiteral', node, opts);
}

function assertLogicalExpression(node, opts) {
    assert('LogicalExpression', node, opts);
}

function assertMemberExpression(node, opts) {
    assert('MemberExpression', node, opts);
}

function assertNewExpression(node, opts) {
    assert('NewExpression', node, opts);
}

function assertProgram(node, opts) {
    assert('Program', node, opts);
}

function assertObjectExpression(node, opts) {
    assert('ObjectExpression', node, opts);
}

function assertObjectMethod(node, opts) {
    assert('ObjectMethod', node, opts);
}

function assertObjectProperty(node, opts) {
    assert('ObjectProperty', node, opts);
}

function assertRestElement(node, opts) {
    assert('RestElement', node, opts);
}

function assertReturnStatement(node, opts) {
    assert('ReturnStatement', node, opts);
}

function assertSequenceExpression(node, opts) {
    assert('SequenceExpression', node, opts);
}

function assertParenthesizedExpression(node, opts) {
    assert('ParenthesizedExpression', node, opts);
}

function assertSwitchCase(node, opts) {
    assert('SwitchCase', node, opts);
}

function assertSwitchStatement(node, opts) {
    assert('SwitchStatement', node, opts);
}

function assertThisExpression(node, opts) {
    assert('ThisExpression', node, opts);
}

function assertThrowStatement(node, opts) {
    assert('ThrowStatement', node, opts);
}

function assertTryStatement(node, opts) {
    assert('TryStatement', node, opts);
}

function assertUnaryExpression(node, opts) {
    assert('UnaryExpression', node, opts);
}

function assertUpdateExpression(node, opts) {
    assert('UpdateExpression', node, opts);
}

function assertVariableDeclaration(node, opts) {
    assert('VariableDeclaration', node, opts);
}

function assertVariableDeclarator(node, opts) {
    assert('VariableDeclarator', node, opts);
}

function assertWhileStatement(node, opts) {
    assert('WhileStatement', node, opts);
}

function assertWithStatement(node, opts) {
    assert('WithStatement', node, opts);
}

function assertAssignmentPattern(node, opts) {
    assert('AssignmentPattern', node, opts);
}

function assertArrayPattern(node, opts) {
    assert('ArrayPattern', node, opts);
}

function assertArrowFunctionExpression(node, opts) {
    assert('ArrowFunctionExpression', node, opts);
}

function assertClassBody(node, opts) {
    assert('ClassBody', node, opts);
}

function assertClassExpression(node, opts) {
    assert('ClassExpression', node, opts);
}

function assertClassDeclaration(node, opts) {
    assert('ClassDeclaration', node, opts);
}

function assertExportAllDeclaration(node, opts) {
    assert('ExportAllDeclaration', node, opts);
}

function assertExportDefaultDeclaration(node, opts) {
    assert('ExportDefaultDeclaration', node, opts);
}

function assertExportNamedDeclaration(node, opts) {
    assert('ExportNamedDeclaration', node, opts);
}

function assertExportSpecifier(node, opts) {
    assert('ExportSpecifier', node, opts);
}

function assertForOfStatement(node, opts) {
    assert('ForOfStatement', node, opts);
}

function assertImportDeclaration(node, opts) {
    assert('ImportDeclaration', node, opts);
}

function assertImportDefaultSpecifier(node, opts) {
    assert('ImportDefaultSpecifier', node, opts);
}

function assertImportNamespaceSpecifier(node, opts) {
    assert('ImportNamespaceSpecifier', node, opts);
}

function assertImportSpecifier(node, opts) {
    assert('ImportSpecifier', node, opts);
}

function assertImportExpression(node, opts) {
    assert('ImportExpression', node, opts);
}

function assertMetaProperty(node, opts) {
    assert('MetaProperty', node, opts);
}

function assertClassMethod(node, opts) {
    assert('ClassMethod', node, opts);
}

function assertObjectPattern(node, opts) {
    assert('ObjectPattern', node, opts);
}

function assertSpreadElement(node, opts) {
    assert('SpreadElement', node, opts);
}

function assertSuper(node, opts) {
    assert('Super', node, opts);
}

function assertTaggedTemplateExpression(node, opts) {
    assert('TaggedTemplateExpression', node, opts);
}

function assertTemplateElement(node, opts) {
    assert('TemplateElement', node, opts);
}

function assertTemplateLiteral(node, opts) {
    assert('TemplateLiteral', node, opts);
}

function assertYieldExpression(node, opts) {
    assert('YieldExpression', node, opts);
}

function assertAwaitExpression(node, opts) {
    assert('AwaitExpression', node, opts);
}

function assertImport(node, opts) {
    assert('Import', node, opts);
}

function assertBigIntLiteral(node, opts) {
    assert('BigIntLiteral', node, opts);
}

function assertExportNamespaceSpecifier(node, opts) {
    assert('ExportNamespaceSpecifier', node, opts);
}

function assertOptionalMemberExpression(node, opts) {
    assert('OptionalMemberExpression', node, opts);
}

function assertOptionalCallExpression(node, opts) {
    assert('OptionalCallExpression', node, opts);
}

function assertClassProperty(node, opts) {
    assert('ClassProperty', node, opts);
}

function assertClassAccessorProperty(node, opts) {
    assert('ClassAccessorProperty', node, opts);
}

function assertClassPrivateProperty(node, opts) {
    assert('ClassPrivateProperty', node, opts);
}

function assertClassPrivateMethod(node, opts) {
    assert('ClassPrivateMethod', node, opts);
}

function assertPrivateName(node, opts) {
    assert('PrivateName', node, opts);
}

function assertStaticBlock(node, opts) {
    assert('StaticBlock', node, opts);
}

function assertImportAttribute(node, opts) {
    assert('ImportAttribute', node, opts);
}

function assertAnyTypeAnnotation(node, opts) {
    assert('AnyTypeAnnotation', node, opts);
}

function assertArrayTypeAnnotation(node, opts) {
    assert('ArrayTypeAnnotation', node, opts);
}

function assertBooleanTypeAnnotation(node, opts) {
    assert('BooleanTypeAnnotation', node, opts);
}

function assertBooleanLiteralTypeAnnotation(node, opts) {
    assert('BooleanLiteralTypeAnnotation', node, opts);
}

function assertNullLiteralTypeAnnotation(node, opts) {
    assert('NullLiteralTypeAnnotation', node, opts);
}

function assertClassImplements(node, opts) {
    assert('ClassImplements', node, opts);
}

function assertDeclareClass(node, opts) {
    assert('DeclareClass', node, opts);
}

function assertDeclareFunction(node, opts) {
    assert('DeclareFunction', node, opts);
}

function assertDeclareInterface(node, opts) {
    assert('DeclareInterface', node, opts);
}

function assertDeclareModule(node, opts) {
    assert('DeclareModule', node, opts);
}

function assertDeclareModuleExports(node, opts) {
    assert('DeclareModuleExports', node, opts);
}

function assertDeclareTypeAlias(node, opts) {
    assert('DeclareTypeAlias', node, opts);
}

function assertDeclareOpaqueType(node, opts) {
    assert('DeclareOpaqueType', node, opts);
}

function assertDeclareVariable(node, opts) {
    assert('DeclareVariable', node, opts);
}

function assertDeclareExportDeclaration(node, opts) {
    assert('DeclareExportDeclaration', node, opts);
}

function assertDeclareExportAllDeclaration(node, opts) {
    assert('DeclareExportAllDeclaration', node, opts);
}

function assertDeclaredPredicate(node, opts) {
    assert('DeclaredPredicate', node, opts);
}

function assertExistsTypeAnnotation(node, opts) {
    assert('ExistsTypeAnnotation', node, opts);
}

function assertFunctionTypeAnnotation(node, opts) {
    assert('FunctionTypeAnnotation', node, opts);
}

function assertFunctionTypeParam(node, opts) {
    assert('FunctionTypeParam', node, opts);
}

function assertGenericTypeAnnotation(node, opts) {
    assert('GenericTypeAnnotation', node, opts);
}

function assertInferredPredicate(node, opts) {
    assert('InferredPredicate', node, opts);
}

function assertInterfaceExtends(node, opts) {
    assert('InterfaceExtends', node, opts);
}

function assertInterfaceDeclaration(node, opts) {
    assert('InterfaceDeclaration', node, opts);
}

function assertInterfaceTypeAnnotation(node, opts) {
    assert('InterfaceTypeAnnotation', node, opts);
}

function assertIntersectionTypeAnnotation(node, opts) {
    assert('IntersectionTypeAnnotation', node, opts);
}

function assertMixedTypeAnnotation(node, opts) {
    assert('MixedTypeAnnotation', node, opts);
}

function assertEmptyTypeAnnotation(node, opts) {
    assert('EmptyTypeAnnotation', node, opts);
}

function assertNullableTypeAnnotation(node, opts) {
    assert('NullableTypeAnnotation', node, opts);
}

function assertNumberLiteralTypeAnnotation(node, opts) {
    assert('NumberLiteralTypeAnnotation', node, opts);
}

function assertNumberTypeAnnotation(node, opts) {
    assert('NumberTypeAnnotation', node, opts);
}

function assertObjectTypeAnnotation(node, opts) {
    assert('ObjectTypeAnnotation', node, opts);
}

function assertObjectTypeInternalSlot(node, opts) {
    assert('ObjectTypeInternalSlot', node, opts);
}

function assertObjectTypeCallProperty(node, opts) {
    assert('ObjectTypeCallProperty', node, opts);
}

function assertObjectTypeIndexer(node, opts) {
    assert('ObjectTypeIndexer', node, opts);
}

function assertObjectTypeProperty(node, opts) {
    assert('ObjectTypeProperty', node, opts);
}

function assertObjectTypeSpreadProperty(node, opts) {
    assert('ObjectTypeSpreadProperty', node, opts);
}

function assertOpaqueType(node, opts) {
    assert('OpaqueType', node, opts);
}

function assertQualifiedTypeIdentifier(node, opts) {
    assert('QualifiedTypeIdentifier', node, opts);
}

function assertStringLiteralTypeAnnotation(node, opts) {
    assert('StringLiteralTypeAnnotation', node, opts);
}

function assertStringTypeAnnotation(node, opts) {
    assert('StringTypeAnnotation', node, opts);
}

function assertSymbolTypeAnnotation(node, opts) {
    assert('SymbolTypeAnnotation', node, opts);
}

function assertThisTypeAnnotation(node, opts) {
    assert('ThisTypeAnnotation', node, opts);
}

function assertTupleTypeAnnotation(node, opts) {
    assert('TupleTypeAnnotation', node, opts);
}

function assertTypeofTypeAnnotation(node, opts) {
    assert('TypeofTypeAnnotation', node, opts);
}

function assertTypeAlias(node, opts) {
    assert('TypeAlias', node, opts);
}

function assertTypeAnnotation(node, opts) {
    assert('TypeAnnotation', node, opts);
}

function assertTypeCastExpression(node, opts) {
    assert('TypeCastExpression', node, opts);
}

function assertTypeParameter(node, opts) {
    assert('TypeParameter', node, opts);
}

function assertTypeParameterDeclaration(node, opts) {
    assert('TypeParameterDeclaration', node, opts);
}

function assertTypeParameterInstantiation(node, opts) {
    assert('TypeParameterInstantiation', node, opts);
}

function assertUnionTypeAnnotation(node, opts) {
    assert('UnionTypeAnnotation', node, opts);
}

function assertVariance(node, opts) {
    assert('Variance', node, opts);
}

function assertVoidTypeAnnotation(node, opts) {
    assert('VoidTypeAnnotation', node, opts);
}

function assertEnumDeclaration(node, opts) {
    assert('EnumDeclaration', node, opts);
}

function assertEnumBooleanBody(node, opts) {
    assert('EnumBooleanBody', node, opts);
}

function assertEnumNumberBody(node, opts) {
    assert('EnumNumberBody', node, opts);
}

function assertEnumStringBody(node, opts) {
    assert('EnumStringBody', node, opts);
}

function assertEnumSymbolBody(node, opts) {
    assert('EnumSymbolBody', node, opts);
}

function assertEnumBooleanMember(node, opts) {
    assert('EnumBooleanMember', node, opts);
}

function assertEnumNumberMember(node, opts) {
    assert('EnumNumberMember', node, opts);
}

function assertEnumStringMember(node, opts) {
    assert('EnumStringMember', node, opts);
}

function assertEnumDefaultedMember(node, opts) {
    assert('EnumDefaultedMember', node, opts);
}

function assertIndexedAccessType(node, opts) {
    assert('IndexedAccessType', node, opts);
}

function assertOptionalIndexedAccessType(node, opts) {
    assert('OptionalIndexedAccessType', node, opts);
}

function assertJSXAttribute(node, opts) {
    assert('JSXAttribute', node, opts);
}

function assertJSXClosingElement(node, opts) {
    assert('JSXClosingElement', node, opts);
}

function assertJSXElement(node, opts) {
    assert('JSXElement', node, opts);
}

function assertJSXEmptyExpression(node, opts) {
    assert('JSXEmptyExpression', node, opts);
}

function assertJSXExpressionContainer(node, opts) {
    assert('JSXExpressionContainer', node, opts);
}

function assertJSXSpreadChild(node, opts) {
    assert('JSXSpreadChild', node, opts);
}

function assertJSXIdentifier(node, opts) {
    assert('JSXIdentifier', node, opts);
}

function assertJSXMemberExpression(node, opts) {
    assert('JSXMemberExpression', node, opts);
}

function assertJSXNamespacedName(node, opts) {
    assert('JSXNamespacedName', node, opts);
}

function assertJSXOpeningElement(node, opts) {
    assert('JSXOpeningElement', node, opts);
}

function assertJSXSpreadAttribute(node, opts) {
    assert('JSXSpreadAttribute', node, opts);
}

function assertJSXText(node, opts) {
    assert('JSXText', node, opts);
}

function assertJSXFragment(node, opts) {
    assert('JSXFragment', node, opts);
}

function assertJSXOpeningFragment(node, opts) {
    assert('JSXOpeningFragment', node, opts);
}

function assertJSXClosingFragment(node, opts) {
    assert('JSXClosingFragment', node, opts);
}

function assertPlaceholder(node, opts) {
    assert('Placeholder', node, opts);
}

function assertV8IntrinsicIdentifier(node, opts) {
    assert('V8IntrinsicIdentifier', node, opts);
}

function assertArgumentPlaceholder(node, opts) {
    assert('ArgumentPlaceholder', node, opts);
}

function assertBindExpression(node, opts) {
    assert('BindExpression', node, opts);
}

function assertDecorator(node, opts) {
    assert('Decorator', node, opts);
}

function assertDoExpression(node, opts) {
    assert('DoExpression', node, opts);
}

function assertExportDefaultSpecifier(node, opts) {
    assert('ExportDefaultSpecifier', node, opts);
}

function assertModuleExpression(node, opts) {
    assert('ModuleExpression', node, opts);
}

function assertTopicReference(node, opts) {
    assert('TopicReference', node, opts);
}

function assertPipelineTopicExpression(node, opts) {
    assert('PipelineTopicExpression', node, opts);
}

function assertPipelineBareFunction(node, opts) {
    assert('PipelineBareFunction', node, opts);
}

function assertPipelinePrimaryTopicReference(node, opts) {
    assert('PipelinePrimaryTopicReference', node, opts);
}

function assertVoidPattern(node, opts) {
    assert('VoidPattern', node, opts);
}

function assertTSParameterProperty(node, opts) {
    assert('TSParameterProperty', node, opts);
}

function assertTSDeclareFunction(node, opts) {
    assert('TSDeclareFunction', node, opts);
}

function assertTSDeclareMethod(node, opts) {
    assert('TSDeclareMethod', node, opts);
}

function assertTSQualifiedName(node, opts) {
    assert('TSQualifiedName', node, opts);
}

function assertTSCallSignatureDeclaration(node, opts) {
    assert('TSCallSignatureDeclaration', node, opts);
}

function assertTSConstructSignatureDeclaration(node, opts) {
    assert('TSConstructSignatureDeclaration', node, opts);
}

function assertTSPropertySignature(node, opts) {
    assert('TSPropertySignature', node, opts);
}

function assertTSMethodSignature(node, opts) {
    assert('TSMethodSignature', node, opts);
}

function assertTSIndexSignature(node, opts) {
    assert('TSIndexSignature', node, opts);
}

function assertTSAnyKeyword(node, opts) {
    assert('TSAnyKeyword', node, opts);
}

function assertTSBooleanKeyword(node, opts) {
    assert('TSBooleanKeyword', node, opts);
}

function assertTSBigIntKeyword(node, opts) {
    assert('TSBigIntKeyword', node, opts);
}

function assertTSIntrinsicKeyword(node, opts) {
    assert('TSIntrinsicKeyword', node, opts);
}

function assertTSNeverKeyword(node, opts) {
    assert('TSNeverKeyword', node, opts);
}

function assertTSNullKeyword(node, opts) {
    assert('TSNullKeyword', node, opts);
}

function assertTSNumberKeyword(node, opts) {
    assert('TSNumberKeyword', node, opts);
}

function assertTSObjectKeyword(node, opts) {
    assert('TSObjectKeyword', node, opts);
}

function assertTSStringKeyword(node, opts) {
    assert('TSStringKeyword', node, opts);
}

function assertTSSymbolKeyword(node, opts) {
    assert('TSSymbolKeyword', node, opts);
}

function assertTSUndefinedKeyword(node, opts) {
    assert('TSUndefinedKeyword', node, opts);
}

function assertTSUnknownKeyword(node, opts) {
    assert('TSUnknownKeyword', node, opts);
}

function assertTSVoidKeyword(node, opts) {
    assert('TSVoidKeyword', node, opts);
}

function assertTSThisType(node, opts) {
    assert('TSThisType', node, opts);
}

function assertTSFunctionType(node, opts) {
    assert('TSFunctionType', node, opts);
}

function assertTSConstructorType(node, opts) {
    assert('TSConstructorType', node, opts);
}

function assertTSTypeReference(node, opts) {
    assert('TSTypeReference', node, opts);
}

function assertTSTypePredicate(node, opts) {
    assert('TSTypePredicate', node, opts);
}

function assertTSTypeQuery(node, opts) {
    assert('TSTypeQuery', node, opts);
}

function assertTSTypeLiteral(node, opts) {
    assert('TSTypeLiteral', node, opts);
}

function assertTSArrayType(node, opts) {
    assert('TSArrayType', node, opts);
}

function assertTSTupleType(node, opts) {
    assert('TSTupleType', node, opts);
}

function assertTSOptionalType(node, opts) {
    assert('TSOptionalType', node, opts);
}

function assertTSRestType(node, opts) {
    assert('TSRestType', node, opts);
}

function assertTSNamedTupleMember(node, opts) {
    assert('TSNamedTupleMember', node, opts);
}

function assertTSUnionType(node, opts) {
    assert('TSUnionType', node, opts);
}

function assertTSIntersectionType(node, opts) {
    assert('TSIntersectionType', node, opts);
}

function assertTSConditionalType(node, opts) {
    assert('TSConditionalType', node, opts);
}

function assertTSInferType(node, opts) {
    assert('TSInferType', node, opts);
}

function assertTSParenthesizedType(node, opts) {
    assert('TSParenthesizedType', node, opts);
}

function assertTSTypeOperator(node, opts) {
    assert('TSTypeOperator', node, opts);
}

function assertTSIndexedAccessType(node, opts) {
    assert('TSIndexedAccessType', node, opts);
}

function assertTSMappedType(node, opts) {
    assert('TSMappedType', node, opts);
}

function assertTSTemplateLiteralType(node, opts) {
    assert('TSTemplateLiteralType', node, opts);
}

function assertTSLiteralType(node, opts) {
    assert('TSLiteralType', node, opts);
}

function assertTSClassImplements(node, opts) {
    assert('TSClassImplements', node, opts);
}

function assertTSInterfaceHeritage(node, opts) {
    assert('TSInterfaceHeritage', node, opts);
}

function assertTSInterfaceDeclaration(node, opts) {
    assert('TSInterfaceDeclaration', node, opts);
}

function assertTSInterfaceBody(node, opts) {
    assert('TSInterfaceBody', node, opts);
}

function assertTSTypeAliasDeclaration(node, opts) {
    assert('TSTypeAliasDeclaration', node, opts);
}

function assertTSInstantiationExpression(node, opts) {
    assert('TSInstantiationExpression', node, opts);
}

function assertTSAsExpression(node, opts) {
    assert('TSAsExpression', node, opts);
}

function assertTSSatisfiesExpression(node, opts) {
    assert('TSSatisfiesExpression', node, opts);
}

function assertTSTypeAssertion(node, opts) {
    assert('TSTypeAssertion', node, opts);
}

function assertTSEnumBody(node, opts) {
    assert('TSEnumBody', node, opts);
}

function assertTSEnumDeclaration(node, opts) {
    assert('TSEnumDeclaration', node, opts);
}

function assertTSEnumMember(node, opts) {
    assert('TSEnumMember', node, opts);
}

function assertTSModuleDeclaration(node, opts) {
    assert('TSModuleDeclaration', node, opts);
}

function assertTSModuleBlock(node, opts) {
    assert('TSModuleBlock', node, opts);
}

function assertTSImportType(node, opts) {
    assert('TSImportType', node, opts);
}

function assertTSImportEqualsDeclaration(node, opts) {
    assert('TSImportEqualsDeclaration', node, opts);
}

function assertTSExternalModuleReference(node, opts) {
    assert('TSExternalModuleReference', node, opts);
}

function assertTSNonNullExpression(node, opts) {
    assert('TSNonNullExpression', node, opts);
}

function assertTSExportAssignment(node, opts) {
    assert('TSExportAssignment', node, opts);
}

function assertTSNamespaceExportDeclaration(node, opts) {
    assert('TSNamespaceExportDeclaration', node, opts);
}

function assertTSTypeAnnotation(node, opts) {
    assert('TSTypeAnnotation', node, opts);
}

function assertTSTypeParameterInstantiation(node, opts) {
    assert('TSTypeParameterInstantiation', node, opts);
}

function assertTSTypeParameterDeclaration(node, opts) {
    assert('TSTypeParameterDeclaration', node, opts);
}

function assertTSTypeParameter(node, opts) {
    assert('TSTypeParameter', node, opts);
}

function assertStandardized(node, opts) {
    assert('Standardized', node, opts);
}

function assertExpression(node, opts) {
    assert('Expression', node, opts);
}

function assertBinary(node, opts) {
    assert('Binary', node, opts);
}

function assertScopable(node, opts) {
    assert('Scopable', node, opts);
}

function assertBlockParent(node, opts) {
    assert('BlockParent', node, opts);
}

function assertBlock(node, opts) {
    assert('Block', node, opts);
}

function assertStatement(node, opts) {
    assert('Statement', node, opts);
}

function assertTerminatorless(node, opts) {
    assert('Terminatorless', node, opts);
}

function assertCompletionStatement(node, opts) {
    assert('CompletionStatement', node, opts);
}

function assertConditional(node, opts) {
    assert('Conditional', node, opts);
}

function assertLoop(node, opts) {
    assert('Loop', node, opts);
}

function assertWhile(node, opts) {
    assert('While', node, opts);
}

function assertExpressionWrapper(node, opts) {
    assert('ExpressionWrapper', node, opts);
}

function assertFor(node, opts) {
    assert('For', node, opts);
}

function assertForXStatement(node, opts) {
    assert('ForXStatement', node, opts);
}

function assertFunction(node, opts) {
    assert('Function', node, opts);
}

function assertFunctionParent(node, opts) {
    assert('FunctionParent', node, opts);
}

function assertPureish(node, opts) {
    assert('Pureish', node, opts);
}

function assertDeclaration(node, opts) {
    assert('Declaration', node, opts);
}

function assertFunctionParameter(node, opts) {
    assert('FunctionParameter', node, opts);
}

function assertPatternLike(node, opts) {
    assert('PatternLike', node, opts);
}

function assertLVal(node, opts) {
    assert('LVal', node, opts);
}

function assertTSEntityName(node, opts) {
    assert('TSEntityName', node, opts);
}

function assertLiteral(node, opts) {
    assert('Literal', node, opts);
}

function assertImmutable(node, opts) {
    assert('Immutable', node, opts);
}

function assertUserWhitespacable(node, opts) {
    assert('UserWhitespacable', node, opts);
}

function assertMethod(node, opts) {
    assert('Method', node, opts);
}

function assertObjectMember(node, opts) {
    assert('ObjectMember', node, opts);
}

function assertProperty(node, opts) {
    assert('Property', node, opts);
}

function assertUnaryLike(node, opts) {
    assert('UnaryLike', node, opts);
}

function assertPattern(node, opts) {
    assert('Pattern', node, opts);
}

function assertClass(node, opts) {
    assert('Class', node, opts);
}

function assertImportOrExportDeclaration(node, opts) {
    assert('ImportOrExportDeclaration', node, opts);
}

function assertExportDeclaration(node, opts) {
    assert('ExportDeclaration', node, opts);
}

function assertModuleSpecifier(node, opts) {
    assert('ModuleSpecifier', node, opts);
}

function assertAccessor(node, opts) {
    assert('Accessor', node, opts);
}

function assertPrivate(node, opts) {
    assert('Private', node, opts);
}

function assertFlow(node, opts) {
    assert('Flow', node, opts);
}

function assertFlowType(node, opts) {
    assert('FlowType', node, opts);
}

function assertFlowBaseAnnotation(node, opts) {
    assert('FlowBaseAnnotation', node, opts);
}

function assertFlowDeclaration(node, opts) {
    assert('FlowDeclaration', node, opts);
}

function assertFlowPredicate(node, opts) {
    assert('FlowPredicate', node, opts);
}

function assertEnumBody(node, opts) {
    assert('EnumBody', node, opts);
}

function assertEnumMember(node, opts) {
    assert('EnumMember', node, opts);
}

function assertJSX(node, opts) {
    assert('JSX', node, opts);
}

function assertMiscellaneous(node, opts) {
    assert('Miscellaneous', node, opts);
}

function assertTypeScript(node, opts) {
    assert('TypeScript', node, opts);
}

function assertTSTypeElement(node, opts) {
    assert('TSTypeElement', node, opts);
}

function assertTSType(node, opts) {
    assert('TSType', node, opts);
}

function assertTSBaseType(node, opts) {
    assert('TSBaseType', node, opts);
}

function assertNumberLiteral(node, opts) {
    deprecationWarning('assertNumberLiteral', 'assertNumericLiteral');
    assert('NumberLiteral', node, opts);
}

function assertRegexLiteral(node, opts) {
    deprecationWarning('assertRegexLiteral', 'assertRegExpLiteral');
    assert('RegexLiteral', node, opts);
}

function assertRestProperty(node, opts) {
    deprecationWarning('assertRestProperty', 'assertRestElement');
    assert('RestProperty', node, opts);
}

function assertSpreadProperty(node, opts) {
    deprecationWarning('assertSpreadProperty', 'assertSpreadElement');
    assert('SpreadProperty', node, opts);
}

function assertModuleDeclaration(node, opts) {
    deprecationWarning('assertModuleDeclaration', 'assertImportOrExportDeclaration');
    assert('ModuleDeclaration', node, opts);
}

function createTypeAnnotationBasedOnTypeof(type) {
    switch(type) {
    case 'string':
        return stringTypeAnnotation();
    
    case 'number':
        return numberTypeAnnotation();
    
    case 'undefined':
        return voidTypeAnnotation();
    
    case 'boolean':
        return booleanTypeAnnotation();
    
    case 'function':
        return genericTypeAnnotation(identifier$2('Function'));
    
    case 'object':
        return genericTypeAnnotation(identifier$2('Object'));
    
    case 'symbol':
        return genericTypeAnnotation(identifier$2('Symbol'));
    
    case 'bigint':
        return anyTypeAnnotation();
    }
    
    throw new Error('Invalid typeof value: ' + type);
}

function getQualifiedName$1(node) {
    return isIdentifier$h(node) ? node.name : `${node.id.name}.${getQualifiedName$1(node.qualification)}`;
}

function removeTypeDuplicates$1(nodesIn) {
    const nodes2 = Array.from(nodesIn);
    const generics =     /* @__PURE__ */new Map();
    const bases =     /* @__PURE__ */new Map();
    const typeGroups =     /* @__PURE__ */new Set();
    const types2 = [];
    
    for (let i = 0; i < nodes2.length; i++) {
        const node = nodes2[i];
        
        if (!node)
            continue;
        
        if (types2.includes(node)) {
            continue;
        }
        
        if (isAnyTypeAnnotation(node)) {
            return [node];
        }
        
        if (isFlowBaseAnnotation()) {
            bases.set(node.type, node);
            continue;
        }
        
        if (isUnionTypeAnnotation(node)) {
            if (!typeGroups.has(node.types)) {
                nodes2.push(...node.types);
                typeGroups.add(node.types);
            }
            
            continue;
        }
        
        if (isGenericTypeAnnotation(node)) {
            const name = getQualifiedName$1(node.id);
            
            if (generics.has(name)) {
                let existing = generics.get(name);
                
                if (existing.typeParameters) {
                    if (node.typeParameters) {
                        existing.typeParameters.params.push(...node.typeParameters.params);
                        existing.typeParameters.params = removeTypeDuplicates$1(existing.typeParameters.params);
                    }
                } else {
                    existing = node.typeParameters;
                }
            } else {
                generics.set(name, node);
            }
            
            continue;
        }
        
        types2.push(node);
    }
    
    for (const [, baseType] of bases) {
        types2.push(baseType);
    }
    
    for (const [, genericName] of generics) {
        types2.push(genericName);
    }
    
    return types2;
}

function createFlowUnionType(types2) {
    const flattened = removeTypeDuplicates$1(types2);
    
    if (flattened.length === 1) {
        return flattened[0];
    } else {
        return unionTypeAnnotation(flattened);
    }
}

function getQualifiedName(node) {
    return isIdentifier$h(node) ? node.name : isThisExpression(node) ? 'this' : `${node.right.name}.${getQualifiedName(node.left)}`;
}

function removeTypeDuplicates(nodesIn) {
    const nodes2 = Array.from(nodesIn);
    const generics =     /* @__PURE__ */new Map();
    const bases =     /* @__PURE__ */new Map();
    const typeGroups =     /* @__PURE__ */new Set();
    const types2 = [];
    
    for (let i = 0; i < nodes2.length; i++) {
        const node = nodes2[i];
        
        if (!node)
            continue;
        
        if (types2.includes(node)) {
            continue;
        }
        
        if (isTSAnyKeyword(node)) {
            return [node];
        }
        
        if (isTSBaseType(node)) {
            bases.set(node.type, node);
            continue;
        }
        
        if (isTSUnionType$1(node)) {
            if (!typeGroups.has(node.types)) {
                nodes2.push(...node.types);
                typeGroups.add(node.types);
            }
            
            continue;
        }
        
        const typeArgumentsKey = 'typeArguments';
        
        if (isTSTypeReference$3(node) && node[typeArgumentsKey]) {
            const typeArguments = node[typeArgumentsKey];
            const name = getQualifiedName(node.typeName);
            
            if (generics.has(name)) {
                let existing = generics.get(name);
                const existingTypeArguments = existing[typeArgumentsKey];
                
                if (existingTypeArguments) {
                    existingTypeArguments.params.push(...typeArguments.params);
                    existingTypeArguments.params = removeTypeDuplicates(existingTypeArguments.params);
                } else {
                    existing = typeArguments;
                }
            } else {
                generics.set(name, node);
            }
            
            continue;
        }
        
        types2.push(node);
    }
    
    for (const [, baseType] of bases) {
        types2.push(baseType);
    }
    
    for (const [, genericName] of generics) {
        types2.push(genericName);
    }
    
    return types2;
}

function createTSUnionType(typeAnnotations) {
    const types2 = typeAnnotations.map((type) => {
        return isTSTypeAnnotation(type) ? type.typeAnnotation : type;
    });
    
    const flattened = removeTypeDuplicates(types2);
    
    if (flattened.length === 1) {
        return flattened[0];
    } else {
        return tsUnionType(flattened);
    }
}

function buildUndefinedNode() {
    return unaryExpression$1('void', numericLiteral(0), true);
}

var {hasOwn} = Object;

function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
    if (obj && typeof obj.type === 'string') {
        return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
    }
    
    return obj;
}

function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
    if (Array.isArray(obj)) {
        return obj.map((node) => cloneIfNode(node, deep, withoutLoc, commentsCache));
    }
    
    return cloneIfNode(obj, deep, withoutLoc, commentsCache);
}

function cloneNode(node, deep = true, withoutLoc = false) {
    return cloneNodeInternal(node, deep, withoutLoc,     /* @__PURE__ */new Map());
}

function cloneNodeInternal(node, deep = true, withoutLoc = false, commentsCache) {
    if (!node)
        return node;
    
    const {type} = node;
    
    const newNode = {
        type: node.type,
    };
    
    if (isIdentifier$h(node)) {
        newNode.name = node.name;
        
        if (hasOwn(node, 'optional') && typeof node.optional === 'boolean') {
            newNode.optional = node.optional;
        }
        
        if (hasOwn(node, 'typeAnnotation')) {
            newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;
        }
        
        if (hasOwn(node, 'decorators')) {
            newNode.decorators = deep ? cloneIfNodeOrArray(node.decorators, true, withoutLoc, commentsCache) : node.decorators;
        }
    } else if (!hasOwn(NODE_FIELDS$1, type)) {
        throw new Error(`Unknown node type: "${type}"`);
    } else {
        for (const field of Object.keys(NODE_FIELDS$1[type])) {
            if (hasOwn(node, field)) {
                if (deep) {
                    newNode[field] = isFile$2(node) && field === 'comments' ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache);
                } else {
                    newNode[field] = node[field];
                }
            }
        }
    }
    
    if (hasOwn(node, 'loc')) {
        if (withoutLoc) {
            newNode.loc = null;
        } else {
            newNode.loc = node.loc;
        }
    }
    
    if (hasOwn(node, 'leadingComments')) {
        newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);
    }
    
    if (hasOwn(node, 'innerComments')) {
        newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);
    }
    
    if (hasOwn(node, 'trailingComments')) {
        newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);
    }
    
    if (hasOwn(node, 'extra')) {
        newNode.extra = {
            ...node.extra,
        };
    }
    
    return newNode;
}

function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
    if (!comments || !deep) {
        return comments;
    }
    
    return comments.map((comment) => {
        const cache2 = commentsCache.get(comment);
        
        if (cache2)
            return cache2;
        
        const {
            type,
            value,
            loc,
        } = comment;
        
        const ret = {
            type,
            value,
            loc,
        };
        
        if (withoutLoc) {
            ret.loc = null;
        }
        
        commentsCache.set(comment, ret);
        return ret;
    });
}

function clone(node) {
    return cloneNode(node, false);
}

function cloneDeep(node) {
    return cloneNode(node);
}

function cloneDeepWithoutLoc(node) {
    return cloneNode(node, true, true);
}

function cloneWithoutLoc(node) {
    return cloneNode(node, false, true);
}

function addComments(node, type, comments) {
    if (!comments || !node)
        return node;
    
    const key = `${type}Comments`;
    
    if (node[key]) {
        if (type === 'leading') {
            node[key] = comments.concat(node[key]);
        } else {
            node[key].push(...comments);
        }
    } else {
        node[key] = comments;
    }
    
    return node;
}

function addComment(node, type, content, line) {
    return addComments(node, type, [{
        type: line ? 'CommentLine' : 'CommentBlock',
        value: content,
    }]);
}

function inherit(key, child, parent) {
    if (child && parent) {
        child[key] = Array.from(new Set([]
            .concat(child[key], parent[key])
            .filter(Boolean)));
    }
}

function inheritInnerComments(child, parent) {
    inherit('innerComments', child, parent);
}

function inheritLeadingComments(child, parent) {
    inherit('leadingComments', child, parent);
}

function inheritTrailingComments(child, parent) {
    inherit('trailingComments', child, parent);
}

function inheritsComments(child, parent) {
    inheritTrailingComments(child, parent);
    inheritLeadingComments(child, parent);
    inheritInnerComments(child, parent);
    return child;
}

function removeComments(node) {
    COMMENT_KEYS.forEach((key) => {
        node[key] = null;
    });
    return node;
}

var STANDARDIZED_TYPES = FLIPPED_ALIAS_KEYS['Standardized'];
var EXPRESSION_TYPES = FLIPPED_ALIAS_KEYS['Expression'];
var BINARY_TYPES = FLIPPED_ALIAS_KEYS['Binary'];
var SCOPABLE_TYPES = FLIPPED_ALIAS_KEYS['Scopable'];
var BLOCKPARENT_TYPES = FLIPPED_ALIAS_KEYS['BlockParent'];
var BLOCK_TYPES = FLIPPED_ALIAS_KEYS['Block'];
var STATEMENT_TYPES = FLIPPED_ALIAS_KEYS['Statement'];
var TERMINATORLESS_TYPES = FLIPPED_ALIAS_KEYS['Terminatorless'];
var COMPLETIONSTATEMENT_TYPES = FLIPPED_ALIAS_KEYS['CompletionStatement'];
var CONDITIONAL_TYPES = FLIPPED_ALIAS_KEYS['Conditional'];
var LOOP_TYPES = FLIPPED_ALIAS_KEYS['Loop'];
var WHILE_TYPES = FLIPPED_ALIAS_KEYS['While'];
var EXPRESSIONWRAPPER_TYPES = FLIPPED_ALIAS_KEYS['ExpressionWrapper'];
var FOR_TYPES = FLIPPED_ALIAS_KEYS['For'];
var FORXSTATEMENT_TYPES = FLIPPED_ALIAS_KEYS['ForXStatement'];
var FUNCTION_TYPES = FLIPPED_ALIAS_KEYS['Function'];
var FUNCTIONPARENT_TYPES = FLIPPED_ALIAS_KEYS['FunctionParent'];
var PUREISH_TYPES = FLIPPED_ALIAS_KEYS['Pureish'];
var DECLARATION_TYPES = FLIPPED_ALIAS_KEYS['Declaration'];
var FUNCTIONPARAMETER_TYPES = FLIPPED_ALIAS_KEYS['FunctionParameter'];
var PATTERNLIKE_TYPES = FLIPPED_ALIAS_KEYS['PatternLike'];
var LVAL_TYPES = FLIPPED_ALIAS_KEYS['LVal'];
var TSENTITYNAME_TYPES = FLIPPED_ALIAS_KEYS['TSEntityName'];
var LITERAL_TYPES = FLIPPED_ALIAS_KEYS['Literal'];
var IMMUTABLE_TYPES = FLIPPED_ALIAS_KEYS['Immutable'];
var USERWHITESPACABLE_TYPES = FLIPPED_ALIAS_KEYS['UserWhitespacable'];
var METHOD_TYPES = FLIPPED_ALIAS_KEYS['Method'];
var OBJECTMEMBER_TYPES = FLIPPED_ALIAS_KEYS['ObjectMember'];
var PROPERTY_TYPES = FLIPPED_ALIAS_KEYS['Property'];
var UNARYLIKE_TYPES = FLIPPED_ALIAS_KEYS['UnaryLike'];
var PATTERN_TYPES = FLIPPED_ALIAS_KEYS['Pattern'];
var CLASS_TYPES = FLIPPED_ALIAS_KEYS['Class'];
var IMPORTOREXPORTDECLARATION_TYPES = FLIPPED_ALIAS_KEYS['ImportOrExportDeclaration'];
var EXPORTDECLARATION_TYPES = FLIPPED_ALIAS_KEYS['ExportDeclaration'];
var MODULESPECIFIER_TYPES = FLIPPED_ALIAS_KEYS['ModuleSpecifier'];
var ACCESSOR_TYPES = FLIPPED_ALIAS_KEYS['Accessor'];
var PRIVATE_TYPES = FLIPPED_ALIAS_KEYS['Private'];
var FLOW_TYPES = FLIPPED_ALIAS_KEYS['Flow'];
var FLOWTYPE_TYPES = FLIPPED_ALIAS_KEYS['FlowType'];
var FLOWBASEANNOTATION_TYPES = FLIPPED_ALIAS_KEYS['FlowBaseAnnotation'];
var FLOWDECLARATION_TYPES = FLIPPED_ALIAS_KEYS['FlowDeclaration'];
var FLOWPREDICATE_TYPES = FLIPPED_ALIAS_KEYS['FlowPredicate'];
var ENUMBODY_TYPES = FLIPPED_ALIAS_KEYS['EnumBody'];
var ENUMMEMBER_TYPES = FLIPPED_ALIAS_KEYS['EnumMember'];
var JSX_TYPES = FLIPPED_ALIAS_KEYS['JSX'];
var MISCELLANEOUS_TYPES = FLIPPED_ALIAS_KEYS['Miscellaneous'];
var TYPESCRIPT_TYPES = FLIPPED_ALIAS_KEYS['TypeScript'];
var TSTYPEELEMENT_TYPES = FLIPPED_ALIAS_KEYS['TSTypeElement'];
var TSTYPE_TYPES = FLIPPED_ALIAS_KEYS['TSType'];
var TSBASETYPE_TYPES = FLIPPED_ALIAS_KEYS['TSBaseType'];
var MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;

function toBlock(node, parent) {
    if (isBlockStatement$7(node)) {
        return node;
    }
    
    let blockNodes = [];
    
    if (isEmptyStatement(node)) {
        blockNodes = [];
    } else {
        if (!isStatement$7(node)) {
            if (isFunction$8(parent)) {
                node = returnStatement(node);
            } else {
                node = expressionStatement$4(node);
            }
        }
        
        blockNodes = [node];
    }
    
    return blockStatement$1(blockNodes);
}

function ensureBlock(node, key = 'body') {
    const result = toBlock(node[key], node);
    
    node[key] = result;
    return result;
}

function toIdentifier(input) {
    input = input + '';
    let name = '';
    
    for (const c of input) {
        name += isIdentifierChar(c.codePointAt(0)) ? c : '-';
    }
    
    name = name.replace(/^[-0-9]+/, '');
    name = name.replace(/[-\s]+(.)?/g, function(match, c) {
        return c ? c.toUpperCase() : '';
    });
    
    if (!isValidIdentifier(name)) {
        name = `_${name}`;
    }
    
    return name || '_';
}

function toBindingIdentifierName(name) {
    name = toIdentifier(name);
    
    if (name === 'eval' || name === 'arguments')
        name = '_' + name;
    
    return name;
}

function toComputedKey(node, key = node.key || node.property) {
    if (!node.computed && isIdentifier$h(key))
        key = stringLiteral$5(key.name);
    
    return key;
}

function toExpression$1(node) {
    if (isExpressionStatement$a(node)) {
        node = node.expression;
    }
    
    if (isExpression$2(node)) {
        return node;
    }
    
    if (isClass(node)) {
        node.type = 'ClassExpression';
        node.abstract = false;
    } else if (isFunction$8(node)) {
        node.type = 'FunctionExpression';
    }
    
    if (!isExpression$2(node)) {
        throw new Error(`cannot turn ${node.type} to an expression`);
    }
    
    return node;
}

var _skip = Symbol();
var _stop = Symbol();

function traverseFast(node, enter, opts) {
    if (!node)
        return false;
    
    const keys2 = VISITOR_KEYS[node.type];
    
    if (!keys2)
        return false;
    
    opts = opts || {};
    const ret = enter(node, opts);
    
    if (ret !== void 0) {
        switch(ret) {
        case _skip:
            return false;
        
        case _stop:
            return true;
        }
    }
    
    for (const key of keys2) {
        const subNode = node[key];
        
        if (!subNode)
            continue;
        
        if (Array.isArray(subNode)) {
            for (const node2 of subNode) {
                if (traverseFast(node2, enter, opts))
                    return true;
            }
        } else {
            if (traverseFast(subNode, enter, opts))
                return true;
        }
    }
    
    return false;
}

traverseFast.skip = _skip;
traverseFast.stop = _stop;
var CLEAR_KEYS = [
    'tokens',
    'start',
    'end',
    'loc',
    'raw',
    'rawValue',
];
var CLEAR_KEYS_PLUS_COMMENTS = [
    ...COMMENT_KEYS,
    'comments',
    ...CLEAR_KEYS,
];

function removeProperties(node, opts = {}) {
    const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
    
    for (const key of map) {
        if (node[key] != null)
            node[key] = void 0;
    }
    
    for (const key of Object.keys(node)) {
        if (key.startsWith('_') && node[key] != null)
            node[key] = void 0;
    }
    
    const symbols = Object.getOwnPropertySymbols(node);
    
    for (const sym of symbols) {
        node[sym] = null;
    }
}

function removePropertiesDeep(tree, opts) {
    traverseFast(tree, removeProperties, opts);
    return tree;
}

function toKeyAlias(node, key = node.key) {
    let alias2;
    
    if (node.kind === 'method') {
        return toKeyAlias.increment() + '';
    } else if (isIdentifier$h(key)) {
        alias2 = key.name;
    } else if (isStringLiteral$a(key)) {
        alias2 = JSON.stringify(key.value);
    } else {
        alias2 = JSON.stringify(removePropertiesDeep(cloneNode(key)));
    }
    
    if (node.computed) {
        alias2 = `[${alias2}]`;
    }
    
    if (node.static) {
        alias2 = `static:${alias2}`;
    }
    
    return alias2;
}

toKeyAlias.uid = 0;
toKeyAlias.increment = function() {
    if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
        return toKeyAlias.uid = 0;
    } else {
        return toKeyAlias.uid++;
    }
};
function toStatement$1(node, ignore) {
    if (isStatement$7(node)) {
        return node;
    }
    
    let mustHaveId = false;
    let newType;
    
    if (isClass(node)) {
        mustHaveId = true;
        newType = 'ClassDeclaration';
    } else if (isFunction$8(node)) {
        mustHaveId = true;
        newType = 'FunctionDeclaration';
    } else if (isAssignmentExpression$4(node)) {
        return expressionStatement$4(node);
    }
    
    if (mustHaveId && !node.id) {
        newType = false;
    }
    
    if (!newType) {
        if (ignore) {
            return false;
        } else {
            throw new Error(`cannot turn ${node.type} to a statement`);
        }
    }
    
    node.type = newType;
    return node;
}

var objectToString = Function.call.bind(Object.prototype.toString);

function isRegExp(value) {
    return objectToString(value) === '[object RegExp]';
}

function isPlainObject(value) {
    if (typeof value !== 'object' || value === null || Object.prototype.toString.call(value) !== '[object Object]') {
        return false;
    }
    
    const proto = Object.getPrototypeOf(value);
    
    return proto === null || Object.getPrototypeOf(proto) === null;
}

function valueToNode(value) {
    if (value === void 0) {
        return identifier$2('undefined');
    }
    
    if (value === true || value === false) {
        return booleanLiteral(value);
    }
    
    if (value === null) {
        return nullLiteral();
    }
    
    if (typeof value === 'string') {
        return stringLiteral$5(value);
    }
    
    if (typeof value === 'number') {
        let result;
        
        if (Number.isFinite(value)) {
            result = numericLiteral(Math.abs(value));
        } else {
            let numerator;
            
            if (Number.isNaN(value)) {
                numerator = numericLiteral(0);
            } else {
                numerator = numericLiteral(1);
            }
            
            result = binaryExpression('/', numerator, numericLiteral(0));
        }
        
        if (value < 0 || Object.is(value, -0)) {
            result = unaryExpression$1('-', result);
        }
        
        return result;
    }
    
    if (typeof value === 'bigint') {
        if (value < 0) {
            return unaryExpression$1('-', bigIntLiteral(-value));
        } else {
            return bigIntLiteral(value);
        }
    }
    
    if (isRegExp(value)) {
        const pattern = value.source;
        const flags = /\/([a-z]*)$/.exec(value.toString())[1];
        
        return regExpLiteral(pattern, flags);
    }
    
    if (Array.isArray(value)) {
        return arrayExpression$3(value.map(valueToNode));
    }
    
    if (isPlainObject(value)) {
        const props = [];
        
        for (const key of Object.keys(value)) {
            let nodeKey, computed = false;
            
            if (isValidIdentifier(key)) {
                if (key === '__proto__') {
                    computed = true;
                    nodeKey = stringLiteral$5(key);
                } else {
                    nodeKey = identifier$2(key);
                }
            } else {
                nodeKey = stringLiteral$5(key);
            }
            
            props.push(objectProperty$3(nodeKey, valueToNode(value[key]), computed));
        }
        
        return objectExpression$2(props);
    }
    
    throw new Error('don\'t know how to turn this value into a node');
}

function appendToMemberExpression(member, append, computed = false) {
    member.object = memberExpression(member.object, member.property, member.computed);
    member.property = append;
    member.computed = !!computed;
    return member;
}

function inherits(child, parent) {
    if (!child || !parent)
        return child;
    
    for (const key of INHERIT_KEYS.optional) {
        if (child[key] == null) {
            child[key] = parent[key];
        }
    }
    
    for (const key of Object.keys(parent)) {
        if (key.startsWith('_') && key !== '__clone') {
            child[key] = parent[key];
        }
    }
    
    for (const key of INHERIT_KEYS.force) {
        child[key] = parent[key];
    }
    
    inheritsComments(child, parent);
    
    return child;
}

function prependToMemberExpression(member, prepend) {
    if (isSuper(member.object)) {
        throw new Error('Cannot prepend node to super property access (`super.foo`).');
    }
    
    member.object = memberExpression(prepend, member.object);
    
    return member;
}

function getAssignmentIdentifiers(node) {
    const search = [].concat(node);
    const ids =     /* @__PURE__ */Object.create(null);
    
    while (search.length) {
        const id = search.pop();
        
        if (!id)
            continue;
        
        switch(id.type) {
        case 'ArrayPattern':
            search.push(...id.elements);
            break;
        
        case 'AssignmentExpression':        
        case 'AssignmentPattern':        
        case 'ForInStatement':        
        case 'ForOfStatement':
            search.push(id.left);
            break;
        
        case 'ObjectPattern':
            search.push(...id.properties);
            break;
        
        case 'ObjectProperty':
            search.push(id.value);
            break;
        
        case 'RestElement':        
        case 'UpdateExpression':
            search.push(id.argument);
            break;
        
        case 'UnaryExpression':
            if (id.operator === 'delete') {
                search.push(id.argument);
            }
            
            break;
        
        case 'Identifier':
            ids[id.name] = id;
            break;
        }
    }
    
    return ids;
}

function getBindingIdentifiers(node, duplicates, outerOnly, newBindingsOnly) {
    const search = [].concat(node);
    const ids =     /* @__PURE__ */Object.create(null);
    
    while (search.length) {
        const id = search.shift();
        
        if (!id)
            continue;
        
        if (newBindingsOnly && (isAssignmentExpression$4(id) || isUnaryExpression$1(id) || isUpdateExpression(id))) {
            continue;
        }
        
        if (isIdentifier$h(id)) {
            if (duplicates) {
                const _ids = ids[id.name] = ids[id.name] || [];
                _ids.push(id);
            } else {
                ids[id.name] = id;
            }
            
            continue;
        }
        
        if (isExportDeclaration$5(id) && !isExportAllDeclaration(id)) {
            if (isDeclaration(id.declaration)) {
                search.push(id.declaration);
            }
            
            continue;
        }
        
        if (outerOnly) {
            if (isFunctionDeclaration$3(id)) {
                search.push(id.id);
                continue;
            }
            
            if (isFunctionExpression$1(id) || isClassExpression(id)) {
                continue;
            }
        }
        
        const keys2 = getBindingIdentifiers.keys[id.type];
        
        if (keys2) {
            for (let i = 0; i < keys2.length; i++) {
                const key = keys2[i];
                const nodes2 = id[key];
                
                if (nodes2) {
                    if (Array.isArray(nodes2)) {
                        search.push(...nodes2);
                    } else {
                        search.push(nodes2);
                    }
                }
            }
        }
    }
    
    return ids;
}

var keys$4 = {
    DeclareClass: ['id'],
    DeclareFunction: ['id'],
    DeclareModule: ['id'],
    DeclareVariable: ['id'],
    DeclareInterface: ['id'],
    DeclareTypeAlias: ['id'],
    DeclareOpaqueType: ['id'],
    InterfaceDeclaration: ['id'],
    TypeAlias: ['id'],
    OpaqueType: ['id'],
    CatchClause: ['param'],
    LabeledStatement: ['label'],
    UnaryExpression: ['argument'],
    AssignmentExpression: ['left'],
    ImportSpecifier: ['local'],
    ImportNamespaceSpecifier: ['local'],
    ImportDefaultSpecifier: ['local'],
    ImportDeclaration: ['specifiers'],
    TSImportEqualsDeclaration: ['id'],
    ExportSpecifier: ['exported'],
    ExportNamespaceSpecifier: ['exported'],
    ExportDefaultSpecifier: ['exported'],
    FunctionDeclaration: ['id', 'params'],
    FunctionExpression: ['id', 'params'],
    ArrowFunctionExpression: ['params'],
    ObjectMethod: ['params'],
    ClassMethod: ['params'],
    ClassPrivateMethod: ['params'],
    ForInStatement: ['left'],
    ForOfStatement: ['left'],
    ClassDeclaration: ['id'],
    ClassExpression: ['id'],
    RestElement: ['argument'],
    UpdateExpression: ['argument'],
    ObjectProperty: ['value'],
    AssignmentPattern: ['left'],
    ArrayPattern: ['elements'],
    ObjectPattern: ['properties'],
    VariableDeclaration: ['declarations'],
    VariableDeclarator: ['id'],
};

getBindingIdentifiers.keys = keys$4;
function getOuterBindingIdentifiers(node, duplicates) {
    return getBindingIdentifiers(node, duplicates, true);
}

function getNameFromLiteralId(id) {
    if (isNullLiteral$1(id)) {
        return 'null';
    }
    
    if (isRegExpLiteral$2(id)) {
        return `/${id.pattern}/${id.flags}`;
    }
    
    if (isTemplateLiteral$4(id)) {
        return id.quasis
            .map((quasi) => quasi.value.raw)
            .join('');
    }
    
    if (id.value !== void 0) {
        return String(id.value);
    }
    
    return null;
}

function getObjectMemberKey(node) {
    if (!node.computed || isLiteral$4(node.key)) {
        return node.key;
    }
}

function getFunctionName(node, parent) {
    if ('id' in node && node.id) {
        return {
            name: node.id.name,
            originalNode: node.id,
        };
    }
    
    let prefix2 = '';
    let id;
    
    if (isObjectProperty$3(parent, {value: node})) {
        id = getObjectMemberKey(parent);
    } else if (isObjectMethod$1(node) || isClassMethod$2(node)) {
        id = getObjectMemberKey(node);
        
        if (node.kind === 'get')
            prefix2 = 'get ';
        else if (node.kind === 'set')
            prefix2 = 'set ';
    } else if (isVariableDeclarator$4(parent, {init: node})) {
        id = parent.id;
    } else if (isAssignmentExpression$4(parent, {operator: '=', right: node})) {
        id = parent.left;
    }

    
    if (!id)
        return null;
    
    const name = isLiteral$4(id) ? getNameFromLiteralId(id) : isIdentifier$h(id) ? id.name : isPrivateName(id) ? id.id.name : null;
    
    if (name == null)
        return null;
    
    return {
        name: prefix2 + name,
        originalNode: id,
    };
}

function traverse$2(node, handlers, state) {
    if (typeof handlers === 'function') {
        handlers = {
            enter: handlers,
        };
    }
    
    const {enter, exit} = handlers;
    
    traverseSimpleImpl(node, enter, exit, state, []);
}

function traverseSimpleImpl(node, enter, exit, state, ancestors) {
    const keys2 = VISITOR_KEYS[node.type];
    
    if (!keys2)
        return;
    
    if (enter)
        enter(node, ancestors, state);
    
    for (const key of keys2) {
        const subNode = node[key];
        
        if (Array.isArray(subNode)) {
            for (let i = 0; i < subNode.length; i++) {
                const child = subNode[i];
                
                if (!child)
                    continue;
                
                ancestors.push({
                    node,
                    key,
                    index: i,
                });
                traverseSimpleImpl(child, enter, exit, state, ancestors);
                ancestors.pop();
            }
        } else if (subNode) {
            ancestors.push({
                node,
                key,
            });
            traverseSimpleImpl(subNode, enter, exit, state, ancestors);
            ancestors.pop();
        }
    }
    
    if (exit)
        exit(node, ancestors, state);
}

function isBinding$1(node, parent, grandparent) {
    if (grandparent && node.type === 'Identifier' && parent.type === 'ObjectProperty' && grandparent.type === 'ObjectExpression') {
        return false;
    }
    
    const keys2 = getBindingIdentifiers.keys[parent.type];
    
    if (keys2) {
        for (let i = 0; i < keys2.length; i++) {
            const key = keys2[i];
            const val = parent[key];
            
            if (Array.isArray(val)) {
                if (val.includes(node))
                    return true;
            } else {
                if (val === node)
                    return true;
            }
        }
    }
    
    return false;
}

function isLet(node) {
    return isVariableDeclaration$5(node) && node.kind !== 'var';
}

function isBlockScoped(node) {
    return isFunctionDeclaration$3(node) || isClassDeclaration(node) || isLet(node);
}

function isImmutable(node) {
    if (isType(node.type, 'Immutable'))
        return true;
    
    if (isIdentifier$h(node)) {
        if (node.name === 'undefined') {
            return true;
        } else {
            return false;
        }
    }
    
    return false;
}

function isNodesEquivalent(a, b2) {
    if (typeof a !== 'object' || typeof b2 !== 'object' || a == null || b2 == null) {
        return a === b2;
    }
    
    if (a.type !== b2.type) {
        return false;
    }
    
    const fields = Object.keys(NODE_FIELDS$1[a.type] || a.type);
    const visitorKeys = VISITOR_KEYS[a.type];
    
    for (const field of fields) {
        const val_a = a[field];
        const val_b = b2[field];
        
        if (typeof val_a !== typeof val_b) {
            return false;
        }
        
        if (val_a == null && val_b == null) {
            continue;
        } else if (val_a == null || val_b == null) {
            return false;
        }
        
        if (Array.isArray(val_a)) {
            if (!Array.isArray(val_b)) {
                return false;
            }
            
            if (val_a.length !== val_b.length) {
                return false;
            }
            
            for (let i = 0; i < val_a.length; i++) {
                if (!isNodesEquivalent(val_a[i], val_b[i])) {
                    return false;
                }
            }
            
            continue;
        }
        
        if (typeof val_a === 'object' && !visitorKeys?.includes(field)) {
            for (const key of Object.keys(val_a)) {
                if (val_a[key] !== val_b[key]) {
                    return false;
                }
            }
            
            continue;
        }
        
        if (!isNodesEquivalent(val_a, val_b)) {
            return false;
        }
    }
    
    return true;
}

function isReferenced(node, parent, grandparent) {
    switch(parent.type) {
    case 'MemberExpression':    
    case 'OptionalMemberExpression':
        if (parent.property === node) {
            return !!parent.computed;
        }
        
        return parent.object === node;
    
    case 'JSXMemberExpression':
        return parent.object === node;
    
    case 'VariableDeclarator':
        return parent.init === node;
    
    case 'ArrowFunctionExpression':
        return parent.body === node;
    
    case 'PrivateName':
        return false;
    
    case 'ClassMethod':    
    case 'ClassPrivateMethod':    
    case 'ObjectMethod':
        if (parent.key === node) {
            return !!parent.computed;
        }
        
        return false;
    
    case 'ObjectProperty':
        if (parent.key === node) {
            return !!parent.computed;
        }
        
        return grandparent?.type !== 'ObjectPattern';
    
    case 'ClassProperty':    
    case 'ClassAccessorProperty':
        if (parent.key === node) {
            return !!parent.computed;
        }
        
        return true;
    
    case 'ClassPrivateProperty':
        return parent.key !== node;
    
    case 'ClassDeclaration':    
    case 'ClassExpression':
        return parent.superClass === node;
    
    case 'AssignmentExpression':
        return parent.right === node;
    
    case 'AssignmentPattern':
        return parent.right === node;
    
    case 'LabeledStatement':
        return false;
    
    case 'CatchClause':
        return false;
    
    case 'RestElement':
        return false;
    
    case 'BreakStatement':    
    case 'ContinueStatement':
        return false;
    
    case 'FunctionDeclaration':    
    case 'FunctionExpression':
        return false;
    
    case 'ExportNamespaceSpecifier':    
    case 'ExportDefaultSpecifier':
        return false;
    
    case 'ExportSpecifier':
        if (grandparent?.source) {
            return false;
        }
        
        return parent.local === node;
    
    case 'ImportDefaultSpecifier':    
    case 'ImportNamespaceSpecifier':    
    case 'ImportSpecifier':
        return false;
    
    case 'ImportAttribute':
        return false;
    
    case 'JSXAttribute':
        return false;
    
    case 'ObjectPattern':    
    case 'ArrayPattern':
        return false;
    
    case 'MetaProperty':
        return false;
    
    case 'ObjectTypeProperty':
        return parent.key !== node;
    
    case 'TSEnumMember':
        return parent.id !== node;
    
    case 'TSPropertySignature':
        if (parent.key === node) {
            return !!parent.computed;
        }
        
        return true;
    }
    
    return true;
}

function isScope(node, parent) {
    if (isBlockStatement$7(node) && (isFunction$8(parent) || isCatchClause(parent))) {
        return false;
    }
    
    if (isPattern(node) && (isFunction$8(parent) || isCatchClause(parent))) {
        return true;
    }
    
    return isScopable(node);
}

function isSpecifierDefault(specifier) {
    return isImportDefaultSpecifier$1(specifier) || isIdentifier$h(specifier.imported || specifier.exported, {
        name: 'default',
    });
}

var RESERVED_WORDS_ES3_ONLY = /* @__PURE__ */new Set([
    'abstract',
    'boolean',
    'byte',
    'char',
    'double',
    'enum',
    'final',
    'float',
    'goto',
    'implements',
    'int',
    'interface',
    'long',
    'native',
    'package',
    'private',
    'protected',
    'public',
    'short',
    'static',
    'synchronized',
    'throws',
    'transient',
    'volatile',
]);

function isValidES3Identifier(name) {
    return isValidIdentifier(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
}

function isVar(node) {
    return isVariableDeclaration$5(node) && node.kind === 'var';
}

var react = {
    isReactComponent,
    isCompatTag,
    buildChildren,
};

// ../babel-babel/packages/babel-parser/lib/index.js
var Position = class {
    line;
    column;
    index;
    constructor(line, col, index2) {
        this.line = line;
        this.column = col;
        this.index = index2;
    }
};

var SourceLocation = class {
    start;
    end;
    filename;
    identifierName;
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
};

function createPositionWithColumnOffset(position, columnOffset) {
    const {
        line,
        column,
        index: index2,
    } = position;
    
    return new Position(line, column + columnOffset, index2 + columnOffset);
}

var code = 'BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED';

var ModuleErrors = {
    ImportMetaOutsideModule: {
        message: `import.meta may appear only with 'sourceType: "module"'`,
        code,
    },
    ImportOutsideModule: {
        message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
        code,
    },
};

var NodeDescriptions = {
    ArrayPattern: 'array destructuring pattern',
    AssignmentExpression: 'assignment expression',
    AssignmentPattern: 'assignment expression',
    ArrowFunctionExpression: 'arrow function expression',
    ConditionalExpression: 'conditional expression',
    CatchClause: 'catch clause',
    ForOfStatement: 'for-of statement',
    ForInStatement: 'for-in statement',
    ForStatement: 'for-loop',
    FormalParameters: 'function parameter list',
    Identifier: 'identifier',
    ImportSpecifier: 'import specifier',
    ImportDefaultSpecifier: 'import default specifier',
    ImportNamespaceSpecifier: 'import namespace specifier',
    ObjectPattern: 'object destructuring pattern',
    ParenthesizedExpression: 'parenthesized expression',
    RestElement: 'rest element',
    UpdateExpression: {
        true: 'prefix operation',
        false: 'postfix operation',
    },
    VariableDeclarator: 'variable declaration',
    YieldExpression: 'yield expression',
};

var toNodeDescription = (node) => node.type === 'UpdateExpression' ? NodeDescriptions.UpdateExpression[`${node.prefix}`] : NodeDescriptions[node.type];

var StandardErrors = {
    AccessorIsGenerator: ({kind}) => `A ${kind}ter cannot be a generator.`,
    ArgumentsInClass: '\'arguments\' is only allowed in functions and class methods.',
    AsyncFunctionInSingleStatementContext: 'Async functions can only be declared at the top level or inside a block.',
    AwaitBindingIdentifier: 'Can not use \'await\' as identifier inside an async function.',
    AwaitBindingIdentifierInStaticBlock: 'Can not use \'await\' as identifier inside a static block.',
    AwaitExpressionFormalParameter: '\'await\' is not allowed in async function parameters.',
    AwaitUsingNotInAsyncContext: '\'await using\' is only allowed within async functions and at the top levels of modules.',
    AwaitNotInAsyncContext: '\'await\' is only allowed within async functions and at the top levels of modules.',
    BadGetterArity: 'A \'get\' accessor must not have any formal parameters.',
    BadSetterArity: 'A \'set\' accessor must have exactly one formal parameter.',
    BadSetterRestParameter: 'A \'set\' accessor function argument must not be a rest parameter.',
    ConstructorClassField: 'Classes may not have a field named \'constructor\'.',
    ConstructorClassPrivateField: 'Classes may not have a private field named \'#constructor\'.',
    ConstructorIsAccessor: 'Class constructor may not be an accessor.',
    ConstructorIsAsync: 'Constructor can\'t be an async function.',
    ConstructorIsGenerator: 'Constructor can\'t be a generator.',
    DeclarationMissingInitializer: ({kind}) => `Missing initializer in ${kind} declaration.`,
    DecoratorArgumentsOutsideParentheses: 'Decorator arguments must be moved inside parentheses: use \'@(decorator(args))\' instead of \'@(decorator)(args)\'.',
    DecoratorsBeforeAfterExport: 'Decorators can be placed *either* before or after the \'export\' keyword, but not in both locations at the same time.',
    DecoratorConstructor: 'Decorators can\'t be used with a constructor. Did you mean \'@dec class { ... }\'?',
    DecoratorSemicolon: 'Decorators must not be followed by a semicolon.',
    DecoratorStaticBlock: 'Decorators can\'t be used with a static block.',
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: 'Deleting a private field is not allowed.',
    DestructureNamedImport: 'ES2015 named imports do not destructure. Use another statement for destructuring after the import.',
    DuplicateConstructor: 'Duplicate constructor in the same class.',
    DuplicateDefaultExport: 'Only one default export allowed per module.',
    DuplicateExport: ({exportName}) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
    DuplicateProto: 'Redefinition of __proto__ property.',
    DuplicateRegExpFlags: 'Duplicate regular expression flag.',
    ElementAfterRest: 'Rest element must be last element.',
    EscapedCharNotAnIdentifier: 'Invalid Unicode escape.',
    ExportBindingIsString: ({localName, exportName}) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
    ExportDefaultFromAsIdentifier: '\'from\' is not allowed as an identifier after \'export default\'.',
    ForInOfLoopInitializer: ({type}) => `'${type === 'ForInStatement' ? 'for-in' : 'for-of'}' loop variable declaration may not have an initializer.`,
    ForInUsing: 'For-in loop may not start with \'using\' declaration.',
    ForOfAsync: 'The left-hand side of a for-of loop may not be \'async\'.',
    ForOfLet: 'The left-hand side of a for-of loop may not start with \'let\'.',
    GeneratorInSingleStatementContext: 'Generators can only be declared at the top level or inside a block.',
    IllegalBreakContinue: ({type}) => `Unsyntactic ${type === 'BreakStatement' ? 'break' : 'continue'}.`,
    IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list.',
    IllegalReturn: '\'return\' outside of function.',
    ImportBindingIsString: ({importName}) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`,
    ImportCallArity: `\`import()\` requires exactly one or two arguments.`,
    ImportCallNotNewExpression: 'Cannot use new with import(...).',
    ImportCallSpreadArgument: '`...` is not allowed in `import()`.',
    IncompatibleRegExpUVFlags: 'The \'u\' and \'v\' regular expression flags cannot be enabled at the same time.',
    InvalidBigIntLiteral: 'Invalid BigIntLiteral.',
    InvalidCodePoint: 'Code point out of bounds.',
    InvalidCoverDiscardElement: '\'void\' must be followed by an expression when not used in a binding position.',
    InvalidCoverInitializedName: 'Invalid shorthand property initializer.',
    InvalidDigit: ({radix}) => `Expected number in radix ${radix}.`,
    InvalidEscapeSequence: 'Bad character escape sequence.',
    InvalidEscapeSequenceTemplate: 'Invalid escape sequence in template.',
    InvalidEscapedReservedWord: ({reservedWord}) => `Escape sequence in keyword ${reservedWord}.`,
    InvalidIdentifier: ({identifierName}) => `Invalid identifier ${identifierName}.`,
    InvalidLhs: ({ancestor}) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
    InvalidLhsBinding: ({ancestor}) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
    InvalidLhsOptionalChaining: ({ancestor}) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,
    InvalidNumber: 'Invalid number.',
    InvalidOrMissingExponent: 'Floating-point numbers require a valid exponent after the \'e\'.',
    InvalidOrUnexpectedToken: ({unexpected}) => `Unexpected character '${unexpected}'.`,
    InvalidParenthesizedAssignment: 'Invalid parenthesized assignment pattern.',
    InvalidPrivateFieldResolution: ({identifierName}) => `Private name #${identifierName} is not defined.`,
    InvalidPropertyBindingPattern: 'Binding member expression.',
    InvalidRestAssignmentPattern: 'Invalid rest operator\'s argument.',
    LabelRedeclaration: ({labelName}) => `Label '${labelName}' is already declared.`,
    LetInLexicalBinding: '\'let\' is disallowed as a lexically bound name.',
    LineTerminatorBeforeArrow: 'No line break is allowed before \'=>\'.',
    MalformedRegExpFlags: 'Invalid regular expression flag.',
    MissingClassName: 'A class name is required.',
    MissingEqInAssignment: 'Only \'=\' operator can be used for specifying default value.',
    MissingSemicolon: 'Missing semicolon.',
    MissingPlugin: ({missingPlugin}) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin
        .map((name) => JSON.stringify(name))
        .join(', ')}.`,
    MissingOneOfPlugins: ({missingPlugin}) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin
        .map((name) => JSON.stringify(name))
        .join(', ')}.`,
    MissingUnicodeEscape: 'Expecting Unicode escape sequence \\uXXXX.',
    MixingCoalesceWithLogical: 'Nullish coalescing operator(??) requires parens when mixing with logical operators.',
    ModuleAttributeInvalidValue: 'Only string literals are allowed as module attribute values.',
    ModuleAttributesWithDuplicateKeys: ({key}) => `Duplicate key "${key}" is not allowed in module attributes.`,
    ModuleExportNameHasLoneSurrogate: ({surrogateCharCode}) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
    ModuleExportUndefined: ({localName}) => `Export '${localName}' is not defined.`,
    MultipleDefaultsInSwitch: 'Multiple default clauses.',
    NewlineAfterThrow: 'Illegal newline after throw.',
    NoCatchOrFinally: 'Missing catch or finally clause.',
    NumberIdentifier: 'Identifier directly after number.',
    NumericSeparatorInEscapeSequence: 'Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.',
    ObsoleteAwaitStar: '\'await*\' has been removed from the async functions proposal. Use Promise.all() instead.',
    OptionalChainingNoNew: 'Constructors in/after an Optional Chain are not allowed.',
    OptionalChainingNoTemplate: 'Tagged Template Literals are not allowed in optionalChain.',
    OverrideOnConstructor: '\'override\' modifier cannot appear on a constructor declaration.',
    ParamDupe: 'Argument name clash.',
    PatternHasAccessor: 'Object pattern can\'t contain getter or setter.',
    PatternHasMethod: 'Object pattern can\'t contain methods.',
    PrivateInExpectedIn: ({identifierName}) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
    PrivateNameRedeclaration: ({identifierName}) => `Duplicate private name #${identifierName}.`,
    RestTrailingComma: 'Unexpected trailing comma after rest element.',
    SloppyFunction: 'In non-strict mode code, functions can only be declared at top level or inside a block.',
    SloppyFunctionAnnexB: 'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.',
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: 'Classes may not have static property named prototype.',
    SuperNotAllowed: '`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name (\'constructor\') or not extending another class?',
    SuperPrivateField: 'Private fields can\'t be accessed on super.',
    TrailingDecorator: 'Decorators must be attached to a class element.',
    UnexpectedArgumentPlaceholder: 'Unexpected argument placeholder.',
    UnexpectedDigitAfterHash: 'Unexpected digit after hash token.',
    UnexpectedImportExport: '\'import\' and \'export\' may only appear at the top level.',
    UnexpectedKeyword: ({keyword}) => `Unexpected keyword '${keyword}'.`,
    UnexpectedLeadingDecorator: 'Leading decorators must be attached to a class declaration.',
    UnexpectedLexicalDeclaration: 'Lexical declaration cannot appear in a single-statement context.',
    UnexpectedNewTarget: '`new.target` can only be used in functions or class properties.',
    UnexpectedNumericSeparator: 'A numeric separator is only allowed between two digits.',
    UnexpectedPrivateField: 'Unexpected private name.',
    UnexpectedReservedWord: ({reservedWord}) => `Unexpected reserved word '${reservedWord}'.`,
    UnexpectedSuper: '\'super\' is only allowed in object methods and classes.',
    UnexpectedToken: ({expected, unexpected}) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ''}${expected ? `, expected "${expected}"` : ''}`,
    UnexpectedTokenUnaryExponentiation: 'Illegal expression. Wrap left hand side or entire exponentiation in parentheses.',
    UnexpectedUsingDeclaration: 'Using declaration cannot appear in the top level when source type is `script` or in the bare case statement.',
    UnexpectedVoidPattern: 'Unexpected void binding.',
    UnsupportedBind: 'Binding should be performed on object property.',
    UnsupportedDecoratorExport: 'A decorated export must export a class declaration.',
    UnsupportedDefaultExport: 'Only expressions, functions or classes are allowed as the `default` export.',
    UnsupportedImport: '`import` can only be used in `import()` or `import.meta`.',
    UnsupportedMetaProperty: ({target, onlyValidPropertyName}) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
    UnsupportedParameterDecorator: 'Decorators cannot be used to decorate parameters.',
    UnsupportedPropertyDecorator: 'Decorators cannot be used to decorate object literal properties.',
    UnsupportedSuper: '\'super\' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).',
    UnterminatedComment: 'Unterminated comment.',
    UnterminatedRegExp: 'Unterminated regular expression.',
    UnterminatedString: 'Unterminated string constant.',
    UnterminatedTemplate: 'Unterminated template.',
    UsingDeclarationExport: 'Using declaration cannot be exported.',
    UsingDeclarationHasBindingPattern: 'Using declaration cannot have destructuring patterns.',
    VarRedeclaration: ({identifierName}) => `Identifier '${identifierName}' has already been declared.`,
    VoidPatternCatchClauseParam: 'A void binding can not be the catch clause parameter. Use `try { ... } catch { ... }` if you want to discard the caught error.',
    VoidPatternInitializer: 'A void binding may not have an initializer.',
    YieldBindingIdentifier: 'Can not use \'yield\' as identifier inside a generator.',
    YieldInParameter: 'Yield expression is not allowed in formal parameters.',
    YieldNotInGeneratorFunction: '\'yield\' is only allowed within generator functions.',
    ZeroDigitNumericSeparator: 'Numeric separator can not be used after leading 0.',
};

var StrictModeErrors = {
    StrictDelete: 'Deleting local variable in strict mode.',
    StrictEvalArguments: ({referenceName}) => `Assigning to '${referenceName}' in strict mode.`,
    StrictEvalArgumentsBinding: ({bindingName}) => `Binding '${bindingName}' in strict mode.`,
    StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block.',
    StrictNumericEscape: 'The only valid numeric escape in strict mode is \'\\0\'.',
    StrictOctalLiteral: 'Legacy octal literals are not allowed in strict mode.',
    StrictWith: '\'with\' in strict mode.',
};

var ParseExpressionErrors = {
    ParseExpressionEmptyInput: 'Unexpected parseExpression() input: The input is empty or contains only comments.',
    ParseExpressionExpectsEOF: ({unexpected}) => `Unexpected parseExpression() input: The input should contain exactly one expression, but the first expression is followed by the unexpected character \`${String.fromCodePoint(unexpected)}\`.`,
};

var UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */new Set([
    'ArrowFunctionExpression',
    'AssignmentExpression',
    'ConditionalExpression',
    'YieldExpression',
]);

var PipelineOperatorErrors = {
    PipeBodyIsTighter: 'Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.',
    PipeTopicRequiresHackPipes: 'Topic references are only supported when using the `"proposal": "hack"` version of the pipeline proposal.',
    PipeTopicUnbound: 'Topic reference is unbound; it must be inside a pipe body.',
    PipeTopicUnconfiguredToken: ({token}) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
    PipeTopicUnused: 'Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.',
    PipeUnparenthesizedBody: ({type}) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
        type,
    })}; please wrap it in parentheses.`,
};

function defineHidden(obj, key, value) {
    Object.defineProperty(obj, key, {
        enumerable: false,
        configurable: true,
        value,
    });
}

function toParseErrorConstructor({toMessage, code: code2, reasonCode, syntaxPlugin}) {
    const hasMissingPlugin = reasonCode === 'MissingPlugin' || reasonCode === 'MissingOneOfPlugins';
    
    return function constructor(loc, details) {
        const error = new SyntaxError();
        
        error.code = code2;
        error.reasonCode = reasonCode;
        error.loc = loc;
        error.pos = loc.index;
        error.syntaxPlugin = syntaxPlugin;
        
        if (hasMissingPlugin) {
            error.missingPlugin = details.missingPlugin;
        }
        
        defineHidden(error, 'clone', function clone2(overrides = {}) {
            const {
                line,
                column,
                index: index2,
            } = overrides.loc ?? loc;
            
            return constructor(new Position(line, column, index2), {
                ...details,
                ...overrides.details,
            });
        });
        defineHidden(error, 'details', details);
        Object.defineProperty(error, 'message', {
            configurable: true,
            get() {
                const message = `${toMessage(details)} (${loc.line}:${loc.column})`;
                
                this.message = message;
                return message;
            },
            set(value) {
                Object.defineProperty(this, 'message', {
                    value,
                    writable: true,
                });
            },
        });
        return error;
    };
}

function ParseErrorEnum(argument, syntaxPlugin) {
    if (Array.isArray(argument)) {
        return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
    }
    
    const ParseErrorConstructors = {};
    
    for (const reasonCode of Object.keys(argument)) {
        const template = argument[reasonCode];
        const {message, ...rest} = typeof template === 'string' ? {
            message: () => template,
        } : typeof template === 'function' ? {
            message: template,
        } : template;
        
        const toMessage = typeof message === 'string' ? () => message : message;
        
        ParseErrorConstructors[reasonCode] = toParseErrorConstructor({
            code: 'BABEL_PARSER_SYNTAX_ERROR',
            reasonCode,
            toMessage,
            ...syntaxPlugin ? {
                syntaxPlugin,
            } : {},
            ...rest,
        });
    }
    
    return ParseErrorConstructors;
}

var Errors = {
    ...ParseErrorEnum(ModuleErrors),
    ...ParseErrorEnum(StandardErrors),
    ...ParseErrorEnum(StrictModeErrors),
    ...ParseErrorEnum(ParseExpressionErrors),
    ...ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors),
};

function createDefaultOptions() {
    return {
        sourceType: 'script',
        sourceFilename: void 0,
        startIndex: 0,
        startColumn: 0,
        startLine: 1,
        allowAwaitOutsideFunction: false,
        allowReturnOutsideFunction: false,
        allowNewTargetOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowSuperOutsideMethod: false,
        allowUndeclaredExports: false,
        allowYieldOutsideFunction: false,
        plugins: [],
        strictMode: void 0,
        ranges: false,
        tokens: false,
        createImportExpressions: true,
        createParenthesizedExpressions: false,
        errorRecovery: false,
        attachComment: true,
        annexB: true,
    };
}

function getOptions(opts) {
    const options = createDefaultOptions();
    
    if (opts == null) {
        return options;
    }
    
    if (opts.annexB != null && opts.annexB !== false) {
        throw new Error('The `annexB` option can only be set to `false`.');
    }
    
    for (const key of Object.keys(options)) {
        if (opts[key] != null)
            options[key] = opts[key];
    }
    
    if (options.startLine === 1) {
        if (opts.startIndex == null && options.startColumn > 0) {
            options.startIndex = options.startColumn;
        } else if (opts.startColumn == null && options.startIndex > 0) {
            options.startColumn = options.startIndex;
        }
    } else if (opts.startColumn == null || opts.startIndex == null) {
        throw new Error('With a `startLine > 1` you must also specify `startIndex` and `startColumn`.');
    }
    
    if (options.sourceType === 'commonjs') {
        if (opts.allowAwaitOutsideFunction != null) {
            throw new Error('The `allowAwaitOutsideFunction` option cannot be used with `sourceType: \'commonjs\'`.');
        }
        
        if (opts.allowReturnOutsideFunction != null) {
            throw new Error('`sourceType: \'commonjs\'` implies `allowReturnOutsideFunction: true`, please remove the `allowReturnOutsideFunction` option or use `sourceType: \'script\'`.');
        }
        
        if (opts.allowNewTargetOutsideFunction != null) {
            throw new Error('`sourceType: \'commonjs\'` implies `allowNewTargetOutsideFunction: true`, please remove the `allowNewTargetOutsideFunction` option or use `sourceType: \'script\'`.');
        }
    }
    
    return options;
}

var {defineProperty} = Object;

var toUnenumerable = (object, key) => {
    if (object) {
        defineProperty(object, key, {
            enumerable: false,
            value: object[key],
        });
    }
};

function toESTreeLocation(node) {
    toUnenumerable(node.loc.start, 'index');
    toUnenumerable(node.loc.end, 'index');
    return node;
}

var estree = (superClass) => class ESTreeParserMixin extends superClass {
    parse() {
        const file2 = toESTreeLocation(super.parse());
        
        if (this.optionFlags & 256) {
            file2.tokens = file2.tokens.map(toESTreeLocation);
        }
        
        return file2;
    }
    
    parseRegExpLiteral({pattern, flags}) {
        let regex = null;
        
        try {
            regex = new RegExp(pattern, flags);
        } catch {}


                const node = this.estreeParseLiteral(regex);
        
        node.regex = {
            pattern,
            flags,
        };
        return node;
    }
    
    parseBigIntLiteral(value) {
        let bigInt;
        
        try {
            bigInt = BigInt(value);
        } catch {
            bigInt = null;
        }


                const node = this.estreeParseLiteral(bigInt);
        
        node.bigint = String(node.value || value);
        return node;
    }
    
    estreeParseLiteral(value) {
        return this.parseLiteral(value, 'Literal');
    }
    
    parseStringLiteral(value) {
        return this.estreeParseLiteral(value);
    }
    
    parseNumericLiteral(value) {
        return this.estreeParseLiteral(value);
    }
    
    parseNullLiteral() {
        return this.estreeParseLiteral(null);
    }
    
    parseBooleanLiteral(value) {
        return this.estreeParseLiteral(value);
    }
    
    estreeParseChainExpression(node, endLoc) {
        const chain2 = this.startNodeAtNode(node);
        
        chain2.expression = node;
        return this.finishNodeAt(chain2, 'ChainExpression', endLoc);
    }
    
    directiveToStmt(directive2) {
        const expression2 = directive2.value;
        delete directive2.value;
        this.castNodeTo(expression2, 'Literal');
        expression2.raw = expression2.extra.raw;
        expression2.value = expression2.extra.expressionValue;
        const stmt = this.castNodeTo(directive2, 'ExpressionStatement');
        
        stmt.expression = expression2;
        stmt.directive = expression2.extra.rawValue;
        delete expression2.extra;
        return stmt;
    }
    
    fillOptionalPropertiesForTSESLint() {}
    
    cloneEstreeStringLiteral(node) {
        const {
            start,
            end,
            loc,
            range,
            raw,
            value,
        } = node;
        
        const cloned = Object.create(node.constructor.prototype);
        
        cloned.type = 'Literal';
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range;
        cloned.raw = raw;
        cloned.value = value;
        return cloned;
    }
    
    initFunction(node, isAsync) {
        super.initFunction(node, isAsync);
        node.expression = false;
    }
    
    checkDeclaration(node) {
        if (node != null && this.isObjectProperty(node)) {
            this.checkDeclaration(node.value);
        } else {
            super.checkDeclaration(node);
        }
    }
    
    getObjectOrClassMethodParams(method) {
        return method.value.params;
    }
    
    isValidDirective(stmt) {
        return stmt.type === 'ExpressionStatement'
            && stmt.expression.type === 'Literal'
            && typeof stmt.expression.value === 'string'
            && !stmt.expression.extra?.parenthesized;
    }
    
    parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
        const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));
        
        node.body = directiveStatements.concat(node.body);
        delete node.directives;
    }
    
    parsePrivateName() {
        const node = super.parsePrivateName();
        return this.convertPrivateNameToPrivateIdentifier(node);
    }
    
    convertPrivateNameToPrivateIdentifier(node) {
        const name = super.getPrivateNameSV(node);
        delete node.id;
        node.name = name;
        return this.castNodeTo(node, 'PrivateIdentifier');
    }
    
    isPrivateName(node) {
        return node.type === 'PrivateIdentifier';
    }
    
    getPrivateNameSV(node) {
        return node.name;
    }
    
    parseLiteral(value, type) {
        const node = super.parseLiteral(value, type);
        
        node.raw = node.extra.raw;
        delete node.extra;
        return node;
    }
    
    parseFunctionBody(node, allowExpression, isMethod3 = false) {
        super.parseFunctionBody(node, allowExpression, isMethod3);
        node.expression = node.body.type !== 'BlockStatement';
    }
    
    parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        let funcNode = this.startNode();
        
        funcNode.kind = node.kind;
        funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        delete funcNode.kind;
        const {typeParameters} = node;
        
        if (typeParameters) {
            delete node.typeParameters;
            funcNode.typeParameters = typeParameters;
            this.resetStartLocationFromNode(funcNode, typeParameters);
        }
        
        const valueNode = this.castNodeTo(funcNode, this.hasPlugin('typescript') && !funcNode.body ? 'TSEmptyBodyFunctionExpression' : 'FunctionExpression');
        
        node.value = valueNode;
        
        if (type === 'ClassPrivateMethod') {
            node.computed = false;
        }
        
        if (this.hasPlugin('typescript')) {
            if (node.abstract) {
                delete node.abstract;
                return this.finishNode(node, 'TSAbstractMethodDefinition');
            }
        }
        
        if (type === 'ObjectMethod') {
            if (node.kind === 'method') {
                node.kind = 'init';
            }
            
            node.shorthand = false;
            return this.finishNode(node, 'Property');
        } else {
            return this.finishNode(node, 'MethodDefinition');
        }
    }
    
    nameIsConstructor(key) {
        if (key.type === 'Literal')
            return key.value === 'constructor';
        
        return super.nameIsConstructor(key);
    }
    
    parseClassProperty(...args) {
        const propertyNode = super.parseClassProperty(...args);
        
        if (propertyNode.abstract && this.hasPlugin('typescript')) {
            delete propertyNode.abstract;
            this.castNodeTo(propertyNode, 'TSAbstractPropertyDefinition');
        } else {
            this.castNodeTo(propertyNode, 'PropertyDefinition');
        }
        
        return propertyNode;
    }
    
    parseClassPrivateProperty(...args) {
        const propertyNode = super.parseClassPrivateProperty(...args);
        
        if (propertyNode.abstract && this.hasPlugin('typescript')) {
            this.castNodeTo(propertyNode, 'TSAbstractPropertyDefinition');
        } else {
            this.castNodeTo(propertyNode, 'PropertyDefinition');
        }
        
        propertyNode.computed = false;
        return propertyNode;
    }
    
    parseClassAccessorProperty(node) {
        const accessorPropertyNode = super.parseClassAccessorProperty(node);
        
        if (accessorPropertyNode.abstract && this.hasPlugin('typescript')) {
            delete accessorPropertyNode.abstract;
            this.castNodeTo(accessorPropertyNode, 'TSAbstractAccessorProperty');
        } else {
            this.castNodeTo(accessorPropertyNode, 'AccessorProperty');
        }
        
        return accessorPropertyNode;
    }
    
    parseObjectProperty(prop, startLoc, isPattern3, refExpressionErrors) {
        const node = super.parseObjectProperty(prop, startLoc, isPattern3, refExpressionErrors);
        
        if (node) {
            node.kind = 'init';
            this.castNodeTo(node, 'Property');
        }
        
        return node;
    }
    
    finishObjectProperty(node) {
        node.kind = 'init';
        return this.finishNode(node, 'Property');
    }
    
    isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding) {
        return type === 'Property' ? 'value' : super.isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding);
    }
    
    isAssignable(node, isBinding3) {
        if (node != null && this.isObjectProperty(node)) {
            return this.isAssignable(node.value, isBinding3);
        }
        
        return super.isAssignable(node, isBinding3);
    }
    
    toAssignable(node, isLHS = false) {
        if (node != null && this.isObjectProperty(node)) {
            const {key, value} = node;
            
            if (this.isPrivateName(key)) {
                this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
            }
            
            this.toAssignable(value, isLHS);
        } else {
            super.toAssignable(node, isLHS);
        }
    }
    
    toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === 'Property' && (prop.kind === 'get' || prop.kind === 'set')) {
            this.raise(Errors.PatternHasAccessor, prop.key);
        } else if (prop.type === 'Property' && prop.method) {
            this.raise(Errors.PatternHasMethod, prop.key);
        } else {
            super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
        }
    }
    
    finishCallExpression(unfinished, optional) {
        const node = super.finishCallExpression(unfinished, optional);
        
        if (node.callee.type === 'Import') {
            this.castNodeTo(node, 'ImportExpression');
            node.source = node.arguments[0];
            node.options = node.arguments[1] ?? null;
            delete node.arguments;
            delete node.callee;
        } else if (node.type === 'OptionalCallExpression') {
            this.castNodeTo(node, 'CallExpression');
        } else {
            node.optional = false;
        }
        
        return node;
    }
    
    toReferencedArguments(node) {
        if (node.type === 'ImportExpression') {
            return;
        }
        
        super.toReferencedArguments(node);
    }
    
    parseExport(unfinished, decorators) {
        const exportStartLoc = this.state.lastTokStartLoc;
        const node = super.parseExport(unfinished, decorators);
        
        switch(node.type) {
        case 'ExportAllDeclaration':
            node.exported = null;
            break;
        
        case 'ExportNamedDeclaration':
            if (node.specifiers.length === 1 && node.specifiers[0].type === 'ExportNamespaceSpecifier') {
                this.castNodeTo(node, 'ExportAllDeclaration');
                node.exported = node.specifiers[0].exported;
                delete node.specifiers;
            }
        
        case 'ExportDefaultDeclaration': {
            const {declaration} = node;
            
            if (declaration?.type === 'ClassDeclaration' && declaration.decorators?.length > 0 && declaration.start === node.start) {
                this.resetStartLocation(node, exportStartLoc);
            }
        }
        break;
        }
        
        
        return node;
    }
    
    stopParseSubscript(base, state) {
        const node = super.stopParseSubscript(base, state);
        
        if (state.optionalChainMember) {
            return this.estreeParseChainExpression(node, base.loc.end);
        }
        
        return node;
    }
    
    parseMember(base, startLoc, state, computed, optional) {
        const node = super.parseMember(base, startLoc, state, computed, optional);
        
        if (node.type === 'OptionalMemberExpression') {
            this.castNodeTo(node, 'MemberExpression');
        } else {
            node.optional = false;
        }
        
        return node;
    }
    
    isOptionalMemberExpression(node) {
        if (node.type === 'ChainExpression') {
            return node.expression.type === 'MemberExpression';
        }
        
        return super.isOptionalMemberExpression(node);
    }
    
    hasPropertyAsPrivateName(node) {
        if (node.type === 'ChainExpression') {
            node = node.expression;
        }
        
        return super.hasPropertyAsPrivateName(node);
    }
    
    isObjectProperty(node) {
        return node.type === 'Property' && node.kind === 'init' && !node.method;
    }
    
    isObjectMethod(node) {
        return node.type === 'Property'
            && (node.method
            || node.kind === 'get'
            || node.kind === 'set');
    }
    
    castNodeTo(node, type) {
        const result = super.castNodeTo(node, type);
        this.fillOptionalPropertiesForTSESLint(result);
        return result;
    }
    
    cloneIdentifier(node) {
        const cloned = super.cloneIdentifier(node);
        this.fillOptionalPropertiesForTSESLint(cloned);
        return cloned;
    }
    
    cloneStringLiteral(node) {
        if (node.type === 'Literal') {
            return this.cloneEstreeStringLiteral(node);
        }
        
        return super.cloneStringLiteral(node);
    }
    
    finishNodeAt(node, type, endLoc) {
        return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
    }
    
    finishNode(node, type) {
        const result = super.finishNode(node, type);
        this.fillOptionalPropertiesForTSESLint(result);
        return result;
    }
    
    resetStartLocation(node, startLoc) {
        super.resetStartLocation(node, startLoc);
        toESTreeLocation(node);
    }
    
    resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
        super.resetEndLocation(node, endLoc);
        toESTreeLocation(node);
    }
};

var beforeExpr = true;
var startsExpr = true;
var isLoop2 = true;
var isAssign = true;
var prefix$1 = true;
var postfix = true;

var ExportedTokenType = class {
    label;
    keyword;
    beforeExpr;
    startsExpr;
    rightAssociative;
    isLoop;
    isAssign;
    prefix;
    postfix;
    binop;
    constructor(label, conf = {}) {
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.rightAssociative = !!conf.rightAssociative;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop != null ? conf.binop : null;
    }
};

var keywords$1$1 = /* @__PURE__ */new Map();

function createKeyword(name, options = {}) {
    options.keyword = name;
    const token = createToken(name, options);
    keywords$1$1.set(name, token);
    return token;
}

function createBinop(name, binop) {
    return createToken(name, {
        beforeExpr,
        binop,
    });
}

var tokenTypeCounter = -1;
var tokenTypes = [];
var tokenLabels = [];
var tokenBinops = [];
var tokenBeforeExprs = [];
var tokenStartsExprs = [];
var tokenPrefixes = [];

function createToken(name, options = {}) {
    ++tokenTypeCounter;
    tokenLabels.push(name);
    tokenBinops.push(options.binop ?? -1);
    tokenBeforeExprs.push(options.beforeExpr ?? false);
    tokenStartsExprs.push(options.startsExpr ?? false);
    tokenPrefixes.push(options.prefix ?? false);
    tokenTypes.push(new ExportedTokenType(name, options));
    return tokenTypeCounter;
}

function createKeywordLike(name, options = {}) {
    ++tokenTypeCounter;
    keywords$1$1.set(name, tokenTypeCounter);
    tokenLabels.push(name);
    tokenBinops.push(options.binop ?? -1);
    tokenBeforeExprs.push(options.beforeExpr ?? false);
    tokenStartsExprs.push(options.startsExpr ?? false);
    tokenPrefixes.push(options.prefix ?? false);
    tokenTypes.push(new ExportedTokenType('name', options));
    return tokenTypeCounter;
}

var tt = {
    bracketL: createToken('[', {
        beforeExpr,
        startsExpr,
    }),
    bracketR: createToken(']'),
    braceL: createToken('{', {
        beforeExpr,
        startsExpr,
    }),
    braceBarL: createToken('{|', {
        beforeExpr,
        startsExpr,
    }),
    braceR: createToken('}'),
    braceBarR: createToken('|}'),
    parenL: createToken('(', {
        beforeExpr,
        startsExpr,
    }),
    parenR: createToken(')'),
    comma: createToken(',', {
        beforeExpr,
    }),
    semi: createToken(';', {
        beforeExpr,
    }),
    colon: createToken(':', {
        beforeExpr,
    }),
    doubleColon: createToken('::', {
        beforeExpr,
    }),
    dot: createToken('.'),
    question: createToken('?', {
        beforeExpr,
    }),
    questionDot: createToken('?.'),
    arrow: createToken('=>', {
        beforeExpr,
    }),
    template: createToken('template'),
    ellipsis: createToken('...', {
        beforeExpr,
    }),
    backQuote: createToken('`', {
        startsExpr,
    }),
    dollarBraceL: createToken('${', {
        beforeExpr,
        startsExpr,
    }),
    templateTail: createToken('...`', {
        startsExpr,
    }),
    templateNonTail: createToken('...${', {
        beforeExpr,
        startsExpr,
    }),
    at: createToken('@'),
    hash: createToken('#', {
        startsExpr,
    }),
    interpreterDirective: createToken('#!...'),
    eq: createToken('=', {
        beforeExpr,
        isAssign,
    }),
    assign: createToken('_=', {
        beforeExpr,
        isAssign,
    }),
    slashAssign: createToken('_=', {
        beforeExpr,
        isAssign,
    }),
    xorAssign: createToken('_=', {
        beforeExpr,
        isAssign,
    }),
    moduloAssign: createToken('_=', {
        beforeExpr,
        isAssign,
    }),
    incDec: createToken('++/--', {
        prefix: prefix$1,
        postfix,
        startsExpr,
    }),
    bang: createToken('!', {
        beforeExpr,
        prefix: prefix$1,
        startsExpr,
    }),
    tilde: createToken('~', {
        beforeExpr,
        prefix: prefix$1,
        startsExpr,
    }),
    doubleCaret: createToken('^^', {
        startsExpr,
    }),
    doubleAt: createToken('@@', {
        startsExpr,
    }),
    pipeline: createBinop('|>', 0),
    nullishCoalescing: createBinop('??', 1),
    logicalOR: createBinop('||', 1),
    logicalAND: createBinop('&&', 2),
    bitwiseOR: createBinop('|', 3),
    bitwiseXOR: createBinop('^', 4),
    bitwiseAND: createBinop('&', 5),
    equality: createBinop('==/!=/===/!==', 6),
    lt: createBinop('</>/<=/>=', 7),
    gt: createBinop('</>/<=/>=', 7),
    relational: createBinop('</>/<=/>=', 7),
    bitShift: createBinop('<</>>/>>>', 8),
    bitShiftL: createBinop('<</>>/>>>', 8),
    bitShiftR: createBinop('<</>>/>>>', 8),
    plusMin: createToken('+/-', {
        beforeExpr,
        binop: 9,
        prefix: prefix$1,
        startsExpr,
    }),
    modulo: createToken('%', {
        binop: 10,
        startsExpr,
    }),
    star: createToken('*', {
        binop: 10,
    }),
    slash: createBinop('/', 10),
    exponent: createToken('**', {
        beforeExpr,
        binop: 11,
        rightAssociative: true,
    }),
    _in: createKeyword('in', {
        beforeExpr,
        binop: 7,
    }),
    _instanceof: createKeyword('instanceof', {
        beforeExpr,
        binop: 7,
    }),
    _break: createKeyword('break'),
    _case: createKeyword('case', {
        beforeExpr,
    }),
    _catch: createKeyword('catch'),
    _continue: createKeyword('continue'),
    _debugger: createKeyword('debugger'),
    _default: createKeyword('default', {
        beforeExpr,
    }),
    _else: createKeyword('else', {
        beforeExpr,
    }),
    _finally: createKeyword('finally'),
    _function: createKeyword('function', {
        startsExpr,
    }),
    _if: createKeyword('if'),
    _return: createKeyword('return', {
        beforeExpr,
    }),
    _switch: createKeyword('switch'),
    _throw: createKeyword('throw', {
        beforeExpr,
        prefix: prefix$1,
        startsExpr,
    }),
    _try: createKeyword('try'),
    _var: createKeyword('var'),
    _const: createKeyword('const'),
    _with: createKeyword('with'),
    _new: createKeyword('new', {
        beforeExpr,
        startsExpr,
    }),
    _this: createKeyword('this', {
        startsExpr,
    }),
    _super: createKeyword('super', {
        startsExpr,
    }),
    _class: createKeyword('class', {
        startsExpr,
    }),
    _extends: createKeyword('extends', {
        beforeExpr,
    }),
    _export: createKeyword('export'),
    _import: createKeyword('import', {
        startsExpr,
    }),
    _null: createKeyword('null', {
        startsExpr,
    }),
    _true: createKeyword('true', {
        startsExpr,
    }),
    _false: createKeyword('false', {
        startsExpr,
    }),
    _typeof: createKeyword('typeof', {
        beforeExpr,
        prefix: prefix$1,
        startsExpr,
    }),
    _void: createKeyword('void', {
        beforeExpr,
        prefix: prefix$1,
        startsExpr,
    }),
    _delete: createKeyword('delete', {
        beforeExpr,
        prefix: prefix$1,
        startsExpr,
    }),
    _do: createKeyword('do', {
        isLoop: isLoop2,
        beforeExpr,
    }),
    _for: createKeyword('for', {
        isLoop: isLoop2,
    }),
    _while: createKeyword('while', {
        isLoop: isLoop2,
    }),
    _as: createKeywordLike('as', {
        startsExpr,
    }),
    _assert: createKeywordLike('assert', {
        startsExpr,
    }),
    _async: createKeywordLike('async', {
        startsExpr,
    }),
    _await: createKeywordLike('await', {
        startsExpr,
    }),
    _defer: createKeywordLike('defer', {
        startsExpr,
    }),
    _from: createKeywordLike('from', {
        startsExpr,
    }),
    _get: createKeywordLike('get', {
        startsExpr,
    }),
    _let: createKeywordLike('let', {
        startsExpr,
    }),
    _meta: createKeywordLike('meta', {
        startsExpr,
    }),
    _of: createKeywordLike('of', {
        startsExpr,
    }),
    _sent: createKeywordLike('sent', {
        startsExpr,
    }),
    _set: createKeywordLike('set', {
        startsExpr,
    }),
    _source: createKeywordLike('source', {
        startsExpr,
    }),
    _static: createKeywordLike('static', {
        startsExpr,
    }),
    _using: createKeywordLike('using', {
        startsExpr,
    }),
    _yield: createKeywordLike('yield', {
        startsExpr,
    }),
    _asserts: createKeywordLike('asserts', {
        startsExpr,
    }),
    _checks: createKeywordLike('checks', {
        startsExpr,
    }),
    _exports: createKeywordLike('exports', {
        startsExpr,
    }),
    _global: createKeywordLike('global', {
        startsExpr,
    }),
    _implements: createKeywordLike('implements', {
        startsExpr,
    }),
    _intrinsic: createKeywordLike('intrinsic', {
        startsExpr,
    }),
    _infer: createKeywordLike('infer', {
        startsExpr,
    }),
    _is: createKeywordLike('is', {
        startsExpr,
    }),
    _mixins: createKeywordLike('mixins', {
        startsExpr,
    }),
    _proto: createKeywordLike('proto', {
        startsExpr,
    }),
    _require: createKeywordLike('require', {
        startsExpr,
    }),
    _satisfies: createKeywordLike('satisfies', {
        startsExpr,
    }),
    _keyof: createKeywordLike('keyof', {
        startsExpr,
    }),
    _readonly: createKeywordLike('readonly', {
        startsExpr,
    }),
    _unique: createKeywordLike('unique', {
        startsExpr,
    }),
    _abstract: createKeywordLike('abstract', {
        startsExpr,
    }),
    _declare: createKeywordLike('declare', {
        startsExpr,
    }),
    _enum: createKeywordLike('enum', {
        startsExpr,
    }),
    _module: createKeywordLike('module', {
        startsExpr,
    }),
    _namespace: createKeywordLike('namespace', {
        startsExpr,
    }),
    _interface: createKeywordLike('interface', {
        startsExpr,
    }),
    _type: createKeywordLike('type', {
        startsExpr,
    }),
    _opaque: createKeywordLike('opaque', {
        startsExpr,
    }),
    name: createToken('name', {
        startsExpr,
    }),
    placeholder: createToken('%%', {
        startsExpr,
    }),
    string: createToken('string', {
        startsExpr,
    }),
    num: createToken('num', {
        startsExpr,
    }),
    bigint: createToken('bigint', {
        startsExpr,
    }),
    regexp: createToken('regexp', {
        startsExpr,
    }),
    privateName: createToken('#name', {
        startsExpr,
    }),
    eof: createToken('eof'),
    jsxName: createToken('jsxName'),
    jsxText: createToken('jsxText', {
        beforeExpr,
    }),
    jsxTagStart: createToken('jsxTagStart', {
        startsExpr,
    }),
    jsxTagEnd: createToken('jsxTagEnd'),
};

function tokenIsIdentifier(token) {
    return token >= 89 && token <= 129;
}

function tokenKeywordOrIdentifierIsKeyword(token) {
    return token <= 88;
}

function tokenIsKeywordOrIdentifier(token) {
    return token >= 54 && token <= 129;
}

function tokenIsLiteralPropertyName(token) {
    return token >= 54 && token <= 132;
}

function tokenComesBeforeExpression(token) {
    return tokenBeforeExprs[token];
}

function tokenCanStartExpression(token) {
    return tokenStartsExprs[token];
}

function tokenIsAssignment(token) {
    return token >= 25 && token <= 29;
}

function tokenIsLoop(token) {
    return token >= 86 && token <= 88;
}

function tokenIsKeyword(token) {
    return token >= 54 && token <= 88;
}

function tokenIsOperator(token) {
    return token >= 35 && token <= 55;
}

function tokenIsPostfix(token) {
    return token === 30;
}

function tokenIsPrefix(token) {
    return tokenPrefixes[token];
}

function tokenIsTSTypeOperator(token) {
    return token >= 117 && token <= 119;
}

function tokenIsTSDeclarationStart(token) {
    return token >= 120 && token <= 126;
}

function tokenLabelName(token) {
    return tokenLabels[token];
}

function tokenOperatorPrecedence(token) {
    return tokenBinops[token];
}

function tokenIsRightAssociative(token) {
    return token === 53;
}

function tokenIsTemplate(token) {
    return token >= 20 && token <= 21;
}

function getExportedToken(token) {
    return tokenTypes[token];
}

var TokContext = class {
    constructor(token, preserveSpace) {
        this.token = token;
        this.preserveSpace = !!preserveSpace;
    }
    
    token;
    preserveSpace;
};

var types$2 = {
    brace: new TokContext('{'),
    j_oTag: new TokContext('<tag'),
    j_cTag: new TokContext('</tag'),
    j_expr: new TokContext('<tag>...</tag>', true),
};

var nonASCIIidentifierStartChars2 = '\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088F\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5C\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDC-\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7DC\uA7F1-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC';
var nonASCIIidentifierChars2 = '\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ADD\u1AE0-\u1AEB\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65';
var nonASCIIidentifierStart2 = new RegExp('[' + nonASCIIidentifierStartChars2 + ']');
var nonASCIIidentifier2 = new RegExp('[' + nonASCIIidentifierStartChars2 + nonASCIIidentifierChars2 + ']');

nonASCIIidentifierStartChars2 =
nonASCIIidentifierChars2 = null;
var astralIdentifierStartCodes2 = [
    0,
    11,
    2,
    25,
    2,
    18,
    2,
    1,
    2,
    14,
    3,
    13,
    35,
    122,
    70,
    52,
    268,
    28,
    4,
    48,
    48,
    31,
    14,
    29,
    6,
    37,
    11,
    29,
    3,
    35,
    5,
    7,
    2,
    4,
    43,
    157,
    19,
    35,
    5,
    35,
    5,
    39,
    9,
    51,
    13,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    2,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    4,
    51,
    13,
    310,
    10,
    21,
    11,
    7,
    25,
    5,
    2,
    41,
    2,
    8,
    70,
    5,
    3,
    0,
    2,
    43,
    2,
    1,
    4,
    0,
    3,
    22,
    11,
    22,
    10,
    30,
    66,
    18,
    2,
    1,
    11,
    21,
    11,
    25,
    7,
    25,
    39,
    55,
    7,
    1,
    65,
    0,
    16,
    3,
    2,
    2,
    2,
    28,
    43,
    28,
    4,
    28,
    36,
    7,
    2,
    27,
    28,
    53,
    11,
    21,
    11,
    18,
    14,
    17,
    111,
    72,
    56,
    50,
    14,
    50,
    14,
    35,
    39,
    27,
    10,
    22,
    251,
    41,
    7,
    1,
    17,
    5,
    57,
    28,
    11,
    0,
    9,
    21,
    43,
    17,
    47,
    20,
    28,
    22,
    13,
    52,
    58,
    1,
    3,
    0,
    14,
    44,
    33,
    24,
    27,
    35,
    30,
    0,
    3,
    0,
    9,
    34,
    4,
    0,
    13,
    47,
    15,
    3,
    22,
    0,
    2,
    0,
    36,
    17,
    2,
    24,
    20,
    1,
    64,
    6,
    2,
    0,
    2,
    3,
    2,
    14,
    2,
    9,
    8,
    46,
    39,
    7,
    3,
    1,
    3,
    21,
    2,
    6,
    2,
    1,
    2,
    4,
    4,
    0,
    19,
    0,
    13,
    4,
    31,
    9,
    2,
    0,
    3,
    0,
    2,
    37,
    2,
    0,
    26,
    0,
    2,
    0,
    45,
    52,
    19,
    3,
    21,
    2,
    31,
    47,
    21,
    1,
    2,
    0,
    185,
    46,
    42,
    3,
    37,
    47,
    21,
    0,
    60,
    42,
    14,
    0,
    72,
    26,
    38,
    6,
    186,
    43,
    117,
    63,
    32,
    7,
    3,
    0,
    3,
    7,
    2,
    1,
    2,
    23,
    16,
    0,
    2,
    0,
    95,
    7,
    3,
    38,
    17,
    0,
    2,
    0,
    29,
    0,
    11,
    39,
    8,
    0,
    22,
    0,
    12,
    45,
    20,
    0,
    19,
    72,
    200,
    32,
    32,
    8,
    2,
    36,
    18,
    0,
    50,
    29,
    113,
    6,
    2,
    1,
    2,
    37,
    22,
    0,
    26,
    5,
    2,
    1,
    2,
    31,
    15,
    0,
    24,
    43,
    261,
    18,
    16,
    0,
    2,
    12,
    2,
    33,
    125,
    0,
    80,
    921,
    103,
    110,
    18,
    195,
    2637,
    96,
    16,
    1071,
    18,
    5,
    26,
    3994,
    6,
    582,
    6842,
    29,
    1763,
    568,
    8,
    30,
    18,
    78,
    18,
    29,
    19,
    47,
    17,
    3,
    32,
    20,
    6,
    18,
    433,
    44,
    212,
    63,
    33,
    24,
    3,
    24,
    45,
    74,
    6,
    0,
    67,
    12,
    65,
    1,
    2,
    0,
    15,
    4,
    10,
    7381,
    42,
    31,
    98,
    114,
    8702,
    3,
    2,
    6,
    2,
    1,
    2,
    290,
    16,
    0,
    30,
    2,
    3,
    0,
    15,
    3,
    9,
    395,
    2309,
    106,
    6,
    12,
    4,
    8,
    8,
    9,
    5991,
    84,
    2,
    70,
    2,
    1,
    3,
    0,
    3,
    1,
    3,
    3,
    2,
    11,
    2,
    0,
    2,
    6,
    2,
    64,
    2,
    3,
    3,
    7,
    2,
    6,
    2,
    27,
    2,
    3,
    2,
    4,
    2,
    0,
    4,
    6,
    2,
    339,
    3,
    24,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    7,
    1845,
    30,
    7,
    5,
    262,
    61,
    147,
    44,
    11,
    6,
    17,
    0,
    322,
    29,
    19,
    43,
    485,
    27,
    229,
    29,
    3,
    0,
    208,
    30,
    2,
    2,
    2,
    1,
    2,
    6,
    3,
    4,
    10,
    1,
    225,
    6,
    2,
    3,
    2,
    1,
    2,
    14,
    2,
    196,
    60,
    67,
    8,
    0,
    1205,
    3,
    2,
    26,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    9,
    2,
    3,
    2,
    0,
    2,
    0,
    7,
    0,
    5,
    0,
    2,
    0,
    2,
    0,
    2,
    2,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    1,
    2,
    0,
    3,
    3,
    2,
    6,
    2,
    3,
    2,
    3,
    2,
    0,
    2,
    9,
    2,
    16,
    6,
    2,
    2,
    4,
    2,
    16,
    4421,
    42719,
    33,
    4381,
    3,
    5773,
    3,
    7472,
    16,
    621,
    2467,
    541,
    1507,
    4938,
    6,
    8489,
];
var astralIdentifierCodes2 = [
    509,
    0,
    227,
    0,
    150,
    4,
    294,
    9,
    1368,
    2,
    2,
    1,
    6,
    3,
    41,
    2,
    5,
    0,
    166,
    1,
    574,
    3,
    9,
    9,
    7,
    9,
    32,
    4,
    318,
    1,
    78,
    5,
    71,
    10,
    50,
    3,
    123,
    2,
    54,
    14,
    32,
    10,
    3,
    1,
    11,
    3,
    46,
    10,
    8,
    0,
    46,
    9,
    7,
    2,
    37,
    13,
    2,
    9,
    6,
    1,
    45,
    0,
    13,
    2,
    49,
    13,
    9,
    3,
    2,
    11,
    83,
    11,
    7,
    0,
    3,
    0,
    158,
    11,
    6,
    9,
    7,
    3,
    56,
    1,
    2,
    6,
    3,
    1,
    3,
    2,
    10,
    0,
    11,
    1,
    3,
    6,
    4,
    4,
    68,
    8,
    2,
    0,
    3,
    0,
    2,
    3,
    2,
    4,
    2,
    0,
    15,
    1,
    83,
    17,
    10,
    9,
    5,
    0,
    82,
    19,
    13,
    9,
    214,
    6,
    3,
    8,
    28,
    1,
    83,
    16,
    16,
    9,
    82,
    12,
    9,
    9,
    7,
    19,
    58,
    14,
    5,
    9,
    243,
    14,
    166,
    9,
    71,
    5,
    2,
    1,
    3,
    3,
    2,
    0,
    2,
    1,
    13,
    9,
    120,
    6,
    3,
    6,
    4,
    0,
    29,
    9,
    41,
    6,
    2,
    3,
    9,
    0,
    10,
    10,
    47,
    15,
    199,
    7,
    137,
    9,
    54,
    7,
    2,
    7,
    17,
    9,
    57,
    21,
    2,
    13,
    123,
    5,
    4,
    0,
    2,
    1,
    2,
    6,
    2,
    0,
    9,
    9,
    49,
    4,
    2,
    1,
    2,
    4,
    9,
    9,
    55,
    9,
    266,
    3,
    10,
    1,
    2,
    0,
    49,
    6,
    4,
    4,
    14,
    10,
    5350,
    0,
    7,
    14,
    11465,
    27,
    2343,
    9,
    87,
    9,
    39,
    4,
    60,
    6,
    26,
    9,
    535,
    9,
    470,
    0,
    2,
    54,
    8,
    3,
    82,
    0,
    12,
    1,
    19628,
    1,
    4178,
    9,
    519,
    45,
    3,
    22,
    543,
    4,
    4,
    5,
    9,
    7,
    3,
    6,
    31,
    3,
    149,
    2,
    1418,
    49,
    513,
    54,
    5,
    49,
    9,
    0,
    15,
    0,
    23,
    4,
    2,
    14,
    1361,
    6,
    2,
    16,
    3,
    6,
    2,
    1,
    2,
    4,
    101,
    0,
    161,
    6,
    10,
    9,
    357,
    0,
    62,
    13,
    499,
    13,
    245,
    1,
    2,
    9,
    233,
    0,
    3,
    0,
    8,
    1,
    6,
    0,
    475,
    6,
    110,
    6,
    6,
    9,
    4759,
    9,
    787719,
    239,
];

function isInAstralSet2(code2, set) {
    let pos = 65536;
    
    for (let i = 0, length = set.length; i < length; i += 2) {
        pos += set[i];
        
        if (pos > code2)
            return false;
        
        pos += set[i + 1];
        
        if (pos >= code2)
            return true;
    }
    
    return false;
}

function isIdentifierStart2(code2) {
    if (code2 < 65)
        return code2 === 36;
    
    if (code2 <= 90)
        return true;
    
    if (code2 < 97)
        return code2 === 95;
    
    if (code2 <= 122)
        return true;
    
    if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifierStart2.test(String.fromCharCode(code2));
    }
    
    return isInAstralSet2(code2, astralIdentifierStartCodes2);
}

function isIdentifierChar2(code2) {
    if (code2 < 48)
        return code2 === 36;
    
    if (code2 < 58)
        return true;
    
    if (code2 < 65)
        return false;
    
    if (code2 <= 90)
        return true;
    
    if (code2 < 97)
        return code2 === 95;
    
    if (code2 <= 122)
        return true;
    
    if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifier2.test(String.fromCharCode(code2));
    }
    
    return isInAstralSet2(code2, astralIdentifierStartCodes2) || isInAstralSet2(code2, astralIdentifierCodes2);
}

var reservedWords2 = {
    keyword: [
        'break',
        'case',
        'catch',
        'continue',
        'debugger',
        'default',
        'do',
        'else',
        'finally',
        'for',
        'function',
        'if',
        'return',
        'switch',
        'throw',
        'try',
        'var',
        'const',
        'while',
        'with',
        'new',
        'this',
        'super',
        'class',
        'extends',
        'export',
        'import',
        'null',
        'true',
        'false',
        'in',
        'instanceof',
        'typeof',
        'void',
        'delete',
    ],
    strict: [
        'implements',
        'interface',
        'let',
        'package',
        'private',
        'protected',
        'public',
        'static',
        'yield',
    ],
    strictBind: ['eval', 'arguments'],
};

var keywords2 = new Set(reservedWords2.keyword);
var reservedWordsStrictSet2 = new Set(reservedWords2.strict);
var reservedWordsStrictBindSet2 = new Set(reservedWords2.strictBind);

function isReservedWord2(word, inModule) {
    return inModule && word === 'await' || word === 'enum';
}

function isStrictReservedWord2(word, inModule) {
    return isReservedWord2(word, inModule) || reservedWordsStrictSet2.has(word);
}

function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet2.has(word);
}

function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord2(word, inModule) || isStrictBindOnlyReservedWord(word);
}

function isKeyword2(word) {
    return keywords2.has(word);
}

var reservedWordLikeSet = /* @__PURE__ */new Set([
    'break',
    'case',
    'catch',
    'continue',
    'debugger',
    'default',
    'do',
    'else',
    'finally',
    'for',
    'function',
    'if',
    'return',
    'switch',
    'throw',
    'try',
    'var',
    'const',
    'while',
    'with',
    'new',
    'this',
    'super',
    'class',
    'extends',
    'export',
    'import',
    'null',
    'true',
    'false',
    'in',
    'instanceof',
    'typeof',
    'void',
    'delete',
    'implements',
    'interface',
    'let',
    'package',
    'private',
    'protected',
    'public',
    'static',
    'yield',
    'eval',
    'arguments',
    'enum',
    'await',
]);

function canBeReservedWord(word) {
    return reservedWordLikeSet.has(word);
}

var Scope = class {
    flags = 0;
    names =     /* @__PURE__ */new Map();
    firstLexicalName = '';
    constructor(flags) {
        this.flags = flags;
    }
};

var ScopeHandler = class {
    parser;
    scopeStack = [];
    inModule;
    undefinedExports =     /* @__PURE__ */new Map();
    constructor(parser, inModule) {
        this.parser = parser;
        this.inModule = inModule;
    }
    
    get inTopLevel() {
        return (this.currentScope().flags & 1) > 0;
    }
    
    get inFunction() {
        return (this.currentVarScopeFlags() & 2) > 0;
    }
    
    get allowSuper() {
        return (this.currentThisScopeFlags() & 16) > 0;
    }
    
    get allowDirectSuper() {
        return (this.currentThisScopeFlags() & 32) > 0;
    }
    
    get allowNewTarget() {
        return (this.currentThisScopeFlags() & 512) > 0;
    }
    
    get inClass() {
        return (this.currentThisScopeFlags() & 64) > 0;
    }
    
    get inClassAndNotInNonArrowFunction() {
        const flags = this.currentThisScopeFlags();
        return (flags & 64) > 0 && (flags & 2) === 0;
    }
    
    get inStaticBlock() {
        for (let i = this.scopeStack.length - 1;; i--) {
            const {flags} = this.scopeStack[i];
            
            if (flags & 128) {
                return true;
            }
            
            if (flags & (1667 | 64)) {
                return false;
            }
        }
    }
    
    get inNonArrowFunction() {
        return (this.currentThisScopeFlags() & 2) > 0;
    }
    
    get inBareCaseStatement() {
        return (this.currentScope().flags & 256) > 0;
    }
    
    get treatFunctionsAsVar() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    
    createScope(flags) {
        return new Scope(flags);
    }
    
    enter(flags) {
        this.scopeStack.push(this.createScope(flags));
    }
    
    exit() {
        const scope2 = this.scopeStack.pop();
        return scope2.flags;
    }
    
    treatFunctionsAsVarInScope(scope2) {
        return !!(scope2.flags & (2 | 128) || !this.parser.inModule && scope2.flags & 1);
    }
    
    declareName(name, bindingType, loc) {
        let scope2 = this.currentScope();
        
        if (bindingType & 8 || bindingType & 16) {
            this.checkRedeclarationInScope(scope2, name, bindingType, loc);
            let type = scope2.names.get(name) || 0;
            
            if (bindingType & 16) {
                type = type | 4;
            } else {
                if (!scope2.firstLexicalName) {
                    scope2.firstLexicalName = name;
                }
                
                type = type | 2;
            }
            
            scope2.names.set(name, type);
            
            if (bindingType & 8) {
                this.maybeExportDefined(scope2, name);
            }
        } else if (bindingType & 4) {
            for (let i = this.scopeStack.length - 1; i >= 0; --i) {
                scope2 = this.scopeStack[i];
                this.checkRedeclarationInScope(scope2, name, bindingType, loc);
                scope2.names.set(name, (scope2.names.get(name) || 0) | 1);
                this.maybeExportDefined(scope2, name);
                
                if (scope2.flags & 1667)
                    break;
            }
        }
        
        if (this.parser.inModule && scope2.flags & 1) {
            this.undefinedExports.delete(name);
        }
    }
    
    maybeExportDefined(scope2, name) {
        if (this.parser.inModule && scope2.flags & 1) {
            this.undefinedExports.delete(name);
        }
    }
    
    checkRedeclarationInScope(scope2, name, bindingType, loc) {
        if (this.isRedeclaredInScope(scope2, name, bindingType)) {
            this.parser.raise(Errors.VarRedeclaration, loc, {
                identifierName: name,
            });
        }
    }
    
    isRedeclaredInScope(scope2, name, bindingType) {
        if (!(bindingType & 1))
            return false;
        
        if (bindingType & 8) {
            return scope2.names.has(name);
        }
        
        const type = scope2.names.get(name) || 0;
        
        if (bindingType & 16) {
            return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope2) && (type & 1) > 0;
        }
        
        return (type & 2) > 0 && !(scope2.flags & 8 && scope2.firstLexicalName === name)
            || !this.treatFunctionsAsVarInScope(scope2) && (type & 4) > 0;
    }
    
    checkLocalExport(id) {
        const {name} = id;
        
        const topLevelScope = this.scopeStack[0];
        
        if (!topLevelScope.names.has(name)) {
            this.undefinedExports.set(name, id.loc.start);
        }
    }
    
    currentScope() {
        return this.scopeStack[this.scopeStack.length - 1];
    }
    
    currentVarScopeFlags() {
        for (let i = this.scopeStack.length - 1;; i--) {
            const {flags} = this.scopeStack[i];
            
            if (flags & 1667) {
                return flags;
            }
        }
    }
    
    currentThisScopeFlags() {
        for (let i = this.scopeStack.length - 1;; i--) {
            const {flags} = this.scopeStack[i];
            
            if (flags & (1667 | 64) && !(flags & 4)) {
                return flags;
            }
        }
    }
};

var entities = {
    __proto__: null,
    quot: '"',
    amp: '&',
    apos: '\'',
    lt: '<',
    gt: '>',
    nbsp: '\xA0',
    iexcl: '\xA1',
    cent: '\xA2',
    pound: '\xA3',
    curren: '\xA4',
    yen: '\xA5',
    brvbar: '\xA6',
    sect: '\xA7',
    uml: '\xA8',
    copy: '\xA9',
    ordf: '\xAA',
    laquo: '\xAB',
    not: '\xAC',
    shy: '\xAD',
    reg: '\xAE',
    macr: '\xAF',
    deg: '\xB0',
    plusmn: '\xB1',
    sup2: '\xB2',
    sup3: '\xB3',
    acute: '\xB4',
    micro: '\xB5',
    para: '\xB6',
    middot: '\xB7',
    cedil: '\xB8',
    sup1: '\xB9',
    ordm: '\xBA',
    raquo: '\xBB',
    frac14: '\xBC',
    frac12: '\xBD',
    frac34: '\xBE',
    iquest: '\xBF',
    Agrave: '\xC0',
    Aacute: '\xC1',
    Acirc: '\xC2',
    Atilde: '\xC3',
    Auml: '\xC4',
    Aring: '\xC5',
    AElig: '\xC6',
    Ccedil: '\xC7',
    Egrave: '\xC8',
    Eacute: '\xC9',
    Ecirc: '\xCA',
    Euml: '\xCB',
    Igrave: '\xCC',
    Iacute: '\xCD',
    Icirc: '\xCE',
    Iuml: '\xCF',
    ETH: '\xD0',
    Ntilde: '\xD1',
    Ograve: '\xD2',
    Oacute: '\xD3',
    Ocirc: '\xD4',
    Otilde: '\xD5',
    Ouml: '\xD6',
    times: '\xD7',
    Oslash: '\xD8',
    Ugrave: '\xD9',
    Uacute: '\xDA',
    Ucirc: '\xDB',
    Uuml: '\xDC',
    Yacute: '\xDD',
    THORN: '\xDE',
    szlig: '\xDF',
    agrave: '\xE0',
    aacute: '\xE1',
    acirc: '\xE2',
    atilde: '\xE3',
    auml: '\xE4',
    aring: '\xE5',
    aelig: '\xE6',
    ccedil: '\xE7',
    egrave: '\xE8',
    eacute: '\xE9',
    ecirc: '\xEA',
    euml: '\xEB',
    igrave: '\xEC',
    iacute: '\xED',
    icirc: '\xEE',
    iuml: '\xEF',
    eth: '\xF0',
    ntilde: '\xF1',
    ograve: '\xF2',
    oacute: '\xF3',
    ocirc: '\xF4',
    otilde: '\xF5',
    ouml: '\xF6',
    divide: '\xF7',
    oslash: '\xF8',
    ugrave: '\xF9',
    uacute: '\xFA',
    ucirc: '\xFB',
    uuml: '\xFC',
    yacute: '\xFD',
    thorn: '\xFE',
    yuml: '\xFF',
    OElig: '\u0152',
    oelig: '\u0153',
    Scaron: '\u0160',
    scaron: '\u0161',
    Yuml: '\u0178',
    fnof: '\u0192',
    circ: '\u02C6',
    tilde: '\u02DC',
    Alpha: '\u0391',
    Beta: '\u0392',
    Gamma: '\u0393',
    Delta: '\u0394',
    Epsilon: '\u0395',
    Zeta: '\u0396',
    Eta: '\u0397',
    Theta: '\u0398',
    Iota: '\u0399',
    Kappa: '\u039A',
    Lambda: '\u039B',
    Mu: '\u039C',
    Nu: '\u039D',
    Xi: '\u039E',
    Omicron: '\u039F',
    Pi: '\u03A0',
    Rho: '\u03A1',
    Sigma: '\u03A3',
    Tau: '\u03A4',
    Upsilon: '\u03A5',
    Phi: '\u03A6',
    Chi: '\u03A7',
    Psi: '\u03A8',
    Omega: '\u03A9',
    alpha: '\u03B1',
    beta: '\u03B2',
    gamma: '\u03B3',
    delta: '\u03B4',
    epsilon: '\u03B5',
    zeta: '\u03B6',
    eta: '\u03B7',
    theta: '\u03B8',
    iota: '\u03B9',
    kappa: '\u03BA',
    lambda: '\u03BB',
    mu: '\u03BC',
    nu: '\u03BD',
    xi: '\u03BE',
    omicron: '\u03BF',
    pi: '\u03C0',
    rho: '\u03C1',
    sigmaf: '\u03C2',
    sigma: '\u03C3',
    tau: '\u03C4',
    upsilon: '\u03C5',
    phi: '\u03C6',
    chi: '\u03C7',
    psi: '\u03C8',
    omega: '\u03C9',
    thetasym: '\u03D1',
    upsih: '\u03D2',
    piv: '\u03D6',
    ensp: '\u2002',
    emsp: '\u2003',
    thinsp: '\u2009',
    zwnj: '\u200C',
    zwj: '\u200D',
    lrm: '\u200E',
    rlm: '\u200F',
    ndash: '\u2013',
    mdash: '\u2014',
    lsquo: '\u2018',
    rsquo: '\u2019',
    sbquo: '\u201A',
    ldquo: '\u201C',
    rdquo: '\u201D',
    bdquo: '\u201E',
    dagger: '\u2020',
    Dagger: '\u2021',
    bull: '\u2022',
    hellip: '\u2026',
    permil: '\u2030',
    prime: '\u2032',
    Prime: '\u2033',
    lsaquo: '\u2039',
    rsaquo: '\u203A',
    oline: '\u203E',
    frasl: '\u2044',
    euro: '\u20AC',
    image: '\u2111',
    weierp: '\u2118',
    real: '\u211C',
    trade: '\u2122',
    alefsym: '\u2135',
    larr: '\u2190',
    uarr: '\u2191',
    rarr: '\u2192',
    darr: '\u2193',
    harr: '\u2194',
    crarr: '\u21B5',
    lArr: '\u21D0',
    uArr: '\u21D1',
    rArr: '\u21D2',
    dArr: '\u21D3',
    hArr: '\u21D4',
    forall: '\u2200',
    part: '\u2202',
    exist: '\u2203',
    empty: '\u2205',
    nabla: '\u2207',
    isin: '\u2208',
    notin: '\u2209',
    ni: '\u220B',
    prod: '\u220F',
    sum: '\u2211',
    minus: '\u2212',
    lowast: '\u2217',
    radic: '\u221A',
    prop: '\u221D',
    infin: '\u221E',
    ang: '\u2220',
    and: '\u2227',
    or: '\u2228',
    cap: '\u2229',
    cup: '\u222A',
    int: '\u222B',
    there4: '\u2234',
    sim: '\u223C',
    cong: '\u2245',
    asymp: '\u2248',
    ne: '\u2260',
    equiv: '\u2261',
    le: '\u2264',
    ge: '\u2265',
    sub: '\u2282',
    sup: '\u2283',
    nsub: '\u2284',
    sube: '\u2286',
    supe: '\u2287',
    oplus: '\u2295',
    otimes: '\u2297',
    perp: '\u22A5',
    sdot: '\u22C5',
    lceil: '\u2308',
    rceil: '\u2309',
    lfloor: '\u230A',
    rfloor: '\u230B',
    lang: '\u2329',
    rang: '\u232A',
    loz: '\u25CA',
    spades: '\u2660',
    clubs: '\u2663',
    hearts: '\u2665',
    diams: '\u2666',
};

var lineBreak = /\r\n|[\r\n\u2028\u2029]/;
var lineBreakG = new RegExp(lineBreak.source, 'g');

function isNewLine$1(code2) {
    switch(code2) {
    case 10:    
    case 13:    
    case 8232:    
    case 8233:
        return true;
    
    default:
        return false;
    }
}

function hasNewLine(input, start, end) {
    for (let i = start; i < end; i++) {
        if (isNewLine$1(input.charCodeAt(i))) {
            return true;
        }
    }
    
    return false;
}

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;

function isWhitespace(code2) {
    switch(code2) {
    case 9:    
    case 11:    
    case 12:    
    case 32:    
    case 160:    
    case 5760:    
    case 8192:    
    case 8193:    
    case 8194:    
    case 8195:    
    case 8196:    
    case 8197:    
    case 8198:    
    case 8199:    
    case 8200:    
    case 8201:    
    case 8202:    
    case 8239:    
    case 8287:    
    case 12288:    
    case 65279:
        return true;
    
    default:
        return false;
    }
}

var JsxErrors = ParseErrorEnum`jsx`({
    AttributeIsEmpty: 'JSX attributes must only be assigned a non-empty expression.',
    MissingClosingTagElement: ({openingTagName}) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
    MissingClosingTagFragment: 'Expected corresponding JSX closing tag for <>.',
    UnexpectedSequenceExpression: 'Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?',
    UnexpectedToken: ({unexpected, HTMLEntity}) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
    UnsupportedJsxValue: 'JSX value should be either an expression or a quoted JSX text.',
    UnterminatedJsxContent: 'Unterminated JSX contents.',
    UnwrappedAdjacentJSXElements: 'Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?',
});

function isFragment(object) {
    return object ? object.type === 'JSXOpeningFragment' || object.type === 'JSXClosingFragment' : false;
}

function getQualifiedJSXName(object) {
    if (object.type === 'JSXIdentifier') {
        return object.name;
    }
    
    if (object.type === 'JSXNamespacedName') {
        return object.namespace.name + ':' + object.name.name;
    }
    
    if (object.type === 'JSXMemberExpression') {
        return getQualifiedJSXName(object.object) + '.' + getQualifiedJSXName(object.property);
    }
    
    throw new Error('Node had unexpected type: ' + object.type);
}

var jsx = (superClass) => class JSXParserMixin extends superClass {
    jsxReadToken() {
        let out = '';
        let chunkStart = this.state.pos;
        
        for (;;) {
            if (this.state.pos >= this.length) {
                throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);
            }
            
            const ch = this.input.charCodeAt(this.state.pos);
            
            switch(ch) {
            case 60:            
            case 123:
                if (this.state.pos === this.state.start) {
                    if (ch === 60 && this.state.canStartJSXElement) {
                        ++this.state.pos;
                        this.finishToken(138);
                    } else {
                        super.getTokenFromCode(ch);
                    }
                    
                    return;
                }
                
                out += this.input.slice(chunkStart, this.state.pos);
                this.finishToken(137, out);
                return;
            
            case 38:
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadEntity();
                chunkStart = this.state.pos;
                break;
            
            case 62:            
            case 125:
                this.raise(JsxErrors.UnexpectedToken, this.state.curPosition(), {
                    unexpected: this.input[this.state.pos],
                    HTMLEntity: ch === 125 ? '&rbrace;' : '&gt;',
                });
            
            default:
                if (isNewLine$1(ch)) {
                    out += this.input.slice(chunkStart, this.state.pos);
                    out += this.jsxReadNewLine(true);
                    chunkStart = this.state.pos;
                } else {
                    ++this.state.pos;
                }
            }
        }
    }
    
    jsxReadNewLine(normalizeCRLF) {
        const ch = this.input.charCodeAt(this.state.pos);
        let out;
        ++this.state.pos;
        
        if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
            ++this.state.pos;
            out = normalizeCRLF ? '\n' : '\r\n';
        } else {
            out = String.fromCharCode(ch);
        }
        
        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        return out;
    }
    
    jsxReadString(quote) {
        let out = '';
        let chunkStart = ++this.state.pos;
        
        for (;;) {
            if (this.state.pos >= this.length) {
                throw this.raise(Errors.UnterminatedString, this.state.startLoc);
            }
            
            const ch = this.input.charCodeAt(this.state.pos);
            
            if (ch === quote)
                break;
            
            if (ch === 38) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadEntity();
                chunkStart = this.state.pos;
            } else if (isNewLine$1(ch)) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadNewLine(false);
                chunkStart = this.state.pos;
            } else {
                ++this.state.pos;
            }
        }
        
        out += this.input.slice(chunkStart, this.state.pos++);
        this.finishToken(130, out);
    }
    
    jsxReadEntity() {
        const startPos = ++this.state.pos;
        
        if (this.codePointAtPos(this.state.pos) === 35) {
            ++this.state.pos;
            let radix = 10;
            
            if (this.codePointAtPos(this.state.pos) === 120) {
                radix = 16;
                ++this.state.pos;
            }
            
            const codePoint = this.readInt(radix, void 0, false, 'bail');
            
            if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
                ++this.state.pos;
                return String.fromCodePoint(codePoint);
            }
        } else {
            let count = 0;
            let semi = false;
            
            while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59)) {
                ++this.state.pos;
            }
            
            if (semi) {
                const desc = this.input.slice(startPos, this.state.pos);
                const entity = entities[desc];
                ++this.state.pos;
                
                if (entity) {
                    return entity;
                }
            }
        }
        
        this.state.pos = startPos;
        return '&';
    }
    
    jsxReadWord() {
        let ch;
        const start = this.state.pos;
        
        do {
            ch = this.input.charCodeAt(++this.state.pos);
        } while (isIdentifierChar2(ch) || ch === 45)
        this.finishToken(136, this.input.slice(start, this.state.pos));
    }
    
    jsxParseIdentifier() {
        const node = this.startNode();
        
        if (this.match(136)) {
            node.name = this.state.value;
        } else if (tokenIsKeyword(this.state.type)) {
            node.name = tokenLabelName(this.state.type);
        } else {
            this.unexpected();
        }
        
        this.next();
        return this.finishNode(node, 'JSXIdentifier');
    }
    
    jsxParseNamespacedName() {
        const startLoc = this.state.startLoc;
        const name = this.jsxParseIdentifier();
        
        if (!this.eat(10))
            return name;
        
        const node = this.startNodeAt(startLoc);
        
        node.namespace = name;
        node.name = this.jsxParseIdentifier();
        return this.finishNode(node, 'JSXNamespacedName');
    }
    
    jsxParseElementName() {
        const startLoc = this.state.startLoc;
        let node = this.jsxParseNamespacedName();
        
        if (node.type === 'JSXNamespacedName') {
            return node;
        }
        
        while (this.eat(12)) {
            const newNode = this.startNodeAt(startLoc);
            
            newNode.object = node;
            newNode.property = this.jsxParseIdentifier();
            node = this.finishNode(newNode, 'JSXMemberExpression');
        }
        
        return node;
    }
    
    jsxParseAttributeValue() {
        let node;
        
        switch(this.state.type) {
        case 2:
            node = this.startNode();
            this.setContext(types$2.brace);
            this.next();
            node = this.jsxParseExpressionContainer(node, types$2.j_oTag);
            
            if (node.expression.type === 'JSXEmptyExpression') {
                this.raise(JsxErrors.AttributeIsEmpty, node);
            }
            
            return node;
        
        case 138:        
        case 130:
            return this.parseExprAtom();
        
        default:
            throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);
        }
    }
    
    jsxParseEmptyExpression() {
        const node = this.startNodeAt(this.state.lastTokEndLoc);
        return this.finishNodeAt(node, 'JSXEmptyExpression', this.state.startLoc);
    }
    
    jsxParseSpreadChild(node) {
        this.next();
        node.expression = this.parseExpression();
        this.setContext(types$2.j_expr);
        this.state.canStartJSXElement = true;
        this.expect(4);
        return this.finishNode(node, 'JSXSpreadChild');
    }
    
    jsxParseExpressionContainer(node, previousContext) {
        if (this.match(4)) {
            node.expression = this.jsxParseEmptyExpression();
        } else {
            const expression2 = this.parseExpression();
            
            if (expression2.type === 'SequenceExpression' && !expression2.extra?.parenthesized) {
                this.raise(JsxErrors.UnexpectedSequenceExpression, expression2.expressions[1]);
            }
            
            node.expression = expression2;
        }
        
        this.setContext(previousContext);
        this.state.canStartJSXElement = true;
        this.expect(4);
        return this.finishNode(node, 'JSXExpressionContainer');
    }
    
    jsxParseAttribute() {
        const node = this.startNode();
        
        if (this.match(2)) {
            this.setContext(types$2.brace);
            this.next();
            this.expect(17);
            node.argument = this.parseMaybeAssignAllowIn();
            this.setContext(types$2.j_oTag);
            this.state.canStartJSXElement = true;
            this.expect(4);
            return this.finishNode(node, 'JSXSpreadAttribute');
        }
        
        node.name = this.jsxParseNamespacedName();
        node.value = this.eat(25) ? this.jsxParseAttributeValue() : null;
        return this.finishNode(node, 'JSXAttribute');
    }
    
    jsxParseOpeningElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        
        if (this.eat(139)) {
            return this.finishNode(node, 'JSXOpeningFragment');
        }
        
        node.name = this.jsxParseElementName();
        return this.jsxParseOpeningElementAfterName(node);
    }
    
    jsxParseOpeningElementAfterName(node) {
        const attributes = [];
        
        while (!this.match(52) && !this.match(139)) {
            attributes.push(this.jsxParseAttribute());
        }
        
        node.attributes = attributes;
        node.selfClosing = this.eat(52);
        this.expect(139);
        return this.finishNode(node, 'JSXOpeningElement');
    }
    
    jsxParseClosingElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        
        if (this.eat(139)) {
            return this.finishNode(node, 'JSXClosingFragment');
        }
        
        node.name = this.jsxParseElementName();
        this.expect(139);
        return this.finishNode(node, 'JSXClosingElement');
    }
    
    jsxParseElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        const children = [];
        const openingElement = this.jsxParseOpeningElementAt(startLoc);
        let closingElement = null;
        
        if (!openingElement.selfClosing) {
            contents: for (;;) {
                switch(this.state.type) {
                case 138:
                    startLoc = this.state.startLoc;
                    this.next();
                    
                    if (this.eat(52)) {
                        closingElement = this.jsxParseClosingElementAt(startLoc);
                        break contents;
                    }
                    
                    children.push(this.jsxParseElementAt(startLoc));
                    break;
                
                case 137:
                    children.push(this.parseLiteral(this.state.value, 'JSXText'));
                    break;
                
                case 2: {
                    const node2 = this.startNode();
                    this.setContext(types$2.brace);
                    this.next();
                    
                    if (this.match(17)) {
                        children.push(this.jsxParseSpreadChild(node2));
                    } else {
                        children.push(this.jsxParseExpressionContainer(node2, types$2.j_expr));
                    }
                    
                    break;
                }
                
                default:
                    this.unexpected();
                }
            }
            if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
                this.raise(JsxErrors.MissingClosingTagFragment, closingElement);
            } else if (!isFragment(openingElement) && isFragment(closingElement)) {
                this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
                    openingTagName: getQualifiedJSXName(openingElement.name),
                });
            } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
                if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
                    this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
                        openingTagName: getQualifiedJSXName(openingElement.name),
                    });
                }
            }

        }
        
        if (isFragment(openingElement)) {
            node.openingFragment = openingElement;
            node.closingFragment = closingElement;
        } else {
            node.openingElement = openingElement;
            node.closingElement = closingElement;
        }
        
        node.children = children;
        
        if (this.match(43)) {
            throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);
        }
        
        return isFragment(openingElement) ? this.finishNode(node, 'JSXFragment') : this.finishNode(node, 'JSXElement');
    }
    
    jsxParseElement() {
        const startLoc = this.state.startLoc;
        this.next();
        return this.jsxParseElementAt(startLoc);
    }
    
    setContext(newContext) {
        const {context} = this.state;
        
        context[context.length - 1] = newContext;
    }
    
    parseExprAtom(refExpressionErrors) {
        if (this.match(138)) {
            return this.jsxParseElement();
        } else if (this.match(43) && this.input.charCodeAt(this.state.pos) !== 33) {
            this.replaceToken(138);
            return this.jsxParseElement();
        } else {
            return super.parseExprAtom(refExpressionErrors);
        }
    }
    
    skipSpace() {
        const curContext = this.curContext();
        
        if (!curContext.preserveSpace)
            super.skipSpace();
    }
    
    getTokenFromCode(code2) {
        const context = this.curContext();
        
        if (context === types$2.j_expr) {
            this.jsxReadToken();
            return;
        }
        
        if (context === types$2.j_oTag || context === types$2.j_cTag) {
            if (isIdentifierStart2(code2)) {
                this.jsxReadWord();
                return;
            }
            
            if (code2 === 62) {
                ++this.state.pos;
                this.finishToken(139);
                return;
            }
            
            if ((code2 === 34 || code2 === 39) && context === types$2.j_oTag) {
                this.jsxReadString(code2);
                return;
            }
        }
        
        if (code2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
            ++this.state.pos;
            this.finishToken(138);
            return;
        }
        
        super.getTokenFromCode(code2);
    }
    
    updateContext(prevType) {
        const {context, type} = this.state;
        
        if (type === 52 && prevType === 138) {
            context.splice(-2, 2, types$2.j_cTag);
            this.state.canStartJSXElement = false;
        } else if (type === 138) {
            context.push(types$2.j_oTag);
        } else if (type === 139) {
            const out = context[context.length - 1];
            
            if (out === types$2.j_oTag && prevType === 52 || out === types$2.j_cTag) {
                context.pop();
                this.state.canStartJSXElement = context[context.length - 1] === types$2.j_expr;
            } else {
                this.setContext(types$2.j_expr);
                this.state.canStartJSXElement = true;
            }
        } else {
            this.state.canStartJSXElement = tokenComesBeforeExpression(type);
        }

    }
};

var TypeScriptScope = class extends Scope {
    tsNames =     /* @__PURE__ */new Map();
};

var TypeScriptScopeHandler = class extends ScopeHandler {
    importsStack = [];
    createScope(flags) {
        this.importsStack.push(        /* @__PURE__ */new Set());
        return new TypeScriptScope(flags);
    }
    
    enter(flags) {
        if (flags === 1024) {
            this.importsStack.push(            /* @__PURE__ */new Set());
        }
        
        super.enter(flags);
    }
    
    exit() {
        const flags = super.exit();
        
        if (flags === 1024) {
            this.importsStack.pop();
        }
        
        return flags;
    }
    
    hasImport(name, allowShadow) {
        const len = this.importsStack.length;
        
        if (this.importsStack[len - 1].has(name)) {
            return true;
        }
        
        if (!allowShadow && len > 1) {
            for (let i = 0; i < len - 1; i++) {
                if (this.importsStack[i].has(name))
                    return true;
            }
        }
        
        return false;
    }
    
    declareName(name, bindingType, loc) {
        if (bindingType & 4096) {
            if (this.hasImport(name, true)) {
                this.parser.raise(Errors.VarRedeclaration, loc, {
                    identifierName: name,
                });
            }
            
            this.importsStack[this.importsStack.length - 1].add(name);
            
            return;
        }
        
        const scope2 = this.currentScope();
        let type = scope2.tsNames.get(name) || 0;
        
        if (bindingType & 1024) {
            this.maybeExportDefined(scope2, name);
            scope2.tsNames.set(name, type | 16);
            return;
        }
        
        super.declareName(name, bindingType, loc);
        
        if (bindingType & 2) {
            if (!(bindingType & 1)) {
                this.checkRedeclarationInScope(scope2, name, bindingType, loc);
                this.maybeExportDefined(scope2, name);
            }
            
            type = type | 1;
        }
        
        if (bindingType & 256) {
            type = type | 2;
        }
        
        if (bindingType & 512) {
            type = type | 4;
        }
        
        if (bindingType & 128) {
            type = type | 8;
        }
        
        if (type)
            scope2.tsNames.set(name, type);
    }
    
    isRedeclaredInScope(scope2, name, bindingType) {
        const type = scope2.tsNames.get(name);
        
        if ((type & 2) > 0) {
            if (bindingType & 256) {
                const isConst = !!(bindingType & 512);
                const wasConst = (type & 4) > 0;
                
                return isConst !== wasConst;
            }
            
            return true;
        }
        
        if (bindingType & 128 && (type & 8) > 0) {
            if (scope2.names.get(name) & 2) {
                return !!(bindingType & 1);
            } else {
                return false;
            }
        }
        
        if (bindingType & 2 && (type & 1) > 0) {
            return true;
        }
        
        return super.isRedeclaredInScope(scope2, name, bindingType);
    }
    
    checkLocalExport(id) {
        const {name} = id;
        
        if (this.hasImport(name))
            return;
        
        const len = this.scopeStack.length;
        
        for (let i = len - 1; i >= 0; i--) {
            const scope2 = this.scopeStack[i];
            const type = scope2.tsNames.get(name);
            
            if ((type & 1) > 0 || (type & 16) > 0) {
                return;
            }
        }
        
        super.checkLocalExport(id);
    }
};

var ProductionParameterHandler = class {
    stacks = [];
    enter(flags) {
        this.stacks.push(flags);
    }
    
    exit() {
        this.stacks.pop();
    }
    
    currentFlags() {
        return this.stacks[this.stacks.length - 1];
    }
    
    get hasAwait() {
        return (this.currentFlags() & 2) > 0;
    }
    
    get hasYield() {
        return (this.currentFlags() & 1) > 0;
    }
    
    get hasReturn() {
        return (this.currentFlags() & 4) > 0;
    }
    
    get hasIn() {
        return (this.currentFlags() & 8) > 0;
    }
};

function functionFlags(isAsync, isGenerator) {
    return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
}

var BaseParser = class {
    sawUnambiguousESM = false;
    ambiguousScriptDifferentAst = false;
    sourceToOffsetPos(sourcePos) {
        return sourcePos + this.startIndex;
    }
    
    offsetToSourcePos(offsetPos) {
        return offsetPos - this.startIndex;
    }
    
    hasPlugin(pluginConfig) {
        if (typeof pluginConfig === 'string') {
            return this.plugins.has(pluginConfig);
        } else {
            const [pluginName, pluginOptions] = pluginConfig;
            
            if (!this.hasPlugin(pluginName)) {
                return false;
            }
            
            const actualOptions = this.plugins.get(pluginName);
            
            for (const key of Object.keys(pluginOptions)) {
                if (actualOptions?.[key] !== pluginOptions[key]) {
                    return false;
                }
            }
            
            return true;
        }
    }
    
    getPluginOption(plugin, name) {
        return this.plugins.get(plugin)?.[name];
    }
};

function setTrailingComments(node, comments) {
    if (node.trailingComments === void 0) {
        node.trailingComments = comments;
    } else {
        node.trailingComments.unshift(...comments);
    }
}

function setLeadingComments(node, comments) {
    if (node.leadingComments === void 0) {
        node.leadingComments = comments;
    } else {
        node.leadingComments.unshift(...comments);
    }
}

function setInnerComments(node, comments) {
    if (node.innerComments === void 0) {
        node.innerComments = comments;
    } else {
        node.innerComments.unshift(...comments);
    }
}

function adjustInnerComments(node, elements, commentWS) {
    let lastElement = null;
    let i = elements.length;
    
    while (lastElement === null && i > 0) {
        lastElement = elements[--i];
    }
    
    if (lastElement === null || lastElement.start > commentWS.start) {
        setInnerComments(node, commentWS.comments);
    } else {
        setTrailingComments(lastElement, commentWS.comments);
    }
}

var CommentsParser = class extends BaseParser {
    addComment(comment) {
        if (this.filename)
            comment.loc.filename = this.filename;
        
        const {commentsLen} = this.state;
        
        if (this.comments.length !== commentsLen) {
            this.comments.length = commentsLen;
        }
        
        this.comments.push(comment);
        this.state.commentsLen++;
    }
    
    processComment(node) {
        const {commentStack} = this.state;
        
        const commentStackLength = commentStack.length;
        
        if (commentStackLength === 0)
            return;
        
        let i = commentStackLength - 1;
        const lastCommentWS = commentStack[i];
        
        if (lastCommentWS.start === node.end) {
            lastCommentWS.leadingNode = node;
            i--;
        }
        
        const {start: nodeStart} = node;
        
        for (; i >= 0; i--) {
            const commentWS = commentStack[i];
            const commentEnd = commentWS.end;
            
            if (commentEnd > nodeStart) {
                commentWS.containingNode = node;
                this.finalizeComment(commentWS);
                commentStack.splice(i, 1);
            } else {
                if (commentEnd === nodeStart) {
                    commentWS.trailingNode = node;
                }
                
                break;
            }
        }
    }
    
    finalizeComment(commentWS) {
        const {comments} = commentWS;
        
        if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
            if (commentWS.leadingNode !== null) {
                setTrailingComments(commentWS.leadingNode, comments);
            }
            
            if (commentWS.trailingNode !== null) {
                setLeadingComments(commentWS.trailingNode, comments);
            }
        } else {
            const node = commentWS.containingNode;
            const commentStart = commentWS.start;
            
            if (this.input.charCodeAt(this.offsetToSourcePos(commentStart) - 1) === 44) {
                switch(node.type) {
                case 'ObjectExpression':                
                case 'ObjectPattern':
                    adjustInnerComments(node, node.properties, commentWS);
                    break;
                
                case 'CallExpression':                
                case 'OptionalCallExpression':
                    adjustInnerComments(node, node.arguments, commentWS);
                    break;
                
                case 'ImportExpression':
                    adjustInnerComments(node, [node.source, node.options ?? null], commentWS);
                    break;
                
                case 'FunctionDeclaration':                
                case 'FunctionExpression':                
                case 'ArrowFunctionExpression':                
                case 'ObjectMethod':                
                case 'ClassMethod':                
                case 'ClassPrivateMethod':
                    adjustInnerComments(node, node.params, commentWS);
                    break;
                
                case 'ArrayExpression':                
                case 'ArrayPattern':
                    adjustInnerComments(node, node.elements, commentWS);
                    break;
                
                case 'ExportNamedDeclaration':                
                case 'ImportDeclaration':
                    adjustInnerComments(node, node.specifiers, commentWS);
                    break;
                
                case 'TSEnumDeclaration':
                    setInnerComments(node, comments);
                    break;
                
                case 'TSEnumBody':
                    adjustInnerComments(node, node.members, commentWS);
                    break;
                
                default: {
                    setInnerComments(node, comments);
                }
                }
            } else {
                setInnerComments(node, comments);
            }
        }
    }
    
    finalizeRemainingComments() {
        const {commentStack} = this.state;
        
        for (let i = commentStack.length - 1; i >= 0; i--) {
            this.finalizeComment(commentStack[i]);
        }
        
        this.state.commentStack = [];
    }
    
    resetPreviousNodeTrailingComments(node) {
        const {commentStack} = this.state;
        
        const {length} = commentStack;
        
        if (length === 0)
            return;
        
        const commentWS = commentStack[length - 1];
        
        if (commentWS.leadingNode === node) {
            commentWS.leadingNode = null;
        }
    }
    
    takeSurroundingComments(node, start, end) {
        const {commentStack} = this.state;
        
        const commentStackLength = commentStack.length;
        
        if (commentStackLength === 0)
            return;
        
        let i = commentStackLength - 1;
        
        for (; i >= 0; i--) {
            const commentWS = commentStack[i];
            const commentEnd = commentWS.end;
            const commentStart = commentWS.start;
            
            if (commentStart === end) {
                commentWS.leadingNode = node;
            } else if (commentEnd === start) {
                commentWS.trailingNode = node;
            } else if (commentEnd < start) {
                break;
            }

        }
    }
};

var State$2 = class _State {
    flags = 1024;
    get strict() {
        return (this.flags & 1) > 0;
    }
    
    set strict(v) {
        if (v)
            this.flags |= 1;
        else
            this.flags &= -2;
    }
    
    startIndex;
    curLine;
    lineStart;
    startLoc;
    endLoc;
    init({strictMode, sourceType, startIndex, startLine, startColumn}) {
        this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === 'module';
        this.startIndex = startIndex;
        this.curLine = startLine;
        this.lineStart = -startColumn;
        this.startLoc =
        this.endLoc = new Position(startLine, startColumn, startIndex);
    }
    
    errors = [];
    potentialArrowAt = -1;
    noArrowAt = [];
    noArrowParamsConversionAt = [];
    get maybeInArrowParameters() {
        return (this.flags & 2) > 0;
    }
    
    set maybeInArrowParameters(v) {
        if (v)
            this.flags |= 2;
        else
            this.flags &= -3;
    }
    
    get inType() {
        return (this.flags & 4) > 0;
    }
    
    set inType(v) {
        if (v)
            this.flags |= 4;
        else
            this.flags &= -5;
    }
    
    get noAnonFunctionType() {
        return (this.flags & 8) > 0;
    }
    
    set noAnonFunctionType(v) {
        if (v)
            this.flags |= 8;
        else
            this.flags &= -9;
    }
    
    get hasFlowComment() {
        return (this.flags & 16) > 0;
    }
    
    set hasFlowComment(v) {
        if (v)
            this.flags |= 16;
        else
            this.flags &= -17;
    }
    
    get isAmbientContext() {
        return (this.flags & 32) > 0;
    }
    
    set isAmbientContext(v) {
        if (v)
            this.flags |= 32;
        else
            this.flags &= -33;
    }
    
    get inAbstractClass() {
        return (this.flags & 64) > 0;
    }
    
    set inAbstractClass(v) {
        if (v)
            this.flags |= 64;
        else
            this.flags &= -65;
    }
    
    get inDisallowConditionalTypesContext() {
        return (this.flags & 128) > 0;
    }
    
    set inDisallowConditionalTypesContext(v) {
        if (v)
            this.flags |= 128;
        else
            this.flags &= -129;
    }
    
    topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null,
    };
    get soloAwait() {
        return (this.flags & 256) > 0;
    }
    
    set soloAwait(v) {
        if (v)
            this.flags |= 256;
        else
            this.flags &= -257;
    }
    
    get inFSharpPipelineDirectBody() {
        return (this.flags & 512) > 0;
    }
    
    set inFSharpPipelineDirectBody(v) {
        if (v)
            this.flags |= 512;
        else
            this.flags &= -513;
    }
    
    labels = [];
    commentsLen = 0;
    commentStack = [];
    pos = 0;
    type = 135;
    value = null;
    start = 0;
    end = 0;
    lastTokEndLoc = null;
    lastTokStartLoc = null;
    context = [types$2.brace];
    get canStartJSXElement() {
        return (this.flags & 1024) > 0;
    }
    
    set canStartJSXElement(v) {
        if (v)
            this.flags |= 1024;
        else
            this.flags &= -1025;
    }
    
    get containsEsc() {
        return (this.flags & 2048) > 0;
    }
    
    set containsEsc(v) {
        if (v)
            this.flags |= 2048;
        else
            this.flags &= -2049;
    }
    
    firstInvalidTemplateEscapePos = null;
    get hasTopLevelAwait() {
        return (this.flags & 4096) > 0;
    }
    
    set hasTopLevelAwait(v) {
        if (v)
            this.flags |= 4096;
        else
            this.flags &= -4097;
    }
    
    strictErrors =     /* @__PURE__ */new Map();
    tokensLength = 0;
    curPosition() {
        return new Position(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
    }
    
    clone() {
        const state = new _State();
        
        state.flags = this.flags;
        state.startIndex = this.startIndex;
        state.curLine = this.curLine;
        state.lineStart = this.lineStart;
        state.startLoc = this.startLoc;
        state.endLoc = this.endLoc;
        state.errors = this.errors.slice();
        state.potentialArrowAt = this.potentialArrowAt;
        state.noArrowAt = this.noArrowAt.slice();
        state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();
        state.topicContext = this.topicContext;
        state.labels = this.labels.slice();
        state.commentsLen = this.commentsLen;
        state.commentStack = this.commentStack.slice();
        state.pos = this.pos;
        state.type = this.type;
        state.value = this.value;
        state.start = this.start;
        state.end = this.end;
        state.lastTokEndLoc = this.lastTokEndLoc;
        state.lastTokStartLoc = this.lastTokStartLoc;
        state.context = this.context.slice();
        state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;
        state.strictErrors = this.strictErrors;
        state.tokensLength = this.tokensLength;
        return state;
    }
};

var _isDigit2 = function isDigit2(code2) {
    return code2 >= 48 && code2 <= 57;
};

var forbiddenNumericSeparatorSiblings2 = {
    decBinOct:     /* @__PURE__ */new Set([
        46,
        66,
        69,
        79,
        95,
        98,
        101,
        111,
    ]),
    hex:     /* @__PURE__ */new Set([
        46,
        88,
        95,
        120,
    ]),
};

var isAllowedNumericSeparatorSibling2 = {
    bin: (ch) => ch === 48 || ch === 49,
    oct: (ch) => ch >= 48 && ch <= 55,
    dec: (ch) => ch >= 48 && ch <= 57,
    hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102,
};

function readStringContents2(type, input, pos, lineStart, curLine, errors) {
    const initialPos = pos;
    const initialLineStart = lineStart;
    const initialCurLine = curLine;
    let out = '';
    let firstInvalidLoc = null;
    let chunkStart = pos;
    
    const {length} = input;
    
    for (;;) {
        if (pos >= length) {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
            out += input.slice(chunkStart, pos);
            break;
        }
        
        const ch = input.charCodeAt(pos);
        
        if (isStringEnd2(type, ch, input, pos)) {
            out += input.slice(chunkStart, pos);
            break;
        }
        
        if (ch === 92) {
            out += input.slice(chunkStart, pos);
            const res = readEscapedChar2(input, pos, lineStart, curLine, type === 'template', errors);
            
            if (res.ch === null && !firstInvalidLoc) {
                firstInvalidLoc = {
                    pos,
                    lineStart,
                    curLine,
                };
            } else {
                out += res.ch;
            }
            
            ({
                pos,
                lineStart,
                curLine,
            } = res);
            chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
            ++pos;
            ++curLine;
            lineStart = pos;
        } else if (ch === 10 || ch === 13) {
            if (type === 'template') {
                out += input.slice(chunkStart, pos) + '\n';
                ++pos;
                
                if (ch === 13 && input.charCodeAt(pos) === 10) {
                    ++pos;
                }
                
                ++curLine;
                chunkStart =
                lineStart = pos;
            } else {
                errors.unterminated(initialPos, initialLineStart, initialCurLine);
            }
        } else {
            ++pos;
        }

    }
    
    return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
    };
}

function isStringEnd2(type, ch, input, pos) {
    if (type === 'template') {
        return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
    }
    
    return ch === (type === 'double' ? 34 : 39);
}

function readEscapedChar2(input, pos, lineStart, curLine, inTemplate, errors) {
    const throwOnInvalid = !inTemplate;
    pos++;
    const res = (ch2) => ({
        pos,
        ch: ch2,
        lineStart,
        curLine,
    });
    
    const ch = input.charCodeAt(pos++);
    
    switch(ch) {
    case 110:
        return res('\n');
    
    case 114:
        return res('\r');
    
    case 120: {
        let code2;
        
        ({
            code: code2,
            pos,
        } = readHexChar2(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
        return res(code2 === null ? null : String.fromCharCode(code2));
    }
    
    case 117: {
        let code2;
        
        ({
            code: code2,
            pos,
        } = readCodePoint2(input, pos, lineStart, curLine, throwOnInvalid, errors));
        return res(code2 === null ? null : String.fromCodePoint(code2));
    }
    
    case 116:
        return res('	');
    
    case 98:
        return res('\b');
    
    case 118:
        return res('\v');
    
    case 102:
        return res('\f');
    
    case 13:
        if (input.charCodeAt(pos) === 10) {
            ++pos;
        }
    
    case 10:
        lineStart = pos;
        ++curLine;
    
    case 8232:    
    case 8233:
        return res('');
    
    case 56:    
    case 57:
        if (inTemplate) {
            return res(null);
        } else {
            errors.strictNumericEscape(pos - 1, lineStart, curLine);
        }
    
    default:
        if (ch >= 48 && ch <= 55) {
            const startPos = pos - 1;
            const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
            let octalStr = match[0];
            let octal = parseInt(octalStr, 8);
            
            if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
            }
            
            pos += octalStr.length - 1;
            const next = input.charCodeAt(pos);
            
            if (octalStr !== '0' || next === 56 || next === 57) {
                if (inTemplate) {
                    return res(null);
                } else {
                    errors.strictNumericEscape(startPos, lineStart, curLine);
                }
            }
            
            return res(String.fromCharCode(octal));
        }
        
        return res(String.fromCharCode(ch));
    }
}

function readHexChar2(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
    const initialPos = pos;
    let n2;
    
    ({n: n2, pos} = readInt2(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
    
    if (n2 === null) {
        if (throwOnInvalid) {
            errors.invalidEscapeSequence(initialPos, lineStart, curLine);
        } else {
            pos = initialPos - 1;
        }
    }
    
    return {
        code: n2,
        pos,
    };
}

function readInt2(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
    const start = pos;
    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings2.hex : forbiddenNumericSeparatorSiblings2.decBinOct;
    const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling2.hex : radix === 10 ? isAllowedNumericSeparatorSibling2.dec : radix === 8 ? isAllowedNumericSeparatorSibling2.oct : isAllowedNumericSeparatorSibling2.bin;
    let invalid = false;
    let total = 0;
    
    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        const code2 = input.charCodeAt(pos);
        let val;
        
        if (code2 === 95 && allowNumSeparator !== 'bail') {
            const prev = input.charCodeAt(pos - 1);
            const next = input.charCodeAt(pos + 1);
            
            if (!allowNumSeparator) {
                if (bailOnError)
                    return {
                        n: null,
                        pos,
                    };
                
                errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
            } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
                if (bailOnError)
                    return {
                        n: null,
                        pos,
                    };
                
                errors.unexpectedNumericSeparator(pos, lineStart, curLine);
            }
            
            ++pos;
            continue;
        }
        
        if (code2 >= 97) {
            val = code2 - 97 + 10;
        } else if (code2 >= 65) {
            val = code2 - 65 + 10;
        } else if (_isDigit2(code2)) {
            val = code2 - 48;
        } else {
            val = Infinity;
        }
        
        if (val >= radix) {
            if (val <= 9 && bailOnError) {
                return {
                    n: null,
                    pos,
                };
            } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
                val = 0;
            } else if (forceLen) {
                val = 0;
                invalid = true;
            } else {
                break;
            }

        }
        
        ++pos;
        total = total * radix + val;
    }
    
    if (pos === start || len != null && pos - start !== len || invalid) {
        return {
            n: null,
            pos,
        };
    }
    
    return {
        n: total,
        pos,
    };
}

function readCodePoint2(input, pos, lineStart, curLine, throwOnInvalid, errors) {
    const ch = input.charCodeAt(pos);
    let code2;
    
    if (ch === 123) {
        ++pos;
        ({
            code: code2,
            pos,
        } = readHexChar2(input, pos, lineStart, curLine, input.indexOf('}', pos) - pos, true, throwOnInvalid, errors));
        ++pos;
        
        if (code2 !== null && code2 > 1114111) {
            if (throwOnInvalid) {
                errors.invalidCodePoint(pos, lineStart, curLine);
            } else {
                return {
                    code: null,
                    pos,
                };
            }
        }
    } else {
        ({
            code: code2,
            pos,
        } = readHexChar2(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
    }
    
    return {
        code: code2,
        pos,
    };
}

function buildPosition(pos, lineStart, curLine) {
    return new Position(curLine, pos - lineStart, pos);
}

var VALID_REGEX_FLAGS = /* @__PURE__ */new Set([
    103,
    109,
    115,
    105,
    121,
    117,
    100,
    118,
]);

var Token = class {
    constructor(state) {
        const startIndex = state.startIndex || 0;
        
        this.type = state.type;
        this.value = state.value;
        this.start = startIndex + state.start;
        this.end = startIndex + state.end;
        this.loc = new SourceLocation(state.startLoc, state.endLoc);
    }
};

var Tokenizer = class extends CommentsParser {
    isLookahead;
    tokens = [];
    constructor(options, input) {
        super();
        this.state = new State$2();
        this.state.init(options);
        this.input = input;
        this.length = input.length;
        this.comments = [];
        this.isLookahead = false;
    }
    
    pushToken(token) {
        this.tokens.length = this.state.tokensLength;
        this.tokens.push(token);
        ++this.state.tokensLength;
    }
    
    next() {
        this.checkKeywordEscapes();
        
        if (this.optionFlags & 256) {
            this.pushToken(new Token(this.state));
        }
        
        this.state.lastTokEndLoc = this.state.endLoc;
        this.state.lastTokStartLoc = this.state.startLoc;
        this.nextToken();
    }
    
    eat(type) {
        if (this.match(type)) {
            this.next();
            return true;
        } else {
            return false;
        }
    }
    
    match(type) {
        return this.state.type === type;
    }
    
    createLookaheadState(state) {
        return {
            pos: state.pos,
            value: null,
            type: state.type,
            start: state.start,
            end: state.end,
            context: [this.curContext()],
            inType: state.inType,
            startLoc: state.startLoc,
            lastTokEndLoc: state.lastTokEndLoc,
            curLine: state.curLine,
            lineStart: state.lineStart,
            curPosition: state.curPosition,
        };
    }
    
    lookahead() {
        const old = this.state;
        
        this.state = this.createLookaheadState(old);
        this.isLookahead = true;
        this.nextToken();
        this.isLookahead = false;
        const curr = this.state;
        
        this.state = old;
        return curr;
    }
    
    nextTokenStart() {
        return this.nextTokenStartSince(this.state.pos);
    }
    
    nextTokenStartSince(pos) {
        skipWhiteSpace.lastIndex = pos;
        return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
    }
    
    lookaheadCharCode() {
        return this.lookaheadCharCodeSince(this.state.pos);
    }
    
    lookaheadCharCodeSince(pos) {
        return this.input.charCodeAt(this.nextTokenStartSince(pos));
    }
    
    nextTokenInLineStart() {
        return this.nextTokenInLineStartSince(this.state.pos);
    }
    
    nextTokenInLineStartSince(pos) {
        skipWhiteSpaceInLine.lastIndex = pos;
        return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
    }
    
    lookaheadInLineCharCode() {
        return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    
    codePointAtPos(pos) {
        let cp = this.input.charCodeAt(pos);
        
        if ((cp & 64512) === 55296 && ++pos < this.input.length) {
            const trail = this.input.charCodeAt(pos);
            
            if ((trail & 64512) === 56320) {
                cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
            }
        }
        
        return cp;
    }
    
    setStrict(strict) {
        this.state.strict = strict;
        
        if (strict) {
            this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at));
            this.state.strictErrors.clear();
        }
    }
    
    curContext() {
        return this.state.context[this.state.context.length - 1];
    }
    
    nextToken() {
        this.skipSpace();
        this.state.start = this.state.pos;
        
        if (!this.isLookahead)
            this.state.startLoc = this.state.curPosition();
        
        if (this.state.pos >= this.length) {
            this.finishToken(135);
            return;
        }
        
        this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    
    skipBlockComment(commentEnd) {
        let startLoc;
        
        if (!this.isLookahead)
            startLoc = this.state.curPosition();
        
        const start = this.state.pos;
        const end = this.input.indexOf(commentEnd, start + 2);
        
        if (end === -1) {
            throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
        }
        
        this.state.pos = end + commentEnd.length;
        lineBreakG.lastIndex = start + 2;
        while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
            ++this.state.curLine;
            this.state.lineStart = lineBreakG.lastIndex;
        }
        
        if (this.isLookahead)
            return;
        
        const comment = {
            type: 'CommentBlock',
            value: this.input.slice(start + 2, end),
            start: this.sourceToOffsetPos(start),
            end: this.sourceToOffsetPos(end + commentEnd.length),
            loc: new SourceLocation(startLoc, this.state.curPosition()),
        };
        
        if (this.optionFlags & 256)
            this.pushToken(comment);
        
        return comment;
    }
    
    skipLineComment(startSkip) {
        const start = this.state.pos;
        let startLoc;
        
        if (!this.isLookahead)
            startLoc = this.state.curPosition();
        
        let ch = this.input.charCodeAt(this.state.pos += startSkip);
        
        if (this.state.pos < this.length) {
            while (!isNewLine$1(ch) && ++this.state.pos < this.length) {
                ch = this.input.charCodeAt(this.state.pos);
            }
        }
        
        if (this.isLookahead)
            return;
        
        const end = this.state.pos;
        const value = this.input.slice(start + startSkip, end);
        
        const comment = {
            type: 'CommentLine',
            value,
            start: this.sourceToOffsetPos(start),
            end: this.sourceToOffsetPos(end),
            loc: new SourceLocation(startLoc, this.state.curPosition()),
        };
        
        if (this.optionFlags & 256)
            this.pushToken(comment);
        
        return comment;
    }
    
    skipSpace() {
        const spaceStart = this.state.pos;
        const comments = this.optionFlags & 4096 ? [] : null;
        
        loop:         while (this.state.pos < this.length) {
            const ch = this.input.charCodeAt(this.state.pos);
            
            switch(ch) {
            case 32:            
            case 160:            
            case 9:
                ++this.state.pos;
                break;
            
            case 13:
                if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                    ++this.state.pos;
                }
            
            case 10:            
            case 8232:            
            case 8233:
                ++this.state.pos;
                ++this.state.curLine;
                this.state.lineStart = this.state.pos;
                break;
            
            case 47:
                switch(this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                    const comment = this.skipBlockComment('*/');
                    
                    if (comment !== void 0) {
                        this.addComment(comment);
                        comments?.push(comment);
                    }
                    
                    break;
                }
                
                case 47: {
                    const comment = this.skipLineComment(2);
                    
                    if (comment !== void 0) {
                        this.addComment(comment);
                        comments?.push(comment);
                    }
                    
                    break;
                }
                
                default:
                    break loop;
                }
                
                break;
            
            default:
                if (isWhitespace(ch)) {
                    ++this.state.pos;
                } else if (ch === 45 && !this.inModule && this.optionFlags & 8192) {
                    const pos = this.state.pos;
                    
                    if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                        const comment = this.skipLineComment(3);
                        
                        if (comment !== void 0) {
                            this.addComment(comment);
                            comments?.push(comment);
                        }
                    } else {
                        break loop;
                    }
                } else if (ch === 60 && !this.inModule && this.optionFlags & 8192) {
                    const pos = this.state.pos;
                    
                    if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                        const comment = this.skipLineComment(4);
                        
                        if (comment !== void 0) {
                            this.addComment(comment);
                            comments?.push(comment);
                        }
                    } else {
                        break loop;
                    }
                } else {
                    break loop;
                }

            }
        }
        if (comments?.length > 0) {
            const end = this.state.pos;
            const commentWhitespace = {
                start: this.sourceToOffsetPos(spaceStart),
                end: this.sourceToOffsetPos(end),
                comments,
                leadingNode: null,
                trailingNode: null,
                containingNode: null,
            };
            
            this.state.commentStack.push(commentWhitespace);
        }
    }
    
    finishToken(type, val) {
        this.state.end = this.state.pos;
        this.state.endLoc = this.state.curPosition();
        const prevType = this.state.type;
        
        this.state.type = type;
        this.state.value = val;
        
        if (!this.isLookahead) {
            this.updateContext(prevType);
        }
    }
    
    replaceToken(type) {
        this.state.type = type;
        this.updateContext();
    }
    
    readToken_numberSign() {
        if (this.state.pos === 0 && this.readToken_interpreter()) {
            return;
        }
        
        const nextPos = this.state.pos + 1;
        const next = this.codePointAtPos(nextPos);
        
        if (next >= 48 && next <= 57) {
            throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());
        }
        
        if (isIdentifierStart2(next)) {
            ++this.state.pos;
            this.finishToken(134, this.readWord1(next));
        } else if (next === 92) {
            ++this.state.pos;
            this.finishToken(134, this.readWord1());
        } else {
            this.finishOp(23, 1);
        }
    }
    
    readToken_dot() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        
        if (next >= 48 && next <= 57) {
            this.readNumber(true);
            return;
        }
        
        if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
            this.state.pos += 3;
            this.finishToken(17);
        } else {
            ++this.state.pos;
            this.finishToken(12);
        }
    }
    
    readToken_slash() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        
        if (next === 61) {
            this.finishOp(27, 2);
        } else {
            this.finishOp(52, 1);
        }
    }
    
    readToken_interpreter() {
        if (this.state.pos !== 0 || this.length < 2)
            return false;
        
        let ch = this.input.charCodeAt(this.state.pos + 1);
        
        if (ch !== 33)
            return false;
        
        const start = this.state.pos;
        
        this.state.pos += 1;
        while (!isNewLine$1(ch) && ++this.state.pos < this.length) {
            ch = this.input.charCodeAt(this.state.pos);
        }
        
        const value = this.input.slice(start + 2, this.state.pos);
        this.finishToken(24, value);
        return true;
    }
    
    readToken_mult_modulo(code2) {
        let type = code2 === 42 ? 51 : 50;
        let width = 1;
        let next = this.input.charCodeAt(this.state.pos + 1);
        
        if (code2 === 42 && next === 42) {
            width++;
            next = this.input.charCodeAt(this.state.pos + 2);
            type = 53;
        }
        
        if (next === 61 && !this.state.inType) {
            width++;
            type = code2 === 37 ? 29 : 26;
        }
        
        this.finishOp(type, width);
    }
    
    readToken_pipe_amp(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        
        if (next === code2) {
            if (this.input.charCodeAt(this.state.pos + 2) === 61) {
                this.finishOp(26, 3);
            } else {
                this.finishOp(code2 === 124 ? 37 : 38, 2);
            }
            
            return;
        }
        
        if (code2 === 124) {
            if (next === 62) {
                this.finishOp(35, 2);
                return;
            }
        }
        
        if (next === 61) {
            this.finishOp(26, 2);
            return;
        }
        
        this.finishOp(code2 === 124 ? 39 : 41, 1);
    }
    
    readToken_caret() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        
        if (next === 61 && !this.state.inType) {
            this.finishOp(28, 2);
        } else if (next === 94 && this.hasPlugin(['pipelineOperator', {proposal: 'hack', topicToken: '^^'}])) {
            this.finishOp(33, 2);
            const lookaheadCh = this.input.codePointAt(this.state.pos);
            
            if (lookaheadCh === 94) {
                this.unexpected();
            }
        } else {
            this.finishOp(40, 1);
        }
    }
    
    readToken_atSign() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        
        if (next === 64 && this.hasPlugin(['pipelineOperator', {proposal: 'hack', topicToken: '@@'}])) {
            this.finishOp(34, 2);
        } else {
            this.finishOp(22, 1);
        }
    }
    
    readToken_plus_min(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        
        if (next === code2) {
            this.finishOp(30, 2);
            return;
        }
        
        if (next === 61) {
            this.finishOp(26, 2);
        } else {
            this.finishOp(49, 1);
        }
    }
    
    readToken_lt() {
        const {pos} = this.state;
        
        const next = this.input.charCodeAt(pos + 1);
        
        if (next === 60) {
            if (this.input.charCodeAt(pos + 2) === 61) {
                this.finishOp(26, 3);
                return;
            }
            
            this.finishOp(47, 2);
            return;
        }
        
        if (next === 61) {
            this.finishOp(45, 2);
            return;
        }
        
        this.finishOp(43, 1);
    }
    
    readToken_gt() {
        const {pos} = this.state;
        
        const next = this.input.charCodeAt(pos + 1);
        
        if (next === 62) {
            const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
            
            if (this.input.charCodeAt(pos + size) === 61) {
                this.finishOp(26, size + 1);
                return;
            }
            
            this.finishOp(48, size);
            return;
        }
        
        if (next === 61) {
            this.finishOp(45, 2);
            return;
        }
        
        this.finishOp(44, 1);
    }
    
    readToken_eq_excl(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        
        if (next === 61) {
            this.finishOp(42, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
            return;
        }
        
        if (code2 === 61 && next === 62) {
            this.state.pos += 2;
            this.finishToken(15);
            return;
        }
        
        this.finishOp(code2 === 61 ? 25 : 31, 1);
    }
    
    readToken_question() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        const next2 = this.input.charCodeAt(this.state.pos + 2);
        
        if (next === 63) {
            if (next2 === 61) {
                this.finishOp(26, 3);
            } else {
                this.finishOp(36, 2);
            }
        } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
            this.state.pos += 2;
            this.finishToken(14);
        } else {
            ++this.state.pos;
            this.finishToken(13);
        }
    }
    
    getTokenFromCode(code2) {
        switch(code2) {
        case 46:
            this.readToken_dot();
            return;
        
        case 40:
            ++this.state.pos;
            this.finishToken(6);
            return;
        
        case 41:
            ++this.state.pos;
            this.finishToken(7);
            return;
        
        case 59:
            ++this.state.pos;
            this.finishToken(9);
            return;
        
        case 44:
            ++this.state.pos;
            this.finishToken(8);
            return;
        
        case 91:
            ++this.state.pos;
            this.finishToken(0);
            return;
        
        case 93:
            ++this.state.pos;
            this.finishToken(1);
            return;
        
        case 123:
            ++this.state.pos;
            this.finishToken(2);
            return;
        
        case 125:
            ++this.state.pos;
            this.finishToken(4);
            return;
        
        case 58:
            if (this.hasPlugin('functionBind') && this.input.charCodeAt(this.state.pos + 1) === 58) {
                this.finishOp(11, 2);
            } else {
                ++this.state.pos;
                this.finishToken(10);
            }
            
            return;
        
        case 63:
            this.readToken_question();
            return;
        
        case 96:
            this.readTemplateToken();
            return;
        
        case 48: {
            const next = this.input.charCodeAt(this.state.pos + 1);
            
            if (next === 120 || next === 88) {
                this.readRadixNumber(16);
                return;
            }
            
            if (next === 111 || next === 79) {
                this.readRadixNumber(8);
                return;
            }
            
            if (next === 98 || next === 66) {
                this.readRadixNumber(2);
                return;
            }
        }
        
        case 49:        
        case 50:        
        case 51:        
        case 52:        
        case 53:        
        case 54:        
        case 55:        
        case 56:        
        case 57:
            this.readNumber(false);
            return;
        
        case 34:        
        case 39:
            this.readString(code2);
            return;
        
        case 47:
            this.readToken_slash();
            return;
        
        case 37:        
        case 42:
            this.readToken_mult_modulo(code2);
            return;
        
        case 124:        
        case 38:
            this.readToken_pipe_amp(code2);
            return;
        
        case 94:
            this.readToken_caret();
            return;
        
        case 43:        
        case 45:
            this.readToken_plus_min(code2);
            return;
        
        case 60:
            this.readToken_lt();
            return;
        
        case 62:
            this.readToken_gt();
            return;
        
        case 61:        
        case 33:
            this.readToken_eq_excl(code2);
            return;
        
        case 126:
            this.finishOp(32, 1);
            return;
        
        case 64:
            this.readToken_atSign();
            return;
        
        case 35:
            this.readToken_numberSign();
            return;
        
        case 92:
            this.readWord();
            return;
        
        default:
            if (isIdentifierStart2(code2)) {
                this.readWord(code2);
                return;
            }
        }
        
        throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {
            unexpected: String.fromCodePoint(code2),
        });
    }
    
    finishOp(type, size) {
        const str = this.input.slice(this.state.pos, this.state.pos + size);
        
        this.state.pos += size;
        this.finishToken(type, str);
    }
    
    readRegexp() {
        const startLoc = this.state.startLoc;
        const start = this.state.start + 1;
        let escaped, inClass;
        
        let {pos} = this.state;
        
        for (;; ++pos) {
            if (pos >= this.length) {
                throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
            }
            
            const ch = this.input.charCodeAt(pos);
            
            if (isNewLine$1(ch)) {
                throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
            }
            
            if (escaped) {
                escaped = false;
            } else {
                if (ch === 91) {
                    inClass = true;
                } else if (ch === 93 && inClass) {
                    inClass = false;
                } else if (ch === 47 && !inClass) {
                    break;
                }
                
                escaped = ch === 92;
            }
        }
        
        const content = this.input.slice(start, pos);
        ++pos;
        let mods = '';
        const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
        
        while (pos < this.length) {
            const cp = this.codePointAtPos(pos);
            const char = String.fromCharCode(cp);
            
            if (VALID_REGEX_FLAGS.has(cp)) {
                if (cp === 118) {
                    if (mods.includes('u')) {
                        this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
                    }
                } else if (cp === 117) {
                    if (mods.includes('v')) {
                        this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
                    }
                }
                
                if (mods.includes(char)) {
                    this.raise(Errors.DuplicateRegExpFlags, nextPos());
                }
            } else if (isIdentifierChar2(cp) || cp === 92) {
                this.raise(Errors.MalformedRegExpFlags, nextPos());
            } else {
                break;
            }
            
            ++pos;
            mods += char;
        }
        
        this.state.pos = pos;
        this.finishToken(133, {
            pattern: content,
            flags: mods,
        });
    }
    
    readInt(radix, len, forceLen = false, allowNumSeparator = true) {
        const {n: n2, pos} = readInt2(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);
        
        this.state.pos = pos;
        return n2;
    }
    
    readRadixNumber(radix) {
        const start = this.state.pos;
        const startLoc = this.state.curPosition();
        let isBigInt = false;
        
        this.state.pos += 2;
        const val = this.readInt(radix);
        
        if (val == null) {
            this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {
                radix,
            });
        }
        
        const next = this.input.charCodeAt(this.state.pos);
        
        if (next === 110) {
            ++this.state.pos;
            isBigInt = true;
        }
        
        if (isIdentifierStart2(this.codePointAtPos(this.state.pos))) {
            throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
        }
        
        if (isBigInt) {
            const str = this
                .input
                .slice(start, this
                .state
                .pos)
                .replace(/[_n]/g, '');
            this.finishToken(132, str);
            return;
        }
        
        this.finishToken(131, val);
    }
    
    readNumber(startsWithDot) {
        const start = this.state.pos;
        const startLoc = this.state.curPosition();
        let isFloat = false;
        let isBigInt = false;
        let isOctal = false;
        
        if (!startsWithDot && this.readInt(10) === null) {
            this.raise(Errors.InvalidNumber, this.state.curPosition());
        }
        
        const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        
        if (hasLeadingZero) {
            const integer = this.input.slice(start, this.state.pos);
            this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);
            
            if (!this.state.strict) {
                const underscorePos = integer.indexOf('_');
                
                if (underscorePos > 0) {
                    this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(
                        startLoc,
                        underscorePos,
                    ));
                }
            }
            
            isOctal = hasLeadingZero && !/[89]/.test(integer);
        }
        
        let next = this.input.charCodeAt(this.state.pos);
        
        if (next === 46 && !isOctal) {
            ++this.state.pos;
            this.readInt(10);
            isFloat = true;
            next = this.input.charCodeAt(this.state.pos);
        }
        
        if ((next === 69 || next === 101) && !isOctal) {
            next = this.input.charCodeAt(++this.state.pos);
            
            if (next === 43 || next === 45) {
                ++this.state.pos;
            }
            
            if (this.readInt(10) === null) {
                this.raise(Errors.InvalidOrMissingExponent, startLoc);
            }
            
            isFloat = true;
            next = this.input.charCodeAt(this.state.pos);
        }
        
        if (next === 110) {
            if (isFloat || hasLeadingZero) {
                this.raise(Errors.InvalidBigIntLiteral, startLoc);
            }
            
            ++this.state.pos;
            isBigInt = true;
        }
        
        if (isIdentifierStart2(this.codePointAtPos(this.state.pos))) {
            throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
        }
        
        const str = this
            .input
            .slice(start, this
            .state
            .pos)
            .replace(/[_mn]/g, '');
        
        if (isBigInt) {
            this.finishToken(132, str);
            return;
        }
        
        const val = isOctal ? parseInt(str, 8) : parseFloat(str);
        this.finishToken(131, val);
    }
    
    readCodePoint(throwOnInvalid) {
        const {code: code2, pos} = readCodePoint2(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
        
        this.state.pos = pos;
        return code2;
    }
    
    readString(quote) {
        const {
            str,
            pos,
            curLine,
            lineStart,
        } = readStringContents2(quote === 34 ? 'double' : 'single', this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
        
        this.state.pos = pos + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        this.finishToken(130, str);
    }
    
    readTemplateContinuation() {
        if (!this.match(4)) {
            this.unexpected(null, 4);
        }
        
        this.state.pos--;
        this.readTemplateToken();
    }
    
    readTemplateToken() {
        const opening = this.input[this.state.pos];
        const {
            str,
            firstInvalidLoc,
            pos,
            curLine,
            lineStart,
        } = readStringContents2('template', this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
        
        this.state.pos = pos + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        
        if (firstInvalidLoc) {
            this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, this.sourceToOffsetPos(firstInvalidLoc.pos));
        }
        
        if (this.input.codePointAt(pos) === 96) {
            this.finishToken(20, firstInvalidLoc ? null : opening + str + '`');
        } else {
            this.state.pos++;
            this.finishToken(21, firstInvalidLoc ? null : opening + str + '${');
        }
    }
    
    recordStrictModeErrors(toParseError, at) {
        const index2 = at.index;
        
        if (this.state.strict && !this.state.strictErrors.has(index2)) {
            this.raise(toParseError, at);
        } else {
            this.state.strictErrors.set(index2, [toParseError, at]);
        }
    }
    
    readWord1(firstCode) {
        this.state.containsEsc = false;
        let word = '';
        const start = this.state.pos;
        let chunkStart = this.state.pos;
        
        if (firstCode !== void 0) {
            this.state.pos += firstCode <= 65535 ? 1 : 2;
        }
        
        while (this.state.pos < this.length) {
            const ch = this.codePointAtPos(this.state.pos);
            
            if (isIdentifierChar2(ch)) {
                this.state.pos += ch <= 65535 ? 1 : 2;
            } else if (ch === 92) {
                this.state.containsEsc = true;
                word += this.input.slice(chunkStart, this.state.pos);
                const escStart = this.state.curPosition();
                const identifierCheck = this.state.pos === start ? isIdentifierStart2 : isIdentifierChar2;
                
                if (this.input.charCodeAt(++this.state.pos) !== 117) {
                    this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());
                    chunkStart = this.state.pos - 1;
                    continue;
                }
                
                ++this.state.pos;
                const esc = this.readCodePoint(true);
                
                if (esc !== null) {
                    if (!identifierCheck(esc)) {
                        this.raise(Errors.EscapedCharNotAnIdentifier, escStart);
                    }
                    
                    word += String.fromCodePoint(esc);
                }
                
                chunkStart = this.state.pos;
            } else {
                break;
            }
        }
        
        return word + this.input.slice(chunkStart, this.state.pos);
    }
    
    readWord(firstCode) {
        const word = this.readWord1(firstCode);
        const type = keywords$1$1.get(word);
        
        if (type !== void 0) {
            this.finishToken(type, tokenLabelName(type));
        } else {
            this.finishToken(128, word);
        }
    }
    
    checkKeywordEscapes() {
        const {type} = this.state;
        
        if (tokenIsKeyword(type) && this.state.containsEsc) {
            this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {
                reservedWord: tokenLabelName(type),
            });
        }
    }
    
    raise(toParseError, at, details = {}) {
        const loc = at instanceof Position ? at : at.loc.start;
        const error = toParseError(loc, details);
        
        if (!(this.optionFlags & 2048))
            throw error;
        
        if (!this.isLookahead)
            this.state.errors.push(error);
        
        return error;
    }
    
    raiseOverwrite(toParseError, at, details = {}) {
        const loc = at instanceof Position ? at : at.loc.start;
        const pos = loc.index;
        const errors = this.state.errors;
        
        for (let i = errors.length - 1; i >= 0; i--) {
            const error = errors[i];
            
            if (error.loc.index === pos) {
                return errors[i] = toParseError(loc, details);
            }
            
            if (error.loc.index < pos)
                break;
        }
        
        return this.raise(toParseError, at, details);
    }
    
    updateContext() {}
    
    unexpected(loc, type) {
        throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {
            expected: type ? tokenLabelName(type) : null,
        });
    }
    
    expectPlugin(pluginName, loc) {
        if (this.hasPlugin(pluginName)) {
            return true;
        }
        
        throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {
            missingPlugin: [pluginName],
        });
    }
    
    expectOnePlugin(pluginNames) {
        if (!pluginNames.some((name) => this.hasPlugin(name))) {
            throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {
                missingPlugin: pluginNames,
            });
        }
    }
    
    errorBuilder(error) {
        return (pos, lineStart, curLine) => {
            this.raise(error, buildPosition(pos, lineStart, curLine));
        };
    }
    
    errorHandlers_readInt = {
        invalidDigit: (pos, lineStart, curLine, radix) => {
            if (!(this.optionFlags & 2048))
                return false;
            
            this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {
                radix,
            });
            return true;
        },
        numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator),
    };
    errorHandlers_readCodePoint = {
        ...this.errorHandlers_readInt,
        invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint),
    };
    errorHandlers_readStringContents_string = {
        ...this.errorHandlers_readCodePoint,
        strictNumericEscape: (pos, lineStart, curLine) => {
            this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));
        },
        unterminated: (pos, lineStart, curLine) => {
            throw this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));
        },
    };
    errorHandlers_readStringContents_template = {
        ...this.errorHandlers_readCodePoint,
        strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
        unterminated: (pos, lineStart, curLine) => {
            throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));
        },
    };
};

var ClassScope = class {
    privateNames =     /* @__PURE__ */new Set();
    loneAccessors =     /* @__PURE__ */new Map();
    undefinedPrivateNames =     /* @__PURE__ */new Map();
};

var ClassScopeHandler = class {
    parser;
    stack = [];
    undefinedPrivateNames =     /* @__PURE__ */new Map();
    constructor(parser) {
        this.parser = parser;
    }
    
    current() {
        return this.stack[this.stack.length - 1];
    }
    
    enter() {
        this.stack.push(new ClassScope());
    }
    
    exit() {
        const oldClassScope = this.stack.pop();
        const current = this.current();
        
        for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
            if (current) {
                if (!current.undefinedPrivateNames.has(name)) {
                    current.undefinedPrivateNames.set(name, loc);
                }
            } else {
                this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
                    identifierName: name,
                });
            }
        }
    }
    
    declarePrivateName(name, elementType, loc) {
        const {
            privateNames,
            loneAccessors,
            undefinedPrivateNames,
        } = this.current();
        
        let redefined = privateNames.has(name);
        
        if (elementType & 3) {
            const accessor = redefined && loneAccessors.get(name);
            
            if (accessor) {
                const oldStatic = accessor & 4;
                const newStatic = elementType & 4;
                const oldKind = accessor & 3;
                const newKind = elementType & 3;
                
                redefined = oldKind === newKind || oldStatic !== newStatic;
                
                if (!redefined)
                    loneAccessors.delete(name);
            } else if (!redefined) {
                loneAccessors.set(name, elementType);
            }
        }
        
        if (redefined) {
            this.parser.raise(Errors.PrivateNameRedeclaration, loc, {
                identifierName: name,
            });
        }
        
        privateNames.add(name);
        undefinedPrivateNames.delete(name);
    }
    
    usePrivateName(name, loc) {
        let classScope;
        
        for (classScope of this.stack) {
            if (classScope.privateNames.has(name))
                return;
        }
        
        if (classScope) {
            classScope.undefinedPrivateNames.set(name, loc);
        } else {
            this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
                identifierName: name,
            });
        }
    }
};

var ExpressionScope = class {
    constructor(type = 0) {
        this.type = type;
    }
    
    canBeArrowParameterDeclaration() {
        return this.type === 2 || this.type === 1;
    }
    
    isCertainlyParameterDeclaration() {
        return this.type === 3;
    }
};

var ArrowHeadParsingScope = class extends ExpressionScope {
    declarationErrors =     /* @__PURE__ */new Map();
    constructor(type) {
        super(type);
    }
    
    recordDeclarationError(ParsingErrorClass, at) {
        const index2 = at.index;
        this.declarationErrors.set(index2, [ParsingErrorClass, at]);
    }
    
    clearDeclarationError(index2) {
        this.declarationErrors.delete(index2);
    }
    
    iterateErrors(iterator) {
        this.declarationErrors.forEach(iterator);
    }
};

var ExpressionScopeHandler = class {
    parser;
    stack = [
        new ExpressionScope(),
    ];
    constructor(parser) {
        this.parser = parser;
    }
    
    enter(scope2) {
        this.stack.push(scope2);
    }
    
    exit() {
        this.stack.pop();
    }
    
    recordParameterInitializerError(toParseError, node) {
        const origin = node.loc.start;
        const {stack} = this;
        
        let i = stack.length - 1;
        let scope2 = stack[i];
        
        while (!scope2.isCertainlyParameterDeclaration()) {
            if (scope2.canBeArrowParameterDeclaration()) {
                scope2.recordDeclarationError(toParseError, origin);
            } else {
                return;
            }
            
            scope2 = stack[--i];
        }
        
        this.parser.raise(toParseError, origin);
    }
    
    recordArrowParameterBindingError(error, node) {
        const {stack} = this;
        
        const scope2 = stack[stack.length - 1];
        const origin = node.loc.start;
        
        if (scope2.isCertainlyParameterDeclaration()) {
            this.parser.raise(error, origin);
        } else if (scope2.canBeArrowParameterDeclaration()) {
            scope2.recordDeclarationError(error, origin);
        } else {
            return;
        }
    }
    
    recordAsyncArrowParametersError(at) {
        const {stack} = this;
        
        let i = stack.length - 1;
        let scope2 = stack[i];
        
        while (scope2.canBeArrowParameterDeclaration()) {
            if (scope2.type === 2) {
                scope2.recordDeclarationError(Errors.AwaitBindingIdentifier, at);
            }
            
            scope2 = stack[--i];
        }
    }
    
    validateAsPattern() {
        const {stack} = this;
        
        const currentScope = stack[stack.length - 1];
        
        if (!currentScope.canBeArrowParameterDeclaration())
            return;
        
        currentScope.iterateErrors(([toParseError, loc]) => {
            this.parser.raise(toParseError, loc);
            let i = stack.length - 2;
            let scope2 = stack[i];
            
            while (scope2.canBeArrowParameterDeclaration()) {
                scope2.clearDeclarationError(loc.index);
                scope2 = stack[--i];
            }
        });
    }
};

function newParameterDeclarationScope() {
    return new ExpressionScope(3);
}

function newArrowHeadScope() {
    return new ArrowHeadParsingScope(1);
}

function newAsyncArrowScope() {
    return new ArrowHeadParsingScope(2);
}

function newExpressionScope() {
    return new ExpressionScope();
}

var UtilParser = class extends Tokenizer {
    addExtra(node, key, value, enumerable = true) {
        if (!node)
            return;
        
        let {extra} = node;
        
        if (extra == null) {
            extra = {};
            node.extra = extra;
        }
        
        if (enumerable) {
            extra[key] = value;
        } else {
            Object.defineProperty(extra, key, {
                enumerable,
                value,
            });
        }
    }
    
    isContextual(token) {
        return this.state.type === token && !this.state.containsEsc;
    }
    
    isUnparsedContextual(nameStart, name) {
        if (this.input.startsWith(name, nameStart)) {
            const nextCh = this.input.charCodeAt(nameStart + name.length);
            return !(isIdentifierChar2(nextCh) || (nextCh & 64512) === 55296);
        }
        
        return false;
    }
    
    isLookaheadContextual(name) {
        const next = this.nextTokenStart();
        return this.isUnparsedContextual(next, name);
    }
    
    eatContextual(token) {
        if (this.isContextual(token)) {
            this.next();
            return true;
        }
        
        return false;
    }
    
    expectContextual(token, toParseError) {
        if (!this.eatContextual(token)) {
            if (toParseError != null) {
                throw this.raise(toParseError, this.state.startLoc);
            }
            
            this.unexpected(null, token);
        }
    }
    
    canInsertSemicolon() {
        return this.match(135) || this.match(4) || this.hasPrecedingLineBreak();
    }
    
    hasPrecedingLineBreak() {
        return hasNewLine(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
    }
    
    hasFollowingLineBreak() {
        return hasNewLine(this.input, this.state.end, this.nextTokenStart());
    }
    
    isLineTerminator() {
        return this.eat(9) || this.canInsertSemicolon();
    }
    
    semicolon(allowAsi = true) {
        if (allowAsi ? this.isLineTerminator() : this.eat(9))
            return;
        
        this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);
    }
    
    expect(type, loc) {
        if (!this.eat(type)) {
            this.unexpected(loc, type);
        }
    }
    
    tryParse(fn, oldState = this.state.clone()) {
        const abortSignal = {
            node: null,
        };
        
        try {
            const node = fn((node2 = null) => {
                abortSignal.node = node2;
                throw abortSignal;
            });
            
            if (this.state.errors.length > oldState.errors.length) {
                const failState = this.state;
                
                this.state = oldState;
                this.state.tokensLength = failState.tokensLength;
                return {
                    node,
                    error: failState.errors[oldState.errors.length],
                    thrown: false,
                    aborted: false,
                    failState,
                };
            }
            
            return {
                node,
                error: null,
                thrown: false,
                aborted: false,
                failState: null,
            };
        } catch(error) {
            const failState = this.state;
            
            this.state = oldState;
            
            if (error instanceof SyntaxError) {
                return {
                    node: null,
                    error,
                    thrown: true,
                    aborted: false,
                    failState,
                };
            }
            
            if (error === abortSignal) {
                return {
                    node: abortSignal.node,
                    error: null,
                    thrown: false,
                    aborted: true,
                    failState,
                };
            }
            
            throw error;
        }
    }
    
    checkExpressionErrors(refExpressionErrors, andThrow) {
        if (!refExpressionErrors)
            return false;
        
        const {
            shorthandAssignLoc,
            doubleProtoLoc,
            privateKeyLoc,
            optionalParametersLoc,
            voidPatternLoc,
        } = refExpressionErrors;
        
        const hasErrors = !!shorthandAssignLoc
            || !!doubleProtoLoc
            || !!optionalParametersLoc
            || !!privateKeyLoc
            || !!voidPatternLoc;
        
        if (!andThrow) {
            return hasErrors;
        }
        
        if (shorthandAssignLoc != null) {
            this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
        }
        
        if (doubleProtoLoc != null) {
            this.raise(Errors.DuplicateProto, doubleProtoLoc);
        }
        
        if (privateKeyLoc != null) {
            this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
        }
        
        if (optionalParametersLoc != null) {
            this.unexpected(optionalParametersLoc);
        }
        
        if (voidPatternLoc != null) {
            this.raise(Errors.InvalidCoverDiscardElement, voidPatternLoc);
        }
    }
    
    isLiteralPropertyName() {
        return tokenIsLiteralPropertyName(this.state.type);
    }
    
    isPrivateName(node) {
        return node.type === 'PrivateName';
    }
    
    getPrivateNameSV(node) {
        return node.id.name;
    }
    
    hasPropertyAsPrivateName(node) {
        return (node.type === 'MemberExpression' || node.type === 'OptionalMemberExpression') && this.isPrivateName(node.property);
    }
    
    isObjectProperty(node) {
        return node.type === 'ObjectProperty';
    }
    
    isObjectMethod(node) {
        return node.type === 'ObjectMethod';
    }
    
    initializeScopes(inModule = this.options.sourceType === 'module') {
        const oldLabels = this.state.labels;
        
        this.state.labels = [];
        const oldExportedIdentifiers = this.exportedIdentifiers;
        
        this.exportedIdentifiers =         /* @__PURE__ */new Set();
        const oldInModule = this.inModule;
        
        this.inModule = inModule;
        const oldScope = this.scope;
        const ScopeHandler2 = this.getScopeHandler();
        
        this.scope = new ScopeHandler2(this, inModule);
        const oldProdParam = this.prodParam;
        
        this.prodParam = new ProductionParameterHandler();
        const oldClassScope = this.classScope;
        
        this.classScope = new ClassScopeHandler(this);
        const oldExpressionScope = this.expressionScope;
        
        this.expressionScope = new ExpressionScopeHandler(this);
        return () => {
            this.state.labels = oldLabels;
            this.exportedIdentifiers = oldExportedIdentifiers;
            this.inModule = oldInModule;
            this.scope = oldScope;
            this.prodParam = oldProdParam;
            this.classScope = oldClassScope;
            this.expressionScope = oldExpressionScope;
        };
    }
    
    enterInitialScopes() {
        let paramFlags = 0;
        
        if (this.inModule || this.optionFlags & 1) {
            paramFlags |= 2;
        }
        
        if (this.optionFlags & 32) {
            paramFlags |= 1;
        }
        
        const isCommonJS = !this.inModule && this.options.sourceType === 'commonjs';
        
        if (isCommonJS || this.optionFlags & 2) {
            paramFlags |= 4;
        }
        
        this.prodParam.enter(paramFlags);
        let scopeFlags = isCommonJS ? 514 : 1;
        
        if (this.optionFlags & 4) {
            scopeFlags |= 512;
        }
        
        if (this.optionFlags & 16) {
            scopeFlags |= 16 | 32;
        }
        
        this.scope.enter(scopeFlags);
    }
    
    checkDestructuringPrivate(refExpressionErrors) {
        const {privateKeyLoc} = refExpressionErrors;
        
        if (privateKeyLoc !== null) {
            this.expectPlugin('destructuringPrivate', privateKeyLoc);
        }
    }
};

var ExpressionErrors = class {
    shorthandAssignLoc = null;
    doubleProtoLoc = null;
    privateKeyLoc = null;
    optionalParametersLoc = null;
    voidPatternLoc = null;
};

var Node$1 = class Node {
    constructor(parser, pos, loc) {
        this.start = pos;
        this.end = 0;
        this.loc = new SourceLocation(loc);
        
        if (parser?.optionFlags & 128)
            this.range = [pos, 0];
        
        if (parser?.filename)
            this.loc.filename = parser.filename;
    }
    
    type = '';
};

var NodePrototype = Node$1.prototype;

var NodeUtils = class extends UtilParser {
    startNode() {
        const loc = this.state.startLoc;
        return new Node$1(this, loc.index, loc);
    }
    
    startNodeAt(loc) {
        return new Node$1(this, loc.index, loc);
    }
    
    startNodeAtNode(type) {
        return this.startNodeAt(type.loc.start);
    }
    
    finishNode(node, type) {
        return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
    }
    
    finishNodeAt(node, type, endLoc) {
        node.type = type;
        node.end = endLoc.index;
        node.loc.end = endLoc;
        
        if (this.optionFlags & 128)
            node.range[1] = endLoc.index;
        
        if (this.optionFlags & 4096) {
            this.processComment(node);
        }
        
        return node;
    }
    
    resetStartLocation(node, startLoc) {
        node.start = startLoc.index;
        node.loc.start = startLoc;
        
        if (this.optionFlags & 128)
            node.range[0] = startLoc.index;
    }
    
    resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
        node.end = endLoc.index;
        node.loc.end = endLoc;
        
        if (this.optionFlags & 128)
            node.range[1] = endLoc.index;
    }
    
    resetStartLocationFromNode(node, locationNode) {
        this.resetStartLocation(node, locationNode.loc.start);
    }
    
    castNodeTo(node, type) {
        node.type = type;
        return node;
    }
    
    cloneIdentifier(node) {
        const {
            type,
            start,
            end,
            loc,
            range,
            name,
        } = node;
        
        const cloned = Object.create(NodePrototype);
        
        cloned.type = type;
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range;
        cloned.name = name;
        
        if (node.extra)
            cloned.extra = node.extra;
        
        return cloned;
    }
    
    cloneStringLiteral(node) {
        const {
            type,
            start,
            end,
            loc,
            range,
            extra,
        } = node;
        
        const cloned = Object.create(NodePrototype);
        
        cloned.type = type;
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range;
        cloned.extra = extra;
        cloned.value = node.value;
        return cloned;
    }
};

var unwrapParenthesizedExpression = (node) => {
    return node.type === 'ParenthesizedExpression' ? unwrapParenthesizedExpression(node.expression) : node;
};

var LValParser = class extends NodeUtils {
    toAssignable(node, isLHS = false) {
        let parenthesized = void 0;
        
        if (node.type === 'ParenthesizedExpression' || node.extra?.parenthesized) {
            parenthesized = unwrapParenthesizedExpression(node);
            
            if (isLHS) {
                if (parenthesized.type === 'Identifier') {
                    this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);
                } else if (parenthesized.type !== 'CallExpression' && parenthesized.type !== 'MemberExpression' && !this.isOptionalMemberExpression(parenthesized)) {
                    this.raise(Errors.InvalidParenthesizedAssignment, node);
                }
            } else {
                this.raise(Errors.InvalidParenthesizedAssignment, node);
            }
        }
        
        switch(node.type) {
        case 'Identifier':        
        case 'ObjectPattern':        
        case 'ArrayPattern':        
        case 'AssignmentPattern':        
        case 'RestElement':        
        case 'VoidPattern':
            break;
        
        case 'ObjectExpression':
            this.castNodeTo(node, 'ObjectPattern');
            for (let i = 0, length = node.properties.length, last2 = length - 1; i < length; i++) {
                const prop = node.properties[i];
                const isLast = i === last2;
                this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
                
                if (isLast && prop.type === 'RestElement' && node.extra?.trailingCommaLoc) {
                    this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);
                }
            }
            
            break;
        
        case 'ObjectProperty': {
            const {key, value} = node;
            
            if (this.isPrivateName(key)) {
                this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
            }
            
            this.toAssignable(value, isLHS);
            break;
        }
        
        case 'SpreadElement': {
            throw new Error('Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable\'s caller.');
        }
        
        case 'ArrayExpression':
            this.castNodeTo(node, 'ArrayPattern');
            this.toAssignableList(node.elements, node.extra?.trailingCommaLoc, isLHS);
            break;
        
        case 'AssignmentExpression':
            if (node.operator !== '=') {
                this.raise(Errors.MissingEqInAssignment, node.left.loc.end);
            }
            
            this.castNodeTo(node, 'AssignmentPattern');
            delete node.operator;
            
            if (node.left.type === 'VoidPattern') {
                this.raise(Errors.VoidPatternInitializer, node.left);
            }
            
            this.toAssignable(node.left, isLHS);
            break;
        
        case 'ParenthesizedExpression':
            this.toAssignable(parenthesized, isLHS);
            break;
        }
    }
    
    toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === 'ObjectMethod') {
            this.raise(prop.kind === 'get' || prop.kind === 'set' ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);
        } else if (prop.type === 'SpreadElement') {
            this.castNodeTo(prop, 'RestElement');
            const arg = prop.argument;
            this.checkToRestConversion(arg, false);
            this.toAssignable(arg, isLHS);
            
            if (!isLast) {
                this.raise(Errors.RestTrailingComma, prop);
            }
        } else {
            this.toAssignable(prop, isLHS);
        }
    }
    
    toAssignableList(exprList, trailingCommaLoc, isLHS) {
        const end = exprList.length - 1;
        
        for (let i = 0; i <= end; i++) {
            const elt = exprList[i];
            
            if (!elt)
                continue;
            
            this.toAssignableListItem(exprList, i, isLHS);
            
            if (elt.type === 'RestElement') {
                if (i < end) {
                    this.raise(Errors.RestTrailingComma, elt);
                } else if (trailingCommaLoc) {
                    this.raise(Errors.RestTrailingComma, trailingCommaLoc);
                }
            }
        }
    }
    
    toAssignableListItem(exprList, index2, isLHS) {
        const node = exprList[index2];
        
        if (node.type === 'SpreadElement') {
            this.castNodeTo(node, 'RestElement');
            const arg = node.argument;
            this.checkToRestConversion(arg, true);
            this.toAssignable(arg, isLHS);
        } else {
            this.toAssignable(node, isLHS);
        }
    }
    
    isAssignable(node, isBinding3) {
        switch(node.type) {
        case 'Identifier':        
        case 'ObjectPattern':        
        case 'ArrayPattern':        
        case 'AssignmentPattern':        
        case 'RestElement':        
        case 'VoidPattern':
            return true;
        
        case 'ObjectExpression': {
            const last2 = node.properties.length - 1;
            
            return node.properties.every((prop, i) => {
                return prop.type !== 'ObjectMethod'
                    && (i === last2
                    || prop.type !== 'SpreadElement')
                    && this.isAssignable(prop);
            });
        }
        
        case 'ObjectProperty':
            return this.isAssignable(node.value);
        
        case 'SpreadElement':
            return this.isAssignable(node.argument);
        
        case 'ArrayExpression':
            return node.elements.every((element) => element === null || this.isAssignable(element));
        
        case 'AssignmentExpression':
            return node.operator === '=';
        
        case 'ParenthesizedExpression':
            return this.isAssignable(node.expression);
        
        case 'MemberExpression':        
        case 'OptionalMemberExpression':
            return !isBinding3;
        
        default:
            return false;
        }
    }
    
    toReferencedList(exprList) {
        return exprList;
    }
    
    toReferencedListDeep(exprList, isParenthesizedExpr) {
        this.toReferencedList(exprList, isParenthesizedExpr);
        for (const expr of exprList) {
            if (expr?.type === 'ArrayExpression') {
                this.toReferencedListDeep(expr.elements);
            }
        }
    }
    
    parseSpread(refExpressionErrors) {
        const node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);
        return this.finishNode(node, 'SpreadElement');
    }
    
    parseRestBinding() {
        const node = this.startNode();
        this.next();
        const argument = this.parseBindingAtom();
        
        if (argument.type === 'VoidPattern') {
            this.raise(Errors.UnexpectedVoidPattern, argument);
        }
        
        node.argument = argument;
        return this.finishNode(node, 'RestElement');
    }
    
    parseBindingAtom() {
        switch(this.state.type) {
        case 0: {
            const node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(1, 93, 1);
            return this.finishNode(node, 'ArrayPattern');
        }
        
        case 2:
            return this.parseObjectLike(4, true);
        
        case 84:
            return this.parseVoidPattern(null);
        }
        
        return this.parseIdentifier();
    }
    
    parseBindingList(close, closeCharCode, flags) {
        const allowEmpty = flags & 1;
        const elts = [];
        let first = true;
        
        while (!this.eat(close)) {
            if (first) {
                first = false;
            } else {
                this.expect(8);
            }
            
            if (allowEmpty && this.match(8)) {
                elts.push(null);
            } else if (this.eat(close)) {
                break;
            } else if (this.match(17)) {
                let rest = this.parseRestBinding();
                
                if (flags & 2) {
                    rest = this.parseFunctionParamType(rest);
                }
                
                elts.push(rest);
                
                if (!this.checkCommaAfterRest(closeCharCode)) {
                    this.expect(close);
                    break;
                }
            } else {
                const decorators = [];
                
                if (flags & 2) {
                    if (this.match(22) && this.hasPlugin('decorators')) {
                        this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);
                    }
                    
                    while (this.match(22)) {
                        decorators.push(this.parseDecorator());
                    }
                }
                
                elts.push(this.parseBindingElement(flags, decorators));
            }

        }
        
        return elts;
    }
    
    parseBindingRestProperty(prop) {
        this.next();
        
        if (this.hasPlugin('discardBinding') && this.match(84)) {
            prop.argument = this.parseVoidPattern(null);
            this.raise(Errors.UnexpectedVoidPattern, prop.argument);
        } else {
            prop.argument = this.parseIdentifier();
        }
        
        this.checkCommaAfterRest(125);
        return this.finishNode(prop, 'RestElement');
    }
    
    parseBindingProperty() {
        const {type, startLoc} = this.state;
        
        if (type === 17) {
            return this.parseBindingRestProperty(this.startNode());
        }
        
        const prop = this.startNode();
        
        if (type === 134) {
            this.expectPlugin('destructuringPrivate', startLoc);
            this.classScope.usePrivateName(this.state.value, startLoc);
            prop.key = this.parsePrivateName();
        } else {
            this.parsePropertyName(prop);
        }
        
        prop.method = false;
        return this.parseObjPropValue(prop, startLoc, false, false, true, false);
    }
    
    parseBindingElement(flags, decorators) {
        const left = this.parseMaybeDefault();
        
        if (flags & 2) {
            this.parseFunctionParamType(left);
        }
        
        if (decorators.length) {
            left.decorators = decorators;
            this.resetStartLocationFromNode(left, decorators[0]);
        }
        
        const elt = this.parseMaybeDefault(left.loc.start, left);
        
        return elt;
    }
    
    parseFunctionParamType(param) {
        return param;
    }
    
    parseMaybeDefault(startLoc, left) {
        startLoc ??= this.state.startLoc;
        left = left ?? this.parseBindingAtom();
        
        if (!this.eat(25))
            return left;
        
        const node = this.startNodeAt(startLoc);
        
        if (left.type === 'VoidPattern') {
            this.raise(Errors.VoidPatternInitializer, left);
        }
        
        node.left = left;
        node.right = this.parseMaybeAssignAllowIn();
        return this.finishNode(node, 'AssignmentPattern');
    }
    
    isValidLVal(type, disallowCallExpression) {
        switch(type) {
        case 'AssignmentPattern':
            return 'left';
        
        case 'RestElement':
            return 'argument';
        
        case 'ObjectProperty':
            return 'value';
        
        case 'ParenthesizedExpression':
            return 'expression';
        
        case 'ArrayPattern':
            return 'elements';
        
        case 'ObjectPattern':
            return 'properties';
        
        case 'VoidPattern':
            return true;
        
        case 'CallExpression':
            if (!disallowCallExpression && !this.state.strict && this.optionFlags & 8192) {
                return true;
            }
        }
        
        return false;
    }
    
    isOptionalMemberExpression(expression2) {
        return expression2.type === 'OptionalMemberExpression';
    }
    
    checkLVal(expression2, ancestor, binding = 64, checkClashes = false, strictModeChanged = false, hasParenthesizedAncestor = false, disallowCallExpression = false) {
        const type = expression2.type;
        
        if (this.isObjectMethod(expression2))
            return;
        
        const isOptionalMemberExpression3 = this.isOptionalMemberExpression(expression2);
        
        if (isOptionalMemberExpression3 || type === 'MemberExpression') {
            if (isOptionalMemberExpression3) {
                this.expectPlugin('optionalChainingAssign', expression2.loc.start);
                
                if (ancestor.type !== 'AssignmentExpression') {
                    this.raise(Errors.InvalidLhsOptionalChaining, expression2, {
                        ancestor,
                    });
                }
            }
            
            if (binding !== 64) {
                this.raise(Errors.InvalidPropertyBindingPattern, expression2);
            }
            
            return;
        }
        
        if (type === 'Identifier') {
            this.checkIdentifier(expression2, binding, strictModeChanged);
            const {name} = expression2;
            
            if (checkClashes) {
                if (checkClashes.has(name)) {
                    this.raise(Errors.ParamDupe, expression2);
                } else {
                    checkClashes.add(name);
                }
            }
            
            return;
        } else if (type === 'VoidPattern' && ancestor.type === 'CatchClause') {
            this.raise(Errors.VoidPatternCatchClauseParam, expression2);
        }
        
        const unwrappedExpression = unwrapParenthesizedExpression(expression2);
        
        disallowCallExpression ||= unwrappedExpression.type === 'CallExpression' && (unwrappedExpression.callee.type === 'Import' || unwrappedExpression.callee.type === 'Super');
        const validity = this.isValidLVal(type, disallowCallExpression, !(hasParenthesizedAncestor || expression2.extra?.parenthesized) && ancestor.type === 'AssignmentExpression', binding);
        
        if (validity === true)
            return;
        
        if (validity === false) {
            const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
            
            this.raise(ParseErrorClass, expression2, {
                ancestor,
            });
            return;
        }
        
        let key, isParenthesizedExpression3;
        
        if (typeof validity === 'string') {
            key = validity;
            isParenthesizedExpression3 = type === 'ParenthesizedExpression';
        } else {
            [key, isParenthesizedExpression3] = validity;
        }
        
        const nextAncestor = type === 'ArrayPattern' || type === 'ObjectPattern' ? {
            type,
        } : ancestor;
        
        const val = expression2[key];
        
        if (Array.isArray(val)) {
            for (const child of val) {
                if (child) {
                    this.checkLVal(child, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression3, true);
                }
            }
        } else if (val) {
            this.checkLVal(val, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression3, disallowCallExpression);
        }
    }
    
    checkIdentifier(at, bindingType, strictModeChanged = false) {
        if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
            if (bindingType === 64) {
                this.raise(Errors.StrictEvalArguments, at, {
                    referenceName: at.name,
                });
            } else {
                this.raise(Errors.StrictEvalArgumentsBinding, at, {
                    bindingName: at.name,
                });
            }
        }
        
        if (bindingType & 8192 && at.name === 'let') {
            this.raise(Errors.LetInLexicalBinding, at);
        }
        
        if (!(bindingType & 64)) {
            this.declareNameFromIdentifier(at, bindingType);
        }
    }
    
    declareNameFromIdentifier(identifier4, binding) {
        this.scope.declareName(identifier4.name, binding, identifier4.loc.start);
    }
    
    checkToRestConversion(node, allowPattern) {
        switch(node.type) {
        case 'ParenthesizedExpression':
            this.checkToRestConversion(node.expression, allowPattern);
            break;
        
        case 'Identifier':        
        case 'MemberExpression':
            break;
        
        case 'ArrayExpression':        
        case 'ObjectExpression':
            if (allowPattern)
                break;
        
        default:
            this.raise(Errors.InvalidRestAssignmentPattern, node);
        }
    }
    
    checkCommaAfterRest(close) {
        if (!this.match(8)) {
            return false;
        }
        
        this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);
        
        return true;
    }
};

var keywordAndTSRelationalOperator = /in(?:stanceof)?|as|satisfies/y;

function nonNull(x) {
    if (x == null) {
        throw new Error(`Unexpected ${x} value.`);
    }
    
    return x;
}

function assert2(x) {
    if (!x) {
        throw new Error('Assert fail');
    }
}

var TSErrors = ParseErrorEnum`typescript`({
    AbstractMethodHasImplementation: ({methodName}) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
    AbstractPropertyHasInitializer: ({propertyName}) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
    AccessorCannotBeOptional: 'An \'accessor\' property cannot be declared optional.',
    AccessorCannotDeclareThisParameter: '\'get\' and \'set\' accessors cannot declare \'this\' parameters.',
    AccessorCannotHaveTypeParameters: 'An accessor cannot have type parameters.',
    ClassMethodHasDeclare: 'Class methods cannot have the \'declare\' modifier.',
    ClassMethodHasReadonly: 'Class methods cannot have the \'readonly\' modifier.',
    ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: 'A \'const\' initializer in an ambient context must be a string or numeric literal or literal enum reference.',
    ConstructorHasTypeParameters: 'Type parameters cannot appear on a constructor declaration.',
    DeclareAccessor: ({kind}) => `'declare' is not allowed in ${kind}ters.`,
    DeclareClassFieldHasInitializer: 'Initializers are not allowed in ambient contexts.',
    DeclareFunctionHasImplementation: 'An implementation cannot be declared in ambient contexts.',
    DuplicateAccessibilityModifier: ({modifier}) => `Accessibility modifier already seen: '${modifier}'.`,
    DuplicateModifier: ({modifier}) => `Duplicate modifier: '${modifier}'.`,
    EmptyHeritageClauseType: ({token}) => `'${token}' list cannot be empty.`,
    EmptyTypeArguments: 'Type argument list cannot be empty.',
    EmptyTypeParameters: 'Type parameter list cannot be empty.',
    ExpectedAmbientAfterExportDeclare: '\'export declare\' must be followed by an ambient declaration.',
    ImportAliasHasImportType: 'An import alias can not use \'import type\'.',
    IncompatibleModifiers: ({modifiers}) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
    IndexSignatureHasAbstract: 'Index signatures cannot have the \'abstract\' modifier.',
    IndexSignatureHasAccessibility: ({modifier}) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
    IndexSignatureHasDeclare: 'Index signatures cannot have the \'declare\' modifier.',
    IndexSignatureHasOverride: '\'override\' modifier cannot appear on an index signature.',
    IndexSignatureHasStatic: 'Index signatures cannot have the \'static\' modifier.',
    InitializerNotAllowedInAmbientContext: 'Initializers are not allowed in ambient contexts.',
    InlineModuleDeclarationMustUseString: '`module ... {}` declarations must have a string name. Use `namespace ... {}` instead.',
    InvalidHeritageClauseType: ({token}) => `'${token}' list can only include identifiers or qualified-names with optional type arguments.`,
    InvalidModifierOnAwaitUsingDeclaration: (modifier) => `'${modifier}' modifier cannot appear on an await using declaration.`,
    InvalidModifierOnTypeMember: ({modifier}) => `'${modifier}' modifier cannot appear on a type member.`,
    InvalidModifierOnTypeParameter: ({modifier}) => `'${modifier}' modifier cannot appear on a type parameter.`,
    InvalidModifierOnTypeParameterPositions: ({modifier}) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
    InvalidModifierOnUsingDeclaration: (modifier) => `'${modifier}' modifier cannot appear on a using declaration.`,
    InvalidModifiersOrder: ({orderedModifiers}) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
    InvalidPropertyAccessAfterInstantiationExpression: 'Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.',
    InvalidTupleMemberLabel: 'Tuple members must be labeled with a simple identifier.',
    MissingInterfaceName: '\'interface\' declarations must be followed by an identifier.',
    NonAbstractClassHasAbstractMethod: 'Abstract methods can only appear within an abstract class.',
    NonClassMethodPropertyHasAbstractModifier: '\'abstract\' modifier can only appear on a class, method, or property declaration.',
    OptionalTypeBeforeRequired: 'A required element cannot follow an optional element.',
    OverrideNotInSubClass: 'This member cannot have an \'override\' modifier because its containing class does not extend another class.',
    PatternIsOptional: 'A binding pattern parameter cannot be optional in an implementation signature.',
    PrivateElementHasAbstract: 'Private elements cannot have the \'abstract\' modifier.',
    PrivateElementHasAccessibility: ({modifier}) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
    ReadonlyForMethodSignature: '\'readonly\' modifier can only appear on a property declaration or index signature.',
    ReservedArrowTypeParam: 'This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.',
    ReservedTypeAssertion: 'This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.',
    SetAccessorCannotHaveOptionalParameter: 'A \'set\' accessor cannot have an optional parameter.',
    SetAccessorCannotHaveRestParameter: 'A \'set\' accessor cannot have rest parameter.',
    SetAccessorCannotHaveReturnType: 'A \'set\' accessor cannot have a return type annotation.',
    SingleTypeParameterWithoutTrailingComma: ({typeParameterName}) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
    StaticBlockCannotHaveModifier: 'Static class blocks cannot have any modifier.',
    TupleOptionalAfterType: 'A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).',
    TypeAnnotationAfterAssign: 'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.',
    TypeImportCannotSpecifyDefaultAndNamed: 'A type-only import can specify a default import or named bindings, but not both.',
    TypeModifierIsUsedInTypeExports: 'The \'type\' modifier cannot be used on a named export when \'export type\' is used on its export statement.',
    TypeModifierIsUsedInTypeImports: 'The \'type\' modifier cannot be used on a named import when \'import type\' is used on its import statement.',
    UnexpectedParameterModifier: 'A parameter property is only allowed in a constructor implementation.',
    UnexpectedReadonly: '\'readonly\' type modifier is only permitted on array and tuple literal types.',
    UnexpectedTypeAnnotation: 'Did not expect a type annotation here.',
    UnexpectedTypeCastInParameter: 'Unexpected type cast in parameter position.',
    UnsupportedImportTypeArgument: 'Argument in a type import must be a string literal.',
    UnsupportedParameterPropertyKind: 'A parameter property may not be declared using a binding pattern.',
    UnsupportedSignatureParameterKind: ({type}) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`,
    UsingDeclarationInAmbientContext: (kind) => `'${kind}' declarations are not allowed in ambient contexts.`,
});

function keywordTypeFromName(value) {
    switch(value) {
    case 'any':
        return 'TSAnyKeyword';
    
    case 'boolean':
        return 'TSBooleanKeyword';
    
    case 'bigint':
        return 'TSBigIntKeyword';
    
    case 'never':
        return 'TSNeverKeyword';
    
    case 'number':
        return 'TSNumberKeyword';
    
    case 'object':
        return 'TSObjectKeyword';
    
    case 'string':
        return 'TSStringKeyword';
    
    case 'symbol':
        return 'TSSymbolKeyword';
    
    case 'undefined':
        return 'TSUndefinedKeyword';
    
    case 'unknown':
        return 'TSUnknownKeyword';
    
    default:
        return void 0;
    }
}

function tsIsAccessModifier(modifier) {
    return modifier === 'private' || modifier === 'public' || modifier === 'protected';
}

function tsIsVarianceAnnotations(modifier) {
    return modifier === 'in' || modifier === 'out';
}

function tsIsEntityName(node) {
    if (node.extra?.parenthesized) {
        return false;
    }
    
    switch(node.type) {
    case 'Identifier':
        return true;
    
    case 'MemberExpression':
        return !node.computed && tsIsEntityName(node.object);
    
    case 'TSInstantiationExpression':
        return tsIsEntityName(node.expression);
    
    default:
        return false;
    }
}

var typescript$1 = (superClass) => class TypeScriptParserMixin extends superClass {
    getScopeHandler() {
        return TypeScriptScopeHandler;
    }
    
    tsIsIdentifier() {
        return tokenIsIdentifier(this.state.type);
    }
    
    tsTokenCanFollowModifier() {
        return this.match(0)
            || this.match(2)
            || this.match(51)
            || this.match(17)
            || this.match(134)
            || this.isLiteralPropertyName();
    }
    
    tsNextTokenOnSameLineAndCanFollowModifier() {
        this.next();
        
        if (this.hasPrecedingLineBreak()) {
            return false;
        }
        
        return this.tsTokenCanFollowModifier();
    }
    
    tsNextTokenCanFollowModifier() {
        if (this.match(102)) {
            this.next();
            return this.tsTokenCanFollowModifier();
        }
        
        return this.tsNextTokenOnSameLineAndCanFollowModifier();
    }
    
    tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock, hasSeenStaticModifier) {
        if (!tokenIsIdentifier(this.state.type) && this.state.type !== 54 && this.state.type !== 71) {
            return void 0;
        }
        
        const modifier = this.state.value;
        
        if (allowedModifiers.includes(modifier)) {
            if (hasSeenStaticModifier && this.match(102)) {
                return void 0;
            }
            
            if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
                return void 0;
            }
            
            if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
                return modifier;
            }
        }
        
        return void 0;
    }
    
    tsParseModifiers({allowedModifiers, disallowedModifiers, stopOnStartOfClassStaticBlock, errorTemplate = TSErrors.InvalidModifierOnTypeMember}, modified) {
        const enforceOrder = (loc, modifier, before, after) => {
            if (modifier === before && modified[after]) {
                this.raise(TSErrors.InvalidModifiersOrder, loc, {
                    orderedModifiers: [before, after],
                });
            }
        };
        
        const incompatible = (loc, modifier, mod1, mod2) => {
            if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
                this.raise(TSErrors.IncompatibleModifiers, loc, {
                    modifiers: [mod1, mod2],
                });
            }
        };
        
        for (;;) {
            const {startLoc} = this.state;
            
            const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers ?? []), stopOnStartOfClassStaticBlock, modified.static);
            
            if (!modifier)
                break;
            
            if (tsIsAccessModifier(modifier)) {
                if (modified.accessibility) {
                    this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {
                        modifier,
                    });
                } else {
                    enforceOrder(startLoc, modifier, modifier, 'override');
                    enforceOrder(startLoc, modifier, modifier, 'static');
                    enforceOrder(startLoc, modifier, modifier, 'readonly');
                    modified.accessibility = modifier;
                }
            } else if (tsIsVarianceAnnotations(modifier)) {
                if (modified[modifier]) {
                    this.raise(TSErrors.DuplicateModifier, startLoc, {
                        modifier,
                    });
                }
                
                modified[modifier] = true;
                enforceOrder(startLoc, modifier, 'in', 'out');
            } else {
                if (Object.hasOwn(modified, modifier)) {
                    this.raise(TSErrors.DuplicateModifier, startLoc, {
                        modifier,
                    });
                } else {
                    enforceOrder(startLoc, modifier, 'static', 'readonly');
                    enforceOrder(startLoc, modifier, 'static', 'override');
                    enforceOrder(startLoc, modifier, 'override', 'readonly');
                    enforceOrder(startLoc, modifier, 'abstract', 'override');
                    incompatible(startLoc, modifier, 'declare', 'override');
                    incompatible(startLoc, modifier, 'static', 'abstract');
                }
                
                modified[modifier] = true;
            }
            
            if (disallowedModifiers?.includes(modifier)) {
                this.raise(errorTemplate, startLoc, {
                    modifier,
                });
            }
        }
    }
    
    tsIsListTerminator(kind) {
        switch(kind) {
        case 'EnumMembers':        
        case 'TypeMembers':
            return this.match(4);
        
        case 'HeritageClauseElement':
            return this.match(2);
        
        case 'TupleElementTypes':
            return this.match(1);
        
        case 'TypeParametersOrArguments':
            return this.match(44);
        }
    }
    
    tsParseList(kind, parseElement) {
        const result = [];
        
        while (!this.tsIsListTerminator(kind)) {
            result.push(parseElement());
        }
        
        return result;
    }
    
    tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
        return nonNull(this.tsParseDelimitedListWorker(
            kind,
            parseElement,
            true,
            refTrailingCommaPos,
        ));
    }
    
    tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
        const result = [];
        let trailingCommaPos = -1;
        
        for (;;) {
            if (this.tsIsListTerminator(kind)) {
                break;
            }
            
            trailingCommaPos = -1;
            const element = parseElement();
            
            if (element == null) {
                return void 0;
            }
            
            result.push(element);
            
            if (this.eat(8)) {
                trailingCommaPos = this.state.lastTokStartLoc.index;
                continue;
            }
            
            if (this.tsIsListTerminator(kind)) {
                break;
            }
            
            if (expectSuccess) {
                this.expect(8);
            }
            
            return void 0;
        }
        
        if (refTrailingCommaPos) {
            refTrailingCommaPos.value = trailingCommaPos;
        }
        
        return result;
    }
    
    tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
        if (!skipFirstToken) {
            if (bracket) {
                this.expect(0);
            } else {
                this.expect(43);
            }
        }
        
        const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
        
        if (bracket) {
            this.expect(1);
        } else {
            this.expect(44);
        }
        
        return result;
    }
    
    tsParseImportType() {
        const node = this.startNode();
        this.expect(79);
        this.expect(6);
        
        if (!this.match(130)) {
            this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);
            node.source = this.tsParseNonConditionalType();
        } else {
            node.source = this.parseStringLiteral(this.state.value);
        }
        
        if (this.eat(8)) {
            node.options = this.tsParseImportTypeOptions();
        } else {
            node.options = null;
        }
        
        this.expect(7);
        
        if (this.eat(12)) {
            node.qualifier = this.tsParseEntityName(1 | 2);
        }
        
        if (this.match(43)) {
            node.typeArguments = this.tsParseTypeArguments();
        }
        
        return this.finishNode(node, 'TSImportType');
    }
    
    tsParseImportTypeOptions() {
        const node = this.startNode();
        this.expect(2);
        const withProperty = this.startNode();
        
        if (this.isContextual(72)) {
            withProperty.method = false;
            withProperty.key = this.parseIdentifier(true);
            withProperty.computed = false;
            withProperty.shorthand = false;
        } else {
            this.unexpected(null, 72);
        }
        
        this.expect(10);
        withProperty.value = this.tsParseImportTypeWithPropertyValue();
        node.properties = [
            this.finishObjectProperty(withProperty),
        ];
        this.eat(8);
        this.expect(4);
        return this.finishNode(node, 'ObjectExpression');
    }
    
    tsParseImportTypeWithPropertyValue() {
        const node = this.startNode();
        const properties = [];
        this.expect(2);
        while (!this.match(4)) {
            const type = this.state.type;
            
            if (tokenIsIdentifier(type) || type === 130) {
                properties.push(super.parsePropertyDefinition(null));
            } else {
                this.unexpected();
            }
            
            this.eat(8);
        }
        
        node.properties = properties;
        this.next();
        return this.finishNode(node, 'ObjectExpression');
    }
    
    tsParseEntityName(flags) {
        let entity;
        
        if (flags & 1 && this.match(74)) {
            if (flags & 2) {
                entity = this.parseIdentifier(true);
            } else {
                const node = this.startNode();
                this.next();
                entity = this.finishNode(node, 'ThisExpression');
            }
        } else {
            entity = this.parseIdentifier(!!(flags & 1));
        }
        
        while (this.eat(12)) {
            const node = this.startNodeAtNode(entity);
            
            node.left = entity;
            node.right = this.parseIdentifier(!!(flags & 1));
            entity = this.finishNode(node, 'TSQualifiedName');
        }
        
        return entity;
    }
    
    tsParseTypeReference() {
        const node = this.startNode();
        
        node.typeName = this.tsParseEntityName(1);
        
        if (!this.hasPrecedingLineBreak() && this.match(43)) {
            node.typeArguments = this.tsParseTypeArguments();
        }
        
        return this.finishNode(node, 'TSTypeReference');
    }
    
    tsParseThisTypePredicate(lhs) {
        this.next();
        const node = this.startNodeAtNode(lhs);
        
        node.parameterName = lhs;
        node.typeAnnotation = this.tsParseTypeAnnotation(false);
        node.asserts = false;
        return this.finishNode(node, 'TSTypePredicate');
    }
    
    tsParseThisTypeNode() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, 'TSThisType');
    }
    
    tsParseTypeQuery() {
        const node = this.startNode();
        this.expect(83);
        
        if (this.match(79)) {
            node.exprName = this.tsParseImportType();
        } else {
            node.exprName = this.tsParseEntityName(1);
        }
        
        if (!this.hasPrecedingLineBreak() && this.match(43)) {
            node.typeArguments = this.tsParseTypeArguments();
        }
        
        return this.finishNode(node, 'TSTypeQuery');
    }
    
    tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ['in', 'out'],
        disallowedModifiers: [
            'const',
            'public',
            'private',
            'protected',
            'readonly',
            'declare',
            'abstract',
            'override',
        ],
        errorTemplate: TSErrors.InvalidModifierOnTypeParameter,
    });
    tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ['const'],
        disallowedModifiers: ['in', 'out'],
        errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions,
    });
    tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: [
            'in',
            'out',
            'const',
        ],
        disallowedModifiers: [
            'public',
            'private',
            'protected',
            'readonly',
            'declare',
            'abstract',
            'override',
        ],
        errorTemplate: TSErrors.InvalidModifierOnTypeParameter,
    });
    tsParseTypeParameter(parseModifiers) {
        const node = this.startNode();
        parseModifiers(node);
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsEatThenParseType(77);
        node.default = this.tsEatThenParseType(25);
        return this.finishNode(node, 'TSTypeParameter');
    }
    
    tsTryParseTypeParameters(parseModifiers) {
        if (this.match(43)) {
            return this.tsParseTypeParameters(parseModifiers);
        }
    }
    
    tsParseTypeParameters(parseModifiers) {
        const node = this.startNode();
        
        if (this.match(43) || this.match(138)) {
            this.next();
        } else {
            this.unexpected();
        }
        
        const refTrailingCommaPos = {
            value: -1,
        };
        
        node.params = this.tsParseBracketedList('TypeParametersOrArguments', this.tsParseTypeParameter.bind(
            this,
            parseModifiers,
        ), false, true, refTrailingCommaPos);
        
        if (node.params.length === 0) {
            this.raise(TSErrors.EmptyTypeParameters, node);
        }
        
        if (refTrailingCommaPos.value !== -1) {
            this.addExtra(node, 'trailingComma', refTrailingCommaPos.value);
        }
        
        return this.finishNode(node, 'TSTypeParameterDeclaration');
    }
    
    tsFillSignature(returnToken, signature) {
        const returnTokenRequired = returnToken === 15;
        const paramsKey = 'params';
        const returnTypeKey = 'returnType';
        
        signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        this.expect(6);
        signature[paramsKey] = this.tsParseBindingListForSignature();
        
        if (returnTokenRequired) {
            signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        } else if (this.match(returnToken)) {
            signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
    }
    
    tsParseBindingListForSignature() {
        const list = super.parseBindingList(7, 41, 2);
        
        for (const pattern of list) {
            const {type} = pattern;
            
            if (type === 'AssignmentPattern' || type === 'TSParameterProperty') {
                this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {
                    type,
                });
            }
        }
        
        return list;
    }
    
    tsParseTypeMemberSemicolon() {
        if (!this.eat(8) && !this.isLineTerminator()) {
            this.expect(9);
        }
    }
    
    tsParseSignatureMember(kind, node) {
        this.tsFillSignature(10, node);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, kind);
    }
    
    tsIsUnambiguouslyIndexSignature() {
        this.next();
        
        if (tokenIsIdentifier(this.state.type)) {
            this.next();
            return this.match(10);
        }
        
        return false;
    }
    
    tsTryParseIndexSignature(node) {
        if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
            return;
        }
        
        this.expect(0);
        const id = this.parseIdentifier();
        
        id.typeAnnotation = this.tsParseTypeAnnotation();
        this.resetEndLocation(id);
        this.expect(1);
        node.parameters = [id];
        const type = this.tsTryParseTypeAnnotation();
        
        if (type)
            node.typeAnnotation = type;
        
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, 'TSIndexSignature');
    }
    
    tsParsePropertyOrMethodSignature(node, readonly) {
        if (this.eat(13))
            node.optional = true;
        
        if (this.match(6) || this.match(43)) {
            if (readonly) {
                this.raise(TSErrors.ReadonlyForMethodSignature, node);
            }
            
            const method = node;
            
            if (method.kind && this.match(43)) {
                this.raise(TSErrors.AccessorCannotHaveTypeParameters, this.state.curPosition());
            }
            
            this.tsFillSignature(10, method);
            this.tsParseTypeMemberSemicolon();
            
            if (method.kind === 'get') {
                if (method.params.length > 0) {
                    this.raise(Errors.BadGetterArity, this.state.curPosition());
                    
                    if (this.isThisParam(method.params[0])) {
                        this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
                    }
                }
            } else if (method.kind === 'set') {
                if (method.params.length !== 1) {
                    this.raise(Errors.BadSetterArity, this.state.curPosition());
                } else {
                    const firstParameter = method.params[0];
                    
                    if (this.isThisParam(firstParameter)) {
                        this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
                    }
                    
                    if (firstParameter.type === 'Identifier' && firstParameter.optional) {
                        this.raise(TSErrors.SetAccessorCannotHaveOptionalParameter, this.state.curPosition());
                    }
                    
                    if (firstParameter.type === 'RestElement') {
                        this.raise(TSErrors.SetAccessorCannotHaveRestParameter, this.state.curPosition());
                    }
                }
                
                if (method.returnType) {
                    this.raise(TSErrors.SetAccessorCannotHaveReturnType, method.returnType);
                }
            } else {
                method.kind = 'method';
            }
            
            return this.finishNode(method, 'TSMethodSignature');
        } else {
            const property = node;
            
            if (readonly)
                property.readonly = true;
            
            const type = this.tsTryParseTypeAnnotation();
            
            if (type)
                property.typeAnnotation = type;
            
            this.tsParseTypeMemberSemicolon();
            return this.finishNode(property, 'TSPropertySignature');
        }
    }
    
    tsParseTypeMember() {
        const node = this.startNode();
        
        if (this.match(6) || this.match(43)) {
            return this.tsParseSignatureMember('TSCallSignatureDeclaration', node);
        }
        
        if (this.match(73)) {
            const id = this.startNode();
            this.next();
            
            if (this.match(6) || this.match(43)) {
                return this.tsParseSignatureMember('TSConstructSignatureDeclaration', node);
            } else {
                node.key = this.createIdentifier(id, 'new');
                return this.tsParsePropertyOrMethodSignature(node, false);
            }
        }
        
        this.tsParseModifiers({
            allowedModifiers: ['readonly'],
            disallowedModifiers: [
                'declare',
                'abstract',
                'private',
                'protected',
                'public',
                'static',
                'override',
            ],
        }, node);
        const idx = this.tsTryParseIndexSignature(node);
        
        if (idx) {
            return idx;
        }
        
        super.parsePropertyName(node);
        
        if (!node.computed && node.key.type === 'Identifier' && (node.key.name === 'get' || node.key.name === 'set') && this.tsTokenCanFollowModifier()) {
            node.kind = node.key.name;
            super.parsePropertyName(node);
            
            if (!this.match(6) && !this.match(43)) {
                this.unexpected(null, 6);
            }
        }
        
        return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
    }
    
    tsParseTypeLiteral() {
        const node = this.startNode();
        
        node.members = this.tsParseObjectTypeMembers();
        return this.finishNode(node, 'TSTypeLiteral');
    }
    
    tsParseObjectTypeMembers() {
        this.expect(2);
        const members = this.tsParseList('TypeMembers', this.tsParseTypeMember.bind(this));
        this.expect(4);
        return members;
    }
    
    tsIsStartOfMappedType() {
        this.next();
        
        if (this.eat(49)) {
            return this.isContextual(118);
        }
        
        if (this.isContextual(118)) {
            this.next();
        }
        
        if (!this.match(0)) {
            return false;
        }
        
        this.next();
        
        if (!this.tsIsIdentifier()) {
            return false;
        }
        
        this.next();
        return this.match(54);
    }
    
    tsParseMappedType() {
        const node = this.startNode();
        this.expect(2);
        
        if (this.match(49)) {
            node.readonly = this.state.value;
            this.next();
            this.expectContextual(118);
        } else if (this.eatContextual(118)) {
            node.readonly = true;
        }
        
        this.expect(0);
        node.key = this.tsParseTypeParameterName();
        node.constraint = this.tsExpectThenParseType(54);
        node.nameType = this.eatContextual(89) ? this.tsParseType() : null;
        this.expect(1);
        
        if (this.match(49)) {
            node.optional = this.state.value;
            this.next();
            this.expect(13);
        } else if (this.eat(13)) {
            node.optional = true;
        }
        
        node.typeAnnotation = this.tsTryParseType();
        this.semicolon();
        this.expect(4);
        return this.finishNode(node, 'TSMappedType');
    }
    
    tsParseTupleType() {
        const node = this.startNode();
        
        node.elementTypes = this.tsParseBracketedList('TupleElementTypes', this.tsParseTupleElementType.bind(this), true, false);
        let seenOptionalElement = false;
        
        node.elementTypes.forEach((elementNode) => {
            const {type} = elementNode;
            
            if (seenOptionalElement && type !== 'TSRestType' && type !== 'TSOptionalType' && !(type === 'TSNamedTupleMember' && elementNode.optional)) {
                this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);
            }
            
            seenOptionalElement ||= type === 'TSNamedTupleMember' && elementNode.optional || type === 'TSOptionalType';
        });
        return this.finishNode(node, 'TSTupleType');
    }
    
    tsParseTupleElementType() {
        const restStartLoc = this.state.startLoc;
        const rest = this.eat(17);
        const {startLoc} = this.state;
        
        let labeled;
        let label;
        let optional;
        let type;
        const isWord = tokenIsKeywordOrIdentifier(this.state.type);
        const chAfterWord = isWord ? this.lookaheadCharCode() : null;
        
        if (chAfterWord === 58) {
            labeled = true;
            optional = false;
            label = this.parseIdentifier(true);
            this.expect(10);
            type = this.tsParseType();
        } else if (chAfterWord === 63) {
            optional = true;
            const wordName = this.state.value;
            const typeOrLabel = this.tsParseNonArrayType();
            
            if (this.lookaheadCharCode() === 58) {
                labeled = true;
                label = this.createIdentifier(this.startNodeAt(startLoc), wordName);
                this.expect(13);
                this.expect(10);
                type = this.tsParseType();
            } else {
                labeled = false;
                type = typeOrLabel;
                this.expect(13);
            }
        } else {
            type = this.tsParseType();
            optional = this.eat(13);
            labeled = this.eat(10);
        }
        
        if (labeled) {
            let labeledNode;
            
            if (label) {
                labeledNode = this.startNodeAt(startLoc);
                labeledNode.optional = optional;
                labeledNode.label = label;
                labeledNode.elementType = type;
                
                if (this.eat(13)) {
                    labeledNode.optional = true;
                    this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);
                }
            } else {
                labeledNode = this.startNodeAt(startLoc);
                labeledNode.optional = optional;
                this.raise(TSErrors.InvalidTupleMemberLabel, type);
                labeledNode.label = type;
                labeledNode.elementType = this.tsParseType();
            }
            
            type = this.finishNode(labeledNode, 'TSNamedTupleMember');
        } else if (optional) {
            const optionalTypeNode = this.startNodeAt(startLoc);
            
            optionalTypeNode.typeAnnotation = type;
            type = this.finishNode(optionalTypeNode, 'TSOptionalType');
        }
        
        if (rest) {
            const restNode = this.startNodeAt(restStartLoc);
            
            restNode.typeAnnotation = type;
            type = this.finishNode(restNode, 'TSRestType');
        }
        
        return type;
    }
    
    tsParseParenthesizedType() {
        const node = this.startNode();
        this.expect(6);
        node.typeAnnotation = this.tsParseType();
        this.expect(7);
        return this.finishNode(node, 'TSParenthesizedType');
    }
    
    tsParseFunctionOrConstructorType(type, abstract) {
        const node = this.startNode();
        
        if (type === 'TSConstructorType') {
            node.abstract = !!abstract;
            
            if (abstract)
                this.next();
            
            this.next();
        }
        
        this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(15, node));
        return this.finishNode(node, type);
    }
    
    tsParseLiteralTypeNode() {
        const node = this.startNode();
        
        switch(this.state.type) {
        case 131:        
        case 132:        
        case 130:        
        case 81:        
        case 82:
            node.literal = super.parseExprAtom();
            break;
        
        default:
            this.unexpected();
        }
        
        
        return this.finishNode(node, 'TSLiteralType');
    }
    
    tsParseTemplateLiteralType() {
        const startLoc = this.state.startLoc;
        let curElt = this.parseTemplateElement(false);
        const quasis = [curElt];
        
        if (curElt.tail) {
            const node = this.startNodeAt(startLoc);
            const literal = this.startNodeAt(startLoc);
            
            literal.expressions = [];
            literal.quasis = quasis;
            node.literal = this.finishNode(literal, 'TemplateLiteral');
            return this.finishNode(node, 'TSLiteralType');
        } else {
            const substitutions = [];
            
            while (!curElt.tail) {
                substitutions.push(this.tsParseType());
                this.readTemplateContinuation();
                quasis.push(curElt = this.parseTemplateElement(false));
            }
            
            const node = this.startNodeAt(startLoc);
            
            node.types = substitutions;
            node.quasis = quasis;
            return this.finishNode(node, 'TSTemplateLiteralType');
        }
    }
    
    parseTemplateSubstitution() {
        if (this.state.inType)
            return this.tsParseType();
        
        return super.parseTemplateSubstitution();
    }
    
    tsParseThisTypeOrThisTypePredicate() {
        const thisKeyword = this.tsParseThisTypeNode();
        
        if (this.isContextual(112) && !this.hasPrecedingLineBreak()) {
            return this.tsParseThisTypePredicate(thisKeyword);
        } else {
            return thisKeyword;
        }
    }
    
    tsParseNonArrayType() {
        switch(this.state.type) {
        case 130:        
        case 131:        
        case 132:        
        case 81:        
        case 82:
            return this.tsParseLiteralTypeNode();
        
        case 49:
            if (this.state.value === '-') {
                const node = this.startNode();
                const nextToken = this.lookahead();
                
                if (nextToken.type !== 131 && nextToken.type !== 132) {
                    this.unexpected();
                }
                
                node.literal = this.parseMaybeUnary();
                return this.finishNode(node, 'TSLiteralType');
            }
            
            break;
        
        case 74:
            return this.tsParseThisTypeOrThisTypePredicate();
        
        case 83:
            return this.tsParseTypeQuery();
        
        case 79:
            return this.tsParseImportType();
        
        case 2:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        
        case 0:
            return this.tsParseTupleType();
        
        case 6:
            if (!(this.optionFlags & 1024)) {
                const startLoc = this.state.startLoc;
                this.next();
                const type = this.tsParseType();
                this.expect(7);
                this.addExtra(type, 'parenthesized', true);
                this.addExtra(type, 'parenStart', startLoc.index);
                return type;
            }
            
            return this.tsParseParenthesizedType();
        
        case 21:        
        case 20:
            return this.tsParseTemplateLiteralType();
        
        default: {
            const {type} = this.state;
            
            if (tokenIsIdentifier(type) || type === 84 || type === 80) {
                const nodeType = type === 84 ? 'TSVoidKeyword' : type === 80 ? 'TSNullKeyword' : keywordTypeFromName(this.state.value);
                
                if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                    const node = this.startNode();
                    this.next();
                    return this.finishNode(node, nodeType);
                }
                
                return this.tsParseTypeReference();
            }
        }
        }
        
        throw this.unexpected();
    }
    
    tsParseArrayTypeOrHigher() {
        const {startLoc} = this.state;
        
        let type = this.tsParseNonArrayType();
        
        while (!this.hasPrecedingLineBreak() && this.eat(0)) {
            if (this.match(1)) {
                const node = this.startNodeAt(startLoc);
                
                node.elementType = type;
                this.expect(1);
                type = this.finishNode(node, 'TSArrayType');
            } else {
                const node = this.startNodeAt(startLoc);
                
                node.objectType = type;
                node.indexType = this.tsParseType();
                this.expect(1);
                type = this.finishNode(node, 'TSIndexedAccessType');
            }
        }
        
        return type;
    }
    
    tsParseTypeOperator() {
        const node = this.startNode();
        const operator = this.state.value;
        this.next();
        node.operator = operator;
        node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
        
        if (operator === 'readonly') {
            this.tsCheckTypeAnnotationForReadOnly(node);
        }
        
        return this.finishNode(node, 'TSTypeOperator');
    }
    
    tsCheckTypeAnnotationForReadOnly(node) {
        switch(node.typeAnnotation.type) {
        case 'TSTupleType':        
        case 'TSArrayType':
            return;
        
        default:
            this.raise(TSErrors.UnexpectedReadonly, node);
        }
    }
    
    tsParseInferType() {
        const node = this.startNode();
        this.expectContextual(111);
        const typeParameter2 = this.startNode();
        
        typeParameter2.name = this.tsParseTypeParameterName();
        typeParameter2.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
        node.typeParameter = this.finishNode(typeParameter2, 'TSTypeParameter');
        return this.finishNode(node, 'TSInferType');
    }
    
    tsParseConstraintForInferType() {
        if (this.eat(77)) {
            const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
            
            if (this.state.inDisallowConditionalTypesContext || !this.match(13)) {
                return constraint;
            }
        }
    }
    
    tsParseTypeOperatorOrHigher() {
        const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
        return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(111) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    
    tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        const node = this.startNode();
        const hasLeadingOperator = this.eat(operator);
        const types2 = [];
        
        do {
            types2.push(parseConstituentType());
        } while (this.eat(operator))
        if (types2.length === 1 && !hasLeadingOperator) {
            return types2[0];
        }
        
        node.types = types2;
        return this.finishNode(node, kind);
    }
    
    tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType('TSIntersectionType', this.tsParseTypeOperatorOrHigher.bind(this), 41);
    }
    
    tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType('TSUnionType', this.tsParseIntersectionTypeOrHigher.bind(this), 39);
    }
    
    tsIsStartOfFunctionType() {
        if (this.match(43)) {
            return true;
        }
        
        return this.match(6) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    
    tsSkipParameterStart() {
        if (tokenIsIdentifier(this.state.type) || this.match(74)) {
            this.next();
            return true;
        }
        
        if (this.match(2)) {
            const {errors} = this.state;
            
            const previousErrorCount = errors.length;
            
            try {
                this.parseObjectLike(4, true);
                return errors.length === previousErrorCount;
            } catch {
                return false;
            }
        }
        
        if (this.match(0)) {
            this.next();
            const {errors} = this.state;
            
            const previousErrorCount = errors.length;
            
            try {
                super.parseBindingList(1, 93, 1);
                return errors.length === previousErrorCount;
            } catch {
                return false;
            }
        }
        
        return false;
    }
    
    tsIsUnambiguouslyStartOfFunctionType() {
        this.next();
        
        if (this.match(7) || this.match(17)) {
            return true;
        }
        
        if (this.tsSkipParameterStart()) {
            if (this.match(10) || this.match(8) || this.match(13) || this.match(25)) {
                return true;
            }
            
            if (this.match(7)) {
                this.next();
                
                if (this.match(15)) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    tsParseTypeOrTypePredicateAnnotation(returnToken) {
        return this.tsInType(() => {
            const t = this.startNode();
            this.expect(returnToken);
            const node = this.startNode();
            const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
            
            if (asserts && this.match(74)) {
                let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
                
                if (thisTypePredicate.type === 'TSThisType') {
                    node.parameterName = thisTypePredicate;
                    node.asserts = true;
                    node.typeAnnotation = null;
                    thisTypePredicate = this.finishNode(node, 'TSTypePredicate');
                } else {
                    this.resetStartLocationFromNode(thisTypePredicate, node);
                    thisTypePredicate.asserts = true;
                }
                
                t.typeAnnotation = thisTypePredicate;
                return this.finishNode(t, 'TSTypeAnnotation');
            }
            
            const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
            
            if (!typePredicateVariable) {
                if (!asserts) {
                    return this.tsParseTypeAnnotation(false, t);
                }
                
                node.parameterName = this.parseIdentifier();
                node.asserts = asserts;
                node.typeAnnotation = null;
                t.typeAnnotation = this.finishNode(node, 'TSTypePredicate');
                return this.finishNode(t, 'TSTypeAnnotation');
            }
            
            const type = this.tsParseTypeAnnotation(false);
            
            node.parameterName = typePredicateVariable;
            node.typeAnnotation = type;
            node.asserts = asserts;
            t.typeAnnotation = this.finishNode(node, 'TSTypePredicate');
            return this.finishNode(t, 'TSTypeAnnotation');
        });
    }
    
    tsTryParseTypeOrTypePredicateAnnotation() {
        if (this.match(10)) {
            return this.tsParseTypeOrTypePredicateAnnotation(10);
        }
    }
    
    tsTryParseTypeAnnotation() {
        if (this.match(10)) {
            return this.tsParseTypeAnnotation();
        }
    }
    
    tsTryParseType() {
        return this.tsEatThenParseType(10);
    }
    
    tsParseTypePredicatePrefix() {
        const id = this.parseIdentifier();
        
        if (this.isContextual(112) && !this.hasPrecedingLineBreak()) {
            this.next();
            return id;
        }
    }
    
    tsParseTypePredicateAsserts() {
        if (this.state.type !== 105) {
            return false;
        }
        
        const containsEsc = this.state.containsEsc;
        this.next();
        
        if (!tokenIsIdentifier(this.state.type) && !this.match(74)) {
            return false;
        }
        
        if (containsEsc) {
            this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
                reservedWord: 'asserts',
            });
        }
        
        return true;
    }
    
    tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
        this.tsInType(() => {
            if (eatColon)
                this.expect(10);
            
            t.typeAnnotation = this.tsParseType();
        });
        return this.finishNode(t, 'TSTypeAnnotation');
    }
    
    tsParseType() {
        assert2(this.state.inType);
        const type = this.tsParseNonConditionalType();
        
        if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(77)) {
            return type;
        }
        
        const node = this.startNodeAtNode(type);
        
        node.checkType = type;
        node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
        this.expect(13);
        node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        this.expect(10);
        node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        return this.finishNode(node, 'TSConditionalType');
    }
    
    isAbstractConstructorSignature() {
        return this.isContextual(120) && this.isLookaheadContextual('new');
    }
    
    tsParseNonConditionalType() {
        if (this.tsIsStartOfFunctionType()) {
            return this.tsParseFunctionOrConstructorType('TSFunctionType');
        }
        
        if (this.match(73)) {
            return this.tsParseFunctionOrConstructorType('TSConstructorType');
        } else if (this.isAbstractConstructorSignature()) {
            return this.tsParseFunctionOrConstructorType('TSConstructorType', true);
        }
        
        return this.tsParseUnionTypeOrHigher();
    }
    
    tsParseTypeAssertion() {
        if (this.getPluginOption('typescript', 'disallowAmbiguousJSXLike')) {
            this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);
        }
        
        const node = this.startNode();
        
        node.typeAnnotation = this.tsInType(() => {
            this.next();
            return this.match(71) ? this.tsParseTypeReference() : this.tsParseType();
        });
        this.expect(44);
        node.expression = this.parseMaybeUnary();
        return this.finishNode(node, 'TSTypeAssertion');
    }
    
    tsParseHeritageClause(token) {
        const originalStartLoc = this.state.startLoc;
        const delimitedList = this.tsParseDelimitedList('HeritageClauseElement', () => {
            const expression2 = super.parseExprSubscripts();
            
            if (!tsIsEntityName(expression2)) {
                this.raise(TSErrors.InvalidHeritageClauseType, expression2.loc.start, {
                    token,
                });
            }
            
            const nodeType = token === 'extends' ? 'TSInterfaceHeritage' : 'TSClassImplements';
            
            if (expression2.type === 'TSInstantiationExpression') {
                expression2.type = nodeType;
                return expression2;
            }
            
            const node = this.startNodeAtNode(expression2);
            
            node.expression = expression2;
            
            if (this.match(43) || this.match(47)) {
                node.typeArguments = this.tsParseTypeArgumentsInExpression();
            }
            
            return this.finishNode(node, nodeType);
        });
        
        if (!delimitedList.length) {
            this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {
                token,
            });
        }
        
        return delimitedList;
    }
    
    tsParseInterfaceDeclaration(node, properties = {}) {
        if (this.hasFollowingLineBreak())
            return null;
        
        this.expectContextual(125);
        
        if (properties.declare)
            node.declare = true;
        
        if (tokenIsIdentifier(this.state.type)) {
            node.id = this.parseIdentifier();
            this.checkIdentifier(node.id, 130);
        } else {
            node.id = null;
            this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);
        }
        
        node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        
        if (this.eat(77)) {
            node.extends = this.tsParseHeritageClause('extends');
        }
        
        const body = this.startNode();
        
        body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
        node.body = this.finishNode(body, 'TSInterfaceBody');
        return this.finishNode(node, 'TSInterfaceDeclaration');
    }
    
    tsParseTypeAliasDeclaration(node) {
        node.id = this.parseIdentifier();
        this.checkIdentifier(node.id, 2);
        node.typeAnnotation = this.tsInType(() => {
            node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);
            this.expect(25);
            
            if (this.isContextual(110) && this.lookaheadCharCode() !== 46) {
                const node2 = this.startNode();
                this.next();
                return this.finishNode(node2, 'TSIntrinsicKeyword');
            }
            
            return this.tsParseType();
        });
        this.semicolon();
        return this.finishNode(node, 'TSTypeAliasDeclaration');
    }
    
    tsInTopLevelContext(cb) {
        if (this.curContext() !== types$2.brace) {
            const oldContext = this.state.context;
            
            this.state.context = [oldContext[0]];
            try {
                return cb();
            } finally {
                this.state.context = oldContext;
            }
        } else {
            return cb();
        }
    }
    
    tsInType(cb) {
        const oldInType = this.state.inType;
        
        this.state.inType = true;
        try {
            return cb();
        } finally {
            this.state.inType = oldInType;
        }
    }
    
    tsInDisallowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        
        this.state.inDisallowConditionalTypesContext = true;
        try {
            return cb();
        } finally {
            this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
    }
    
    tsInAllowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        
        this.state.inDisallowConditionalTypesContext = false;
        try {
            return cb();
        } finally {
            this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
    }
    
    tsEatThenParseType(token) {
        if (this.match(token)) {
            return this.tsNextThenParseType();
        }
    }
    
    tsExpectThenParseType(token) {
        return this.tsInType(() => {
            this.expect(token);
            return this.tsParseType();
        });
    }
    
    tsNextThenParseType() {
        return this.tsInType(() => {
            this.next();
            return this.tsParseType();
        });
    }
    
    tsParseEnumMember() {
        const node = this.startNode();
        
        node.id = this.match(130) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
        
        if (this.eat(25)) {
            node.initializer = super.parseMaybeAssignAllowIn();
        }
        
        return this.finishNode(node, 'TSEnumMember');
    }
    
    tsParseEnumDeclaration(node, properties = {}) {
        if (properties.const)
            node.const = true;
        
        if (properties.declare)
            node.declare = true;
        
        this.expectContextual(122);
        node.id = this.parseIdentifier();
        this.checkIdentifier(node.id, node.const ? 8971 : 8459);
        node.body = this.tsParseEnumBody();
        return this.finishNode(node, 'TSEnumDeclaration');
    }
    
    tsParseEnumBody() {
        const node = this.startNode();
        this.expect(2);
        node.members = this.tsParseDelimitedList('EnumMembers', this.tsParseEnumMember.bind(this));
        this.expect(4);
        return this.finishNode(node, 'TSEnumBody');
    }
    
    tsParseModuleBlock() {
        const node = this.startNode();
        this.scope.enter(0);
        this.expect(2);
        super.parseBlockOrModuleBlockBody(node.body = [], void 0, true, 4);
        this.scope.exit();
        return this.finishNode(node, 'TSModuleBlock');
    }
    
    tsParseNamespaceDeclaration(node) {
        node.id = this.tsParseEntityName(1);
        
        if (node.id.type === 'Identifier') {
            this.checkIdentifier(node.id, 1024);
        }
        
        this.scope.enter(1024);
        this.prodParam.enter(0);
        node.body = this.tsParseModuleBlock();
        this.prodParam.exit();
        this.scope.exit();
        return this.finishNode(node, 'TSModuleDeclaration');
    }
    
    tsParseAmbientExternalModuleDeclaration(node) {
        if (this.isContextual(108)) {
            node.kind = 'global';
            node.id = this.parseIdentifier();
        } else {
            node.kind = 'module';
            node.id = super.parseStringLiteral(this.state.value);
        }
        
        if (this.match(2)) {
            this.scope.enter(1024);
            this.prodParam.enter(0);
            node.body = this.tsParseModuleBlock();
            this.prodParam.exit();
            this.scope.exit();
        } else {
            this.semicolon();
        }
        
        return this.finishNode(node, 'TSModuleDeclaration');
    }
    
    tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier) {
        node.id = maybeDefaultIdentifier || this.parseIdentifier();
        this.checkIdentifier(node.id, 4096);
        this.expect(25);
        const moduleReference = this.tsParseModuleReference();
        
        if (node.importKind === 'type' && moduleReference.type !== 'TSExternalModuleReference') {
            this.raise(TSErrors.ImportAliasHasImportType, moduleReference);
        }
        
        node.moduleReference = moduleReference;
        this.semicolon();
        return this.finishNode(node, 'TSImportEqualsDeclaration');
    }
    
    tsIsExternalModuleReference() {
        return this.isContextual(115) && this.lookaheadCharCode() === 40;
    }
    
    tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
    }
    
    tsParseExternalModuleReference() {
        const node = this.startNode();
        this.expectContextual(115);
        this.expect(6);
        
        if (!this.match(130)) {
            this.unexpected();
        }
        
        node.expression = super.parseExprAtom();
        this.expect(7);
        this.sawUnambiguousESM = true;
        return this.finishNode(node, 'TSExternalModuleReference');
    }
    
    tsLookAhead(f) {
        const state = this.state.clone();
        const res = f();
        
        this.state = state;
        return res;
    }
    
    tsTryParseAndCatch(f) {
        const result = this.tryParse((abort) => f() || abort());
        
        if (result.aborted || !result.node)
            return;
        
        if (result.error)
            this.state = result.failState;
        
        return result.node;
    }
    
    tsTryParse(f) {
        const state = this.state.clone();
        const result = f();
        
        if (result !== void 0 && result !== false) {
            return result;
        }
        
        this.state = state;
    }
    
    tsTryParseDeclare(node) {
        if (this.isLineTerminator()) {
            return;
        }
        
        const startType = this.state.type;
        
        return this.tsInAmbientContext(() => {
            switch(startType) {
            case 64:
                node.declare = true;
                return super.parseFunctionStatement(node, false, false);
            
            case 76:
                node.declare = true;
                return this.parseClass(node, true, false);
            
            case 122:
                return this.tsParseEnumDeclaration(node, {
                    declare: true,
                });
            
            case 108:
                return this.tsParseAmbientExternalModuleDeclaration(node);
            
            case 96:
                if (this.state.containsEsc) {
                    return;
                }
            
            case 71:            
            case 70:
                if (!this.match(71) || !this.isLookaheadContextual('enum')) {
                    node.declare = true;
                    return this.parseVarStatement(node, this.state.value, true);
                }
                
                this.expect(71);
                return this.tsParseEnumDeclaration(node, {
                    const: true,
                    declare: true,
                });
            
            case 103:
                if (this.isUsing()) {
                    this.raise(TSErrors.InvalidModifierOnUsingDeclaration, this.state.startLoc, 'declare');
                    node.declare = true;
                    return this.parseVarStatement(node, 'using', true);
                }
                
                break;
            
            case 92:
                if (this.isAwaitUsing()) {
                    this.raise(TSErrors.InvalidModifierOnAwaitUsingDeclaration, this.state.startLoc, 'declare');
                    node.declare = true;
                    this.next();
                    return this.parseVarStatement(node, 'await using', true);
                }
                
                break;
            
            case 125: {
                const result = this.tsParseInterfaceDeclaration(node, {
                    declare: true,
                });
                
                if (result)
                    return result;
            }
            
            default:
                if (tokenIsIdentifier(startType)) {
                    return this.tsParseDeclaration(node, this.state.type, true, null);
                }
            }
        });
    }
    
    tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.type, true, null);
    }
    
    tsParseDeclaration(node, type, next, decorators) {
        switch(type) {
        case 120:
            if (this.tsCheckLineTerminator(next) && (this.match(76) || tokenIsIdentifier(this.state.type))) {
                return this.tsParseAbstractDeclaration(node, decorators);
            }
            
            break;
        
        case 123:
            if (this.tsCheckLineTerminator(next)) {
                return this.tsParseAmbientExternalModuleDeclaration(node);
            }
            
            break;
        
        case 124:
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
                node.kind = 'namespace';
                return this.tsParseNamespaceDeclaration(node);
            }
            
            break;
        
        case 126:
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
                return this.tsParseTypeAliasDeclaration(node);
            }
            
            break;
        }
    }
    
    tsCheckLineTerminator(next) {
        if (next) {
            if (this.hasFollowingLineBreak())
                return false;
            
            this.next();
            return true;
        }
        
        return !this.isLineTerminator();
    }
    
    tsTryParseGenericAsyncArrowFunction(startLoc) {
        if (!this.match(43))
            return;
        
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        
        this.state.maybeInArrowParameters = true;
        const res = this.tsTryParseAndCatch(() => {
            const node = this.startNodeAt(startLoc);
            
            node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
            super.parseFunctionParams(node);
            node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
            this.expect(15);
            return node;
        });
        
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        
        if (!res)
            return;
        
        return super.parseArrowExpression(res, null, true);
    }
    
    tsParseTypeArgumentsInExpression() {
        if (this.reScan_lt() !== 43)
            return;
        
        return this.tsParseTypeArguments();
    }
    
    tsParseTypeArguments() {
        const node = this.startNode();
        
        node.params = this.tsInType(() => this.tsInTopLevelContext(() => {
            this.expect(43);
            return this.tsParseDelimitedList('TypeParametersOrArguments', this.tsParseType.bind(this));
        }));
        
        if (node.params.length === 0) {
            this.raise(TSErrors.EmptyTypeArguments, node);
        } else if (!this.state.inType && this.curContext() === types$2.brace) {
            this.reScan_lt_gt();
        }
        
        this.expect(44);
        return this.finishNode(node, 'TSTypeParameterInstantiation');
    }
    
    tsIsDeclarationStart() {
        return tokenIsTSDeclarationStart(this.state.type);
    }
    
    isExportDefaultSpecifier() {
        if (this.tsIsDeclarationStart())
            return false;
        
        return super.isExportDefaultSpecifier();
    }
    
    parseBindingElement(flags, decorators) {
        const startLoc = decorators.length ? decorators[0].loc.start : this.state.startLoc;
        const modified = {};
        
        this.tsParseModifiers({
            allowedModifiers: [
                'public',
                'private',
                'protected',
                'override',
                'readonly',
            ],
        }, modified);
        const accessibility = modified.accessibility;
        const override = modified.override;
        const readonly = modified.readonly;
        
        if (!(flags & 4) && (accessibility || readonly || override)) {
            this.raise(TSErrors.UnexpectedParameterModifier, startLoc);
        }
        
        const left = this.parseMaybeDefault();
        
        if (flags & 2) {
            this.parseFunctionParamType(left);
        }
        
        const elt = this.parseMaybeDefault(left.loc.start, left);
        
        if (accessibility || readonly || override) {
            const pp = this.startNodeAt(startLoc);
            
            if (decorators.length) {
                pp.decorators = decorators;
            }
            
            if (accessibility)
                pp.accessibility = accessibility;
            
            if (readonly)
                pp.readonly = readonly;
            
            if (override)
                pp.override = override;
            
            if (elt.type !== 'Identifier' && elt.type !== 'AssignmentPattern') {
                this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);
            }
            
            pp.parameter = elt;
            return this.finishNode(pp, 'TSParameterProperty');
        }
        
        if (decorators.length) {
            left.decorators = decorators;
        }
        
        return elt;
    }
    
    isSimpleParameter(node) {
        return node.type === 'TSParameterProperty' && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
    }
    
    tsDisallowOptionalPattern(node) {
        for (const param of node.params) {
            if (param.type !== 'Identifier' && param.optional && !this.state.isAmbientContext) {
                this.raise(TSErrors.PatternIsOptional, param);
            }
        }
    }
    
    setArrowFunctionParameters(node, params, trailingCommaLoc) {
        super.setArrowFunctionParameters(node, params, trailingCommaLoc);
        this.tsDisallowOptionalPattern(node);
    }
    
    parseFunctionBodyAndFinish(node, type, isMethod3 = false) {
        if (this.match(10)) {
            node.returnType = this.tsParseTypeOrTypePredicateAnnotation(10);
        }
        
        const bodilessType = type === 'FunctionDeclaration' ? 'TSDeclareFunction' : type === 'ClassMethod' || type === 'ClassPrivateMethod' ? 'TSDeclareMethod' : void 0;
        
        if (bodilessType && !this.match(2) && this.isLineTerminator()) {
            return this.finishNode(node, bodilessType);
        }
        
        if (bodilessType === 'TSDeclareFunction' && this.state.isAmbientContext) {
            this.raise(TSErrors.DeclareFunctionHasImplementation, node);
            
            if (node.declare) {
                return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod3);
            }
        }
        
        this.tsDisallowOptionalPattern(node);
        return super.parseFunctionBodyAndFinish(node, type, isMethod3);
    }
    
    registerFunctionStatementId(node) {
        if (!node.body && node.id) {
            this.checkIdentifier(node.id, 1024);
        } else {
            super.registerFunctionStatementId(node);
        }
    }
    
    tsCheckForInvalidTypeCasts(items) {
        items.forEach((node) => {
            if (node?.type === 'TSTypeCastExpression') {
                this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);
            }
        });
    }
    
    toReferencedList(exprList) {
        this.tsCheckForInvalidTypeCasts(exprList);
        return exprList;
    }
    
    parseArrayLike(close, refExpressionErrors) {
        const node = super.parseArrayLike(close, refExpressionErrors);
        
        if (node.type === 'ArrayExpression') {
            this.tsCheckForInvalidTypeCasts(node.elements);
        }
        
        return node;
    }
    
    parseSubscript(base, startLoc, noCalls, state) {
        if (!this.hasPrecedingLineBreak() && this.match(31)) {
            this.state.canStartJSXElement = false;
            this.next();
            const nonNullExpression = this.startNodeAt(startLoc);
            
            nonNullExpression.expression = base;
            return this.finishNode(nonNullExpression, 'TSNonNullExpression');
        }
        
        let isOptionalCall = false;
        
        if (this.match(14) && this.lookaheadCharCode() === 60) {
            if (noCalls) {
                state.stop = true;
                return base;
            }
            
            state.optionalChainMember =
            isOptionalCall = true;
            this.next();
        }
        
        if (this.match(43) || this.match(47)) {
            let missingParenErrorLoc;
            const result = this.tsTryParseAndCatch(() => {
                if (!noCalls && this.atPossibleAsyncArrow(base)) {
                    const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
                    
                    if (asyncArrowFn) {
                        state.stop = true;
                        return asyncArrowFn;
                    }
                }
                
                const typeArguments = this.tsParseTypeArgumentsInExpression();
                
                if (!typeArguments)
                    return;
                
                if (isOptionalCall && !this.match(6)) {
                    missingParenErrorLoc = this.state.curPosition();
                    return;
                }
                
                if (tokenIsTemplate(this.state.type)) {
                    const result2 = super.parseTaggedTemplateExpression(base, startLoc, state);
                    
                    result2.typeArguments = typeArguments;
                    return result2;
                }
                
                if (!noCalls && this.eat(6)) {
                    const node2 = this.startNodeAt(startLoc);
                    
                    node2.callee = base;
                    node2.arguments = this.parseCallExpressionArguments();
                    this.tsCheckForInvalidTypeCasts(node2.arguments);
                    node2.typeArguments = typeArguments;
                    
                    if (state.optionalChainMember) {
                        node2.optional = isOptionalCall;
                    }
                    
                    return this.finishCallExpression(node2, state.optionalChainMember);
                }
                
                const tokenType = this.state.type;
                
                if (tokenType === 44 || tokenType === 48 || tokenType !== 6 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {
                    return;
                }
                
                const node = this.startNodeAt(startLoc);
                
                node.expression = base;
                node.typeArguments = typeArguments;
                return this.finishNode(node, 'TSInstantiationExpression');
            });
            
            if (missingParenErrorLoc) {
                this.unexpected(missingParenErrorLoc, 6);
            }
            
            if (result) {
                if (result.type === 'TSInstantiationExpression') {
                    if (this.match(12) || this.match(14) && this.lookaheadCharCode() !== 40) {
                        this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);
                    }
                    
                    if (!this.match(12) && !this.match(14)) {
                        result.expression = super.stopParseSubscript(base, state);
                    }
                }
                
                return result;
            }
        }
        
        return super.parseSubscript(base, startLoc, noCalls, state);
    }
    
    parseNewCallee(node) {
        super.parseNewCallee(node);
        const {callee} = node;
        
        if (callee.type === 'TSInstantiationExpression' && !callee.extra?.parenthesized) {
            node.typeArguments = callee.typeArguments;
            node.callee = callee.expression;
        }
    }
    
    parseExprOp(left, leftStartLoc, minPrec) {
        let isSatisfies;
        
        if (tokenOperatorPrecedence(54) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(89) || (isSatisfies = this.isContextual(116)))) {
            const node = this.startNodeAt(leftStartLoc);
            
            node.expression = left;
            node.typeAnnotation = this.tsInType(() => {
                this.next();
                
                if (this.match(71)) {
                    if (isSatisfies) {
                        this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {
                            keyword: 'const',
                        });
                    }
                    
                    return this.tsParseTypeReference();
                }
                
                return this.tsParseType();
            });
            this.finishNode(node, isSatisfies ? 'TSSatisfiesExpression' : 'TSAsExpression');
            this.reScan_lt_gt();
            return this.parseExprOp(node, leftStartLoc, minPrec);
        }
        
        return super.parseExprOp(left, leftStartLoc, minPrec);
    }
    
    checkReservedWord(word, startLoc, checkKeywords, isBinding3) {
        if (!this.state.isAmbientContext) {
            super.checkReservedWord(word, startLoc, checkKeywords, isBinding3);
        }
    }
    
    checkDuplicateExports() {}
    
    isPotentialImportPhase(isExport) {
        if (super.isPotentialImportPhase(isExport))
            return true;
        
        if (this.isContextual(126)) {
            const ch = this.lookaheadCharCode();
            return isExport ? ch === 123 || ch === 42 : ch !== 61;
        }
        
        return !isExport && this.isContextual(83);
    }
    
    applyImportPhase(node, isExport, phase, loc) {
        super.applyImportPhase(node, isExport, phase, loc);
        
        if (isExport) {
            node.exportKind = phase === 'type' ? 'type' : 'value';
        } else {
            node.importKind = phase === 'type' || phase === 'typeof' ? phase : 'value';
        }
    }
    
    parseImport(node) {
        if (this.match(130)) {
            node.importKind = 'value';
            return super.parseImport(node);
        }
        
        let importNode;
        
        if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
            node.importKind = 'value';
            return this.tsParseImportEqualsDeclaration(node);
        } else if (this.isContextual(126)) {
            const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
            
            if (this.lookaheadCharCode() === 61) {
                return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);
            } else {
                importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);
            }
        } else {
            importNode = super.parseImport(node);
        }
        
        if (importNode.importKind === 'type' && importNode.specifiers.length > 1 && importNode.specifiers[0].type === 'ImportDefaultSpecifier') {
            this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);
        }
        
        return importNode;
    }
    
    parseExport(node, decorators) {
        if (this.match(79)) {
            const nodeImportEquals = this.startNode();
            this.next();
            let maybeDefaultIdentifier = null;
            
            if (this.isContextual(126) && this.isPotentialImportPhase(false)) {
                maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, false);
            } else {
                nodeImportEquals.importKind = 'value';
            }
            
            const declaration = this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier);
            
            node.attributes = [];
            node.declaration = declaration;
            node.exportKind = 'value';
            node.source = null;
            node.specifiers = [];
            return this.finishNode(node, 'ExportNamedDeclaration');
        } else if (this.eat(25)) {
            const assign = node;
            
            assign.expression = super.parseExpression();
            this.semicolon();
            this.sawUnambiguousESM = true;
            return this.finishNode(assign, 'TSExportAssignment');
        } else if (this.eatContextual(89)) {
            const decl = node;
            this.expectContextual(124);
            decl.id = this.parseIdentifier();
            this.semicolon();
            return this.finishNode(decl, 'TSNamespaceExportDeclaration');
        } else {
            return super.parseExport(node, decorators);
        }

    }
    
    isAbstractClass() {
        return this.isContextual(120) && this.isLookaheadContextual('class');
    }
    
    parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
            const cls = this.startNode();
            this.next();
            cls.abstract = true;
            return this.parseClass(cls, true, true);
        }
        
        if (this.match(125)) {
            const result = this.tsParseInterfaceDeclaration(this.startNode());
            
            if (result)
                return result;
        }
        
        return super.parseExportDefaultExpression();
    }
    
    parseVarStatement(node, kind, allowMissingInitializer = false) {
        const {isAmbientContext} = this.state;
        
        const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
        
        if (!isAmbientContext)
            return declaration;
        
        if (!node.declare && (kind === 'using' || kind === 'await using')) {
            this.raiseOverwrite(TSErrors.UsingDeclarationInAmbientContext, node, kind);
            return declaration;
        }
        
        for (const {id, init} of declaration.declarations) {
            if (!init)
                continue;
            
            if (kind === 'var' || kind === 'let' || !!id.typeAnnotation) {
                this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);
            } else if (!isValidAmbientConstInitializer(init, this.hasPlugin('estree'))) {
                this.raise(TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);
            }
        }
        
        return declaration;
    }
    
    parseStatementContent(flags, decorators) {
        if (!this.state.containsEsc) {
            switch(this.state.type) {
            case 71: {
                if (this.isLookaheadContextual('enum')) {
                    const node = this.startNode();
                    this.expect(71);
                    return this.tsParseEnumDeclaration(node, {
                        const: true,
                    });
                }
                
                break;
            }
            
            case 120:            
            case 121: {
                if (this.nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine()) {
                    const token = this.state.type;
                    const node = this.startNode();
                    this.next();
                    const declaration = token === 121 ? this.tsTryParseDeclare(node) : this.tsParseAbstractDeclaration(node, decorators);
                    
                    if (declaration) {
                        if (token === 121) {
                            declaration.declare = true;
                        }
                        
                        return declaration;
                    } else {
                        node.expression = this.createIdentifier(this.startNodeAt(node.loc.start), token === 121 ? 'declare' : 'abstract');
                        this.semicolon(false);
                        return this.finishNode(node, 'ExpressionStatement');
                    }
                }
                
                break;
            }
            
            case 122:
                return this.tsParseEnumDeclaration(this.startNode());
            
            case 108: {
                const nextCh = this.lookaheadCharCode();
                
                if (nextCh === 123) {
                    const node = this.startNode();
                    return this.tsParseAmbientExternalModuleDeclaration(node);
                }
                
                break;
            }
            
            case 125: {
                const result = this.tsParseInterfaceDeclaration(this.startNode());
                
                if (result)
                    return result;
                
                break;
            }
            
            case 123: {
                if (this.nextTokenIsStringLiteralOnSameLine()) {
                    const node = this.startNode();
                    this.next();
                    return this.tsParseDeclaration(node, 123, false, decorators);
                } else if (this.nextTokenIsIdentifierOnSameLine()) {
                    this.raise(TSErrors.InlineModuleDeclarationMustUseString, this.state.startLoc);
                    const node = this.startNode();
                    this.next();
                    return this.tsParseDeclaration(node, 124, false, decorators);
                }
                
                break;
            }
            
            case 124: {
                if (this.nextTokenIsIdentifierOnSameLine()) {
                    const node = this.startNode();
                    this.next();
                    return this.tsParseDeclaration(node, 124, false, decorators);
                }
                
                break;
            }
            
            case 126: {
                if (this.nextTokenIsIdentifierOnSameLine()) {
                    const node = this.startNode();
                    this.next();
                    return this.tsParseTypeAliasDeclaration(node);
                }
                
                break;
            }
            }
        }
        
        return super.parseStatementContent(flags, decorators);
    }
    
    parseAccessModifier() {
        return this.tsParseModifier(['public', 'protected', 'private']);
    }
    
    tsHasSomeModifiers(member, modifiers) {
        return modifiers.some((modifier) => {
            if (tsIsAccessModifier(modifier)) {
                return member.accessibility === modifier;
            }
            
            return !!member[modifier];
        });
    }
    
    tsIsStartOfStaticBlocks() {
        return this.isContextual(102) && this.lookaheadCharCode() === 123;
    }
    
    parseClassMember(classBody2, member, state) {
        const modifiers = [
            'declare',
            'private',
            'public',
            'protected',
            'override',
            'abstract',
            'readonly',
            'static',
        ];
        
        this.tsParseModifiers({
            allowedModifiers: modifiers,
            disallowedModifiers: ['in', 'out'],
            stopOnStartOfClassStaticBlock: true,
            errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions,
        }, member);
        const callParseClassMemberWithIsStatic = () => {
            if (this.tsIsStartOfStaticBlocks()) {
                this.next();
                this.next();
                
                if (this.tsHasSomeModifiers(member, modifiers)) {
                    this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition());
                }
                
                super.parseClassStaticBlock(classBody2, member);
            } else {
                this.parseClassMemberWithIsStatic(classBody2, member, state, !!member.static);
            }
        };
        
        if (member.declare) {
            this.tsInAmbientContext(callParseClassMemberWithIsStatic);
        } else {
            callParseClassMemberWithIsStatic();
        }
    }
    
    parseClassMemberWithIsStatic(classBody2, member, state, isStatic2) {
        const idx = this.tsTryParseIndexSignature(member);
        
        if (idx) {
            classBody2.body.push(idx);
            
            if (member.abstract) {
                this.raise(TSErrors.IndexSignatureHasAbstract, member);
            }
            
            if (member.accessibility) {
                this.raise(TSErrors.IndexSignatureHasAccessibility, member, {
                    modifier: member.accessibility,
                });
            }
            
            if (member.declare) {
                this.raise(TSErrors.IndexSignatureHasDeclare, member);
            }
            
            if (member.override) {
                this.raise(TSErrors.IndexSignatureHasOverride, member);
            }
            
            return;
        }
        
        if (!this.state.inAbstractClass && member.abstract) {
            this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);
        }
        
        if (member.override) {
            if (!state.hadSuperClass) {
                this.raise(TSErrors.OverrideNotInSubClass, member);
            }
        }
        
        super.parseClassMemberWithIsStatic(classBody2, member, state, isStatic2);
    }
    
    parsePostMemberNameModifiers(methodOrProp) {
        const optional = this.eat(13);
        
        if (optional)
            methodOrProp.optional = true;
        
        if (methodOrProp.readonly && this.match(6)) {
            this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);
        }
        
        if (methodOrProp.declare && this.match(6)) {
            this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);
        }
    }
    
    shouldParseExportDeclaration() {
        if (this.tsIsDeclarationStart())
            return true;
        
        return super.shouldParseExportDeclaration();
    }
    
    parseConditional(expr, startLoc, refExpressionErrors) {
        if (!this.match(13))
            return expr;
        
        if (this.state.maybeInArrowParameters) {
            const nextCh = this.lookaheadCharCode();
            
            if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
                this.setOptionalParametersError(refExpressionErrors);
                return expr;
            }
        }
        
        return super.parseConditional(expr, startLoc, refExpressionErrors);
    }
    
    parseParenItem(node, startLoc) {
        const newNode = super.parseParenItem(node, startLoc);
        
        if (this.eat(13)) {
            newNode.optional = true;
            this.resetEndLocation(node);
        }
        
        if (this.match(10)) {
            const typeCastNode = this.startNodeAt(startLoc);
            
            typeCastNode.expression = node;
            typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
            return this.finishNode(typeCastNode, 'TSTypeCastExpression');
        }
        
        return node;
    }
    
    parseExportDeclaration(node) {
        if (!this.state.isAmbientContext && this.isContextual(121)) {
            return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
        }
        
        const startLoc = this.state.startLoc;
        const isDeclare = this.eatContextual(121);
        
        if (isDeclare && (this.isContextual(121) || !this.shouldParseExportDeclaration())) {
            throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
        }
        
        const isIdentifier5 = tokenIsIdentifier(this.state.type);
        const declaration = isIdentifier5 && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
        
        if (!declaration)
            return null;
        
        if (declaration.type === 'TSInterfaceDeclaration' || declaration.type === 'TSTypeAliasDeclaration' || isDeclare) {
            node.exportKind = 'type';
        }
        
        if (isDeclare && declaration.type !== 'TSImportEqualsDeclaration') {
            this.resetStartLocation(declaration, startLoc);
            declaration.declare = true;
        }
        
        return declaration;
    }
    
    parseClassId(node, isStatement5, optionalId) {
        if ((!isStatement5 || optionalId) && this.isContextual(109)) {
            return;
        }
        
        super.parseClassId(node, isStatement5, optionalId, node.declare ? 1024 : 8331);
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        
        if (typeParameters)
            node.typeParameters = typeParameters;
    }
    
    parseClassPropertyAnnotation(node) {
        if (!node.optional) {
            if (this.eat(31)) {
                node.definite = true;
            } else if (this.eat(13)) {
                node.optional = true;
            }
        }
        
        const type = this.tsTryParseTypeAnnotation();
        
        if (type)
            node.typeAnnotation = type;
    }
    
    parseClassProperty(node) {
        this.parseClassPropertyAnnotation(node);
        
        if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(25)) {
            this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);
        }
        
        if (node.abstract && this.match(25)) {
            const {key} = node;
            
            this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {
                propertyName: key.type === 'Identifier' && !node.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`,
            });
        }
        
        return super.parseClassProperty(node);
    }
    
    parseClassPrivateProperty(node) {
        if (node.abstract) {
            this.raise(TSErrors.PrivateElementHasAbstract, node);
        }
        
        if (node.accessibility) {
            this.raise(TSErrors.PrivateElementHasAccessibility, node, {
                modifier: node.accessibility,
            });
        }
        
        this.parseClassPropertyAnnotation(node);
        return super.parseClassPrivateProperty(node);
    }
    
    parseClassAccessorProperty(node) {
        this.parseClassPropertyAnnotation(node);
        
        if (node.optional) {
            this.raise(TSErrors.AccessorCannotBeOptional, node);
        }
        
        return super.parseClassAccessorProperty(node);
    }
    
    pushClassMethod(classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        
        if (typeParameters && isConstructor) {
            this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);
        }
        
        const {declare = false, kind} = method;
        
        if (declare && (kind === 'get' || kind === 'set')) {
            this.raise(TSErrors.DeclareAccessor, method, {
                kind,
            });
        }
        
        if (typeParameters)
            method.typeParameters = typeParameters;
        
        super.pushClassMethod(classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
    }
    
    pushClassPrivateMethod(classBody2, method, isGenerator, isAsync) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        
        if (typeParameters)
            method.typeParameters = typeParameters;
        
        super.pushClassPrivateMethod(classBody2, method, isGenerator, isAsync);
    }
    
    declareClassPrivateMethodInScope(node, kind) {
        if (node.type === 'TSDeclareMethod')
            return;
        
        if (node.type === 'MethodDefinition' && node.value.body == null) {
            return;
        }
        
        super.declareClassPrivateMethodInScope(node, kind);
    }
    
    parseClassSuper(node) {
        super.parseClassSuper(node);
        
        if (node.superClass && (this.match(43) || this.match(47))) {
            node.superTypeArguments = this.tsParseTypeArgumentsInExpression();
        }
        
        if (this.eatContextual(109)) {
            node.implements = this.tsParseHeritageClause('implements');
        }
    }
    
    parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern3, isAccessor2, refExpressionErrors) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        
        if (typeParameters)
            prop.typeParameters = typeParameters;
        
        return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern3, isAccessor2, refExpressionErrors);
    }
    
    parseFunctionParams(node, isConstructor) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        
        if (typeParameters)
            node.typeParameters = typeParameters;
        
        super.parseFunctionParams(node, isConstructor);
    }
    
    parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        
        if (decl.id.type === 'Identifier' && !this.hasPrecedingLineBreak() && this.eat(31)) {
            decl.definite = true;
        }
        
        const type = this.tsTryParseTypeAnnotation();
        
        if (type) {
            decl.id.typeAnnotation = type;
            this.resetEndLocation(decl.id);
        }
    }
    
    parseAsyncArrowFromCallExpression(node, call2) {
        if (this.match(10)) {
            node.returnType = this.tsParseTypeAnnotation();
        }
        
        return super.parseAsyncArrowFromCallExpression(node, call2);
    }
    
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        let state;
        let jsx2;
        let typeCast;
        
        if (this.hasPlugin('jsx') && (this.match(138) || this.match(43))) {
            state = this.state.clone();
            jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
            
            if (!jsx2.error)
                return jsx2.node;
            
            const {context} = this.state;
            
            const currentContext = context[context.length - 1];
            
            if (currentContext === types$2.j_oTag || currentContext === types$2.j_expr) {
                context.pop();
            }
        }
        
        if (!jsx2?.error && !this.match(43)) {
            return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        }
        
        if (!state || state === this.state)
            state = this.state.clone();
        
        let typeParameters;
        
        const arrow = this.tryParse((abort) => {
            typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
            const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
            
            if (expr.type !== 'ArrowFunctionExpression' || expr.extra?.parenthesized) {
                abort();
            }
            
            if (typeParameters?.params.length !== 0) {
                this.resetStartLocationFromNode(expr, typeParameters);
            }
            
            expr.typeParameters = typeParameters;
            
            if (this.hasPlugin('jsx') && expr.typeParameters.params.length === 1 && !expr.typeParameters.extra?.trailingComma) {
                const parameter = expr.typeParameters.params[0];
                
                if (!parameter.constraint) {
                    this.raise(TSErrors.SingleTypeParameterWithoutTrailingComma, createPositionWithColumnOffset(parameter.loc.end, 1), {
                        typeParameterName: parameter.name.name,
                    });
                }
            }
            
            return expr;
        }, state);
        
        if (!arrow.error && !arrow.aborted) {
            if (typeParameters)
                this.reportReservedArrowTypeParam(typeParameters);
            
            return arrow.node;
        }
        
        if (!jsx2) {
            assert2(!this.hasPlugin('jsx'));
            typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
            
            if (!typeCast.error)
                return typeCast.node;
        }
        
        if (jsx2?.node) {
            this.state = jsx2.failState;
            return jsx2.node;
        }
        
        if (arrow.node) {
            this.state = arrow.failState;
            
            if (typeParameters)
                this.reportReservedArrowTypeParam(typeParameters);
            
            return arrow.node;
        }
        
        if (typeCast?.node) {
            this.state = typeCast.failState;
            return typeCast.node;
        }
        
        throw jsx2?.error || arrow.error || typeCast?.error;
    }
    
    reportReservedArrowTypeParam(node) {
        if (node.params.length === 1 && !node.params[0].constraint && !node.extra?.trailingComma && this.getPluginOption('typescript', 'disallowAmbiguousJSXLike')) {
            this.raise(TSErrors.ReservedArrowTypeParam, node);
        }
    }
    
    parseMaybeUnary(refExpressionErrors, sawUnary) {
        if (!this.hasPlugin('jsx') && this.match(43)) {
            return this.tsParseTypeAssertion();
        }
        
        return super.parseMaybeUnary(refExpressionErrors, sawUnary);
    }
    
    parseArrow(node) {
        if (this.match(10)) {
            const result = this.tryParse((abort) => {
                const returnType = this.tsParseTypeOrTypePredicateAnnotation(10);
                
                if (this.canInsertSemicolon() || !this.match(15))
                    abort();
                
                return returnType;
            });
            
            if (result.aborted)
                return;
            
            if (!result.thrown) {
                if (result.error)
                    this.state = result.failState;
                
                node.returnType = result.node;
            }
        }
        
        return super.parseArrow(node);
    }
    
    parseFunctionParamType(param) {
        if (this.eat(13)) {
            param.optional = true;
        }
        
        const type = this.tsTryParseTypeAnnotation();
        
        if (type)
            param.typeAnnotation = type;
        
        this.resetEndLocation(param);
        return param;
    }
    
    isAssignable(node, isBinding3) {
        switch(node.type) {
        case 'TSTypeCastExpression':
            return this.isAssignable(node.expression, isBinding3);
        
        case 'TSParameterProperty':
            return true;
        
        default:
            return super.isAssignable(node, isBinding3);
        }
    }
    
    toAssignable(node, isLHS = false) {
        switch(node.type) {
        case 'ParenthesizedExpression':
            this.toAssignableParenthesizedExpression(node, isLHS);
            break;
        
        case 'TSAsExpression':        
        case 'TSSatisfiesExpression':        
        case 'TSNonNullExpression':        
        case 'TSTypeAssertion':
            if (isLHS) {
                this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);
            } else {
                this.raise(TSErrors.UnexpectedTypeCastInParameter, node);
            }
            
            this.toAssignable(node.expression, isLHS);
            break;
        
        case 'AssignmentExpression':
            if (!isLHS && node.left.type === 'TSTypeCastExpression') {
                node.left = this.typeCastToParameter(node.left);
            }
        
        default:
            super.toAssignable(node, isLHS);
        }
    }
    
    toAssignableParenthesizedExpression(node, isLHS) {
        switch(node.expression.type) {
        case 'TSAsExpression':        
        case 'TSSatisfiesExpression':        
        case 'TSNonNullExpression':        
        case 'TSTypeAssertion':        
        case 'ParenthesizedExpression':
            this.toAssignable(node.expression, isLHS);
            break;
        
        default:
            super.toAssignable(node, isLHS);
        }
    }
    
    checkToRestConversion(node, allowPattern) {
        switch(node.type) {
        case 'TSAsExpression':        
        case 'TSSatisfiesExpression':        
        case 'TSTypeAssertion':        
        case 'TSNonNullExpression':
            this.checkToRestConversion(node.expression, false);
            break;
        
        default:
            super.checkToRestConversion(node, allowPattern);
        }
    }
    
    isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding) {
        switch(type) {
        case 'TSTypeCastExpression':
            return true;
        
        case 'TSParameterProperty':
            return 'parameter';
        
        case 'TSNonNullExpression':
            return 'expression';
        
        case 'TSAsExpression':        
        case 'TSSatisfiesExpression':        
        case 'TSTypeAssertion':
            return (binding !== 64 || !isUnparenthesizedInAssign) && [
                'expression',
                true,
            ];
        
        default:
            return super.isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding);
        }
    }
    
    parseBindingAtom() {
        if (this.state.type === 74) {
            return this.parseIdentifier(true);
        }
        
        return super.parseBindingAtom();
    }
    
    parseMaybeDecoratorArguments(expr, startLoc) {
        if (this.match(43) || this.match(47)) {
            const typeArguments = this.tsParseTypeArgumentsInExpression();
            
            if (this.match(6)) {
                const call2 = super.parseMaybeDecoratorArguments(expr, startLoc);
                
                call2.typeArguments = typeArguments;
                return call2;
            }
            
            this.unexpected(null, 6);
        }
        
        return super.parseMaybeDecoratorArguments(expr, startLoc);
    }
    
    checkCommaAfterRest(close) {
        if (this.state.isAmbientContext && this.match(8) && this.lookaheadCharCode() === close) {
            this.next();
            return false;
        }
        
        return super.checkCommaAfterRest(close);
    }
    
    isClassMethod() {
        return this.match(43) || super.isClassMethod();
    }
    
    isClassProperty() {
        return this.match(31) || this.match(10) || super.isClassProperty();
    }
    
    parseMaybeDefault(startLoc, left) {
        const node = super.parseMaybeDefault(startLoc, left);
        
        if (node.type === 'AssignmentPattern' && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
            this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);
        }
        
        return node;
    }
    
    getTokenFromCode(code2) {
        if (this.state.inType) {
            if (code2 === 62) {
                this.finishOp(44, 1);
                return;
            }
            
            if (code2 === 60) {
                this.finishOp(43, 1);
                return;
            }
        }
        
        super.getTokenFromCode(code2);
    }
    
    reScan_lt_gt() {
        const {type} = this.state;
        
        if (type === 43) {
            this.state.pos -= 1;
            this.readToken_lt();
        } else if (type === 44) {
            this.state.pos -= 1;
            this.readToken_gt();
        }
    }
    
    reScan_lt() {
        const {type} = this.state;
        
        if (type === 47) {
            this.state.pos -= 2;
            this.finishOp(43, 1);
            return 43;
        }
        
        return type;
    }
    
    toAssignableListItem(exprList, index2, isLHS) {
        const node = exprList[index2];
        
        if (node.type === 'TSTypeCastExpression') {
            exprList[index2] = this.typeCastToParameter(node);
        }
        
        super.toAssignableListItem(exprList, index2, isLHS);
    }
    
    typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
        return node.expression;
    }
    
    shouldParseArrow(params) {
        if (this.match(10)) {
            return params.every((expr) => this.isAssignable(expr, true));
        }
        
        return super.shouldParseArrow(params);
    }
    
    shouldParseAsyncArrow() {
        return this.match(10) || super.shouldParseAsyncArrow();
    }
    
    canHaveLeadingDecorator() {
        return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    
    jsxParseOpeningElementAfterName(node) {
        if (this.match(43) || this.match(47)) {
            const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
            
            if (typeArguments) {
                node.typeArguments = typeArguments;
            }
        }
        
        return super.jsxParseOpeningElementAfterName(node);
    }
    
    getGetterSetterExpectedParamCount(method) {
        const baseCount = super.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        const firstParam = params[0];
        const hasContextParam = firstParam && this.isThisParam(firstParam);
        
        return hasContextParam ? baseCount + 1 : baseCount;
    }
    
    parseCatchClauseParam() {
        const param = super.parseCatchClauseParam();
        const type = this.tsTryParseTypeAnnotation();
        
        if (type) {
            param.typeAnnotation = type;
            this.resetEndLocation(param);
        }
        
        return param;
    }
    
    tsInAmbientContext(cb) {
        const {
            isAmbientContext: oldIsAmbientContext,
            strict: oldStrict,
        } = this.state;
        
        this.state.isAmbientContext = true;
        this.state.strict = false;
        try {
            return cb();
        } finally {
            this.state.isAmbientContext = oldIsAmbientContext;
            this.state.strict = oldStrict;
        }
    }
    
    parseClass(node, isStatement5, optionalId) {
        const oldInAbstractClass = this.state.inAbstractClass;
        
        this.state.inAbstractClass = !!node.abstract;
        try {
            return super.parseClass(node, isStatement5, optionalId);
        } finally {
            this.state.inAbstractClass = oldInAbstractClass;
        }
    }
    
    tsParseAbstractDeclaration(node, decorators) {
        if (this.match(76)) {
            node.abstract = true;
            return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));
        } else if (this.isContextual(125)) {
            if (!this.hasFollowingLineBreak()) {
                node.abstract = true;
                this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifier, node);
                return this.tsParseInterfaceDeclaration(node);
            } else {
                return null;
            }
        }
        
        throw this.unexpected(null, 76);
    }
    
    parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
        const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        
        if (method.abstract || method.type === 'TSAbstractMethodDefinition') {
            const hasEstreePlugin = this.hasPlugin('estree');
            const methodFn = hasEstreePlugin ? method.value : method;
            
            if (methodFn.body) {
                const {key} = method;
                
                this.raise(TSErrors.AbstractMethodHasImplementation, method, {
                    methodName: key.type === 'Identifier' && !method.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`,
                });
            }
        }
        
        return method;
    }
    
    tsParseTypeParameterName() {
        return this.parseIdentifier();
    }
    
    shouldParseAsAmbientContext() {
        return !!this.getPluginOption('typescript', 'dts');
    }
    
    parse() {
        if (this.shouldParseAsAmbientContext()) {
            this.state.isAmbientContext = true;
        }
        
        return super.parse();
    }
    
    getExpression() {
        if (this.shouldParseAsAmbientContext()) {
            this.state.isAmbientContext = true;
        }
        
        return super.getExpression();
    }
    
    parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
        if (!isString && isMaybeTypeOnly) {
            this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
            return this.finishNode(node, 'ExportSpecifier');
        }
        
        node.exportKind = 'value';
        return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);
    }
    
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
        if (!importedIsString && isMaybeTypeOnly) {
            this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
            return this.finishNode(specifier, 'ImportSpecifier');
        }
        
        specifier.importKind = 'value';
        return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);
    }
    
    parseTypeOnlyImportExportSpecifier(node, isImport2, isInTypeOnlyImportExport) {
        const leftOfAsKey = isImport2 ? 'imported' : 'local';
        const rightOfAsKey = isImport2 ? 'local' : 'exported';
        let leftOfAs = node[leftOfAsKey];
        let rightOfAs;
        let hasTypeSpecifier = false;
        let canParseAsKeyword = true;
        const loc = leftOfAs.loc.start;
        
        if (this.isContextual(89)) {
            const firstAs = this.parseIdentifier();
            
            if (this.isContextual(89)) {
                const secondAs = this.parseIdentifier();
                
                if (tokenIsKeywordOrIdentifier(this.state.type)) {
                    hasTypeSpecifier = true;
                    leftOfAs = firstAs;
                    rightOfAs = isImport2 ? this.parseIdentifier() : this.parseModuleExportName();
                    canParseAsKeyword = false;
                } else {
                    rightOfAs = secondAs;
                    canParseAsKeyword = false;
                }
            } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
                canParseAsKeyword = false;
                rightOfAs = isImport2 ? this.parseIdentifier() : this.parseModuleExportName();
            } else {
                hasTypeSpecifier = true;
                leftOfAs = firstAs;
            }
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            hasTypeSpecifier = true;
            
            if (isImport2) {
                leftOfAs = this.parseIdentifier(true);
                
                if (!this.isContextual(89)) {
                    this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
                }
            } else {
                leftOfAs = this.parseModuleExportName();
            }
        }
        
        if (hasTypeSpecifier && isInTypeOnlyImportExport) {
            this.raise(isImport2 ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);
        }
        
        node[leftOfAsKey] = leftOfAs;
        node[rightOfAsKey] = rightOfAs;
        const kindKey = isImport2 ? 'importKind' : 'exportKind';
        
        node[kindKey] = hasTypeSpecifier ? 'type' : 'value';
        
        if (canParseAsKeyword && this.eatContextual(89)) {
            node[rightOfAsKey] = isImport2 ? this.parseIdentifier() : this.parseModuleExportName();
        }
        
        if (!node[rightOfAsKey]) {
            node[rightOfAsKey] = this.cloneIdentifier(node[leftOfAsKey]);
        }
        
        if (isImport2) {
            this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
        }
    }
    
    fillOptionalPropertiesForTSESLint(node) {
        switch(node.type) {
        case 'ExpressionStatement':
            node.directive ??= void 0;
            return;
        
        case 'RestElement':
            node.value = void 0;
        
        case 'Identifier':        
        case 'ArrayPattern':        
        case 'AssignmentPattern':        
        case 'ObjectPattern':
            node.decorators ??= [];
            node.optional ??= false;
            node.typeAnnotation ??= void 0;
            return;
        
        case 'TSParameterProperty':
            node.accessibility ??= void 0;
            node.decorators ??= [];
            node.override ??= false;
            node.readonly ??= false;
            node.static ??= false;
            return;
        
        case 'TSEmptyBodyFunctionExpression':
            node.body = null;
        
        case 'TSDeclareFunction':        
        case 'FunctionDeclaration':        
        case 'FunctionExpression':        
        case 'ClassMethod':        
        case 'ClassPrivateMethod':
            node.declare ??= false;
            node.returnType ??= void 0;
            node.typeParameters ??= void 0;
            return;
        
        case 'Property':
            node.optional ??= false;
            return;
        
        case 'TSMethodSignature':        
        case 'TSPropertySignature':
            node.optional ??= false;
        
        case 'TSIndexSignature':
            node.accessibility ??= void 0;
            node.readonly ??= false;
            node.static ??= false;
            return;
        
        case 'TSAbstractPropertyDefinition':        
        case 'PropertyDefinition':        
        case 'TSAbstractAccessorProperty':        
        case 'AccessorProperty':
            node.declare ??= false;
            node.definite ??= false;
            node.readonly ??= false;
            node.typeAnnotation ??= void 0;
        
        case 'TSAbstractMethodDefinition':        
        case 'MethodDefinition':
            node.accessibility ??= void 0;
            node.decorators ??= [];
            node.override ??= false;
            node.optional ??= false;
            return;
        
        case 'ClassExpression':
            node.id ??= null;
        
        case 'ClassDeclaration':
            node.abstract ??= false;
            node.declare ??= false;
            node.decorators ??= [];
            node.implements ??= [];
            node.superTypeArguments ??= void 0;
            node.typeParameters ??= void 0;
            return;
        
        case 'TSTypeAliasDeclaration':        
        case 'VariableDeclaration':
            node.declare ??= false;
            return;
        
        case 'VariableDeclarator':
            node.definite ??= false;
            return;
        
        case 'TSEnumDeclaration':
            node.const ??= false;
            node.declare ??= false;
            return;
        
        case 'TSEnumMember':
            node.computed ??= false;
            return;
        
        case 'TSImportType':
            node.qualifier ??= null;
            node.options ??= null;
            node.typeArguments ??= null;
            return;
        
        case 'TSInterfaceDeclaration':
            node.declare ??= false;
            node.extends ??= [];
            return;
        
        case 'TSMappedType':
            node.optional ??= false;
            node.readonly ??= void 0;
            return;
        
        case 'TSModuleDeclaration':
            node.declare ??= false;
            node.global ??= node.kind === 'global';
            return;
        
        case 'TSTypeParameter':
            node.const ??= false;
            node.in ??= false;
            node.out ??= false;
            return;
        }
    }
    
    chStartsBindingIdentifierAndNotRelationalOperator(ch, pos) {
        if (isIdentifierStart2(ch)) {
            keywordAndTSRelationalOperator.lastIndex = pos;
            
            if (keywordAndTSRelationalOperator.test(this.input)) {
                const endCh = this.codePointAtPos(keywordAndTSRelationalOperator.lastIndex);
                
                if (!isIdentifierChar2(endCh) && endCh !== 92) {
                    return false;
                }
            }
            
            return true;
        } else if (ch === 92) {
            return true;
        } else {
            return false;
        }
    }
    
    nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine() {
        const next = this.nextTokenInLineStart();
        const nextCh = this.codePointAtPos(next);
        
        return this.chStartsBindingIdentifierAndNotRelationalOperator(nextCh, next);
    }
    
    nextTokenIsStringLiteralOnSameLine() {
        const next = this.nextTokenInLineStart();
        const nextCh = this.codePointAtPos(next);
        
        return nextCh === 34 || nextCh === 39;
    }
};

function isPossiblyLiteralEnum(expression2) {
    if (expression2.type !== 'MemberExpression')
        return false;
    
    const {computed, property} = expression2;
    
    if (computed && property.type !== 'StringLiteral' && (property.type !== 'TemplateLiteral' || property.expressions.length > 0)) {
        return false;
    }
    
    return isUncomputedMemberExpressionChain(expression2.object);
}

function isValidAmbientConstInitializer(expression2, estree2) {
    const {type} = expression2;
    
    if (expression2.extra?.parenthesized) {
        return false;
    }
    
    if (estree2) {
        if (type === 'Literal') {
            const {value} = expression2;
            
            if (typeof value === 'string' || typeof value === 'boolean') {
                return true;
            }
        }
    } else {
        if (type === 'StringLiteral' || type === 'BooleanLiteral') {
            return true;
        }
    }
    
    if (isNumber$3(expression2, estree2) || isNegativeNumber(expression2, estree2)) {
        return true;
    }
    
    if (type === 'TemplateLiteral' && expression2.expressions.length === 0) {
        return true;
    }
    
    if (isPossiblyLiteralEnum(expression2)) {
        return true;
    }
    
    return false;
}

function isNumber$3(expression2, estree2) {
    if (estree2) {
        return expression2.type === 'Literal' && (typeof expression2.value === 'number' || 'bigint' in expression2);
    }
    
    return expression2.type === 'NumericLiteral' || expression2.type === 'BigIntLiteral';
}

function isNegativeNumber(expression2, estree2) {
    if (expression2.type === 'UnaryExpression') {
        const {operator, argument} = expression2;
        
        if (operator === '-' && isNumber$3(argument, estree2)) {
            return true;
        }
    }
    
    return false;
}

function isUncomputedMemberExpressionChain(expression2) {
    if (expression2.type === 'Identifier')
        return true;
    
    if (expression2.type !== 'MemberExpression' || expression2.computed) {
        return false;
    }
    
    return isUncomputedMemberExpressionChain(expression2.object);
}

var PlaceholderErrors = ParseErrorEnum`placeholders`({
    ClassNameIsRequired: 'A class name is required.',
    UnexpectedSpace: 'Unexpected space in placeholder.',
});

var placeholders = (superClass) => class PlaceholdersParserMixin extends superClass {
    parsePlaceholder(expectedNode) {
        if (this.match(129)) {
            const node = this.startNode();
            this.next();
            this.assertNoSpace();
            node.name = super.parseIdentifier(true);
            this.assertNoSpace();
            this.expect(129);
            return this.finishPlaceholder(node, expectedNode);
        }
    }
    
    finishPlaceholder(node, expectedNode) {
        let placeholder2 = node;
        
        if (!placeholder2.expectedNode || !placeholder2.type) {
            placeholder2 = this.finishNode(placeholder2, 'Placeholder');
        }
        
        placeholder2.expectedNode = expectedNode;
        return placeholder2;
    }
    
    getTokenFromCode(code2) {
        if (code2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
            this.finishOp(129, 2);
        } else {
            super.getTokenFromCode(code2);
        }
    }
    
    parseExprAtom(refExpressionErrors) {
        return this.parsePlaceholder('Expression') || super.parseExprAtom(refExpressionErrors);
    }
    
    parseIdentifier(liberal) {
        return this.parsePlaceholder('Identifier') || super.parseIdentifier(liberal);
    }
    
    checkReservedWord(word, startLoc, checkKeywords, isBinding3) {
        if (word !== void 0) {
            super.checkReservedWord(word, startLoc, checkKeywords, isBinding3);
        }
    }
    
    cloneIdentifier(node) {
        const cloned = super.cloneIdentifier(node);
        
        if (cloned.type === 'Placeholder') {
            cloned.expectedNode = node.expectedNode;
        }
        
        return cloned;
    }
    
    cloneStringLiteral(node) {
        if (node.type === 'Placeholder') {
            return this.cloneIdentifier(node);
        }
        
        return super.cloneStringLiteral(node);
    }
    
    parseBindingAtom() {
        return this.parsePlaceholder('Pattern') || super.parseBindingAtom();
    }
    
    isValidLVal(type, disallowCallExpression, isParenthesized, binding) {
        return type === 'Placeholder' || super.isValidLVal(type, disallowCallExpression, isParenthesized, binding);
    }
    
    toAssignable(node, isLHS) {
        if (node && node.type === 'Placeholder' && node.expectedNode === 'Expression') {
            node.expectedNode = 'Pattern';
        } else {
            super.toAssignable(node, isLHS);
        }
    }
    
    chStartsBindingIdentifier(ch, pos) {
        if (super.chStartsBindingIdentifier(ch, pos)) {
            return true;
        }
        
        const next = this.nextTokenStart();
        
        if (this.input.charCodeAt(next) === 37 && this.input.charCodeAt(next + 1) === 37) {
            return true;
        }
        
        return false;
    }
    
    verifyBreakContinue(node, isBreak) {
        if (node.label?.type === 'Placeholder')
            return;
        
        super.verifyBreakContinue(node, isBreak);
    }
    
    parseExpressionStatement(node, expr) {
        if (expr.type !== 'Placeholder' || expr.extra?.parenthesized) {
            return super.parseExpressionStatement(node, expr);
        }
        
        if (this.match(10)) {
            const stmt = node;
            
            stmt.label = this.finishPlaceholder(expr, 'Identifier');
            this.next();
            stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();
            return this.finishNode(stmt, 'LabeledStatement');
        }
        
        this.semicolon();
        const stmtPlaceholder = node;
        
        stmtPlaceholder.name = expr.name;
        return this.finishPlaceholder(stmtPlaceholder, 'Statement');
    }
    
    parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
        return this.parsePlaceholder('BlockStatement') || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
    }
    
    parseFunctionId(requireId) {
        return this.parsePlaceholder('Identifier') || super.parseFunctionId(requireId);
    }
    
    parseClass(node, isStatement5, optionalId) {
        const type = isStatement5 ? 'ClassDeclaration' : 'ClassExpression';
        this.next();
        const oldStrict = this.state.strict;
        const placeholder2 = this.parsePlaceholder('Identifier');
        
        if (placeholder2) {
            if (this.match(77) || this.match(129) || this.match(2)) {
                node.id = placeholder2;
            } else if (optionalId || !isStatement5) {
                node.id = null;
                node.body = this.finishPlaceholder(placeholder2, 'ClassBody');
                return this.finishNode(node, type);
            } else {
                throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);
            }
        } else {
            this.parseClassId(node, isStatement5, optionalId);
        }
        
        super.parseClassSuper(node);
        node.body = this.parsePlaceholder('ClassBody') || super.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, type);
    }
    
    parseExport(node, decorators) {
        const placeholder2 = this.parsePlaceholder('Identifier');
        
        if (!placeholder2)
            return super.parseExport(node, decorators);
        
        const node2 = node;
        
        if (!this.isContextual(94) && !this.match(8)) {
            node2.specifiers = [];
            node2.source = null;
            node2.declaration = this.finishPlaceholder(placeholder2, 'Declaration');
            return this.finishNode(node2, 'ExportNamedDeclaration');
        }
        
        this.expectPlugin('exportDefaultFrom');
        const specifier = this.startNode();
        
        specifier.exported = placeholder2;
        node2.specifiers = [
            this.finishNode(specifier, 'ExportDefaultSpecifier'),
        ];
        return super.parseExport(node2, decorators);
    }
    
    isExportDefaultSpecifier() {
        if (this.match(61)) {
            const next = this.nextTokenStart();
            
            if (this.isUnparsedContextual(next, 'from')) {
                if (this.input.startsWith(tokenLabelName(129), this.nextTokenStartSince(next + 4))) {
                    return true;
                }
            }
        }
        
        return super.isExportDefaultSpecifier();
    }
    
    maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
        if (node.specifiers?.length) {
            return true;
        }
        
        return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
    }
    
    checkExport(node) {
        const {specifiers} = node;
        
        if (specifiers?.length) {
            node.specifiers = specifiers.filter((node2) => node2.exported.type === 'Placeholder');
        }
        
        super.checkExport(node);
        node.specifiers = specifiers;
    }
    
    parseImport(node) {
        const placeholder2 = this.parsePlaceholder('Identifier');
        
        if (!placeholder2)
            return super.parseImport(node);
        
        node.specifiers = [];
        
        if (!this.isContextual(94) && !this.match(8)) {
            node.source = this.finishPlaceholder(placeholder2, 'StringLiteral');
            this.semicolon();
            return this.finishNode(node, 'ImportDeclaration');
        }
        
        const specifier = this.startNodeAtNode(placeholder2);
        
        specifier.local = placeholder2;
        node.specifiers.push(this.finishNode(specifier, 'ImportDefaultSpecifier'));
        
        if (this.eat(8)) {
            const hasStarImport = this.maybeParseStarImportSpecifier(node);
            
            if (!hasStarImport)
                this.parseNamedImportSpecifiers(node);
        }
        
        this.expectContextual(94);
        node.source = this.parseImportSource();
        this.semicolon();
        return this.finishNode(node, 'ImportDeclaration');
    }
    
    parseImportSource() {
        return this.parsePlaceholder('StringLiteral') || super.parseImportSource();
    }
    
    assertNoSpace() {
        if (this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index)) {
            this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);
        }
    }
};

var v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {
    parseV8Intrinsic() {
        if (this.match(50)) {
            const v8IntrinsicStartLoc = this.state.startLoc;
            const node = this.startNode();
            this.next();
            
            if (tokenIsIdentifier(this.state.type)) {
                const name = this.parseIdentifierName();
                const identifier4 = this.createIdentifier(node, name);
                this.castNodeTo(identifier4, 'V8IntrinsicIdentifier');
                
                if (this.match(6)) {
                    return identifier4;
                }
            }
            
            this.unexpected(v8IntrinsicStartLoc);
        }
    }
    
    parseExprAtom(refExpressionErrors) {
        return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
    }
};

var PIPELINE_PROPOSALS = [
    'fsharp',
    'hack',
];
var TOPIC_TOKENS = [
    '^^',
    '@@',
    '^',
    '%',
    '#',
];

function validatePlugins(pluginsMap) {
    if (pluginsMap.has('decorators')) {
        if (pluginsMap.has('decorators-legacy')) {
            throw new Error('Cannot use the decorators and decorators-legacy plugin together');
        }
    }
    
    if (pluginsMap.has('flow') && pluginsMap.has('typescript')) {
        throw new Error('Cannot combine flow and typescript plugins.');
    }
    
    if (pluginsMap.has('placeholders') && pluginsMap.has('v8intrinsic')) {
        throw new Error('Cannot combine placeholders and v8intrinsic plugins.');
    }
    
    if (pluginsMap.has('pipelineOperator')) {
        const proposal = pluginsMap.get('pipelineOperator').proposal;
        
        if (!PIPELINE_PROPOSALS.includes(proposal)) {
            const proposalList = PIPELINE_PROPOSALS
                .map((p) => `"${p}"`)
                .join(', ');
            throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
        }
        
        if (proposal === 'hack') {
            if (pluginsMap.has('placeholders')) {
                throw new Error('Cannot combine placeholders plugin and Hack-style pipes.');
            }
            
            if (pluginsMap.has('v8intrinsic')) {
                throw new Error('Cannot combine v8intrinsic plugin and Hack-style pipes.');
            }
            
            const topicToken = pluginsMap.get('pipelineOperator').topicToken;
            
            if (!TOPIC_TOKENS.includes(topicToken)) {
                const tokenList = TOPIC_TOKENS
                    .map((t) => `"${t}"`)
                    .join(', ');
                throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
            }
        }
    }
    
    if (pluginsMap.has('moduleAttributes')) {
        throw new Error('`moduleAttributes` has been removed in Babel 8, please migrate to import attributes instead.');
    }
    
    if (pluginsMap.has('importAssertions')) {
        throw new Error('`importAssertions` has been removed in Babel 8, please use import attributes instead.');
    }
    
    if (pluginsMap.has('deprecatedImportAssert')) {
        console.warn('`deprecatedImportAssert` has been removed in Babel 8, please use import attributes instead.');
    } else if (pluginsMap.has('importAttributes') && pluginsMap.get('importAttributes').deprecatedAssertSyntax) {
        console.warn('The \'importAttributes\' plugin has been removed in Babel 8. Please migrate any usage of `assert`-style attributes to `with`.');
    }
    
    if (pluginsMap.has('recordAndTuple')) {
        throw new Error('The \'recordAndTuple\' plugin has been removed in Babel 8. Please remove it from your configuration.');
    }
    
    if (pluginsMap.has('asyncDoExpressions') && !pluginsMap.has('doExpressions')) {
        const error = new Error('\'asyncDoExpressions\' requires \'doExpressions\', please add \'doExpressions\' to parser plugins.');
        
        error.missingPlugins = 'doExpressions';
        throw error;
    }
    
    if (pluginsMap.has('optionalChainingAssign') && pluginsMap.get('optionalChainingAssign').version !== '2023-07') {
        throw new Error('The \'optionalChainingAssign\' plugin requires a \'version\' option, representing the last proposal update. Currently, the only supported value is \'2023-07\'.');
    }
    
    if (pluginsMap.has('discardBinding') && pluginsMap.get('discardBinding').syntaxType !== 'void') {
        throw new Error('The \'discardBinding\' plugin requires a \'syntaxType\' option. Currently the only supported value is \'void\'.');
    }
    
    if (pluginsMap.has('decimal')) {
        throw new Error('The \'decimal\' plugin has been removed in Babel 8. Please remove it from your configuration.');
    }
    
    if (pluginsMap.has('importReflection')) {
        throw new Error('The \'importReflection\' plugin has been removed in Babel 8. Use \'sourcePhaseImports\' instead, and replace \'import module\' with \'import source\' in your code.');
    }
}

var mixinPlugins = {
    estree,
    jsx,
    typescript: typescript$1,
    v8intrinsic,
    placeholders,
};

var mixinPluginNames = Object.keys(mixinPlugins);

var ExpressionParser = class extends LValParser {
    checkProto(prop, sawProto, refExpressionErrors) {
        if (prop.type === 'SpreadElement' || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
            return sawProto;
        }
        
        const key = prop.key;
        const name = key.type === 'Identifier' ? key.name : key.value;
        
        if (name === '__proto__') {
            if (sawProto) {
                if (refExpressionErrors) {
                    if (refExpressionErrors.doubleProtoLoc === null) {
                        refExpressionErrors.doubleProtoLoc = key.loc.start;
                    }
                } else {
                    this.raise(Errors.DuplicateProto, key);
                }
            }
            
            return true;
        }
        
        return sawProto;
    }
    
    shouldExitDescending(expr, potentialArrowAt) {
        return expr.type === 'ArrowFunctionExpression' && this.offsetToSourcePos(expr.start) === potentialArrowAt;
    }
    
    getExpression() {
        this.enterInitialScopes();
        this.nextToken();
        
        if (this.match(135)) {
            throw this.raise(Errors.ParseExpressionEmptyInput, this.state.startLoc);
        }
        
        const expr = this.parseExpression();
        
        if (!this.match(135)) {
            throw this.raise(Errors.ParseExpressionExpectsEOF, this.state.startLoc, {
                unexpected: this.input.codePointAt(this.state.start),
            });
        }
        
        this.finalizeRemainingComments();
        expr.comments = this.comments;
        expr.errors = this.state.errors;
        
        if (this.optionFlags & 256) {
            expr.tokens = createExportedTokens(this.tokens);
        }
        
        return expr;
    }
    
    parseExpression(disallowIn, refExpressionErrors) {
        if (disallowIn) {
            return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
        }
        
        return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
    }
    
    parseExpressionBase(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const expr = this.parseMaybeAssign(refExpressionErrors);
        
        if (this.match(8)) {
            const node = this.startNodeAt(startLoc);
            
            node.expressions = [expr];
            while (this.eat(8)) {
                node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
            }
            
            this.toReferencedList(node.expressions);
            return this.finishNode(node, 'SequenceExpression');
        }
        
        return expr;
    }
    
    parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
        return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
    }
    
    parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
        return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
    }
    
    setOptionalParametersError(refExpressionErrors) {
        refExpressionErrors.optionalParametersLoc = this.state.startLoc;
    }
    
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        const startLoc = this.state.startLoc;
        const isYield = this.isContextual(104);
        
        if (isYield) {
            if (this.prodParam.hasYield) {
                this.next();
                let left2 = this.parseYield(startLoc);
                
                if (afterLeftParse) {
                    left2 = afterLeftParse.call(this, left2, startLoc);
                }
                
                return left2;
            }
        }
        
        let ownExpressionErrors;
        
        if (refExpressionErrors) {
            ownExpressionErrors = false;
        } else {
            refExpressionErrors = new ExpressionErrors();
            ownExpressionErrors = true;
        }
        
        const {type} = this.state;
        
        if (type === 6 || tokenIsIdentifier(type)) {
            this.state.potentialArrowAt = this.state.start;
        }
        
        let left = this.parseMaybeConditional(refExpressionErrors);
        
        if (afterLeftParse) {
            left = afterLeftParse.call(this, left, startLoc);
        }
        
        if (tokenIsAssignment(this.state.type)) {
            const node = this.startNodeAt(startLoc);
            const operator = this.state.value;
            
            node.operator = operator;
            
            if (this.match(25)) {
                this.toAssignable(left, true);
                node.left = left;
                const startIndex = startLoc.index;
                
                if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
                    refExpressionErrors.doubleProtoLoc = null;
                }
                
                if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
                    refExpressionErrors.shorthandAssignLoc = null;
                }
                
                if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
                    this.checkDestructuringPrivate(refExpressionErrors);
                    refExpressionErrors.privateKeyLoc = null;
                }
                
                if (refExpressionErrors.voidPatternLoc != null && refExpressionErrors.voidPatternLoc.index >= startIndex) {
                    refExpressionErrors.voidPatternLoc = null;
                }
            } else {
                node.left = left;
            }
            
            this.next();
            node.right = this.parseMaybeAssign();
            this.checkLVal(left, this.finishNode(node, 'AssignmentExpression'), void 0, void 0, void 0, void 0, operator === '||=' || operator === '&&=' || operator === '??=');
            return node;
        } else if (ownExpressionErrors) {
            this.checkExpressionErrors(refExpressionErrors, true);
        }
        
        if (isYield) {
            const {type: type2} = this.state;
            
            const startsExpr2 = this.hasPlugin('v8intrinsic') ? tokenCanStartExpression(type2) : tokenCanStartExpression(type2) && !this.match(50);
            
            if (startsExpr2 && !this.isAmbiguousPrefixOrIdentifier()) {
                this.raiseOverwrite(Errors.YieldNotInGeneratorFunction, startLoc);
                return this.parseYield(startLoc);
            }
        }
        
        return left;
    }
    
    parseMaybeConditional(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprOps(refExpressionErrors);
        
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
        }
        
        return this.parseConditional(expr, startLoc, refExpressionErrors);
    }
    
    parseConditional(expr, startLoc) {
        if (this.eat(13)) {
            const node = this.startNodeAt(startLoc);
            
            node.test = expr;
            node.consequent = this.parseMaybeAssignAllowIn();
            this.expect(10);
            node.alternate = this.parseMaybeAssign();
            return this.finishNode(node, 'ConditionalExpression');
        }
        
        return expr;
    }
    
    parseMaybeUnaryOrPrivate(refExpressionErrors) {
        return this.match(134) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
    }
    
    parseExprOps(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
        
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
        }
        
        return this.parseExprOp(expr, startLoc, -1);
    }
    
    parseExprOp(left, leftStartLoc, minPrec) {
        if (this.isPrivateName(left)) {
            const value = this.getPrivateNameSV(left);
            
            if (minPrec >= tokenOperatorPrecedence(54) || !this.prodParam.hasIn || !this.match(54)) {
                this.raise(Errors.PrivateInExpectedIn, left, {
                    identifierName: value,
                });
            }
            
            this.classScope.usePrivateName(value, left.loc.start);
        }
        
        const op = this.state.type;
        
        if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(54))) {
            let prec = tokenOperatorPrecedence(op);
            
            if (prec > minPrec) {
                if (op === 35) {
                    this.expectPlugin('pipelineOperator');
                    
                    if (this.state.inFSharpPipelineDirectBody) {
                        return left;
                    }
                }
                
                const node = this.startNodeAt(leftStartLoc);
                
                node.left = left;
                node.operator = this.state.value;
                const logical = op === 37 || op === 38;
                const coalesce = op === 36;
                
                if (coalesce) {
                    prec = tokenOperatorPrecedence(38);
                }
                
                this.next();
                node.right = this.parseExprOpRightExpr(op, prec);
                const finishedNode = this.finishNode(node, logical || coalesce ? 'LogicalExpression' : 'BinaryExpression');
                const nextOp = this.state.type;
                
                if (coalesce && (nextOp === 37 || nextOp === 38) || logical && nextOp === 36) {
                    throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);
                }
                
                return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
            }
        }
        
        return left;
    }
    
    parseExprOpRightExpr(op, prec) {
        switch(op) {
        case 35:
            switch(this.getPluginOption('pipelineOperator', 'proposal')) {
            case 'hack':
                return this.withTopicBindingContext(() => {
                    return this.parseHackPipeBody();
                });
            
            case 'fsharp':
                return this.withSoloAwaitPermittingContext(() => {
                    return this.parseFSharpPipelineBody(prec);
                });
            }
        
        default:
            return this.parseExprOpBaseRightExpr(op, prec);
        }
    }
    
    parseExprOpBaseRightExpr(op, prec) {
        const startLoc = this.state.startLoc;
        return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
    }
    
    parseHackPipeBody() {
        const {startLoc} = this.state;
        
        const body = this.parseMaybeAssign();
        const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
        
        if (requiredParentheses && !body.extra?.parenthesized) {
            this.raise(Errors.PipeUnparenthesizedBody, startLoc, {
                type: body.type,
            });
        }
        
        if (!this.topicReferenceWasUsedInCurrentContext()) {
            this.raise(Errors.PipeTopicUnused, startLoc);
        }
        
        return body;
    }
    
    checkExponentialAfterUnary(node) {
        if (this.match(53)) {
            this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);
        }
    }
    
    parseMaybeUnary(refExpressionErrors, sawUnary) {
        const startLoc = this.state.startLoc;
        const isAwait = this.isContextual(92);
        
        if (isAwait && this.recordAwaitIfAllowed()) {
            this.next();
            const expr2 = this.parseAwait(startLoc);
            
            if (!sawUnary)
                this.checkExponentialAfterUnary(expr2);
            
            return expr2;
        }
        
        const update = this.match(30);
        const node = this.startNode();
        
        if (tokenIsPrefix(this.state.type)) {
            node.operator = this.state.value;
            node.prefix = true;
            
            if (this.match(68)) {
                this.expectPlugin('throwExpressions');
            }
            
            const isDelete = this.match(85);
            this.next();
            node.argument = this.parseMaybeUnary(null, true);
            this.checkExpressionErrors(refExpressionErrors, true);
            
            if (this.state.strict && isDelete) {
                const arg = node.argument;
                
                if (arg.type === 'Identifier') {
                    this.raise(Errors.StrictDelete, node);
                } else if (this.hasPropertyAsPrivateName(arg)) {
                    this.raise(Errors.DeletePrivateField, node);
                }
            }
            
            if (!update) {
                if (!sawUnary) {
                    this.checkExponentialAfterUnary(node);
                }
                
                return this.finishNode(node, 'UnaryExpression');
            }
        }
        
        const expr = this.parseUpdate(node, update, refExpressionErrors);
        
        if (isAwait) {
            const {type} = this.state;
            
            const startsExpr2 = this.hasPlugin('v8intrinsic') ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(50);
            
            if (startsExpr2 && !this.isAmbiguousPrefixOrIdentifier()) {
                this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);
                return this.parseAwait(startLoc);
            }
        }
        
        return expr;
    }
    
    parseUpdate(node, update, refExpressionErrors) {
        if (update) {
            const updateExpressionNode = node;
            this.checkLVal(updateExpressionNode.argument, this.finishNode(
                updateExpressionNode,
                'UpdateExpression',
            ));
            return node;
        }
        
        const startLoc = this.state.startLoc;
        let expr = this.parseExprSubscripts(refExpressionErrors);
        
        if (this.checkExpressionErrors(refExpressionErrors, false))
            return expr;
        
        while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
            const node2 = this.startNodeAt(startLoc);
            
            node2.operator = this.state.value;
            node2.prefix = false;
            node2.argument = expr;
            this.next();
            this.checkLVal(expr, expr = this.finishNode(node2, 'UpdateExpression'));
        }
        
        return expr;
    }
    
    parseExprSubscripts(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprAtom(refExpressionErrors);
        
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
        }
        
        return this.parseSubscripts(expr, startLoc);
    }
    
    parseSubscripts(base, startLoc, noCalls) {
        const state = {
            optionalChainMember: false,
            maybeAsyncArrow: this.atPossibleAsyncArrow(base),
            stop: false,
        };
        
        do {
            base = this.parseSubscript(base, startLoc, noCalls, state);
            state.maybeAsyncArrow = false;
        } while (!state.stop)
        
        return base;
    }
    
    parseSubscript(base, startLoc, noCalls, state) {
        const {type} = this.state;
        
        if (!noCalls && type === 11) {
            return this.parseBind(base, startLoc, noCalls, state);
        } else if (tokenIsTemplate(type)) {
            return this.parseTaggedTemplateExpression(base, startLoc, state);
        }
        
        let optional = false;
        
        if (type === 14) {
            if (noCalls) {
                this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);
                
                if (this.lookaheadCharCode() === 40) {
                    return this.stopParseSubscript(base, state);
                }
            }
            
            state.optionalChainMember =
            optional = true;
            this.next();
        }
        
        if (!noCalls && this.match(6)) {
            return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
        } else {
            const computed = this.eat(0);
            
            if (computed || optional || this.eat(12)) {
                return this.parseMember(base, startLoc, state, computed, optional);
            } else {
                return this.stopParseSubscript(base, state);
            }
        }
    }
    
    stopParseSubscript(base, state) {
        state.stop = true;
        return base;
    }
    
    parseMember(base, startLoc, state, computed, optional) {
        const node = this.startNodeAt(startLoc);
        
        node.object = base;
        node.computed = computed;
        
        if (computed) {
            node.property = this.parseExpression();
            this.expect(1);
        } else if (this.match(134)) {
            if (base.type === 'Super') {
                this.raise(Errors.SuperPrivateField, startLoc);
            }
            
            this.classScope.usePrivateName(this.state.value, this.state.startLoc);
            node.property = this.parsePrivateName();
        } else {
            node.property = this.parseIdentifier(true);
        }
        
        if (state.optionalChainMember) {
            node.optional = optional;
            return this.finishNode(node, 'OptionalMemberExpression');
        } else {
            return this.finishNode(node, 'MemberExpression');
        }
    }
    
    parseBind(base, startLoc, noCalls, state) {
        const node = this.startNodeAt(startLoc);
        
        node.object = base;
        this.next();
        node.callee = this.parseNoCallExpr();
        state.stop = true;
        return this.parseSubscripts(this.finishNode(node, 'BindExpression'), startLoc, noCalls);
    }
    
    parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        let refExpressionErrors = null;
        
        this.state.maybeInArrowParameters = true;
        this.next();
        const node = this.startNodeAt(startLoc);
        
        node.callee = base;
        const {
            maybeAsyncArrow,
            optionalChainMember,
        } = state;
        
        if (maybeAsyncArrow) {
            this.expressionScope.enter(newAsyncArrowScope());
            refExpressionErrors = new ExpressionErrors();
        }
        
        if (optionalChainMember) {
            node.optional = optional;
        }
        
        if (optional) {
            node.arguments = this.parseCallExpressionArguments();
        } else {
            node.arguments = this.parseCallExpressionArguments(base.type !== 'Super', node, refExpressionErrors);
        }
        
        let finishedNode = this.finishCallExpression(node, optionalChainMember);
        
        if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
            state.stop = true;
            this.checkDestructuringPrivate(refExpressionErrors);
            this.expressionScope.validateAsPattern();
            this.expressionScope.exit();
            finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
        } else {
            if (maybeAsyncArrow) {
                this.checkExpressionErrors(refExpressionErrors, true);
                this.expressionScope.exit();
            }
            
            this.toReferencedArguments(finishedNode);
        }
        
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return finishedNode;
    }
    
    toReferencedArguments(node, isParenthesizedExpr) {
        this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
    }
    
    parseTaggedTemplateExpression(base, startLoc, state) {
        const node = this.startNodeAt(startLoc);
        
        node.tag = base;
        node.quasi = this.parseTemplate(true);
        
        if (state.optionalChainMember) {
            this.raise(Errors.OptionalChainingNoTemplate, startLoc);
        }
        
        return this.finishNode(node, 'TaggedTemplateExpression');
    }
    
    atPossibleAsyncArrow(base) {
        return base.type === 'Identifier'
            && base.name === 'async'
            && this.state.lastTokEndLoc.index === base.end
            && !this.canInsertSemicolon()
            && base.end - base.start === 5
            && this.offsetToSourcePos(base.start) === this.state.potentialArrowAt;
    }
    
    finishCallExpression(node, optional) {
        if (node.callee.type === 'Import') {
            if (node.arguments.length === 0 || node.arguments.length > 2) {
                this.raise(Errors.ImportCallArity, node);
            } else {
                for (const arg of node.arguments) {
                    if (arg.type === 'SpreadElement') {
                        this.raise(Errors.ImportCallSpreadArgument, arg);
                    }
                }
            }
        }
        
        return this.finishNode(node, optional ? 'OptionalCallExpression' : 'CallExpression');
    }
    
    parseCallExpressionArguments(allowPlaceholder, nodeForExtra, refExpressionErrors) {
        const elts = [];
        let first = true;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        
        this.state.inFSharpPipelineDirectBody = false;
        while (!this.eat(7)) {
            if (first) {
                first = false;
            } else {
                this.expect(8);
                
                if (this.match(7)) {
                    if (nodeForExtra) {
                        this.addTrailingCommaExtraToNode(nodeForExtra);
                    }
                    
                    this.next();
                    break;
                }
            }
            
            elts.push(this.parseExprListItem(
                7,
                false,
                refExpressionErrors,
                allowPlaceholder,
            ));
        }
        
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return elts;
    }
    
    shouldParseAsyncArrow() {
        return this.match(15) && !this.canInsertSemicolon();
    }
    
    parseAsyncArrowFromCallExpression(node, call2) {
        this.resetPreviousNodeTrailingComments(call2);
        this.expect(15);
        this.parseArrowExpression(node, call2.arguments, true, call2.extra?.trailingCommaLoc);
        
        if (call2.innerComments) {
            setInnerComments(node, call2.innerComments);
        }
        
        if (call2.callee.trailingComments) {
            setInnerComments(node, call2.callee.trailingComments);
        }
        
        return node;
    }
    
    parseNoCallExpr() {
        const startLoc = this.state.startLoc;
        return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
    }
    
    parseExprAtom(refExpressionErrors) {
        let node;
        let decorators = null;
        const {type} = this.state;
        
        switch(type) {
        case 75:
            return this.parseSuper();
        
        case 79:
            node = this.startNode();
            this.next();
            
            if (this.match(12)) {
                return this.parseImportMetaPropertyOrPhaseCall(node);
            }
            
            if (this.match(6)) {
                if (this.optionFlags & 512) {
                    return this.parseImportCall(node);
                } else {
                    return this.finishNode(node, 'Import');
                }
            } else {
                this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);
                return this.finishNode(node, 'Import');
            }
        
        case 74:
            node = this.startNode();
            this.next();
            return this.finishNode(node, 'ThisExpression');
        
        case 86: {
            return this.parseDo(this.startNode(), false);
        }
        
        case 52:        
        case 27: {
            this.readRegexp();
            return this.parseRegExpLiteral(this.state.value);
        }
        
        case 131:
            return this.parseNumericLiteral(this.state.value);
        
        case 132:
            return this.parseBigIntLiteral(this.state.value);
        
        case 130:
            return this.parseStringLiteral(this.state.value);
        
        case 80:
            return this.parseNullLiteral();
        
        case 81:
            return this.parseBooleanLiteral(true);
        
        case 82:
            return this.parseBooleanLiteral(false);
        
        case 6: {
            const canBeArrow = this.state.potentialArrowAt === this.state.start;
            return this.parseParenAndDistinguishExpression(canBeArrow);
        }
        
        case 0: {
            return this.parseArrayLike(1, refExpressionErrors);
        }
        
        case 2: {
            return this.parseObjectLike(4, false, refExpressionErrors);
        }
        
        case 64:
            return this.parseFunctionOrFunctionSent();
        
        case 22:
            decorators = this.parseDecorators();
        
        case 76:
            return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
        
        case 73:
            return this.parseNewOrNewTarget();
        
        case 21:        
        case 20:
            return this.parseTemplate(false);
        
        case 11: {
            node = this.startNode();
            this.next();
            node.object = null;
            const callee = node.callee = this.parseNoCallExpr();
            
            if (callee.type === 'MemberExpression') {
                return this.finishNode(node, 'BindExpression');
            } else {
                throw this.raise(Errors.UnsupportedBind, callee);
            }
        }
        
        case 134: {
            this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {
                identifierName: this.state.value,
            });
            return this.parsePrivateName();
        }
        
        case 29: {
            return this.parseTopicReferenceThenEqualsSign(50, '%');
        }
        
        case 28: {
            return this.parseTopicReferenceThenEqualsSign(40, '^');
        }
        
        case 33:        
        case 34: {
            return this.parseTopicReference('hack');
        }
        
        case 40:        
        case 50:        
        case 23: {
            const pipeProposal = this.getPluginOption('pipelineOperator', 'proposal');
            
            if (pipeProposal) {
                return this.parseTopicReference(pipeProposal);
            }
            
            throw this.unexpected();
        }
        
        case 43: {
            const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
            
            if (isIdentifierStart2(lookaheadCh) || lookaheadCh === 62) {
                throw this.expectOnePlugin(['jsx', 'flow', 'typescript']);
            }
            
            throw this.unexpected();
        }
        
        default:
            if (tokenIsIdentifier(type)) {
                if (this.isContextual(123) && this.lookaheadInLineCharCode() === 123) {
                    return this.parseModuleExpression();
                }
                
                const canBeArrow = this.state.potentialArrowAt === this.state.start;
                const containsEsc = this.state.containsEsc;
                const id = this.parseIdentifier();
                
                if (!containsEsc && id.name === 'async' && !this.canInsertSemicolon()) {
                    const {type: type2} = this.state;
                    
                    if (type2 === 64) {
                        this.resetPreviousNodeTrailingComments(id);
                        this.next();
                        return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
                    } else if (tokenIsIdentifier(type2)) {
                        if (this.lookaheadCharCode() === 61) {
                            return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                        } else {
                            return id;
                        }
                    } else if (type2 === 86) {
                        this.resetPreviousNodeTrailingComments(id);
                        return this.parseDo(this.startNodeAtNode(id), true);
                    }

                }
                
                if (canBeArrow && this.match(15) && !this.canInsertSemicolon()) {
                    this.next();
                    return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
                }
                
                return id;
            } else {
                throw this.unexpected();
            }
        }
    }
    
    parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
        const pipeProposal = this.getPluginOption('pipelineOperator', 'proposal');
        
        if (pipeProposal) {
            this.state.type = topicTokenType;
            this.state.value = topicTokenValue;
            this.state.pos--;
            this.state.end--;
            this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
            return this.parseTopicReference(pipeProposal);
        }
        
        throw this.unexpected();
    }
    
    parseTopicReference(pipeProposal) {
        const node = this.startNode();
        const startLoc = this.state.startLoc;
        const tokenType = this.state.type;
        
        this.next();
        return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
    }
    
    finishTopicReference(node, startLoc, pipeProposal, tokenType) {
        if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
            if (!this.topicReferenceIsAllowedInCurrentContext()) {
                this.raise(Errors.PipeTopicUnbound, startLoc);
            }
            
            this.registerTopicReference();
            return this.finishNode(node, 'TopicReference');
        } else {
            throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {
                token: tokenLabelName(tokenType),
            });
        }
    }
    
    testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
        switch(pipeProposal) {
        case 'hack': {
            return this.hasPlugin(['pipelineOperator', {
                topicToken: tokenLabelName(tokenType),
            }]);
        }
        
        default:
            throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);
        }
    }
    
    parseAsyncArrowUnaryFunction(node) {
        this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
        const params = [
            this.parseIdentifier(),
        ];
        this.prodParam.exit();
        
        if (this.hasPrecedingLineBreak()) {
            this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());
        }
        
        this.expect(15);
        return this.parseArrowExpression(node, params, true);
    }
    
    parseDo(node, isAsync) {
        this.expectPlugin('doExpressions');
        
        if (isAsync) {
            this.expectPlugin('asyncDoExpressions');
        }
        
        node.async = isAsync;
        this.next();
        const oldLabels = this.state.labels;
        
        this.state.labels = [];
        
        if (isAsync) {
            this.prodParam.enter(2);
            node.body = this.parseBlock();
            this.prodParam.exit();
        } else {
            node.body = this.parseBlock();
        }
        
        this.state.labels = oldLabels;
        return this.finishNode(node, 'DoExpression');
    }
    
    parseSuper() {
        const node = this.startNode();
        this.next();
        
        if (this.match(6) && !this.scope.allowDirectSuper) {
            this.raise(Errors.SuperNotAllowed, node);
        } else if (!this.scope.allowSuper) {
            this.raise(Errors.UnexpectedSuper, node);
        }
        
        if (!this.match(6) && !this.match(0) && !this.match(12)) {
            this.raise(Errors.UnsupportedSuper, node);
        }
        
        return this.finishNode(node, 'Super');
    }
    
    parsePrivateName() {
        const node = this.startNode();
        const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
        const name = this.state.value;
        
        this.next();
        node.id = this.createIdentifier(id, name);
        return this.finishNode(node, 'PrivateName');
    }
    
    parseFunctionOrFunctionSent() {
        const node = this.startNode();
        this.next();
        
        if (this.prodParam.hasYield && this.match(12)) {
            const meta = this.createIdentifier(this.startNodeAtNode(node), 'function');
            this.next();
            
            if (this.match(99)) {
                this.expectPlugin('functionSent');
            } else if (!this.hasPlugin('functionSent')) {
                this.unexpected();
            }
            
            return this.parseMetaProperty(node, meta, 'sent');
        }
        
        return this.parseFunction(node);
    }
    
    parseMetaProperty(node, meta, propertyName) {
        node.meta = meta;
        const containsEsc = this.state.containsEsc;
        
        node.property = this.parseIdentifier(true);
        
        if (node.property.name !== propertyName || containsEsc) {
            this.raise(Errors.UnsupportedMetaProperty, node.property, {
                target: meta.name,
                onlyValidPropertyName: propertyName,
            });
        }
        
        return this.finishNode(node, 'MetaProperty');
    }
    
    parseImportMetaPropertyOrPhaseCall(node) {
        this.next();
        
        if (this.isContextual(101) || this.isContextual(93)) {
            const isSource = this.isContextual(101);
            this.expectPlugin(isSource ? 'sourcePhaseImports' : 'deferredImportEvaluation');
            this.next();
            node.phase = isSource ? 'source' : 'defer';
            return this.parseImportCall(node);
        } else {
            const id = this.createIdentifierAt(this.startNodeAtNode(node), 'import', this.state.lastTokStartLoc);
            
            if (this.isContextual(97)) {
                if (!this.inModule) {
                    this.raise(Errors.ImportMetaOutsideModule, id);
                }
                
                this.sawUnambiguousESM = true;
            }
            
            return this.parseMetaProperty(node, id, 'meta');
        }
    }
    
    parseLiteralAtNode(value, type, node) {
        this.addExtra(node, 'rawValue', value);
        this.addExtra(node, 'raw', this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
        node.value = value;
        this.next();
        return this.finishNode(node, type);
    }
    
    parseLiteral(value, type) {
        const node = this.startNode();
        return this.parseLiteralAtNode(value, type, node);
    }
    
    parseStringLiteral(value) {
        return this.parseLiteral(value, 'StringLiteral');
    }
    
    parseNumericLiteral(value) {
        return this.parseLiteral(value, 'NumericLiteral');
    }
    
    parseBigIntLiteral(value) {
        let bigInt;
        
        try {
            bigInt = BigInt(value);
        } catch {
            bigInt = null;
        }


                const node = this.parseLiteral(bigInt, 'BigIntLiteral');
        
        return node;
    }
    
    parseRegExpLiteral(value) {
        const node = this.startNode();
        this.addExtra(node, 'raw', this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
        node.pattern = value.pattern;
        node.flags = value.flags;
        this.next();
        return this.finishNode(node, 'RegExpLiteral');
    }
    
    parseBooleanLiteral(value) {
        const node = this.startNode();
        
        node.value = value;
        this.next();
        return this.finishNode(node, 'BooleanLiteral');
    }
    
    parseNullLiteral() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, 'NullLiteral');
    }
    
    parseParenAndDistinguishExpression(canBeArrow) {
        const startLoc = this.state.startLoc;
        let val;
        this.next();
        this.expressionScope.enter(newArrowHeadScope());
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        
        this.state.maybeInArrowParameters = true;
        this.state.inFSharpPipelineDirectBody = false;
        const innerStartLoc = this.state.startLoc;
        const exprList = [];
        const refExpressionErrors = new ExpressionErrors();
        let first = true;
        let spreadStartLoc;
        let optionalCommaStartLoc;
        
        while (!this.match(7)) {
            if (first) {
                first = false;
            } else {
                this.expect(8, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
                
                if (this.match(7)) {
                    optionalCommaStartLoc = this.state.startLoc;
                    break;
                }
            }
            
            if (this.match(17)) {
                const spreadNodeStartLoc = this.state.startLoc;
                
                spreadStartLoc = this.state.startLoc;
                exprList.push(this.parseParenItem(
                    this.parseRestBinding(),
                    spreadNodeStartLoc,
                ));
                
                if (!this.checkCommaAfterRest(41)) {
                    break;
                }
            } else {
                exprList.push(this.parseMaybeAssignAllowInOrVoidPattern(
                    7,
                    refExpressionErrors,
                    this.parseParenItem,
                ));
            }
        }
        
        const innerEndLoc = this.state.lastTokEndLoc;
        this.expect(7);
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let arrowNode = this.startNodeAt(startLoc);
        
        if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
            this.checkDestructuringPrivate(refExpressionErrors);
            this.expressionScope.validateAsPattern();
            this.expressionScope.exit();
            this.parseArrowExpression(arrowNode, exprList, false);
            return arrowNode;
        }
        
        this.expressionScope.exit();
        
        if (!exprList.length) {
            this.unexpected(this.state.lastTokStartLoc);
        }
        
        if (optionalCommaStartLoc)
            this.unexpected(optionalCommaStartLoc);
        
        if (spreadStartLoc)
            this.unexpected(spreadStartLoc);
        
        this.checkExpressionErrors(refExpressionErrors, true);
        this.toReferencedListDeep(exprList, true);
        
        if (exprList.length > 1) {
            val = this.startNodeAt(innerStartLoc);
            val.expressions = exprList;
            this.finishNode(val, 'SequenceExpression');
            this.resetEndLocation(val, innerEndLoc);
        } else {
            val = exprList[0];
        }
        
        return this.wrapParenthesis(startLoc, val);
    }
    
    wrapParenthesis(startLoc, expression2) {
        if (!(this.optionFlags & 1024)) {
            this.addExtra(expression2, 'parenthesized', true);
            this.addExtra(expression2, 'parenStart', startLoc.index);
            this.takeSurroundingComments(expression2, startLoc.index, this.state.lastTokEndLoc.index);
            return expression2;
        }
        
        const parenExpression = this.startNodeAt(startLoc);
        
        parenExpression.expression = expression2;
        return this.finishNode(parenExpression, 'ParenthesizedExpression');
    }
    
    shouldParseArrow() {
        return !this.canInsertSemicolon();
    }
    
    parseArrow(node) {
        if (this.eat(15)) {
            return node;
        }
    }
    
    parseParenItem(node) {
        return node;
    }
    
    parseNewOrNewTarget() {
        const node = this.startNode();
        this.next();
        
        if (this.match(12)) {
            const meta = this.createIdentifier(this.startNodeAtNode(node), 'new');
            this.next();
            const metaProp = this.parseMetaProperty(node, meta, 'target');
            
            if (!this.scope.allowNewTarget) {
                this.raise(Errors.UnexpectedNewTarget, metaProp);
            }
            
            return metaProp;
        }
        
        return this.parseNew(node);
    }
    
    parseNew(node) {
        this.parseNewCallee(node);
        
        if (this.eat(6)) {
            const args = this.parseExprList(7);
            this.toReferencedList(args);
            node.arguments = args;
        } else {
            node.arguments = [];
        }
        
        return this.finishNode(node, 'NewExpression');
    }
    
    parseNewCallee(node) {
        const isImport2 = this.match(79);
        const callee = this.parseNoCallExpr();
        
        node.callee = callee;
        
        if (isImport2 && (callee.type === 'Import' || callee.type === 'ImportExpression')) {
            this.raise(Errors.ImportCallNotNewExpression, callee);
        }
    }
    
    parseTemplateElement(isTagged) {
        const {
            start,
            startLoc,
            end,
            value,
        } = this.state;
        
        const elemStart = start + 1;
        const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
        
        if (value === null) {
            if (!isTagged) {
                this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));
            }
        }
        
        const isTail = this.match(20);
        const endOffset = isTail ? -1 : -2;
        const elemEnd = end + endOffset;
        
        elem.value = {
            raw: this
                .input
                .slice(elemStart, elemEnd)
                .replace(/\r\n?/g, '\n'),
            cooked: value === null ? null : value.slice(1, endOffset),
        };
        elem.tail = isTail;
        this.next();
        const finishedNode = this.finishNode(elem, 'TemplateElement');
        this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
        return finishedNode;
    }
    
    parseTemplate(isTagged) {
        const node = this.startNode();
        let curElt = this.parseTemplateElement(isTagged);
        const quasis = [curElt];
        const substitutions = [];
        
        while (!curElt.tail) {
            substitutions.push(this.parseTemplateSubstitution());
            this.readTemplateContinuation();
            quasis.push(curElt = this.parseTemplateElement(isTagged));
        }
        
        node.expressions = substitutions;
        node.quasis = quasis;
        return this.finishNode(node, 'TemplateLiteral');
    }
    
    parseTemplateSubstitution() {
        return this.parseExpression();
    }
    
    parseObjectLike(close, isPattern3, refExpressionErrors) {
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        
        this.state.inFSharpPipelineDirectBody = false;
        let sawProto = false;
        let first = true;
        const node = this.startNode();
        
        node.properties = [];
        this.next();
        while (!this.match(close)) {
            if (first) {
                first = false;
            } else {
                this.expect(8);
                
                if (this.match(close)) {
                    this.addTrailingCommaExtraToNode(node);
                    break;
                }
            }
            
            let prop;
            
            if (isPattern3) {
                prop = this.parseBindingProperty();
            } else {
                prop = this.parsePropertyDefinition(refExpressionErrors);
                sawProto = this.checkProto(prop, sawProto, refExpressionErrors);
            }
            
            node.properties.push(prop);
        }
        
        this.next();
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        const type = isPattern3 ? 'ObjectPattern' : 'ObjectExpression';
        
        return this.finishNode(node, type);
    }
    
    addTrailingCommaExtraToNode(node) {
        this.addExtra(node, 'trailingComma', this.state.lastTokStartLoc.index);
        this.addExtra(node, 'trailingCommaLoc', this.state.lastTokStartLoc, false);
    }
    
    maybeAsyncOrAccessorProp(prop) {
        return !prop.computed && prop.key.type === 'Identifier'
            && (this.isLiteralPropertyName()
            || this.match(0)
            || this.match(51));
    }
    
    parsePropertyDefinition(refExpressionErrors) {
        let decorators = [];
        
        if (this.match(22)) {
            if (this.hasPlugin('decorators')) {
                this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);
            }
            
            while (this.match(22)) {
                decorators.push(this.parseDecorator());
            }
        }
        
        const prop = this.startNode();
        let isAsync = false;
        let isAccessor2 = false;
        let startLoc;
        
        if (this.match(17)) {
            if (decorators.length)
                this.unexpected();
            
            return this.parseSpread();
        }
        
        if (decorators.length) {
            prop.decorators = decorators;
            decorators = [];
        }
        
        prop.method = false;
        
        if (refExpressionErrors) {
            startLoc = this.state.startLoc;
        }
        
        let isGenerator = this.eat(51);
        this.parsePropertyNamePrefixOperator(prop);
        const containsEsc = this.state.containsEsc;
        this.parsePropertyName(prop, refExpressionErrors);
        
        if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
            const {key} = prop;
            
            const keyName = key.name;
            
            if (keyName === 'async' && !this.hasPrecedingLineBreak()) {
                isAsync = true;
                this.resetPreviousNodeTrailingComments(key);
                isGenerator = this.eat(51);
                this.parsePropertyName(prop);
            }
            
            if (keyName === 'get' || keyName === 'set') {
                isAccessor2 = true;
                this.resetPreviousNodeTrailingComments(key);
                prop.kind = keyName;
                
                if (this.match(51)) {
                    isGenerator = true;
                    this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {
                        kind: keyName,
                    });
                    this.next();
                }
                
                this.parsePropertyName(prop);
            }
        }
        
        return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor2, refExpressionErrors);
    }
    
    getGetterSetterExpectedParamCount(method) {
        return method.kind === 'get' ? 0 : 1;
    }
    
    getObjectOrClassMethodParams(method) {
        return method.params;
    }
    
    checkGetterSetterParams(method) {
        const paramCount = this.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        
        if (params.length !== paramCount) {
            this.raise(method.kind === 'get' ? Errors.BadGetterArity : Errors.BadSetterArity, method);
        }
        
        if (method.kind === 'set' && params[params.length - 1]?.type === 'RestElement') {
            this.raise(Errors.BadSetterRestParameter, method);
        }
    }
    
    parseObjectMethod(prop, isGenerator, isAsync, isPattern3, isAccessor2) {
        if (isAccessor2) {
            const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, 'ObjectMethod');
            this.checkGetterSetterParams(finishedProp);
            return finishedProp;
        }
        
        if (isAsync || isGenerator || this.match(6)) {
            if (isPattern3)
                this.unexpected();
            
            prop.kind = 'method';
            prop.method = true;
            return this.parseMethod(prop, isGenerator, isAsync, false, false, 'ObjectMethod');
        }
    }
    
    parseObjectProperty(prop, startLoc, isPattern3, refExpressionErrors) {
        prop.shorthand = false;
        
        if (this.eat(10)) {
            prop.value = isPattern3 ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowInOrVoidPattern(4, refExpressionErrors);
            return this.finishObjectProperty(prop);
        }
        
        if (!prop.computed && prop.key.type === 'Identifier') {
            this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
            
            if (isPattern3) {
                prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));
            } else if (this.match(25)) {
                const shorthandAssignLoc = this.state.startLoc;
                
                if (refExpressionErrors != null) {
                    if (refExpressionErrors.shorthandAssignLoc === null) {
                        refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
                    }
                } else {
                    this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
                }
                
                prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));
            } else {
                prop.value = this.cloneIdentifier(prop.key);
            }
            
            prop.shorthand = true;
            return this.finishObjectProperty(prop);
        }
    }
    
    finishObjectProperty(node) {
        return this.finishNode(node, 'ObjectProperty');
    }
    
    parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern3, isAccessor2, refExpressionErrors) {
        const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern3, isAccessor2) || this.parseObjectProperty(prop, startLoc, isPattern3, refExpressionErrors);
        
        if (!node)
            this.unexpected();
        
        return node;
    }
    
    parsePropertyName(prop, refExpressionErrors) {
        if (this.eat(0)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssignAllowIn();
            this.expect(1);
        } else {
            const {type, value} = this.state;
            
            let key;
            
            if (tokenIsKeywordOrIdentifier(type)) {
                key = this.parseIdentifier(true);
            } else {
                switch(type) {
                case 131:
                    key = this.parseNumericLiteral(value);
                    break;
                
                case 130:
                    key = this.parseStringLiteral(value);
                    break;
                
                case 132:
                    key = this.parseBigIntLiteral(value);
                    break;
                
                case 134: {
                    const privateKeyLoc = this.state.startLoc;
                    
                    if (refExpressionErrors != null) {
                        if (refExpressionErrors.privateKeyLoc === null) {
                            refExpressionErrors.privateKeyLoc = privateKeyLoc;
                        }
                    } else {
                        this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
                    }
                    
                    key = this.parsePrivateName();
                    break;
                }
                
                default:
                    this.unexpected();
                }
            }
            
            prop.key = key;
            
            if (type !== 134) {
                prop.computed = false;
            }
        }
    }
    
    initFunction(node, isAsync) {
        node.id = null;
        node.generator = false;
        node.async = isAsync;
    }
    
    parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        this.initFunction(node, isAsync);
        node.generator = isGenerator;
        this.scope.enter(514 | 16 | (inClassScope ? 576 : 0) | (allowDirectSuper ? 32 : 0));
        this.prodParam.enter(functionFlags(isAsync, node.generator));
        this.parseFunctionParams(node, isConstructor);
        const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
        this.prodParam.exit();
        this.scope.exit();
        return finishedNode;
    }
    
    parseArrayLike(close, refExpressionErrors) {
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        
        this.state.inFSharpPipelineDirectBody = false;
        const node = this.startNode();
        this.next();
        node.elements = this.parseExprList(close, true, refExpressionErrors, node);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return this.finishNode(node, 'ArrayExpression');
    }
    
    parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
        this.scope.enter(514 | 4);
        let flags = functionFlags(isAsync, false);
        
        if (!this.match(2) && this.prodParam.hasIn) {
            flags |= 8;
        }
        
        this.prodParam.enter(flags);
        this.initFunction(node, isAsync);
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        
        if (params) {
            this.state.maybeInArrowParameters = true;
            this.setArrowFunctionParameters(node, params, trailingCommaLoc);
        }
        
        this.state.maybeInArrowParameters = false;
        this.parseFunctionBody(node, true);
        this.prodParam.exit();
        this.scope.exit();
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return this.finishNode(node, 'ArrowFunctionExpression');
    }
    
    setArrowFunctionParameters(node, params, trailingCommaLoc) {
        this.toAssignableList(params, trailingCommaLoc, false);
        node.params = params;
    }
    
    parseFunctionBodyAndFinish(node, type, isMethod3 = false) {
        this.parseFunctionBody(node, false, isMethod3);
        return this.finishNode(node, type);
    }
    
    parseFunctionBody(node, allowExpression, isMethod3 = false) {
        const isExpression4 = allowExpression && !this.match(2);
        this.expressionScope.enter(newExpressionScope());
        
        if (isExpression4) {
            node.body = this.parseMaybeAssign();
            this.checkParams(node, false, allowExpression, false);
        } else {
            const oldStrict = this.state.strict;
            const oldLabels = this.state.labels;
            
            this.state.labels = [];
            this.prodParam.enter(this.prodParam.currentFlags() | 4);
            node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
                const nonSimple = !this.isSimpleParamList(node.params);
                
                if (hasStrictModeDirective && nonSimple) {
                    this.raise(Errors.IllegalLanguageModeDirective, (node.kind === 'method' || node.kind === 'constructor') && !!node.key ? node.key.loc.end : node);
                }
                
                const strictModeChanged = !oldStrict && this.state.strict;
                this.checkParams(node, !this.state.strict && !allowExpression && !isMethod3 && !nonSimple, allowExpression, strictModeChanged);
                
                if (this.state.strict && node.id) {
                    this.checkIdentifier(node.id, 65, strictModeChanged);
                }
            });
            this.prodParam.exit();
            this.state.labels = oldLabels;
        }
        
        this.expressionScope.exit();
    }
    
    isSimpleParameter(node) {
        return node.type === 'Identifier';
    }
    
    isSimpleParamList(params) {
        for (let i = 0, len = params.length; i < len; i++) {
            if (!this.isSimpleParameter(params[i]))
                return false;
        }
        
        return true;
    }
    
    checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        const checkClashes = !allowDuplicates &&         /* @__PURE__ */new Set();
        const formalParameters = {
            type: 'FormalParameters',
        };
        
        for (const param of node.params) {
            this.checkLVal(param, formalParameters, 5, checkClashes, strictModeChanged);
        }
    }
    
    parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
        const elts = [];
        let first = true;
        
        while (!this.eat(close)) {
            if (first) {
                first = false;
            } else {
                this.expect(8);
                
                if (this.match(close)) {
                    if (nodeForExtra) {
                        this.addTrailingCommaExtraToNode(nodeForExtra);
                    }
                    
                    this.next();
                    break;
                }
            }
            
            elts.push(this.parseExprListItem(
                close,
                allowEmpty,
                refExpressionErrors,
            ));
        }
        
        return elts;
    }
    
    parseExprListItem(close, allowEmpty, refExpressionErrors, allowPlaceholder) {
        let elt;
        
        if (this.match(8)) {
            if (!allowEmpty) {
                this.raise(Errors.UnexpectedToken, this.state.curPosition(), {
                    unexpected: ',',
                });
            }
            
            elt = null;
        } else if (this.match(17)) {
            const spreadNodeStartLoc = this.state.startLoc;
            elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
        } else if (this.match(13)) {
            this.expectPlugin('partialApplication');
            
            if (!allowPlaceholder) {
                this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);
            }
            
            const node = this.startNode();
            this.next();
            elt = this.finishNode(node, 'ArgumentPlaceholder');
        } else {
            elt = this.parseMaybeAssignAllowInOrVoidPattern(close, refExpressionErrors, this.parseParenItem);
        }
        
        return elt;
    }
    
    parseIdentifier(liberal) {
        const node = this.startNode();
        const name = this.parseIdentifierName(liberal);
        
        return this.createIdentifier(node, name);
    }
    
    createIdentifier(node, name) {
        node.name = name;
        node.loc.identifierName = name;
        return this.finishNode(node, 'Identifier');
    }
    
    createIdentifierAt(node, name, endLoc) {
        node.name = name;
        node.loc.identifierName = name;
        return this.finishNodeAt(node, 'Identifier', endLoc);
    }
    
    parseIdentifierName(liberal) {
        let name;
        const {startLoc, type} = this.state;
        
        if (tokenIsKeywordOrIdentifier(type)) {
            name = this.state.value;
        } else {
            this.unexpected();
        }
        
        const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
        
        if (liberal) {
            if (tokenIsKeyword2) {
                this.replaceToken(128);
            }
        } else {
            this.checkReservedWord(name, startLoc, tokenIsKeyword2, false);
        }
        
        this.next();
        return name;
    }
    
    checkReservedWord(word, startLoc, checkKeywords, isBinding3) {
        if (word.length > 10) {
            return;
        }
        
        if (!canBeReservedWord(word)) {
            return;
        }
        
        if (checkKeywords && isKeyword2(word)) {
            this.raise(Errors.UnexpectedKeyword, startLoc, {
                keyword: word,
            });
            return;
        }
        
        const reservedTest = !this.state.strict ? isReservedWord2 : isBinding3 ? isStrictBindReservedWord : isStrictReservedWord2;
        
        if (reservedTest(word, this.inModule)) {
            this.raise(Errors.UnexpectedReservedWord, startLoc, {
                reservedWord: word,
            });
            return;
        } else if (word === 'yield') {
            if (this.prodParam.hasYield) {
                this.raise(Errors.YieldBindingIdentifier, startLoc);
                return;
            }
        } else if (word === 'await') {
            if (this.prodParam.hasAwait) {
                this.raise(Errors.AwaitBindingIdentifier, startLoc);
                return;
            }
            
            if (this.scope.inStaticBlock) {
                this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);
                return;
            }
            
            this.expressionScope.recordAsyncArrowParametersError(startLoc);
        } else if (word === 'arguments') {
            if (this.scope.inClassAndNotInNonArrowFunction) {
                this.raise(Errors.ArgumentsInClass, startLoc);
                return;
            }
        }


    }
    
    recordAwaitIfAllowed() {
        const isAwaitAllowed = this.prodParam.hasAwait;
        
        if (isAwaitAllowed && !this.scope.inFunction) {
            this.state.hasTopLevelAwait = true;
        }
        
        return isAwaitAllowed;
    }
    
    parseAwait(startLoc) {
        const node = this.startNodeAt(startLoc);
        this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);
        
        if (this.eat(51)) {
            this.raise(Errors.ObsoleteAwaitStar, node);
        }
        
        if (!this.scope.inFunction && !(this.optionFlags & 1)) {
            if (this.isAmbiguousPrefixOrIdentifier()) {
                this.ambiguousScriptDifferentAst = true;
            } else {
                this.sawUnambiguousESM = true;
            }
        }
        
        if (!this.state.soloAwait) {
            node.argument = this.parseMaybeUnary(null, true);
        }
        
        return this.finishNode(node, 'AwaitExpression');
    }
    
    isAmbiguousPrefixOrIdentifier() {
        if (this.hasPrecedingLineBreak())
            return true;
        
        const {type} = this.state;
        
        return type === 49
            || type === 6
            || type === 0
            || tokenIsTemplate(type)
            || type === 98
            && !this.state.containsEsc
            || type === 133
            || type === 52
            || this.hasPlugin('v8intrinsic') && type === 50;
    }
    
    parseYield(startLoc) {
        const node = this.startNodeAt(startLoc);
        this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);
        let delegating = false;
        let argument = null;
        
        if (!this.hasPrecedingLineBreak()) {
            delegating = this.eat(51);
            switch(this.state.type) {
            case 9:            
            case 135:            
            case 4:            
            case 7:            
            case 1:            
            case 5:            
            case 10:            
            case 8:
                if (!delegating)
                    break;
            
            default:
                argument = this.parseMaybeAssign();
            }
        }
        
        node.delegate = delegating;
        node.argument = argument;
        return this.finishNode(node, 'YieldExpression');
    }
    
    parseImportCall(node) {
        this.next();
        node.source = this.parseMaybeAssignAllowIn();
        node.options = null;
        
        if (this.eat(8)) {
            if (!this.match(7)) {
                node.options = this.parseMaybeAssignAllowIn();
                
                if (this.eat(8)) {
                    this.addTrailingCommaExtraToNode(node.options);
                    
                    if (!this.match(7)) {
                        do {
                            this.parseMaybeAssignAllowIn();
                        } while (this.eat(8) && !this.match(7))
                        this.raise(Errors.ImportCallArity, node);
                    }
                }
            } else {
                this.addTrailingCommaExtraToNode(node.source);
            }
        }
        
        this.expect(7);
        return this.finishNode(node, 'ImportExpression');
    }
    
    withTopicBindingContext(callback) {
        const outerContextTopicState = this.state.topicContext;
        
        this.state.topicContext = {
            maxNumOfResolvableTopics: 1,
            maxTopicIndex: null,
        };
        try {
            return callback();
        } finally {
            this.state.topicContext = outerContextTopicState;
        }
    }
    
    withSoloAwaitPermittingContext(callback) {
        const outerContextSoloAwaitState = this.state.soloAwait;
        
        this.state.soloAwait = true;
        try {
            return callback();
        } finally {
            this.state.soloAwait = outerContextSoloAwaitState;
        }
    }
    
    allowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToSet = 8 & ~flags;
        
        if (prodParamToSet) {
            this.prodParam.enter(flags | 8);
            try {
                return callback();
            } finally {
                this.prodParam.exit();
            }
        }
        
        return callback();
    }
    
    disallowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToClear = 8 & flags;
        
        if (prodParamToClear) {
            this.prodParam.enter(flags & -9);
            try {
                return callback();
            } finally {
                this.prodParam.exit();
            }
        }
        
        return callback();
    }
    
    registerTopicReference() {
        this.state.topicContext.maxTopicIndex = 0;
    }
    
    topicReferenceIsAllowedInCurrentContext() {
        return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    
    topicReferenceWasUsedInCurrentContext() {
        return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    
    parseFSharpPipelineBody(prec) {
        const startLoc = this.state.startLoc;
        
        this.state.potentialArrowAt = this.state.start;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        
        this.state.inFSharpPipelineDirectBody = true;
        const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
        
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return ret;
    }
    
    parseModuleExpression() {
        this.expectPlugin('moduleBlocks');
        const node = this.startNode();
        this.next();
        
        if (!this.match(2)) {
            this.unexpected(null, 2);
        }
        
        const program3 = this.startNodeAt(this.state.endLoc);
        this.next();
        const revertScopes = this.initializeScopes(true);
        this.enterInitialScopes();
        try {
            node.body = this.parseProgram(program3, 4, 'module');
        } finally {
            revertScopes();
        }

                
        return this.finishNode(node, 'ModuleExpression');
    }
    
    parseVoidPattern(refExpressionErrors) {
        this.expectPlugin('discardBinding');
        const node = this.startNode();
        
        if (refExpressionErrors != null) {
            refExpressionErrors.voidPatternLoc = this.state.startLoc;
        }
        
        this.next();
        return this.finishNode(node, 'VoidPattern');
    }
    
    parseMaybeAssignAllowInOrVoidPattern(close, refExpressionErrors, afterLeftParse) {
        if (refExpressionErrors != null && this.match(84)) {
            const nextCode = this.lookaheadCharCode();
            
            if (nextCode === 44 || nextCode === (close === 1 ? 93 : close === 4 ? 125 : 41) || nextCode === 61) {
                return this.parseMaybeDefault(this.state.startLoc, this.parseVoidPattern(refExpressionErrors));
            }
        }
        
        return this.parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse);
    }
    
    parsePropertyNamePrefixOperator() {}
};

var loopLabel = {
    kind: 1,
};

var switchLabel = {
    kind: 2,
};

var loneSurrogate = /[\uD800-\uDFFF]/u;
var keywordRelationalOperator = /in(?:stanceof)?/y;

function createExportedTokens(tokens) {
    for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        const {type} = token;
        
        if (typeof type === 'number') {
            token.type = getExportedToken(type);
        }
    }
    
    return tokens;
}

var StatementParser = class extends ExpressionParser {
    parseTopLevel(file2, program3) {
        file2.program = this.parseProgram(program3, 135, this.options.sourceType === 'module' ? 'module' : 'script');
        file2.comments = this.comments;
        
        if (this.optionFlags & 256) {
            file2.tokens = createExportedTokens(this.tokens);
        }
        
        return this.finishNode(file2, 'File');
    }
    
    parseProgram(program3, end, sourceType) {
        program3.sourceType = sourceType;
        program3.interpreter = this.parseInterpreterDirective();
        this.parseBlockBody(program3, true, true, end);
        
        if (this.inModule) {
            if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0) {
                for (const [localName, at] of Array.from(this.scope.undefinedExports)) {
                    this.raise(Errors.ModuleExportUndefined, at, {
                        localName,
                    });
                }
            }
            
            this.addExtra(program3, 'topLevelAwait', this.state.hasTopLevelAwait);
        }
        
        let finishedProgram;
        
        if (end === 135) {
            finishedProgram = this.finishNode(program3, 'Program');
        } else {
            finishedProgram = this.finishNodeAt(program3, 'Program', createPositionWithColumnOffset(this.state.startLoc, -1));
        }
        
        return finishedProgram;
    }
    
    stmtToDirective(stmt) {
        const directive2 = this.castNodeTo(stmt, 'Directive');
        const directiveLiteral2 = this.castNodeTo(stmt.expression, 'DirectiveLiteral');
        const expressionValue = directiveLiteral2.value;
        const raw = this.input.slice(this.offsetToSourcePos(directiveLiteral2.start), this.offsetToSourcePos(directiveLiteral2.end));
        const val = directiveLiteral2.value = raw.slice(1, -1);
        
        this.addExtra(directiveLiteral2, 'raw', raw);
        this.addExtra(directiveLiteral2, 'rawValue', val);
        this.addExtra(directiveLiteral2, 'expressionValue', expressionValue);
        directive2.value = directiveLiteral2;
        delete stmt.expression;
        return directive2;
    }
    
    parseInterpreterDirective() {
        if (!this.match(24)) {
            return null;
        }
        
        const node = this.startNode();
        
        node.value = this.state.value;
        this.next();
        return this.finishNode(node, 'InterpreterDirective');
    }
    
    isLet() {
        if (!this.isContextual(96)) {
            return false;
        }
        
        return this.hasFollowingBindingAtom();
    }
    
    isUsing() {
        if (!this.isContextual(103)) {
            return false;
        }
        
        return this.nextTokenIsIdentifierOnSameLine();
    }
    
    isForUsing() {
        if (!this.isContextual(103)) {
            return false;
        }
        
        const next = this.nextTokenInLineStart();
        const nextCh = this.codePointAtPos(next);
        
        if (this.isUnparsedContextual(next, 'of')) {
            const nextCharAfterOf = this.lookaheadCharCodeSince(next + 2);
            
            if (nextCharAfterOf !== 61 && nextCharAfterOf !== 58 && nextCharAfterOf !== 59) {
                return false;
            }
        }
        
        if (this.chStartsBindingIdentifier(nextCh, next) || this.isUnparsedContextual(next, 'void')) {
            return true;
        }
        
        return false;
    }
    
    nextTokenIsIdentifierOnSameLine() {
        const next = this.nextTokenInLineStart();
        const nextCh = this.codePointAtPos(next);
        
        return this.chStartsBindingIdentifier(nextCh, next);
    }
    
    isAwaitUsing() {
        if (!this.isContextual(92)) {
            return false;
        }
        
        let next = this.nextTokenInLineStart();
        
        if (this.isUnparsedContextual(next, 'using')) {
            next = this.nextTokenInLineStartSince(next + 5);
            const nextCh = this.codePointAtPos(next);
            
            if (this.chStartsBindingIdentifier(nextCh, next)) {
                return true;
            }
        }
        
        return false;
    }
    
    chStartsBindingIdentifier(ch, pos) {
        if (isIdentifierStart2(ch)) {
            keywordRelationalOperator.lastIndex = pos;
            
            if (keywordRelationalOperator.test(this.input)) {
                const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
                
                if (!isIdentifierChar2(endCh) && endCh !== 92) {
                    return false;
                }
            }
            
            return true;
        } else if (ch === 92) {
            return true;
        } else {
            return false;
        }
    }
    
    chStartsBindingPattern(ch) {
        return ch === 91 || ch === 123;
    }
    
    hasFollowingBindingAtom() {
        const next = this.nextTokenStart();
        const nextCh = this.codePointAtPos(next);
        
        return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
    }
    
    hasInLineFollowingBindingIdentifierOrBrace() {
        const next = this.nextTokenInLineStart();
        const nextCh = this.codePointAtPos(next);
        
        return nextCh === 123 || this.chStartsBindingIdentifier(nextCh, next);
    }
    
    allowsUsing() {
        return (this.scope.inModule || !this.scope.inTopLevel) && !this.scope.inBareCaseStatement;
    }
    
    parseModuleItem() {
        return this.parseStatementLike(1 | 2 | 4 | 8);
    }
    
    parseStatementListItem() {
        return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    
    parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {
        let flags = 0;
        
        if (this.options.annexB && !this.state.strict) {
            flags |= 4;
            
            if (allowLabeledFunction) {
                flags |= 8;
            }
        }
        
        return this.parseStatementLike(flags);
    }
    
    parseStatement() {
        return this.parseStatementLike(0);
    }
    
    parseStatementLike(flags) {
        let decorators = null;
        
        if (this.match(22)) {
            decorators = this.parseDecorators(true);
        }
        
        return this.parseStatementContent(flags, decorators);
    }
    
    parseStatementContent(flags, decorators) {
        const startType = this.state.type;
        const node = this.startNode();
        const allowDeclaration = !!(flags & 2);
        const allowFunctionDeclaration = !!(flags & 4);
        const topLevel = flags & 1;
        
        switch(startType) {
        case 56:
            return this.parseBreakContinueStatement(node, true);
        
        case 59:
            return this.parseBreakContinueStatement(node, false);
        
        case 60:
            return this.parseDebuggerStatement(node);
        
        case 86:
            return this.parseDoWhileStatement(node);
        
        case 87:
            return this.parseForStatement(node);
        
        case 64:
            if (this.lookaheadCharCode() === 46)
                break;
            
            if (!allowFunctionDeclaration) {
                this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);
            }
            
            return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);
        
        case 76:
            if (!allowDeclaration)
                this.unexpected();
            
            return this.parseClass(this.maybeTakeDecorators(decorators, node), true);
        
        case 65:
            return this.parseIfStatement(node);
        
        case 66:
            return this.parseReturnStatement(node);
        
        case 67:
            return this.parseSwitchStatement(node);
        
        case 68:
            return this.parseThrowStatement(node);
        
        case 69:
            return this.parseTryStatement(node);
        
        case 92:
            if (this.isAwaitUsing()) {
                if (!this.allowsUsing()) {
                    this.raise(Errors.UnexpectedUsingDeclaration, node);
                } else if (!allowDeclaration) {
                    this.raise(Errors.UnexpectedLexicalDeclaration, node);
                } else if (!this.recordAwaitIfAllowed()) {
                    this.raise(Errors.AwaitUsingNotInAsyncContext, node);
                }
                
                this.next();
                return this.parseVarStatement(node, 'await using');
            }
            
            break;
        
        case 103:
            if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) {
                break;
            }
            
            if (!this.allowsUsing()) {
                this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);
            } else if (!allowDeclaration) {
                this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
            }
            
            return this.parseVarStatement(node, 'using');
        
        case 96: {
            if (this.state.containsEsc) {
                break;
            }
            
            const next = this.nextTokenStart();
            const nextCh = this.codePointAtPos(next);
            
            if (nextCh !== 91) {
                if (!allowDeclaration && this.hasFollowingLineBreak())
                    break;
                
                if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
                    break;
                }
            }
        }
        
        case 71: {
            if (!allowDeclaration) {
                this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
            }
        }
        
        case 70: {
            const kind = this.state.value;
            return this.parseVarStatement(node, kind);
        }
        
        case 88:
            return this.parseWhileStatement(node);
        
        case 72:
            return this.parseWithStatement(node);
        
        case 2:
            return this.parseBlock();
        
        case 9:
            return this.parseEmptyStatement(node);
        
        case 79: {
            const nextTokenCharCode = this.lookaheadCharCode();
            
            if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
                break;
            }
        }
        
        case 78: {
            if (!(this.optionFlags & 8) && !topLevel) {
                this.raise(Errors.UnexpectedImportExport, this.state.startLoc);
            }
            
            this.next();
            let result;
            
            if (startType === 79) {
                result = this.parseImport(node);
            } else {
                result = this.parseExport(node, decorators);
            }
            
            this.assertModuleNodeAllowed(result);
            return result;
        }
        
        default: {
            if (this.isAsyncFunction()) {
                if (!allowDeclaration) {
                    this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);
                }
                
                this.next();
                return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);
            }
        }
        }
        
        const maybeName = this.state.value;
        const expr = this.parseExpression();
        
        if (tokenIsIdentifier(startType) && expr.type === 'Identifier' && this.eat(10)) {
            return this.parseLabeledStatement(node, maybeName, expr, flags);
        } else {
            return this.parseExpressionStatement(node, expr, decorators);
        }
    }
    
    assertModuleNodeAllowed(node) {
        if (!(this.optionFlags & 8) && !this.inModule) {
            this.raise(Errors.ImportOutsideModule, node);
        }
    }
    
    maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
        if (maybeDecorators) {
            if (classNode.decorators?.length) {
                this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);
                classNode.decorators.unshift(...maybeDecorators);
            } else {
                classNode.decorators = maybeDecorators;
            }
            
            this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
            
            if (exportNode)
                this.resetStartLocationFromNode(exportNode, classNode);
        }
        
        return classNode;
    }
    
    canHaveLeadingDecorator() {
        return this.match(76);
    }
    
    parseDecorators(allowExport) {
        const decorators = [];
        
        do {
            decorators.push(this.parseDecorator());
        } while (this.match(22))
        if (this.match(78)) {
            if (!allowExport) {
                this.unexpected();
            }
        } else if (!this.canHaveLeadingDecorator()) {
            throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);
        }
        
        return decorators;
    }
    
    parseDecorator() {
        this.expectOnePlugin(['decorators', 'decorators-legacy']);
        const node = this.startNode();
        this.next();
        
        if (this.hasPlugin('decorators')) {
            const startLoc = this.state.startLoc;
            let expr;
            
            if (this.match(6)) {
                const startLoc2 = this.state.startLoc;
                this.next();
                expr = this.parseExpression();
                this.expect(7);
                expr = this.wrapParenthesis(startLoc2, expr);
                const paramsStartLoc = this.state.startLoc;
                
                node.expression = this.parseMaybeDecoratorArguments(expr, startLoc2);
                
                if (node.expression !== expr) {
                    this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);
                }
            } else {
                expr = this.parseIdentifier(false);
                while (this.eat(12)) {
                    const node2 = this.startNodeAt(startLoc);
                    
                    node2.object = expr;
                    
                    if (this.match(134)) {
                        this.classScope.usePrivateName(this.state.value, this.state.startLoc);
                        node2.property = this.parsePrivateName();
                    } else {
                        node2.property = this.parseIdentifier(true);
                    }
                    
                    node2.computed = false;
                    expr = this.finishNode(node2, 'MemberExpression');
                }
                
                node.expression = this.parseMaybeDecoratorArguments(expr, startLoc);
            }
        } else {
            node.expression = this.parseExprSubscripts();
        }
        
        return this.finishNode(node, 'Decorator');
    }
    
    parseMaybeDecoratorArguments(expr, startLoc) {
        if (this.eat(6)) {
            const node = this.startNodeAt(startLoc);
            
            node.callee = expr;
            node.arguments = this.parseCallExpressionArguments();
            this.toReferencedList(node.arguments);
            return this.finishNode(node, 'CallExpression');
        }
        
        return expr;
    }
    
    parseBreakContinueStatement(node, isBreak) {
        this.next();
        
        if (this.isLineTerminator()) {
            node.label = null;
        } else {
            node.label = this.parseIdentifier();
            this.semicolon();
        }
        
        this.verifyBreakContinue(node, isBreak);
        return this.finishNode(node, isBreak ? 'BreakStatement' : 'ContinueStatement');
    }
    
    verifyBreakContinue(node, isBreak) {
        let i;
        
        for (i = 0; i < this.state.labels.length; ++i) {
            const lab = this.state.labels[i];
            
            if (node.label == null || lab.name === node.label.name) {
                if (lab.kind != null && (isBreak || lab.kind === 1)) {
                    break;
                }
                
                if (node.label && isBreak)
                    break;
            }
        }
        
        if (i === this.state.labels.length) {
            const type = isBreak ? 'BreakStatement' : 'ContinueStatement';
            
            this.raise(Errors.IllegalBreakContinue, node, {
                type,
            });
        }
    }
    
    parseDebuggerStatement(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, 'DebuggerStatement');
    }
    
    parseHeaderExpression() {
        this.expect(6);
        const val = this.parseExpression();
        this.expect(7);
        return val;
    }
    
    parseDoWhileStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        node.body = this.parseStatement();
        this.state.labels.pop();
        this.expect(88);
        node.test = this.parseHeaderExpression();
        this.eat(9);
        return this.finishNode(node, 'DoWhileStatement');
    }
    
    parseForStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        let awaitAt = null;
        
        if (this.isContextual(92) && this.recordAwaitIfAllowed()) {
            awaitAt = this.state.startLoc;
            this.next();
        }
        
        this.scope.enter(0);
        this.expect(6);
        
        if (this.match(9)) {
            if (awaitAt !== null) {
                this.unexpected(awaitAt);
            }
            
            return this.parseFor(node, null);
        }
        
        const startsWithLet = this.isContextual(96);
        
        {
            const startsWithAwaitUsing = this.isAwaitUsing();
            const starsWithUsingDeclaration = startsWithAwaitUsing || this.isForUsing();
            const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
            
            if (this.match(70) || this.match(71) || isLetOrUsing) {
                const initNode = this.startNode();
                let kind;
                
                if (startsWithAwaitUsing) {
                    kind = 'await using';
                    
                    if (!this.recordAwaitIfAllowed()) {
                        this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);
                    }
                    
                    this.next();
                } else {
                    kind = this.state.value;
                }
                
                this.next();
                this.parseVar(initNode, true, kind);
                const init2 = this.finishNode(initNode, 'VariableDeclaration');
                const isForIn = this.match(54);
                
                if (isForIn && starsWithUsingDeclaration) {
                    this.raise(Errors.ForInUsing, init2);
                }
                
                if ((isForIn || this.isContextual(98)) && init2.declarations.length === 1) {
                    return this.parseForIn(node, init2, awaitAt);
                }
                
                if (awaitAt !== null) {
                    this.unexpected(awaitAt);
                }
                
                return this.parseFor(node, init2);
            }
        }
        const startsWithAsync = this.isContextual(91);
        const refExpressionErrors = new ExpressionErrors();
        const init = this.parseExpression(true, refExpressionErrors);
        const isForOf = this.isContextual(98);
        
        if (isForOf) {
            if (startsWithLet) {
                this.raise(Errors.ForOfLet, init);
            }
            
            if (awaitAt === null && startsWithAsync && init.type === 'Identifier') {
                this.raise(Errors.ForOfAsync, init);
            }
        }
        
        if (isForOf || this.match(54)) {
            this.checkDestructuringPrivate(refExpressionErrors);
            this.toAssignable(init, true);
            const type = isForOf ? 'ForOfStatement' : 'ForInStatement';
            
            this.checkLVal(init, {
                type,
            });
            return this.parseForIn(node, init, awaitAt);
        } else {
            this.checkExpressionErrors(refExpressionErrors, true);
        }
        
        if (awaitAt !== null) {
            this.unexpected(awaitAt);
        }
        
        return this.parseFor(node, init);
    }
    
    parseFunctionStatement(node, isAsync, isHangingDeclaration) {
        this.next();
        return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
    }
    
    parseIfStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
        node.alternate = this.eat(62) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
        return this.finishNode(node, 'IfStatement');
    }
    
    parseReturnStatement(node) {
        if (!this.prodParam.hasReturn) {
            this.raise(Errors.IllegalReturn, this.state.startLoc);
        }
        
        this.next();
        
        if (this.isLineTerminator()) {
            node.argument = null;
        } else {
            node.argument = this.parseExpression();
            this.semicolon();
        }
        
        return this.finishNode(node, 'ReturnStatement');
    }
    
    parseSwitchStatement(node) {
        this.next();
        node.discriminant = this.parseHeaderExpression();
        const cases = node.cases = [];
        this.expect(2);
        this.state.labels.push(switchLabel);
        this.scope.enter(256);
        let cur;
        
        for (let sawDefault; !this.match(4);) {
            if (this.match(57) || this.match(61)) {
                const isCase = this.match(57);
                
                if (cur)
                    this.finishNode(cur, 'SwitchCase');
                
                cases.push(cur = this.startNode());
                cur.consequent = [];
                this.next();
                
                if (isCase) {
                    cur.test = this.parseExpression();
                } else {
                    if (sawDefault) {
                        this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);
                    }
                    
                    sawDefault = true;
                    cur.test = null;
                }
                
                this.expect(10);
            } else {
                if (cur) {
                    cur.consequent.push(this.parseStatementListItem());
                } else {
                    this.unexpected();
                }
            }
        }
        
        this.scope.exit();
        
        if (cur)
            this.finishNode(cur, 'SwitchCase');
        
        this.next();
        this.state.labels.pop();
        return this.finishNode(node, 'SwitchStatement');
    }
    
    parseThrowStatement(node) {
        this.next();
        
        if (this.hasPrecedingLineBreak()) {
            this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);
        }
        
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, 'ThrowStatement');
    }
    
    parseCatchClauseParam() {
        const param = this.parseBindingAtom();
        this.scope.enter(this.options.annexB && param.type === 'Identifier' ? 8 : 0);
        this.checkLVal(param, {
            type: 'CatchClause',
        }, 9);
        return param;
    }
    
    parseTryStatement(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        
        if (this.match(58)) {
            const clause = this.startNode();
            this.next();
            
            if (this.match(6)) {
                this.expect(6);
                clause.param = this.parseCatchClauseParam();
                this.expect(7);
            } else {
                clause.param = null;
                this.scope.enter(0);
            }
            
            clause.body = this.parseBlock(false, false);
            this.scope.exit();
            node.handler = this.finishNode(clause, 'CatchClause');
        }
        
        node.finalizer = this.eat(63) ? this.parseBlock() : null;
        
        if (!node.handler && !node.finalizer) {
            this.raise(Errors.NoCatchOrFinally, node);
        }
        
        return this.finishNode(node, 'TryStatement');
    }
    
    parseVarStatement(node, kind, allowMissingInitializer = false) {
        this.next();
        this.parseVar(node, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node, 'VariableDeclaration');
    }
    
    parseWhileStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        this.state.labels.push(loopLabel);
        node.body = this.parseStatement();
        this.state.labels.pop();
        return this.finishNode(node, 'WhileStatement');
    }
    
    parseWithStatement(node) {
        if (this.state.strict) {
            this.raise(Errors.StrictWith, this.state.startLoc);
        }
        
        this.next();
        node.object = this.parseHeaderExpression();
        node.body = this.parseStatement();
        return this.finishNode(node, 'WithStatement');
    }
    
    parseEmptyStatement(node) {
        this.next();
        return this.finishNode(node, 'EmptyStatement');
    }
    
    parseLabeledStatement(node, maybeName, expr, flags) {
        for (const label of this.state.labels) {
            if (label.name === maybeName) {
                this.raise(Errors.LabelRedeclaration, expr, {
                    labelName: maybeName,
                });
            }
        }
        
        const kind = tokenIsLoop(this.state.type) ? 1 : this.match(67) ? 2 : null;
        
        for (let i = this.state.labels.length - 1; i >= 0; i--) {
            const label = this.state.labels[i];
            
            if (label.statementStart === node.start) {
                label.statementStart = this.sourceToOffsetPos(this.state.start);
                label.kind = kind;
            } else {
                break;
            }
        }
        
        this.state.labels.push({
            name: maybeName,
            kind,
            statementStart: this.sourceToOffsetPos(this.state.start),
        });
        node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
        this.state.labels.pop();
        node.label = expr;
        return this.finishNode(node, 'LabeledStatement');
    }
    
    parseExpressionStatement(node, expr) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, 'ExpressionStatement');
    }
    
    parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
        const node = this.startNode();
        
        if (allowDirectives) {
            this.state.strictErrors.clear();
        }
        
        this.expect(2);
        
        if (createNewLexicalScope) {
            this.scope.enter(0);
        }
        
        this.parseBlockBody(node, allowDirectives, false, 4, afterBlockParse);
        
        if (createNewLexicalScope) {
            this.scope.exit();
        }
        
        return this.finishNode(node, 'BlockStatement');
    }
    
    isValidDirective(stmt) {
        return stmt.type === 'ExpressionStatement' && stmt.expression.type === 'StringLiteral' && !stmt.expression.extra.parenthesized;
    }
    
    parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        const body = node.body = [];
        const directives = node.directives = [];
        this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
    }
    
    parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
        const oldStrict = this.state.strict;
        let hasStrictModeDirective = false;
        let parsedNonDirective = false;
        
        while (!this.match(end)) {
            const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
            
            if (directives && !parsedNonDirective) {
                if (this.isValidDirective(stmt)) {
                    const directive2 = this.stmtToDirective(stmt);
                    directives.push(directive2);
                    
                    if (!hasStrictModeDirective && directive2.value.value === 'use strict') {
                        hasStrictModeDirective = true;
                        this.setStrict(true);
                    }
                    
                    continue;
                }
                
                parsedNonDirective = true;
                this.state.strictErrors.clear();
            }
            
            body.push(stmt);
        }
        
        afterBlockParse?.call(this, hasStrictModeDirective);
        
        if (!oldStrict) {
            this.setStrict(false);
        }
        
        this.next();
    }
    
    parseFor(node, init) {
        node.init = init;
        this.semicolon(false);
        node.test = this.match(9) ? null : this.parseExpression();
        this.semicolon(false);
        node.update = this.match(7) ? null : this.parseExpression();
        this.expect(7);
        node.body = this.parseStatement();
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, 'ForStatement');
    }
    
    parseForIn(node, init, awaitAt) {
        const isForIn = this.match(54);
        this.next();
        
        if (isForIn) {
            if (awaitAt !== null)
                this.unexpected(awaitAt);
        } else {
            node.await = awaitAt !== null;
        }
        
        if (init.type === 'VariableDeclaration' && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== 'var' || init.declarations[0].id.type !== 'Identifier')) {
            this.raise(Errors.ForInOfLoopInitializer, init, {
                type: isForIn ? 'ForInStatement' : 'ForOfStatement',
            });
        }
        
        if (init.type === 'AssignmentPattern') {
            this.raise(Errors.InvalidLhs, init, {
                ancestor: {
                    type: 'ForStatement',
                },
            });
        }
        
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
        this.expect(7);
        node.body = this.parseStatement();
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, isForIn ? 'ForInStatement' : 'ForOfStatement');
    }
    
    parseVar(node, isFor3, kind, allowMissingInitializer = false) {
        const declarations = node.declarations = [];
        
        node.kind = kind;
        for (;;) {
            const decl = this.startNode();
            this.parseVarId(decl, kind);
            decl.init = !this.eat(25) ? null : isFor3 ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
            
            if (decl.init === null && !allowMissingInitializer) {
                if (decl.id.type !== 'Identifier' && !(isFor3 && (this.match(54) || this.isContextual(98)))) {
                    this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                        kind: 'destructuring',
                    });
                } else if ((kind === 'const' || kind === 'using' || kind === 'await using') && !(this.match(54) || this.isContextual(98))) {
                    this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                        kind,
                    });
                }
            }
            
            declarations.push(this.finishNode(decl, 'VariableDeclarator'));
            
            if (!this.eat(8))
                break;
        }
        
        return node;
    }
    
    parseVarId(decl, kind) {
        const id = this.parseBindingAtom();
        
        if (kind === 'using' || kind === 'await using') {
            if (id.type === 'ArrayPattern' || id.type === 'ObjectPattern') {
                this.raise(Errors.UsingDeclarationHasBindingPattern, id.loc.start);
            }
        } else {
            if (id.type === 'VoidPattern') {
                this.raise(Errors.UnexpectedVoidPattern, id.loc.start);
            }
        }
        
        this.checkLVal(id, {
            type: 'VariableDeclarator',
        }, kind === 'var' ? 5 : 8201);
        decl.id = id;
    }
    
    parseAsyncFunctionExpression(node) {
        return this.parseFunction(node, 8);
    }
    
    parseFunction(node, flags = 0) {
        const hangingDeclaration = flags & 2;
        const isDeclaration2 = !!(flags & 1);
        const requireId = isDeclaration2 && !(flags & 4);
        const isAsync = !!(flags & 8);
        
        this.initFunction(node, isAsync);
        
        if (this.match(51)) {
            if (hangingDeclaration) {
                this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);
            }
            
            this.next();
            node.generator = true;
        }
        
        if (isDeclaration2) {
            node.id = this.parseFunctionId(requireId);
        }
        
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        
        this.state.maybeInArrowParameters = false;
        this.scope.enter(514);
        this.prodParam.enter(functionFlags(isAsync, node.generator));
        
        if (!isDeclaration2) {
            node.id = this.parseFunctionId();
        }
        
        this.parseFunctionParams(node, false);
        this.parseFunctionBodyAndFinish(node, isDeclaration2 ? 'FunctionDeclaration' : 'FunctionExpression');
        this.prodParam.exit();
        this.scope.exit();
        
        if (isDeclaration2 && !hangingDeclaration) {
            this.registerFunctionStatementId(node);
        }
        
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return node;
    }
    
    parseFunctionId(requireId) {
        return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
    }
    
    parseFunctionParams(node, isConstructor) {
        this.expect(6);
        this.expressionScope.enter(newParameterDeclarationScope());
        node.params = this.parseBindingList(7, 41, 2 | (isConstructor ? 4 : 0));
        this.expressionScope.exit();
    }
    
    registerFunctionStatementId(node) {
        if (!node.id)
            return;
        
        this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);
    }
    
    parseClass(node, isStatement5, optionalId) {
        this.next();
        const oldStrict = this.state.strict;
        
        this.state.strict = true;
        this.parseClassId(node, isStatement5, optionalId);
        this.parseClassSuper(node);
        node.body = this.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, isStatement5 ? 'ClassDeclaration' : 'ClassExpression');
    }
    
    isClassProperty() {
        return this.match(25) || this.match(9) || this.match(4);
    }
    
    isClassMethod() {
        return this.match(6);
    }
    
    nameIsConstructor(key) {
        return key.type === 'Identifier' && key.name === 'constructor'
            || key.type === 'StringLiteral' && key.value === 'constructor';
    }
    
    isNonstaticConstructor(method) {
        return !method.computed && !method.static && this.nameIsConstructor(method.key);
    }
    
    parseClassBody(hadSuperClass, oldStrict) {
        this.classScope.enter();
        const state = {
            hadConstructor: false,
            hadSuperClass,
        };
        
        let decorators = [];
        const classBody2 = this.startNode();
        
        classBody2.body = [];
        this.expect(2);
        while (!this.match(4)) {
            if (this.eat(9)) {
                if (decorators.length > 0) {
                    throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);
                }
                
                continue;
            }
            
            if (this.match(22)) {
                decorators.push(this.parseDecorator());
                continue;
            }
            
            const member = this.startNode();
            
            if (decorators.length) {
                member.decorators = decorators;
                this.resetStartLocationFromNode(member, decorators[0]);
                decorators = [];
            }
            
            this.parseClassMember(classBody2, member, state);
            
            if (member.kind === 'constructor' && member.decorators && member.decorators.length > 0) {
                this.raise(Errors.DecoratorConstructor, member);
            }
        }
        
        this.state.strict = oldStrict;
        this.next();
        
        if (decorators.length) {
            throw this.raise(Errors.TrailingDecorator, this.state.startLoc);
        }
        
        this.classScope.exit();
        return this.finishNode(classBody2, 'ClassBody');
    }
    
    parseClassMemberFromModifier(classBody2, member) {
        const key = this.parseIdentifier(true);
        
        if (this.isClassMethod()) {
            const method = member;
            
            method.kind = 'method';
            method.computed = false;
            method.key = key;
            method.static = false;
            this.pushClassMethod(classBody2, method, false, false, false, false);
            return true;
        } else if (this.isClassProperty()) {
            const prop = member;
            
            prop.computed = false;
            prop.key = key;
            prop.static = false;
            classBody2.body.push(this.parseClassProperty(prop));
            return true;
        }
        
        this.resetPreviousNodeTrailingComments(key);
        return false;
    }
    
    parseClassMember(classBody2, member, state) {
        const isStatic2 = this.isContextual(102);
        
        if (isStatic2) {
            if (this.parseClassMemberFromModifier(classBody2, member)) {
                return;
            }
            
            if (this.eat(2)) {
                this.parseClassStaticBlock(classBody2, member);
                return;
            }
        }
        
        this.parseClassMemberWithIsStatic(classBody2, member, state, isStatic2);
    }
    
    parseClassMemberWithIsStatic(classBody2, member, state, isStatic2) {
        const publicMethod = member;
        const privateMethod = member;
        const publicProp = member;
        const privateProp = member;
        const accessorProp = member;
        const method = publicMethod;
        const publicMember = publicMethod;
        
        member.static = isStatic2;
        this.parsePropertyNamePrefixOperator(member);
        
        if (this.eat(51)) {
            method.kind = 'method';
            const isPrivateName3 = this.match(134);
            this.parseClassElementName(method);
            this.parsePostMemberNameModifiers(method);
            
            if (isPrivateName3) {
                this.pushClassPrivateMethod(classBody2, privateMethod, true, false);
                return;
            }
            
            if (this.isNonstaticConstructor(publicMethod)) {
                this.raise(Errors.ConstructorIsGenerator, publicMethod.key);
            }
            
            this.pushClassMethod(classBody2, publicMethod, true, false, false, false);
            return;
        }
        
        const isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type);
        const key = this.parseClassElementName(member);
        const maybeContextualKw = isContextual ? key.name : null;
        const isPrivate2 = this.isPrivateName(key);
        const maybeQuestionTokenStartLoc = this.state.startLoc;
        
        this.parsePostMemberNameModifiers(publicMember);
        
        if (this.isClassMethod()) {
            method.kind = 'method';
            
            if (isPrivate2) {
                this.pushClassPrivateMethod(classBody2, privateMethod, false, false);
                return;
            }
            
            const isConstructor = this.isNonstaticConstructor(publicMethod);
            let allowsDirectSuper = false;
            
            if (isConstructor) {
                publicMethod.kind = 'constructor';
                
                if (state.hadConstructor && !this.hasPlugin('typescript')) {
                    this.raise(Errors.DuplicateConstructor, key);
                }
                
                if (isConstructor && this.hasPlugin('typescript') && member.override) {
                    this.raise(Errors.OverrideOnConstructor, key);
                }
                
                state.hadConstructor = true;
                allowsDirectSuper = state.hadSuperClass;
            }
            
            this.pushClassMethod(classBody2, publicMethod, false, false, isConstructor, allowsDirectSuper);
        } else if (this.isClassProperty()) {
            if (isPrivate2) {
                this.pushClassPrivateProperty(classBody2, privateProp);
            } else {
                this.pushClassProperty(classBody2, publicProp);
            }
        } else if (maybeContextualKw === 'async' && !this.isLineTerminator()) {
            this.resetPreviousNodeTrailingComments(key);
            const isGenerator = this.eat(51);
            
            if (publicMember.optional) {
                this.unexpected(maybeQuestionTokenStartLoc);
            }
            
            method.kind = 'method';
            const isPrivate3 = this.match(134);
            this.parseClassElementName(method);
            this.parsePostMemberNameModifiers(publicMember);
            
            if (isPrivate3) {
                this.pushClassPrivateMethod(classBody2, privateMethod, isGenerator, true);
            } else {
                if (this.isNonstaticConstructor(publicMethod)) {
                    this.raise(Errors.ConstructorIsAsync, publicMethod.key);
                }
                
                this.pushClassMethod(classBody2, publicMethod, isGenerator, true, false, false);
            }
        } else if ((maybeContextualKw === 'get' || maybeContextualKw === 'set') && !(this.match(51) && this.isLineTerminator())) {
            this.resetPreviousNodeTrailingComments(key);
            method.kind = maybeContextualKw;
            const isPrivate3 = this.match(134);
            this.parseClassElementName(publicMethod);
            
            if (isPrivate3) {
                this.pushClassPrivateMethod(classBody2, privateMethod, false, false);
            } else {
                if (this.isNonstaticConstructor(publicMethod)) {
                    this.raise(Errors.ConstructorIsAccessor, publicMethod.key);
                }
                
                this.pushClassMethod(classBody2, publicMethod, false, false, false, false);
            }
            
            this.checkGetterSetterParams(publicMethod);
        } else if (maybeContextualKw === 'accessor' && !this.isLineTerminator()) {
            this.expectPlugin('decoratorAutoAccessors');
            this.resetPreviousNodeTrailingComments(key);
            const isPrivate3 = this.match(134);
            this.parseClassElementName(publicProp);
            this.pushClassAccessorProperty(classBody2, accessorProp, isPrivate3);
        } else if (this.isLineTerminator()) {
            if (isPrivate2) {
                this.pushClassPrivateProperty(classBody2, privateProp);
            } else {
                this.pushClassProperty(classBody2, publicProp);
            }
        } else {
            this.unexpected();
        }




    }
    
    parseClassElementName(member) {
        const {type, value} = this.state;
        
        if ((type === 128 || type === 130) && member.static && value === 'prototype') {
            this.raise(Errors.StaticPrototype, this.state.startLoc);
        }
        
        if (type === 134) {
            if (value === 'constructor') {
                this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);
            }
            
            const key = this.parsePrivateName();
            
            member.key = key;
            return key;
        }
        
        this.parsePropertyName(member);
        return member.key;
    }
    
    parseClassStaticBlock(classBody2, member) {
        this.scope.enter(576 | 128 | 16);
        const oldLabels = this.state.labels;
        
        this.state.labels = [];
        this.prodParam.enter(0);
        const body = member.body = [];
        this.parseBlockOrModuleBlockBody(body, void 0, false, 4);
        this.prodParam.exit();
        this.scope.exit();
        this.state.labels = oldLabels;
        classBody2.body.push(this.finishNode(member, 'StaticBlock'));
        
        if (member.decorators?.length) {
            this.raise(Errors.DecoratorStaticBlock, member);
        }
    }
    
    pushClassProperty(classBody2, prop) {
        if (!prop.computed && this.nameIsConstructor(prop.key)) {
            this.raise(Errors.ConstructorClassField, prop.key);
        }
        
        classBody2.body.push(this.parseClassProperty(prop));
    }
    
    pushClassPrivateProperty(classBody2, prop) {
        const node = this.parseClassPrivateProperty(prop);
        classBody2.body.push(node);
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
    }
    
    pushClassAccessorProperty(classBody2, prop, isPrivate2) {
        if (!isPrivate2 && !prop.computed && this.nameIsConstructor(prop.key)) {
            this.raise(Errors.ConstructorClassField, prop.key);
        }
        
        const node = this.parseClassAccessorProperty(prop);
        classBody2.body.push(node);
        
        if (isPrivate2) {
            this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
        }
    }
    
    pushClassMethod(classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        classBody2.body.push(this.parseMethod(
            method,
            isGenerator,
            isAsync,
            isConstructor,
            allowsDirectSuper,
            'ClassMethod',
            true,
        ));
    }
    
    pushClassPrivateMethod(classBody2, method, isGenerator, isAsync) {
        const node = this.parseMethod(method, isGenerator, isAsync, false, false, 'ClassPrivateMethod', true);
        classBody2.body.push(node);
        const kind = node.kind === 'get' ? node.static ? 6 : 2 : node.kind === 'set' ? node.static ? 5 : 1 : 0;
        this.declareClassPrivateMethodInScope(node, kind);
    }
    
    declareClassPrivateMethodInScope(node, kind) {
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
    }
    
    parsePostMemberNameModifiers() {}
    
    parseClassPrivateProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, 'ClassPrivateProperty');
    }
    
    parseClassProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, 'ClassProperty');
    }
    
    parseClassAccessorProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, 'ClassAccessorProperty');
    }
    
    parseInitializer(node) {
        this.scope.enter(576 | 16);
        this.expressionScope.enter(newExpressionScope());
        this.prodParam.enter(0);
        node.value = this.eat(25) ? this.parseMaybeAssignAllowIn() : null;
        this.expressionScope.exit();
        this.prodParam.exit();
        this.scope.exit();
    }
    
    parseClassId(node, isStatement5, optionalId, bindingType = 8331) {
        if (tokenIsIdentifier(this.state.type)) {
            node.id = this.parseIdentifier();
            
            if (isStatement5) {
                this.declareNameFromIdentifier(node.id, bindingType);
            }
        } else {
            if (optionalId || !isStatement5) {
                node.id = null;
            } else {
                throw this.raise(Errors.MissingClassName, this.state.startLoc);
            }
        }
    }
    
    parseClassSuper(node) {
        node.superClass = this.eat(77) ? this.parseExprSubscripts() : null;
    }
    
    parseExport(node, decorators) {
        const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);
        const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
        const parseAfterDefault = !hasDefault || this.eat(8);
        const hasStar = parseAfterDefault && this.eatExportStar(node);
        const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
        const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(8));
        const isFromRequired = hasDefault || hasStar;
        
        if (hasStar && !hasNamespace) {
            if (hasDefault)
                this.unexpected();
            
            if (decorators) {
                throw this.raise(Errors.UnsupportedDecoratorExport, node);
            }
            
            this.parseExportFrom(node, true);
            this.sawUnambiguousESM = true;
            return this.finishNode(node, 'ExportAllDeclaration');
        }
        
        const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
        
        if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {
            this.unexpected(null, 2);
        }
        
        if (hasNamespace && parseAfterNamespace) {
            this.unexpected(null, 94);
        }
        
        let hasDeclaration;
        
        if (isFromRequired || hasSpecifiers) {
            hasDeclaration = false;
            
            if (decorators) {
                throw this.raise(Errors.UnsupportedDecoratorExport, node);
            }
            
            this.parseExportFrom(node, isFromRequired);
        } else {
            hasDeclaration = this.maybeParseExportDeclaration(node);
        }
        
        if (isFromRequired || hasSpecifiers || hasDeclaration) {
            const node2 = node;
            this.checkExport(node2, true, false, !!node2.source);
            
            if (node2.declaration?.type === 'ClassDeclaration') {
                this.maybeTakeDecorators(decorators, node2.declaration, node2);
            } else if (decorators) {
                throw this.raise(Errors.UnsupportedDecoratorExport, node);
            }
            
            this.sawUnambiguousESM = true;
            return this.finishNode(node2, 'ExportNamedDeclaration');
        }
        
        if (this.eat(61)) {
            const node2 = node;
            const decl = this.parseExportDefaultExpression();
            
            node2.declaration = decl;
            
            if (decl.type === 'ClassDeclaration') {
                this.maybeTakeDecorators(decorators, decl, node2);
            } else if (decorators) {
                throw this.raise(Errors.UnsupportedDecoratorExport, node);
            }
            
            this.checkExport(node2, true, true);
            this.sawUnambiguousESM = true;
            return this.finishNode(node2, 'ExportDefaultDeclaration');
        }
        
        throw this.unexpected(null, 2);
    }
    
    eatExportStar() {
        return this.eat(51);
    }
    
    maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
        if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
            this.expectPlugin('exportDefaultFrom', maybeDefaultIdentifier?.loc.start);
            const id = maybeDefaultIdentifier || this.parseIdentifier(true);
            const specifier = this.startNodeAtNode(id);
            
            specifier.exported = id;
            node.specifiers = [
                this.finishNode(specifier, 'ExportDefaultSpecifier'),
            ];
            return true;
        }
        
        return false;
    }
    
    maybeParseExportNamespaceSpecifier(node) {
        if (this.isContextual(89)) {
            node.specifiers ??= [];
            const specifier = this.startNodeAt(this.state.lastTokStartLoc);
            this.next();
            specifier.exported = this.parseModuleExportName();
            node.specifiers.push(this.finishNode(specifier, 'ExportNamespaceSpecifier'));
            return true;
        }
        
        return false;
    }
    
    maybeParseExportNamedSpecifiers(node) {
        if (this.match(2)) {
            const node2 = node;
            
            if (!node2.specifiers)
                node2.specifiers = [];
            
            const isTypeExport = node2.exportKind === 'type';
            node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
            node2.source = null;
            node2.attributes = [];
            node2.declaration = null;
            return true;
        }
        
        return false;
    }
    
    maybeParseExportDeclaration(node) {
        if (this.shouldParseExportDeclaration()) {
            node.specifiers = [];
            node.source = null;
            node.attributes = [];
            node.declaration = this.parseExportDeclaration(node);
            return true;
        }
        
        return false;
    }
    
    isAsyncFunction() {
        if (!this.isContextual(91))
            return false;
        
        const next = this.nextTokenInLineStart();
        
        return this.isUnparsedContextual(next, 'function');
    }
    
    parseExportDefaultExpression() {
        const expr = this.startNode();
        
        if (this.match(64)) {
            this.next();
            return this.parseFunction(expr, 1 | 4);
        } else if (this.isAsyncFunction()) {
            this.next();
            this.next();
            return this.parseFunction(expr, 1 | 4 | 8);
        }
        
        if (this.match(76)) {
            return this.parseClass(expr, true, true);
        }
        
        if (this.match(22)) {
            return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
        }
        
        if (this.match(71) || this.match(70) || this.isLet() || this.isUsing() || this.isAwaitUsing()) {
            throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);
        }
        
        const res = this.parseMaybeAssignAllowIn();
        this.semicolon();
        return res;
    }
    
    parseExportDeclaration() {
        if (this.match(76)) {
            const node2 = this.parseClass(this.startNode(), true, false);
            return node2;
        }
        
        return this.parseStatementListItem();
    }
    
    isExportDefaultSpecifier() {
        const {type} = this.state;
        
        if (tokenIsIdentifier(type)) {
            if (type === 91 && !this.state.containsEsc || type === 96) {
                return false;
            }
            
            if ((type === 126 || type === 125) && !this.state.containsEsc) {
                const next2 = this.nextTokenStart();
                const nextChar = this.input.charCodeAt(next2);
                
                if (nextChar === 123 || this.chStartsBindingIdentifier(nextChar, next2) && !this.input.startsWith('from', next2)) {
                    this.expectOnePlugin(['flow', 'typescript']);
                    return false;
                }
            }
        } else if (!this.match(61)) {
            return false;
        }
        
        const next = this.nextTokenStart();
        const hasFrom = this.isUnparsedContextual(next, 'from');
        
        if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
            return true;
        }
        
        if (this.match(61) && hasFrom) {
            const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
            return nextAfterFrom === 34 || nextAfterFrom === 39;
        }
        
        return false;
    }
    
    parseExportFrom(node, expect) {
        if (this.eatContextual(94)) {
            node.source = this.parseImportSource();
            this.checkExport(node);
            this.maybeParseImportAttributes(node);
        } else if (expect) {
            this.unexpected();
        }
        
        this.semicolon();
    }
    
    shouldParseExportDeclaration() {
        const {type} = this.state;
        
        if (type === 22) {
            this.expectOnePlugin(['decorators', 'decorators-legacy']);
            
            if (this.hasPlugin('decorators')) {
                return true;
            }
        }
        
        if (this.isUsing()) {
            this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
            return true;
        }
        
        if (this.isAwaitUsing()) {
            this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
            return true;
        }
        
        return type === 70
            || type === 71
            || type === 64
            || type === 76
            || this.isLet()
            || this.isAsyncFunction();
    }
    
    checkExport(node, checkNames, isDefault, isFrom) {
        if (checkNames) {
            if (isDefault) {
                this.checkDuplicateExports(node, 'default');
                
                if (this.hasPlugin('exportDefaultFrom')) {
                    const declaration = node.declaration;
                    
                    if (declaration.type === 'Identifier' && declaration.name === 'from' && declaration.end - declaration.start === 4 && !declaration.extra?.parenthesized) {
                        this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);
                    }
                }
            } else if (node.specifiers?.length) {
                for (const specifier of node.specifiers) {
                    const {exported} = specifier;
                    
                    const exportName = exported.type === 'Identifier' ? exported.name : exported.value;
                    this.checkDuplicateExports(specifier, exportName);
                    
                    if (!isFrom && specifier.local) {
                        const {local} = specifier;
                        
                        if (local.type !== 'Identifier') {
                            this.raise(Errors.ExportBindingIsString, specifier, {
                                localName: local.value,
                                exportName,
                            });
                        } else {
                            this.checkReservedWord(local.name, local.loc.start, true, false);
                            this.scope.checkLocalExport(local);
                        }
                    }
                }
            } else if (node.declaration) {
                const decl = node.declaration;
                
                if (decl.type === 'FunctionDeclaration' || decl.type === 'ClassDeclaration') {
                    const {id} = decl;
                    
                    if (!id)
                        throw new Error('Assertion failure');
                    
                    this.checkDuplicateExports(node, id.name);
                } else if (decl.type === 'VariableDeclaration') {
                    for (const declaration of decl.declarations) {
                        this.checkDeclaration(declaration.id);
                    }
                }
            }

        }
    }
    
    checkDeclaration(node) {
        if (node.type === 'Identifier') {
            this.checkDuplicateExports(node, node.name);
        } else if (node.type === 'ObjectPattern') {
            for (const prop of node.properties) {
                this.checkDeclaration(prop);
            }
        } else if (node.type === 'ArrayPattern') {
            for (const elem of node.elements) {
                if (elem) {
                    this.checkDeclaration(elem);
                }
            }
        } else if (node.type === 'ObjectProperty') {
            this.checkDeclaration(node.value);
        } else if (node.type === 'RestElement') {
            this.checkDeclaration(node.argument);
        } else if (node.type === 'AssignmentPattern') {
            this.checkDeclaration(node.left);
        }




    }
    
    checkDuplicateExports(node, exportName) {
        if (this.exportedIdentifiers.has(exportName)) {
            if (exportName === 'default') {
                this.raise(Errors.DuplicateDefaultExport, node);
            } else {
                this.raise(Errors.DuplicateExport, node, {
                    exportName,
                });
            }
        }
        
        this.exportedIdentifiers.add(exportName);
    }
    
    parseExportSpecifiers(isInTypeExport) {
        const nodes2 = [];
        let first = true;
        this.expect(2);
        while (!this.eat(4)) {
            if (first) {
                first = false;
            } else {
                this.expect(8);
                
                if (this.eat(4))
                    break;
            }
            
            const isMaybeTypeOnly = this.isContextual(126);
            const isString = this.match(130);
            const node = this.startNode();
            
            node.local = this.parseModuleExportName();
            nodes2.push(this.parseExportSpecifier(
                node,
                isString,
                isInTypeExport,
                isMaybeTypeOnly,
            ));
        }
        
        return nodes2;
    }
    
    parseExportSpecifier(node, isString) {
        if (this.eatContextual(89)) {
            node.exported = this.parseModuleExportName();
        } else if (isString) {
            node.exported = this.cloneStringLiteral(node.local);
        } else if (!node.exported) {
            node.exported = this.cloneIdentifier(node.local);
        }
        
        return this.finishNode(node, 'ExportSpecifier');
    }
    
    parseModuleExportName() {
        if (this.match(130)) {
            const result = this.parseStringLiteral(this.state.value);
            const surrogate = loneSurrogate.exec(result.value);
            
            if (surrogate) {
                this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {
                    surrogateCharCode: surrogate[0].charCodeAt(0),
                });
            }
            
            return result;
        }
        
        return this.parseIdentifier(true);
    }
    
    checkImportPhase(node) {
        const {specifiers} = node;
        
        const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
        
        if (node.phase === 'source') {
            if (singleBindingType !== 'ImportDefaultSpecifier') {
                this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);
            }
        } else if (node.phase === 'defer') {
            if (singleBindingType !== 'ImportNamespaceSpecifier') {
                this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);
            }
        }
    }
    
    isPotentialImportPhase(isExport) {
        if (isExport)
            return false;
        
        return this.isContextual(101) || this.isContextual(93);
    }
    
    applyImportPhase(node, isExport, phase, loc) {
        if (isExport) {
            return;
        }
        
        if (phase === 'source') {
            this.expectPlugin('sourcePhaseImports', loc);
            node.phase = 'source';
        } else if (phase === 'defer') {
            this.expectPlugin('deferredImportEvaluation', loc);
            node.phase = 'defer';
        } else if (this.hasPlugin('sourcePhaseImports')) {
            node.phase = null;
        }

    }
    
    parseMaybeImportPhase(node, isExport) {
        if (!this.isPotentialImportPhase(isExport)) {
            this.applyImportPhase(node, isExport, null);
            return null;
        }
        
        const phaseIdentifier = this.startNode();
        const phaseIdentifierName = this.parseIdentifierName(true);
        
        const {type} = this.state;
        
        const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 94 || this.lookaheadCharCode() === 102 : type !== 8;
        
        if (isImportPhase) {
            this.applyImportPhase(node, isExport, phaseIdentifierName, phaseIdentifier.loc.start);
            return null;
        } else {
            this.applyImportPhase(node, isExport, null);
            return this.createIdentifier(phaseIdentifier, phaseIdentifierName);
        }
    }
    
    isPrecedingIdImportPhase() {
        const {type} = this.state;
        
        return tokenIsIdentifier(type) ? type !== 94 || this.lookaheadCharCode() === 102 : type !== 8;
    }
    
    parseImport(node) {
        if (this.match(130)) {
            return this.parseImportSourceAndAttributes(node);
        }
        
        return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));
    }
    
    parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {
        node.specifiers = [];
        const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);
        const parseNext = !hasDefault || this.eat(8);
        const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
        
        if (parseNext && !hasStar)
            this.parseNamedImportSpecifiers(node);
        
        this.expectContextual(94);
        return this.parseImportSourceAndAttributes(node);
    }
    
    parseImportSourceAndAttributes(node) {
        node.specifiers ??= [];
        node.source = this.parseImportSource();
        this.maybeParseImportAttributes(node);
        this.checkImportPhase(node);
        this.semicolon();
        this.sawUnambiguousESM = true;
        return this.finishNode(node, 'ImportDeclaration');
    }
    
    parseImportSource() {
        if (!this.match(130))
            this.unexpected();
        
        return this.parseExprAtom();
    }
    
    parseImportSpecifierLocal(node, specifier, type) {
        specifier.local = this.parseIdentifier();
        node.specifiers.push(this.finishImportSpecifier(specifier, type));
    }
    
    finishImportSpecifier(specifier, type, bindingType = 8201) {
        this.checkLVal(specifier.local, {
            type,
        }, bindingType);
        return this.finishNode(specifier, type);
    }
    
    parseImportAttributes() {
        this.expect(2);
        const attrs = [];
        const attrNames =         /* @__PURE__ */new Set();
        
        do {
            if (this.match(4)) {
                break;
            }
            
            const node = this.startNode();
            const keyName = this.state.value;
            
            if (attrNames.has(keyName)) {
                this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
                    key: keyName,
                });
            }
            
            attrNames.add(keyName);
            
            if (this.match(130)) {
                node.key = this.parseStringLiteral(keyName);
            } else {
                node.key = this.parseIdentifier(true);
            }
            
            this.expect(10);
            
            if (!this.match(130)) {
                throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
            }
            
            node.value = this.parseStringLiteral(this.state.value);
            attrs.push(this.finishNode(node, 'ImportAttribute'));
        } while (this.eat(8))
        this.expect(4);
        return attrs;
    }
    
    maybeParseImportAttributes(node) {
        let attributes;
        
        if (this.match(72)) {
            if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {
                return;
            }
            
            this.next();
            attributes = this.parseImportAttributes();
        } else {
            attributes = [];
        }
        
        node.attributes = attributes;
    }
    
    maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {
        if (maybeDefaultIdentifier) {
            const specifier = this.startNodeAtNode(maybeDefaultIdentifier);
            
            specifier.local = maybeDefaultIdentifier;
            node.specifiers.push(this.finishImportSpecifier(specifier, 'ImportDefaultSpecifier'));
            return true;
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            this.parseImportSpecifierLocal(node, this.startNode(), 'ImportDefaultSpecifier');
            return true;
        }
        
        return false;
    }
    
    maybeParseStarImportSpecifier(node) {
        if (this.match(51)) {
            const specifier = this.startNode();
            this.next();
            this.expectContextual(89);
            this.parseImportSpecifierLocal(node, specifier, 'ImportNamespaceSpecifier');
            return true;
        }
        
        return false;
    }
    
    parseNamedImportSpecifiers(node) {
        let first = true;
        this.expect(2);
        while (!this.eat(4)) {
            if (first) {
                first = false;
            } else {
                if (this.eat(10)) {
                    throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);
                }
                
                this.expect(8);
                
                if (this.eat(4))
                    break;
            }
            
            const specifier = this.startNode();
            const importedIsString = this.match(130);
            const isMaybeTypeOnly = this.isContextual(126);
            
            specifier.imported = this.parseModuleExportName();
            const importSpecifier2 = this.parseImportSpecifier(specifier, importedIsString, node.importKind === 'type' || node.importKind === 'typeof', isMaybeTypeOnly, void 0);
            node.specifiers.push(importSpecifier2);
        }
    }
    
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        if (this.eatContextual(89)) {
            specifier.local = this.parseIdentifier();
        } else {
            const {imported} = specifier;
            
            if (importedIsString) {
                throw this.raise(Errors.ImportBindingIsString, specifier, {
                    importName: imported.value,
                });
            }
            
            this.checkReservedWord(imported.name, specifier.loc.start, true, true);
            
            if (!specifier.local) {
                specifier.local = this.cloneIdentifier(imported);
            }
        }
        
        return this.finishImportSpecifier(specifier, 'ImportSpecifier', bindingType);
    }
    
    isThisParam(param) {
        return param.type === 'Identifier' && param.name === 'this';
    }
};

var Parser = class extends StatementParser {
    constructor(options, input, pluginsMap) {
        const normalizedOptions = getOptions(options);
        super(normalizedOptions, input);
        this.options = normalizedOptions;
        this.initializeScopes();
        this.plugins = pluginsMap;
        this.filename = normalizedOptions.sourceFilename;
        this.startIndex = normalizedOptions.startIndex;
        let optionFlags = 0;
        
        if (normalizedOptions.allowAwaitOutsideFunction) {
            optionFlags |= 1;
        }
        
        if (normalizedOptions.allowReturnOutsideFunction) {
            optionFlags |= 2;
        }
        
        if (normalizedOptions.allowImportExportEverywhere) {
            optionFlags |= 8;
        }
        
        if (normalizedOptions.allowSuperOutsideMethod) {
            optionFlags |= 16;
        }
        
        if (normalizedOptions.allowUndeclaredExports) {
            optionFlags |= 64;
        }
        
        if (normalizedOptions.allowNewTargetOutsideFunction) {
            optionFlags |= 4;
        }
        
        if (normalizedOptions.allowYieldOutsideFunction) {
            optionFlags |= 32;
        }
        
        if (normalizedOptions.ranges) {
            optionFlags |= 128;
        }
        
        if (normalizedOptions.tokens) {
            optionFlags |= 256;
        }
        
        if (normalizedOptions.createImportExpressions) {
            optionFlags |= 512;
        }
        
        if (normalizedOptions.createParenthesizedExpressions) {
            optionFlags |= 1024;
        }
        
        if (normalizedOptions.errorRecovery) {
            optionFlags |= 2048;
        }
        
        if (normalizedOptions.attachComment) {
            optionFlags |= 4096;
        }
        
        if (normalizedOptions.annexB) {
            optionFlags |= 8192;
        }
        
        this.optionFlags = optionFlags;
    }
    
    getScopeHandler() {
        return ScopeHandler;
    }
    
    parse() {
        this.enterInitialScopes();
        const file2 = this.startNode();
        const program3 = this.startNode();
        
        this.nextToken();
        file2.errors = null;
        const result = this.parseTopLevel(file2, program3);
        
        result.errors = this.state.errors;
        result.comments.length = this.state.commentsLen;
        return result;
    }
};

function parse$9(input, options) {
    if (options?.sourceType === 'unambiguous') {
        options = {
            ...options,
        };
        try {
            options.sourceType = 'module';
            const parser = getParser$1(options, input);
            const ast = parser.parse();
            
            if (parser.sawUnambiguousESM) {
                return ast;
            }
            
            if (parser.ambiguousScriptDifferentAst) {
                try {
                    options.sourceType = 'script';
                    return getParser$1(options, input).parse();
                } catch {}
            } else {
                ast.program.sourceType = 'script';
            }
            
            return ast;
        } catch(moduleError) {
            try {
                options.sourceType = 'script';
                return getParser$1(options, input).parse();
            } catch {}


                        throw moduleError;
        }
    } else {
        return getParser$1(options, input).parse();
    }
}

function parseExpression$1(input, options) {
    const parser = getParser$1(options, input);
    
    if (parser.options.strictMode) {
        parser.state.strict = true;
    }
    
    return parser.getExpression();
}

function generateExportedTokenTypes(internalTokenTypes) {
    const tokenTypes2 = {};
    
    for (const typeName of Object.keys(internalTokenTypes)) {
        tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
    }
    
    return tokenTypes2;
}

var tokTypes = generateExportedTokenTypes(tt);

function getParser$1(options, input) {
    let cls = Parser;
    const pluginsMap =     /* @__PURE__ */new Map();
    
    if (options?.plugins) {
        for (const plugin of options.plugins) {
            let name, opts;
            
            if (typeof plugin === 'string') {
                name = plugin;
            } else {
                [name, opts] = plugin;
            }
            
            if (!pluginsMap.has(name)) {
                pluginsMap.set(name, opts || {});
            }
        }
        
        validatePlugins(pluginsMap);
        cls = getParserClass(pluginsMap);
    }
    
    return new cls(options, input, pluginsMap);
}

var parserClassCache = /* @__PURE__ */new Map();

function getParserClass(pluginsMap) {
    const pluginList = [];
    
    for (const name of mixinPluginNames) {
        if (pluginsMap.has(name)) {
            pluginList.push(name);
        }
    }
    
    const key = pluginList.join('|');
    let cls = parserClassCache.get(key);
    
    if (!cls) {
        cls = Parser;
        for (const plugin of pluginList) {
            cls = mixinPlugins[plugin](cls);
        }
        
        parserClassCache.set(key, cls);
    }
    
    return cls;
}

// ../babel-babel/packages/babel-code-frame/lib/index.js
var import_picocolors = __toESM(require_picocolors());

// ../babel-babel/node_modules/js-tokens/index.js
var HashbangComment;
var Identifier2;
var JSXIdentifier2;
var JSXPunctuator;
var JSXString;
var JSXText2;
var KeywordsWithExpressionAfter;
var KeywordsWithNoLineTerminatorAfter;
var LineTerminatorSequence;
var MultiLineComment;
var Newline;
var NumericLiteral2;
var Punctuator;
var RegularExpressionLiteral;
var SingleLineComment;
var StringLiteral2;
var Template;
var TokensNotPrecedingObjectLiteral;
var TokensPrecedingExpression;
var WhiteSpace;
var jsTokens;

RegularExpressionLiteral = /\/(?![*\/])(?:\[(?:[^\]\\\n\r\u2028\u2029]+|\\.)*\]?|[^\/[\\\n\r\u2028\u2029]+|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/yu;
Punctuator = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y;
Identifier2 = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]+|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/yu;
StringLiteral2 = /(['"])(?:[^'"\\\n\r]+|(?!\1)['"]|\\(?:\r\n|[^]))*(\1)?/y;
NumericLiteral2 = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y;
Template = /[`}](?:[^`\\$]+|\\[^]|\$(?!\{))*(`|\$\{)?/y;
WhiteSpace = /[\t\v\f\ufeff\p{Zs}]+/yu;
LineTerminatorSequence = /\r?\n|[\r\u2028\u2029]/y;
MultiLineComment = /\/\*(?:[^*]+|\*(?!\/))*(\*\/)?/y;
SingleLineComment = /\/\/.*/y;
HashbangComment = /^#!.*/;
JSXPunctuator = /[<>.:={}]|\/(?![\/*])/y;
JSXIdentifier2 = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/yu;
JSXString = /(['"])(?:[^'"]+|(?!\1)['"])*(\1)?/y;
JSXText2 = /[^<>{}]+/y;
TokensPrecedingExpression = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;
TokensNotPrecedingObjectLiteral = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;
KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;
KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/;
Newline = RegExp(LineTerminatorSequence.source);
jsTokens = function*(input, {jsx: jsx2 = false} = {}) {
    var braces,
        firstCodePoint,
        isExpression4,
        lastIndex,
        lastSignificantToken,
        length,
        match,
        mode,
        nextLastIndex,
        nextLastSignificantToken,
        parenNesting,
        postfixIncDec,
        punctuator,
        stack;
    
    ({length} = input);
    lastIndex = 0;
    lastSignificantToken = '';
    stack = [{
        tag: 'JS',
    }];
    braces = [];
    parenNesting = 0;
    postfixIncDec = false;
    
    if (match = HashbangComment.exec(input)) {
        yield {
            type: 'HashbangComment',
            value: match[0],
        };
        lastIndex = match[0].length;
    }
    
    while (lastIndex < length) {
        mode = stack[stack.length - 1];
        switch(mode.tag) {
        case 'JS':        
        case 'JSNonExpressionParen':        
        case 'InterpolationInTemplate':        
        case 'InterpolationInJSX':
            if (input[lastIndex] === '/' && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
                RegularExpressionLiteral.lastIndex = lastIndex;
                
                if (match = RegularExpressionLiteral.exec(input)) {
                    lastIndex = RegularExpressionLiteral.lastIndex;
                    lastSignificantToken = match[0];
                    postfixIncDec = true;
                    yield {
                        type: 'RegularExpressionLiteral',
                        value: match[0],
                        closed: match[1] !== void 0 && match[1] !== '\\',
                    };
                    continue;
                }
            }
            
            Punctuator.lastIndex = lastIndex;
            
            if (match = Punctuator.exec(input)) {
                punctuator = match[0];
                nextLastIndex = Punctuator.lastIndex;
                nextLastSignificantToken = punctuator;
                switch(punctuator) {
                case '(':
                    if (lastSignificantToken === '?NonExpressionParenKeyword') {
                        stack.push({
                            tag: 'JSNonExpressionParen',
                            nesting: parenNesting,
                        });
                    }
                    
                    parenNesting++;
                    postfixIncDec = false;
                    break;
                
                case ')':
                    parenNesting--;
                    postfixIncDec = true;
                    
                    if (mode.tag === 'JSNonExpressionParen' && parenNesting === mode.nesting) {
                        stack.pop();
                        nextLastSignificantToken = '?NonExpressionParenEnd';
                        postfixIncDec = false;
                    }
                    
                    break;
                
                case '{':
                    Punctuator.lastIndex = 0;
                    isExpression4 = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken));
                    braces.push(isExpression4);
                    postfixIncDec = false;
                    break;
                
                case '}':
                    switch(mode.tag) {
                    case 'InterpolationInTemplate':
                        if (braces.length === mode.nesting) {
                            Template.lastIndex = lastIndex;
                            match = Template.exec(input);
                            lastIndex = Template.lastIndex;
                            lastSignificantToken = match[0];
                            
                            if (match[1] === '${') {
                                lastSignificantToken = '?InterpolationInTemplate';
                                postfixIncDec = false;
                                yield {
                                    type: 'TemplateMiddle',
                                    value: match[0],
                                };
                            } else {
                                stack.pop();
                                postfixIncDec = true;
                                yield {
                                    type: 'TemplateTail',
                                    value: match[0],
                                    closed: match[1] === '`',
                                };
                            }
                            
                            continue;
                        }
                        
                        break;
                    
                    case 'InterpolationInJSX':
                        if (braces.length === mode.nesting) {
                            stack.pop();
                            lastIndex += 1;
                            lastSignificantToken = '}';
                            yield {
                                type: 'JSXPunctuator',
                                value: '}',
                            };
                            continue;
                        }
                    }
                    
                    postfixIncDec = braces.pop();
                    nextLastSignificantToken = postfixIncDec ? '?ExpressionBraceEnd' : '}';
                    break;
                
                case ']':
                    postfixIncDec = true;
                    break;
                
                case '++':                
                case '--':
                    nextLastSignificantToken = postfixIncDec ? '?PostfixIncDec' : '?UnaryIncDec';
                    break;
                
                case '<':
                    if (jsx2 && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
                        stack.push({
                            tag: 'JSXTag',
                        });
                        lastIndex += 1;
                        lastSignificantToken = '<';
                        yield {
                            type: 'JSXPunctuator',
                            value: punctuator,
                        };
                        continue;
                    }
                    
                    postfixIncDec = false;
                    break;
                
                default:
                    postfixIncDec = false;
                }
                
                lastIndex = nextLastIndex;
                lastSignificantToken = nextLastSignificantToken;
                yield {
                    type: 'Punctuator',
                    value: punctuator,
                };
                continue;
            }
            
            Identifier2.lastIndex = lastIndex;
            
            if (match = Identifier2.exec(input)) {
                lastIndex = Identifier2.lastIndex;
                nextLastSignificantToken = match[0];
                switch(match[0]) {
                case 'for':                
                case 'if':                
                case 'while':                
                case 'with':
                    if (lastSignificantToken !== '.' && lastSignificantToken !== '?.') {
                        nextLastSignificantToken = '?NonExpressionParenKeyword';
                    }
                }
                
                lastSignificantToken = nextLastSignificantToken;
                postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]);
                yield {
                    type: match[1] === '#' ? 'PrivateIdentifier' : 'IdentifierName',
                    value: match[0],
                };
                continue;
            }
            
            StringLiteral2.lastIndex = lastIndex;
            
            if (match = StringLiteral2.exec(input)) {
                lastIndex = StringLiteral2.lastIndex;
                lastSignificantToken = match[0];
                postfixIncDec = true;
                yield {
                    type: 'StringLiteral',
                    value: match[0],
                    closed: match[2] !== void 0,
                };
                continue;
            }
            
            NumericLiteral2.lastIndex = lastIndex;
            
            if (match = NumericLiteral2.exec(input)) {
                lastIndex = NumericLiteral2.lastIndex;
                lastSignificantToken = match[0];
                postfixIncDec = true;
                yield {
                    type: 'NumericLiteral',
                    value: match[0],
                };
                continue;
            }
            
            Template.lastIndex = lastIndex;
            
            if (match = Template.exec(input)) {
                lastIndex = Template.lastIndex;
                lastSignificantToken = match[0];
                
                if (match[1] === '${') {
                    lastSignificantToken = '?InterpolationInTemplate';
                    stack.push({
                        tag: 'InterpolationInTemplate',
                        nesting: braces.length,
                    });
                    postfixIncDec = false;
                    yield {
                        type: 'TemplateHead',
                        value: match[0],
                    };
                } else {
                    postfixIncDec = true;
                    yield {
                        type: 'NoSubstitutionTemplate',
                        value: match[0],
                        closed: match[1] === '`',
                    };
                }
                
                continue;
            }
            
            break;
        
        case 'JSXTag':        
        case 'JSXTagEnd':
            JSXPunctuator.lastIndex = lastIndex;
            
            if (match = JSXPunctuator.exec(input)) {
                lastIndex = JSXPunctuator.lastIndex;
                nextLastSignificantToken = match[0];
                switch(match[0]) {
                case '<':
                    stack.push({
                        tag: 'JSXTag',
                    });
                    break;
                
                case '>':
                    stack.pop();
                    
                    if (lastSignificantToken === '/' || mode.tag === 'JSXTagEnd') {
                        nextLastSignificantToken = '?JSX';
                        postfixIncDec = true;
                    } else {
                        stack.push({
                            tag: 'JSXChildren',
                        });
                    }
                    
                    break;
                
                case '{':
                    stack.push({
                        tag: 'InterpolationInJSX',
                        nesting: braces.length,
                    });
                    nextLastSignificantToken = '?InterpolationInJSX';
                    postfixIncDec = false;
                    break;
                
                case '/':
                    if (lastSignificantToken === '<') {
                        stack.pop();
                        
                        if (stack[stack.length - 1].tag === 'JSXChildren') {
                            stack.pop();
                        }
                        
                        stack.push({
                            tag: 'JSXTagEnd',
                        });
                    }
                }
                
                lastSignificantToken = nextLastSignificantToken;
                yield {
                    type: 'JSXPunctuator',
                    value: match[0],
                };
                continue;
            }
            
            JSXIdentifier2.lastIndex = lastIndex;
            
            if (match = JSXIdentifier2.exec(input)) {
                lastIndex = JSXIdentifier2.lastIndex;
                lastSignificantToken = match[0];
                yield {
                    type: 'JSXIdentifier',
                    value: match[0],
                };
                continue;
            }
            
            JSXString.lastIndex = lastIndex;
            
            if (match = JSXString.exec(input)) {
                lastIndex = JSXString.lastIndex;
                lastSignificantToken = match[0];
                yield {
                    type: 'JSXString',
                    value: match[0],
                    closed: match[2] !== void 0,
                };
                continue;
            }
            
            break;
        
        case 'JSXChildren':
            JSXText2.lastIndex = lastIndex;
            
            if (match = JSXText2.exec(input)) {
                lastIndex = JSXText2.lastIndex;
                lastSignificantToken = match[0];
                yield {
                    type: 'JSXText',
                    value: match[0],
                };
                continue;
            }
            
            switch(input[lastIndex]) {
            case '<':
                stack.push({
                    tag: 'JSXTag',
                });
                lastIndex++;
                lastSignificantToken = '<';
                yield {
                    type: 'JSXPunctuator',
                    value: '<',
                };
                continue;
            
            case '{':
                stack.push({
                    tag: 'InterpolationInJSX',
                    nesting: braces.length,
                });
                lastIndex++;
                lastSignificantToken = '?InterpolationInJSX';
                postfixIncDec = false;
                yield {
                    type: 'JSXPunctuator',
                    value: '{',
                };
                continue;
            }
        }
        
        WhiteSpace.lastIndex = lastIndex;
        
        if (match = WhiteSpace.exec(input)) {
            lastIndex = WhiteSpace.lastIndex;
            yield {
                type: 'WhiteSpace',
                value: match[0],
            };
            continue;
        }
        
        LineTerminatorSequence.lastIndex = lastIndex;
        
        if (match = LineTerminatorSequence.exec(input)) {
            lastIndex = LineTerminatorSequence.lastIndex;
            postfixIncDec = false;
            
            if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
                lastSignificantToken = '?NoLineTerminatorHere';
            }
            
            yield {
                type: 'LineTerminatorSequence',
                value: match[0],
            };
            continue;
        }
        
        MultiLineComment.lastIndex = lastIndex;
        
        if (match = MultiLineComment.exec(input)) {
            lastIndex = MultiLineComment.lastIndex;
            
            if (Newline.test(match[0])) {
                postfixIncDec = false;
                
                if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
                    lastSignificantToken = '?NoLineTerminatorHere';
                }
            }
            
            yield {
                type: 'MultiLineComment',
                value: match[0],
                closed: match[1] !== void 0,
            };
            continue;
        }
        
        SingleLineComment.lastIndex = lastIndex;
        
        if (match = SingleLineComment.exec(input)) {
            lastIndex = SingleLineComment.lastIndex;
            postfixIncDec = false;
            yield {
                type: 'SingleLineComment',
                value: match[0],
            };
            continue;
        }
        
        firstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex));
        lastIndex += firstCodePoint.length;
        lastSignificantToken = firstCodePoint;
        postfixIncDec = false;
        yield {
            type: mode.tag.startsWith('JSX') ? 'JSXInvalid' : 'Invalid',
            value: firstCodePoint,
        };
    }
    
    return void 0;
};
var js_tokens_default = jsTokens;

// ../babel-babel/packages/babel-code-frame/lib/index.js
function isColorSupported() {
    return typeof browser$1 === 'object' && (browser$1.env.FORCE_COLOR === '0' || browser$1.env.FORCE_COLOR === 'false') ? false : import_picocolors.default.isColorSupported;
}

var compose = (f, g) => (v) => f(g(v));

function buildDefs(colors2) {
    return {
        keyword: colors2.cyan,
        capitalized: colors2.yellow,
        jsxIdentifier: colors2.yellow,
        punctuator: colors2.yellow,
        number: colors2.magenta,
        string: colors2.green,
        regex: colors2.magenta,
        comment: colors2.gray,
        invalid: compose(compose(colors2.white, colors2.bgRed), colors2.bold),
        gutter: colors2.gray,
        marker: compose(colors2.red, colors2.bold),
        message: compose(colors2.red, colors2.bold),
        reset: colors2.reset,
    };
}

var defsOn = buildDefs((0, import_picocolors.createColors)(true));
var defsOff = buildDefs((0, import_picocolors.createColors)(false));

function getDefs(enabled2) {
    return enabled2 ? defsOn : defsOff;
}

var sometimesKeywords = /* @__PURE__ */new Set([
    'as',
    'async',
    'from',
    'get',
    'of',
    'set',
]);
var NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
var BRACKET = /^[()[\]{}]$/;

var getTokenType = function(token) {
    if (token.type === 'IdentifierName') {
        const tokenValue = token.value;
        
        if (isKeyword$1(tokenValue) || isStrictReservedWord(tokenValue, true) || sometimesKeywords.has(tokenValue)) {
            return 'keyword';
        }
        
        const firstChar = tokenValue.charCodeAt(0);
        
        if (firstChar < 128) {
            if (firstChar >= 65 && firstChar <= 90) {
                return 'capitalized';
            }
        } else {
            const firstChar2 = String.fromCodePoint(tokenValue.codePointAt(0));
            
            if (firstChar2 !== firstChar2.toLowerCase()) {
                return 'capitalized';
            }
        }
    }
    
    if (token.type === 'Punctuator' && BRACKET.test(token.value)) {
        return 'uncolored';
    }
    
    if (token.type === 'Invalid' && token.value === '@') {
        return 'punctuator';
    }
    
    switch(token.type) {
    case 'NumericLiteral':
        return 'number';
    
    case 'StringLiteral':    
    case 'JSXString':    
    case 'NoSubstitutionTemplate':
        return 'string';
    
    case 'RegularExpressionLiteral':
        return 'regex';
    
    case 'Punctuator':    
    case 'JSXPunctuator':
        return 'punctuator';
    
    case 'MultiLineComment':    
    case 'SingleLineComment':
        return 'comment';
    
    case 'Invalid':    
    case 'JSXInvalid':
        return 'invalid';
    
    case 'JSXIdentifier':
        return 'jsxIdentifier';
    
    default:
        return 'uncolored';
    }
};

function* tokenize$1(text) {
    for (const token of js_tokens_default(text, {jsx: true})) {
        switch(token.type) {
        case 'TemplateHead':
            yield {
                type: 'string',
                value: token.value.slice(0, -2),
            };
            yield {
                type: 'punctuator',
                value: '${',
            };
            break;
        
        case 'TemplateMiddle':
            yield {
                type: 'punctuator',
                value: '}',
            };
            yield {
                type: 'string',
                value: token.value.slice(1, -2),
            };
            yield {
                type: 'punctuator',
                value: '${',
            };
            break;
        
        case 'TemplateTail':
            yield {
                type: 'punctuator',
                value: '}',
            };
            yield {
                type: 'string',
                value: token.value.slice(1),
            };
            break;
        
        default:
            yield {
                type: getTokenType(token),
                value: token.value,
            };
        }
    }
}

function highlight(text) {
    if (text === '')
        return '';
    
    const defs = getDefs(true);
    let highlighted = '';
    
    for (const {type, value} of tokenize$1(text)) {
        if (type in defs) {
            highlighted += value
                .split(NEWLINE$1)
                .map((str) => defs[type](str))
                .join('\n');
        } else {
            highlighted += value;
        }
    }
    
    return highlighted;
}

var NEWLINE$2 = /\r\n|[\n\r\u2028\u2029]/;

function getMarkerLines(loc, source, opts) {
    const startLoc = {
        column: 0,
        line: -1,
        ...loc.start,
    };
    
    const endLoc = {
        ...startLoc,
        ...loc.end,
    };
    
    const {linesAbove = 2, linesBelow = 3} = opts || {};
    
    const startLine = startLoc.line;
    const startColumn = startLoc.column;
    const endLine = endLoc.line;
    const endColumn = endLoc.column;
    let start = Math.max(startLine - (linesAbove + 1), 0);
    let end = Math.min(source.length, endLine + linesBelow);
    
    if (startLine === -1) {
        start = 0;
    }
    
    if (endLine === -1) {
        end = source.length;
    }
    
    const lineDiff = endLine - startLine;
    const markerLines = {};
    
    if (lineDiff) {
        for (let i = 0; i <= lineDiff; i++) {
            const lineNumber = i + startLine;
            
            if (!startColumn) {
                markerLines[lineNumber] = true;
            } else if (i === 0) {
                const sourceLength = source[lineNumber - 1].length;
                markerLines[lineNumber] = [
                    startColumn,
                    sourceLength - startColumn + 1,
                ];
            } else if (i === lineDiff) {
                markerLines[lineNumber] = [0, endColumn];
            } else {
                const sourceLength = source[lineNumber - i].length;
                markerLines[lineNumber] = [0, sourceLength];
            }

        }
    } else {
        if (startColumn === endColumn) {
            if (startColumn) {
                markerLines[startLine] = [startColumn, 0];
            } else {
                markerLines[startLine] = true;
            }
        } else {
            markerLines[startLine] = [
                startColumn,
                endColumn - startColumn,
            ];
        }
    }
    
    return {
        start,
        end,
        markerLines,
    };
}

function codeFrameColumns(rawLines, loc, opts = {}) {
    const shouldHighlight = opts.forceColor || isColorSupported() && opts.highlightCode;
    const defs = getDefs(shouldHighlight);
    const lines = rawLines.split(NEWLINE$2);
    
    const {
        start,
        end,
        markerLines,
    } = getMarkerLines(loc, lines, opts);
    
    const hasColumns = loc.start && typeof loc.start.column === 'number';
    const numberMaxWidth = String(end).length;
    const highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;
    
    let frame = highlightedLines
        .split(NEWLINE$2, end)
        .slice(start, end)
        .map((line, index2) => {
        const number = start + 1 + index2;
        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
        const gutter = ` ${paddedNumber} |`;
        const hasMarker = markerLines[number];
        const lastMarkerLine = !markerLines[number + 1];
        
        if (hasMarker) {
            let markerLine = '';
            
            if (Array.isArray(hasMarker)) {
                const markerSpacing = line
                    .slice(0, Math.max(hasMarker[0] - 1, 0))
                    .replace(/[^\t]/g, ' ');
                const numberOfMarkers = hasMarker[1] || 1;
                
                markerLine = [
                    '\n ',
                    defs.gutter(gutter.replace(/\d/g, ' ')),
                    ' ',
                    markerSpacing,
                    defs
                        .marker('^')
                        .repeat(numberOfMarkers),
                ].join('');
                
                if (lastMarkerLine && opts.message) {
                    markerLine += ' ' + defs.message(opts.message);
                }
            }
            
            return [
                defs.marker('>'),
                defs.gutter(gutter),
                line.length > 0 ? ` ${line}` : '',
                markerLine,
            ].join('');
        } else {
            return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : ''}`;
        }
    })
        .join('\n');
    
    if (opts.message && !hasColumns) {
        frame = `${' '.repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
    }
    
    if (shouldHighlight) {
        return defs.reset(frame);
    } else {
        return frame;
    }
}

// ../babel-babel/packages/babel-template/lib/index.js
var {assertExpressionStatement: assertExpressionStatement2} = lib_exports;

function makeStatementFormatter(fn) {
    return {
        code: (str) => `/* @babel/template */;
${str}`,
        validate: () => {},
        unwrap: (ast) => {
            return fn(ast.program.body.slice(1));
        },
    };
}

var smart$1 = makeStatementFormatter((body) => {
    if (body.length > 1) {
        return body;
    } else {
        return body[0];
    }
});

var statements$1 = makeStatementFormatter((body) => body);

var statement$1 = makeStatementFormatter((body) => {
    if (body.length === 0) {
        throw new Error('Found nothing to return.');
    }
    
    if (body.length > 1) {
        throw new Error('Found multiple statements but wanted one');
    }
    
    return body[0];
});

var expression$1 = {
    code: (str) => `(
${str}
)`,
    validate: (ast) => {
        if (ast.program.body.length > 1) {
            throw new Error('Found multiple statements but wanted one');
        }
        
        if (expression$1.unwrap(ast).start === 0) {
            throw new Error('Parse result included parens.');
        }
    },
    unwrap: ({program: program3}) => {
        const [stmt] = program3.body;
        assertExpressionStatement2(stmt);
        return stmt.expression;
    },
};

var program$1$1 = {
    code: (str) => str,
    validate: () => {},
    unwrap: (ast) => ast.program,
};

function merge$3(a, b2) {
    const {
        placeholderWhitelist = a.placeholderWhitelist,
        placeholderPattern = a.placeholderPattern,
        preserveComments = a.preserveComments,
        syntacticPlaceholders = a.syntacticPlaceholders,
    } = b2;
    
    return {
        parser: {
            ...a.parser,
            ...b2.parser,
        },
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders,
    };
}

function validate$12(opts) {
    if (opts != null && typeof opts !== 'object') {
        throw new Error('Unknown template options.');
    }
    
    const {
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders,
        ...parser
    } = opts || {};
    
    if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
        throw new Error('\'.placeholderWhitelist\' must be a Set, null, or undefined');
    }
    
    if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
        throw new Error('\'.placeholderPattern\' must be a RegExp, false, null, or undefined');
    }
    
    if (preserveComments != null && typeof preserveComments !== 'boolean') {
        throw new Error('\'.preserveComments\' must be a boolean, null, or undefined');
    }
    
    if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== 'boolean') {
        throw new Error('\'.syntacticPlaceholders\' must be a boolean, null, or undefined');
    }
    
    if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
        throw new Error('\'.placeholderWhitelist\' and \'.placeholderPattern\' aren\'t compatible with \'.syntacticPlaceholders: true\'');
    }
    
    return {
        parser,
        placeholderWhitelist: placeholderWhitelist || void 0,
        placeholderPattern: placeholderPattern == null ? void 0 : placeholderPattern,
        preserveComments: preserveComments == null ? void 0 : preserveComments,
        syntacticPlaceholders: syntacticPlaceholders == null ? void 0 : syntacticPlaceholders,
    };
}

function normalizeReplacements(replacements) {
    if (Array.isArray(replacements)) {
        return replacements.reduce((acc, replacement, i) => {
            acc['$' + i] = replacement;
            return acc;
        }, {});
    } else if (typeof replacements === 'object' || replacements == null) {
        return replacements || void 0;
    }
    
    throw new Error('Template replacements must be an array, object, null, or undefined');
}

var {
    isCallExpression: isCallExpression2,
    isExpressionStatement: isExpressionStatement2,
    isFunction: isFunction2,
    isIdentifier: isIdentifier2,
    isJSXIdentifier: isJSXIdentifier2,
    isNewExpression: isNewExpression2,
    isPlaceholder: isPlaceholder2,
    isStatement: isStatement$1$1,
    isStringLiteral: isStringLiteral$1$1,
    removePropertiesDeep: removePropertiesDeep2,
    traverse: traverse2,
} = lib_exports;

var PATTERN = /^[_$A-Z0-9]+$/;

function parseAndBuildMetadata(formatter, code2, opts) {
    const {
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders,
    } = opts;
    
    const ast = parseWithCodeFrame(code2, opts.parser, syntacticPlaceholders);
    
    removePropertiesDeep2(ast, {
        preserveComments,
    });
    formatter.validate(ast);
    const state = {
        syntactic: {
            placeholders: [],
            placeholderNames:             /* @__PURE__ */new Set(),
        },
        legacy: {
            placeholders: [],
            placeholderNames:             /* @__PURE__ */new Set(),
        },
        placeholderWhitelist,
        placeholderPattern,
        syntacticPlaceholders,
    };
    
    traverse2(ast, placeholderVisitorHandler, state);
    return {
        ast,
        ...state.syntactic.placeholders.length ? state.syntactic : state.legacy,
    };
}

function placeholderVisitorHandler(node, ancestors, state) {
    let name;
    let hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;
    
    if (isPlaceholder2(node)) {
        if (state.syntacticPlaceholders === false) {
            throw new Error('%%foo%%-style placeholders can\'t be used when \'.syntacticPlaceholders\' is false.');
        }
        
        name = node.name.name;
        hasSyntacticPlaceholders = true;
    } else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {
        return;
    } else if (isIdentifier2(node) || isJSXIdentifier2(node)) {
        name = node.name;
    } else if (isStringLiteral$1$1(node)) {
        name = node.value;
    } else {
        return;
    }

    
    if (hasSyntacticPlaceholders && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
        throw new Error('\'.placeholderWhitelist\' and \'.placeholderPattern\' aren\'t compatible with \'.syntacticPlaceholders: true\'');
    }
    
    if (!hasSyntacticPlaceholders && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !state.placeholderWhitelist?.has(name)) {
        return;
    }
    
    ancestors = ancestors.slice();
    const {node: parent, key} = ancestors[ancestors.length - 1];
    
    let type;
    
    if (isStringLiteral$1$1(node) || isPlaceholder2(node, {expectedNode: 'StringLiteral'})) {
        type = 'string';
    } else if (isNewExpression2(parent) && key === 'arguments' || isCallExpression2(parent) && key === 'arguments' || isFunction2(parent) && key === 'params') {
        type = 'param';
    } else if (isExpressionStatement2(parent) && !isPlaceholder2(node)) {
        type = 'statement';
        ancestors = ancestors.slice(0, -1);
    } else if (isStatement$1$1(node) && isPlaceholder2(node)) {
        type = 'statement';
    } else {
        type = 'other';
    }

    
    const {
        placeholders: placeholders2,
        placeholderNames,
    } = !hasSyntacticPlaceholders ? state.legacy : state.syntactic;
    
    placeholders2.push({
        name,
        type,
        resolve: (ast) => resolveAncestors(ast, ancestors),
        isDuplicate: placeholderNames.has(name),
    });
    placeholderNames.add(name);
}

function resolveAncestors(ast, ancestors) {
    let parent = ast;
    
    for (let i = 0; i < ancestors.length - 1; i++) {
        const {key: key2, index: index3} = ancestors[i];
        
        if (index3 === void 0) {
            parent = parent[key2];
        } else {
            parent = parent[key2][index3];
        }
    }
    
    const {key, index: index2} = ancestors[ancestors.length - 1];
    
    return {
        parent,
        key,
        index: index2,
    };
}

function parseWithCodeFrame(code2, parserOpts, syntacticPlaceholders) {
    const plugins = (parserOpts.plugins || []).slice();
    
    if (syntacticPlaceholders !== false) {
        plugins.push('placeholders');
    }
    
    parserOpts = {
        allowAwaitOutsideFunction: true,
        allowReturnOutsideFunction: true,
        allowNewTargetOutsideFunction: true,
        allowSuperOutsideMethod: true,
        allowYieldOutsideFunction: true,
        sourceType: 'module',
        ...parserOpts,
        plugins,
    };
    try {
        return parse$9(code2, parserOpts);
    } catch(err) {
        const loc = err.loc;
        
        if (loc) {
            err.message += '\n' + codeFrameColumns(code2, {
                start: loc,
            });
            err.code = 'BABEL_TEMPLATE_PARSE_ERROR';
        }
        
        throw err;
    }
}

var {
    blockStatement: blockStatement2,
    cloneNode: cloneNode2,
    emptyStatement: emptyStatement2,
    expressionStatement: expressionStatement2,
    identifier: identifier2,
    isStatement: isStatement2,
    isStringLiteral: isStringLiteral2,
    stringLiteral: stringLiteral2,
    validate: validate2,
} = lib_exports;

function populatePlaceholders(metadata, replacements) {
    const ast = cloneNode2(metadata.ast);
    
    if (replacements) {
        metadata.placeholders.forEach((placeholder2) => {
            if (!Object.hasOwn(replacements, placeholder2.name)) {
                const placeholderName = placeholder2.name;
                
                throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`);
            }
        });
        Object
            .keys(replacements)
            .forEach((key) => {
                if (!metadata.placeholderNames.has(key)) {
                    throw new Error(`Unknown substitution "${key}" given`);
                }
            });
    }
    
    metadata.placeholders
        .slice()
        .reverse()
        .forEach((placeholder2) => {
            try {
                applyReplacement(placeholder2, ast, (replacements && replacements[placeholder2.name]) ?? null);
            } catch(e) {
                e.message = `@babel/template placeholder "${placeholder2.name}": ${e.message}`;
                throw e;
            }
        });
    return ast;
}

function applyReplacement(placeholder2, ast, replacement) {
    if (placeholder2.isDuplicate) {
        if (Array.isArray(replacement)) {
            replacement = replacement.map((node) => cloneNode2(node));
        } else if (typeof replacement === 'object') {
            replacement = cloneNode2(replacement);
        }
    }
    
    const {
        parent,
        key,
        index: index2,
    } = placeholder2.resolve(ast);
    
    if (placeholder2.type === 'string') {
        if (typeof replacement === 'string') {
            replacement = stringLiteral2(replacement);
        }
        
        if (!replacement || !isStringLiteral2(replacement)) {
            throw new Error('Expected string substitution');
        }
    } else if (placeholder2.type === 'statement') {
        if (index2 === void 0) {
            if (!replacement) {
                replacement = emptyStatement2();
            } else if (Array.isArray(replacement)) {
                replacement = blockStatement2(replacement);
            } else if (typeof replacement === 'string') {
                replacement = expressionStatement2(identifier2(replacement));
            } else if (!isStatement2(replacement)) {
                replacement = expressionStatement2(replacement);
            }


        } else {
            if (replacement && !Array.isArray(replacement)) {
                if (typeof replacement === 'string') {
                    replacement = identifier2(replacement);
                }
                
                if (!isStatement2(replacement)) {
                    replacement = expressionStatement2(replacement);
                }
            }
        }
    } else if (placeholder2.type === 'param') {
        if (typeof replacement === 'string') {
            replacement = identifier2(replacement);
        }
        
        if (index2 === void 0)
            throw new Error('Assertion failure.');
    } else {
        if (typeof replacement === 'string') {
            replacement = identifier2(replacement);
        }
        
        if (Array.isArray(replacement)) {
            throw new Error('Cannot replace single expression with an array.');
        }
    }
    
    function set(parent2, key2, value) {
        const node = parent2[key2];
        
        parent2[key2] = value;
        
        if (node.type === 'Identifier' || node.type === 'Placeholder') {
            if (node.typeAnnotation) {
                value.typeAnnotation = node.typeAnnotation;
            }
            
            if (node.optional) {
                value.optional = node.optional;
            }
            
            if (node.decorators) {
                value.decorators = node.decorators;
            }
        }
    }
    
    if (index2 === void 0) {
        validate2(parent, key, replacement);
        set(parent, key, replacement);
    } else {
        const items = parent[key].slice();
        
        if (placeholder2.type === 'statement' || placeholder2.type === 'param') {
            if (replacement == null) {
                items.splice(index2, 1);
            } else if (Array.isArray(replacement)) {
                items.splice(index2, 1, ...replacement);
            } else {
                set(items, index2, replacement);
            }
        } else {
            set(items, index2, replacement);
        }
        
        validate2(parent, key, items);
        parent[key] = items;
    }
}

function stringTemplate(formatter, code2, opts) {
    code2 = formatter.code(code2);
    let metadata;
    
    return (arg) => {
        const replacements = normalizeReplacements(arg);
        
        if (!metadata)
            metadata = parseAndBuildMetadata(formatter, code2, opts);
        
        return formatter.unwrap(populatePlaceholders(
            metadata,
            replacements,
        ));
    };
}

function literalTemplate(formatter, tpl, opts) {
    const {metadata, names: names2} = buildLiteralData(formatter, tpl, opts);
    
    return (arg) => {
        const defaultReplacements = {};
        
        arg.forEach((replacement, i) => {
            defaultReplacements[names2[i]] = replacement;
        });
        return (arg2) => {
            const replacements = normalizeReplacements(arg2);
            
            if (replacements) {
                Object
                    .keys(replacements)
                    .forEach((key) => {
                        if (Object.hasOwn(defaultReplacements, key)) {
                            throw new Error('Unexpected replacement overlap.');
                        }
                    });
            }
            
            return formatter.unwrap(populatePlaceholders(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
        };
    };
}

function buildLiteralData(formatter, tpl, opts) {
    let prefix2 = 'BABEL_TPL$';
    const raw = tpl.join('');
    
    do {
        prefix2 = '$$' + prefix2;
    } while (raw.includes(prefix2))
    const {names: names2, code: code2} = buildTemplateCode(tpl, prefix2);
    
    const metadata = parseAndBuildMetadata(formatter, formatter.code(code2), {
        parser: opts.parser,
        placeholderWhitelist: new Set(names2.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
        placeholderPattern: opts.placeholderPattern,
        preserveComments: opts.preserveComments,
        syntacticPlaceholders: opts.syntacticPlaceholders,
    });
    
    return {
        metadata,
        names: names2,
    };
}

function buildTemplateCode(tpl, prefix2) {
    const names2 = [];
    let code2 = tpl[0];
    
    for (let i = 1; i < tpl.length; i++) {
        const value = `${prefix2}${i - 1}`;
        names2.push(value);
        code2 += value + tpl[i];
    }
    
    return {
        names: names2,
        code: code2,
    };
}

var NO_PLACEHOLDER = validate$12({
    placeholderPattern: false,
});

function createTemplateBuilder(formatter, defaultOpts) {
    const templateFnCache =     /* @__PURE__ */new WeakMap();
    const templateAstCache =     /* @__PURE__ */new WeakMap();
    const cachedOpts = defaultOpts || validate$12(null);
    
    return Object.assign((tpl, ...args) => {
        if (typeof tpl === 'string') {
            if (args.length > 1)
                throw new Error('Unexpected extra params.');
            
            return extendedTrace(stringTemplate(formatter, tpl, merge$3(cachedOpts, validate$12(args[0]))));
        } else if (Array.isArray(tpl)) {
            let builder = templateFnCache.get(tpl);
            
            if (!builder) {
                builder = literalTemplate(formatter, tpl, cachedOpts);
                templateFnCache.set(tpl, builder);
            }
            
            return extendedTrace(builder(args));
        } else if (typeof tpl === 'object' && tpl) {
            if (args.length > 0)
                throw new Error('Unexpected extra params.');
            
            return createTemplateBuilder(formatter, merge$3(cachedOpts, validate$12(tpl)));
        }
        
        throw new Error(`Unexpected template param ${typeof tpl}`);
    }, {
        ast: (tpl, ...args) => {
            if (typeof tpl === 'string') {
                if (args.length > 1)
                    throw new Error('Unexpected extra params.');
                
                return stringTemplate(formatter, tpl, merge$3(
                    merge$3(cachedOpts, validate$12(args[0])),
                    NO_PLACEHOLDER,
                ))();
            } else if (Array.isArray(tpl)) {
                let builder = templateAstCache.get(tpl);
                
                if (!builder) {
                    builder = literalTemplate(formatter, tpl, merge$3(
                        cachedOpts,
                        NO_PLACEHOLDER,
                    ));
                    templateAstCache.set(tpl, builder);
                }
                
                return builder(args)();
            }
            
            throw new Error(`Unexpected template param ${typeof tpl}`);
        },
    });
}

function extendedTrace(fn) {
    let rootStack = '';
    
    try {
        throw new Error();
    } catch(error) {
        if (error.stack) {
            rootStack = error.stack
                .split('\n')
                .slice(3)
                .join('\n');
        }
    }


        
    return (arg) => {
        try {
            return fn(arg);
        } catch(err) {
            err.stack += `
    =============
${rootStack}`;
            throw err;
        }
    };
}

var smart = createTemplateBuilder(smart$1);
var statement = createTemplateBuilder(statement$1);
var statements$2 = createTemplateBuilder(statements$1);
var expression = createTemplateBuilder(expression$1);
var program2 = createTemplateBuilder(program$1$1);

var index = Object.assign(smart.bind(void 0), {
    smart,
    statement,
    statements: statements$2,
    expression,
    program: program2,
    ast: smart.ast,
});

// ../babel-babel/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
var comma = ','.charCodeAt(0);
var semicolon = ';'.charCodeAt(0);
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);

for (let i = 0; i < chars.length; i++) {
    const c = chars.charCodeAt(i);
    
    intToChar[i] = c;
    charToInt[c] = i;
}

function decodeInteger(reader, relative) {
    let value = 0;
    let shift = 0;
    let integer = 0;
    
    do {
        const c = reader.next();
        
        integer = charToInt[c];
        value |= (integer & 31) << shift;
        shift += 5;
    } while (integer & 32)
    const shouldNegate = value & 1;
    
    value >>>= 1;
    
    if (shouldNegate) {
        value = -2147483648 | -value;
    }
    
    return relative + value;
}

function encodeInteger(builder, num, relative) {
    let delta = num - relative;
    
    delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
    do {
        let clamped = delta & 31;
        
        delta >>>= 5;
        
        if (delta > 0)
            clamped |= 32;
        
        builder.write(intToChar[clamped]);
    } while (delta > 0)
    
    return num;
}

function hasMoreVlq(reader, max) {
    if (reader.pos >= max)
        return false;
    
    return reader.peek() !== comma;
}

var bufLength = 1024 * 16;

var td = typeof TextDecoder !== 'undefined' ? /* @__PURE__ */new TextDecoder() : typeof Buffer !== 'undefined' ? {
    decode(buf) {
        const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
        return out.toString();
    },
} : {
    decode(buf) {
        let out = '';
        
        for (let i = 0; i < buf.length; i++) {
            out += String.fromCharCode(buf[i]);
        }
        
        return out;
    },
};

var StringWriter = class {
    constructor() {
        this.pos = 0;
        this.out = '';
        this.buffer = new Uint8Array(bufLength);
    }
    
    write(v) {
        const {buffer} = this;
        
        buffer[this.pos++] = v;
        
        if (this.pos === bufLength) {
            this.out += td.decode(buffer);
            this.pos = 0;
        }
    }
    
    flush() {
        const {
            buffer,
            out,
            pos,
        } = this;
        return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
    }
};

var StringReader = class {
    constructor(buffer) {
        this.pos = 0;
        this.buffer = buffer;
    }
    
    next() {
        return this.buffer.charCodeAt(this.pos++);
    }
    
    peek() {
        return this.buffer.charCodeAt(this.pos);
    }
    
    indexOf(char) {
        const {buffer, pos} = this;
        const idx = buffer.indexOf(char, pos);
        
        return idx === -1 ? buffer.length : idx;
    }
};

function decode(mappings) {
    const {length} = mappings;
    const reader = new StringReader(mappings);
    const decoded = [];
    let genColumn = 0;
    let sourcesIndex = 0;
    let sourceLine = 0;
    let sourceColumn = 0;
    let namesIndex = 0;
    
    do {
        const semi = reader.indexOf(';');
        const line = [];
        let sorted = true;
        let lastCol = 0;
        
        genColumn = 0;
        while (reader.pos < semi) {
            let seg;
            
            genColumn = decodeInteger(reader, genColumn);
            
            if (genColumn < lastCol)
                sorted = false;
            
            lastCol = genColumn;
            
            if (hasMoreVlq(reader, semi)) {
                sourcesIndex = decodeInteger(reader, sourcesIndex);
                sourceLine = decodeInteger(reader, sourceLine);
                sourceColumn = decodeInteger(reader, sourceColumn);
                
                if (hasMoreVlq(reader, semi)) {
                    namesIndex = decodeInteger(reader, namesIndex);
                    seg = [
                        genColumn,
                        sourcesIndex,
                        sourceLine,
                        sourceColumn,
                        namesIndex,
                    ];
                } else {
                    seg = [
                        genColumn,
                        sourcesIndex,
                        sourceLine,
                        sourceColumn,
                    ];
                }
            } else {
                seg = [genColumn];
            }
            
            line.push(seg);
            reader.pos++;
        }
        
        if (!sorted)
            sort(line);
        
        decoded.push(line);
        reader.pos = semi + 1;
    } while (reader.pos <= length)
    
    return decoded;
}

function sort(line) {
    line.sort(sortComparator);
}

function sortComparator(a, b2) {
    return a[0] - b2[0];
}

function encode(decoded) {
    const writer = new StringWriter();
    let sourcesIndex = 0;
    let sourceLine = 0;
    let sourceColumn = 0;
    let namesIndex = 0;
    
    for (let i = 0; i < decoded.length; i++) {
        const line = decoded[i];
        
        if (i > 0)
            writer.write(semicolon);
        
        if (line.length === 0)
            continue;
        
        let genColumn = 0;
        
        for (let j = 0; j < line.length; j++) {
            const segment = line[j];
            
            if (j > 0)
                writer.write(comma);
            
            genColumn = encodeInteger(writer, segment[0], genColumn);
            
            if (segment.length === 1)
                continue;
            
            sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
            sourceLine = encodeInteger(writer, segment[2], sourceLine);
            sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
            
            if (segment.length === 4)
                continue;
            
            namesIndex = encodeInteger(writer, segment[4], namesIndex);
        }
    }
    
    return writer.flush();
}

// ../babel-babel/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs
var schemeRegex = /^[\w+.-]+:\/\//;
var urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
var fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;

function isAbsoluteUrl(input) {
    return schemeRegex.test(input);
}

function isSchemeRelativeUrl(input) {
    return input.startsWith('//');
}

function isAbsolutePath(input) {
    return input.startsWith('/');
}

function isFileUrl(input) {
    return input.startsWith('file:');
}

function isRelative(input) {
    return /^[.?#]/.test(input);
}

function parseAbsoluteUrl(input) {
    const match = urlRegex.exec(input);
    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');
}

function parseFileUrl(input) {
    const match = fileRegex.exec(input);
    const path = match[2];
    
    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');
}

function makeUrl(scheme, user, host, port, path, query, hash) {
    return {
        scheme,
        user,
        host,
        port,
        path,
        query,
        hash,
        type: 7,
    };
}

function parseUrl(input) {
    if (isSchemeRelativeUrl(input)) {
        const url2 = parseAbsoluteUrl('http:' + input);
        
        url2.scheme = '';
        url2.type = 6;
        return url2;
    }
    
    if (isAbsolutePath(input)) {
        const url2 = parseAbsoluteUrl('http://foo.com' + input);
        
        url2.scheme = '';
        url2.host = '';
        url2.type = 5;
        return url2;
    }
    
    if (isFileUrl(input))
        return parseFileUrl(input);
    
    if (isAbsoluteUrl(input))
        return parseAbsoluteUrl(input);
    
    const url = parseAbsoluteUrl('http://foo.com/' + input);
    
    url.scheme = '';
    url.host = '';
    url.type = input ? input.startsWith('?') ? 3 : input.startsWith('#') ? 2 : 4 : 1;
    return url;
}

function stripPathFilename(path) {
    if (path.endsWith('/..'))
        return path;
    
    const index2 = path.lastIndexOf('/');
    
    return path.slice(0, index2 + 1);
}

function mergePaths(url, base) {
    normalizePath(base, base.type);
    
    if (url.path === '/') {
        url.path = base.path;
    } else {
        url.path = stripPathFilename(base.path) + url.path;
    }
}

function normalizePath(url, type) {
    const rel = type <= 4;
    const pieces = url.path.split('/');
    let pointer = 1;
    let positive = 0;
    let addTrailingSlash = false;
    
    for (let i = 1; i < pieces.length; i++) {
        const piece = pieces[i];
        
        if (!piece) {
            addTrailingSlash = true;
            continue;
        }
        
        addTrailingSlash = false;
        
        if (piece === '.')
            continue;
        
        if (piece === '..') {
            if (positive) {
                addTrailingSlash = true;
                positive--;
                pointer--;
            } else if (rel) {
                pieces[pointer++] = piece;
            }
            
            continue;
        }
        
        pieces[pointer++] = piece;
        positive++;
    }
    
    let path = '';
    
    for (let i = 1; i < pointer; i++) {
        path += '/' + pieces[i];
    }
    
    if (!path || addTrailingSlash && !path.endsWith('/..')) {
        path += '/';
    }
    
    url.path = path;
}

function resolve$1(input, base) {
    if (!input && !base)
        return '';
    
    const url = parseUrl(input);
    let inputType = url.type;
    
    if (base && inputType !== 7) {
        const baseUrl = parseUrl(base);
        const baseType = baseUrl.type;
        
        switch(inputType) {
        case 1:
            url.hash = baseUrl.hash;
        
        // fall through
case 2:
            url.query = baseUrl.query;
        
        // fall through
case 3:        
        case 4:
            mergePaths(url, baseUrl);
        
        // fall through
case 5:
            url.user = baseUrl.user;
            url.host = baseUrl.host;
            url.port = baseUrl.port;
        
        // fall through
case 6:
            url.scheme = baseUrl.scheme;
        }
        
        if (baseType > inputType)
            inputType = baseType;
    }
    
    normalizePath(url, inputType);
    const queryHash = url.query + url.hash;
    
    switch(inputType) {
    // This is impossible, because of the empty checks at the start of the function.
// case UrlType.Empty:
case 2:    
    case 3:
        return queryHash;
    
    case 4: {
        const path = url.path.slice(1);
        
        if (!path)
            return queryHash || '.';
        
        if (isRelative(base || input) && !isRelative(path)) {
            return './' + path + queryHash;
        }
        
        return path + queryHash;
    }
    
    case 5:
        return url.path + queryHash;
    
    default:
        return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;
    }
}

// ../babel-babel/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs
function stripFilename(path) {
    if (!path)
        return '';
    
    const index2 = path.lastIndexOf('/');
    
    return path.slice(0, index2 + 1);
}

function resolver(mapUrl, sourceRoot) {
    const from = stripFilename(mapUrl);
    const prefix2 = sourceRoot ? sourceRoot + '/' : '';
    
    return (source) => resolve$1(prefix2 + (source || ''), from);
}

var COLUMN = 0;
var SOURCES_INDEX = 1;
var SOURCE_LINE = 2;
var SOURCE_COLUMN = 3;
var NAMES_INDEX = 4;

function maybeSort(mappings, owned) {
    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
    
    if (unsortedIndex === mappings.length)
        return mappings;
    
    if (!owned)
        mappings = mappings.slice();
    
    for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
        mappings[i] = sortSegments(mappings[i], owned);
    }
    
    return mappings;
}

function nextUnsortedSegmentLine(mappings, start) {
    for (let i = start; i < mappings.length; i++) {
        if (!isSorted(mappings[i]))
            return i;
    }
    
    return mappings.length;
}

function isSorted(line) {
    for (let j = 1; j < line.length; j++) {
        if (line[j][COLUMN] < line[j - 1][COLUMN]) {
            return false;
        }
    }
    
    return true;
}

function sortSegments(line, owned) {
    if (!owned)
        line = line.slice();
    
    return line.sort(sortComparator2);
}

function sortComparator2(a, b2) {
    return a[COLUMN] - b2[COLUMN];
}

var found = false;

function binarySearch(haystack, needle, low, high) {
    while (low <= high) {
        const mid = low + (high - low >> 1);
        const cmp = haystack[mid][COLUMN] - needle;
        
        if (cmp === 0) {
            found = true;
            return mid;
        }
        
        if (cmp < 0) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    
    found = false;
    return low - 1;
}

function upperBound(haystack, needle, index2) {
    for (let i = index2 + 1; i < haystack.length; index2 = i++) {
        if (haystack[i][COLUMN] !== needle)
            break;
    }
    
    return index2;
}

function lowerBound(haystack, needle, index2) {
    for (let i = index2 - 1; i >= 0; index2 = i--) {
        if (haystack[i][COLUMN] !== needle)
            break;
    }
    
    return index2;
}

function memoizedState() {
    return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1,
    };
}

function memoizedBinarySearch(haystack, needle, state, key) {
    const {
        lastKey,
        lastNeedle,
        lastIndex,
    } = state;
    let low = 0;
    let high = haystack.length - 1;
    
    if (key === lastKey) {
        if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
        }
        
        if (needle >= lastNeedle) {
            low = lastIndex === -1 ? 0 : lastIndex;
        } else {
            high = lastIndex;
        }
    }
    
    state.lastKey = key;
    state.lastNeedle = needle;
    return state.lastIndex = binarySearch(haystack, needle, low, high);
}

function parse2(map) {
    return typeof map === 'string' ? JSON.parse(map) : map;
}

var LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';
var COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';
var LEAST_UPPER_BOUND = -1;
var GREATEST_LOWER_BOUND = 1;

var TraceMap = class {
    constructor(map, mapUrl) {
        const isString = typeof map === 'string';
        
        if (!isString && map._decodedMemo)
            return map;
        
        const parsed = parse2(map);
        const {
            version,
            file: file2,
            names: names2,
            sourceRoot,
            sources,
            sourcesContent,
        } = parsed;
        
        this.version = version;
        this.file = file2;
        this.names = names2 || [];
        this.sourceRoot = sourceRoot;
        this.sources = sources;
        this.sourcesContent = sourcesContent;
        this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
        const resolve3 = resolver(mapUrl, sourceRoot);
        
        this.resolvedSources = sources.map(resolve3);
        const {mappings} = parsed;
        
        if (typeof mappings === 'string') {
            this._encoded = mappings;
            this._decoded = void 0;
        } else if (Array.isArray(mappings)) {
            this._encoded = void 0;
            this._decoded = maybeSort(mappings, isString);
        } else if (parsed.sections) {
            throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);
        } else {
            throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);
        }
        
        this._decodedMemo = memoizedState();
        this._bySources = void 0;
        this._bySourceMemos = void 0;
    }
};

function cast(map) {
    return map;
}

function decodedMappings(map) {
    var _a;
    return (_a = cast(map))._decoded || (_a._decoded = decode(cast(map)._encoded));
}

function originalPositionFor(map, needle) {
    let {
        line,
        column,
        bias,
    } = needle;
    line--;
    
    if (line < 0)
        throw new Error(LINE_GTR_ZERO);
    
    if (column < 0)
        throw new Error(COL_GTR_EQ_ZERO);
    
    const decoded = decodedMappings(map);
    
    if (line >= decoded.length)
        return OMapping(null, null, null, null);
    
    const segments = decoded[line];
    
    const index2 = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
    
    if (index2 === -1)
        return OMapping(null, null, null, null);
    
    const segment = segments[index2];
    
    if (segment.length === 1)
        return OMapping(null, null, null, null);
    
    const {
        names: names2,
        resolvedSources,
    } = map;
    
    return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names2[segment[NAMES_INDEX]] : null);
}

function OMapping(source, line, column, name) {
    return {
        source,
        line,
        column,
        name,
    };
}

function traceSegmentInternal(segments, memo, line, column, bias) {
    let index2 = memoizedBinarySearch(segments, column, memo, line);
    
    if (found) {
        index2 = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index2);
    }    else if (bias === LEAST_UPPER_BOUND)
        index2++;
    
    if (index2 === -1 || index2 === segments.length)
        return -1;
    
    return index2;
}

// ../babel-babel/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs
var SetArray = class {
    constructor() {
        this._indexes = {
            __proto__: null,
        };
        this.array = [];
    }
};

function cast2(set) {
    return set;
}

function get$1(setarr, key) {
    return cast2(setarr)._indexes[key];
}

function put(setarr, key) {
    const index2 = get$1(setarr, key);
    
    if (index2 !== void 0)
        return index2;
    
    const {array, _indexes: indexes} = cast2(setarr);
    const length = array.push(key);
    
    return indexes[key] = length - 1;
}

var COLUMN2 = 0;
var SOURCES_INDEX2 = 1;
var SOURCE_LINE2 = 2;
var SOURCE_COLUMN2 = 3;
var NAMES_INDEX2 = 4;
var NO_NAME = -1;

var GenMapping = class {
    constructor({file: file2, sourceRoot} = {}) {
        this._names = new SetArray();
        this._sources = new SetArray();
        this._sourcesContent = [];
        this._mappings = [];
        this.file = file2;
        this.sourceRoot = sourceRoot;
        this._ignoreList = new SetArray();
    }
};

function cast22(map) {
    return map;
}

var maybeAddMapping = (map, mapping) => {
    return addMappingInternal(true, map, mapping);
};

function setSourceContent(map, source, content) {
    const {
        _sources: sources,
        _sourcesContent: sourcesContent,
    } = cast22(map);
    
    const index2 = put(sources, source);
    
    sourcesContent[index2] = content;
}

function toDecodedMap(map) {
    const {
        _mappings: mappings,
        _sources: sources,
        _sourcesContent: sourcesContent,
        _names: names2,
        _ignoreList: ignoreList,
    } = cast22(map);
    
    removeEmptyFinalLines(mappings);
    return {
        version: 3,
        file: map.file || void 0,
        names: names2.array,
        sourceRoot: map.sourceRoot || void 0,
        sources: sources.array,
        sourcesContent,
        mappings,
        // originalScopes,

        // generatedRanges,
        ignoreList: ignoreList.array,
    };
}

function toEncodedMap(map) {
    const decoded = toDecodedMap(map);
    
    return Object.assign({}, decoded, {
        // originalScopes: decoded.originalScopes.map((os) => encodeOriginalScopes(os)),
        // generatedRanges: encodeGeneratedRanges(decoded.generatedRanges as GeneratedRange[]),
        mappings: encode(decoded.mappings),
    });
}

function allMappings(map) {
    const out = [];
    const {
        _mappings: mappings,
        _sources: sources,
        _names: names2,
    } = cast22(map);
    
    for (let i = 0; i < mappings.length; i++) {
        const line = mappings[i];
        
        for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const generated = {
                line: i + 1,
                column: seg[COLUMN2],
            };
            let source = void 0;
            let original = void 0;
            let name = void 0;
            
            if (seg.length !== 1) {
                source = sources.array[seg[SOURCES_INDEX2]];
                original = {
                    line: seg[SOURCE_LINE2] + 1,
                    column: seg[SOURCE_COLUMN2],
                };
                
                if (seg.length === 5)
                    name = names2.array[seg[NAMES_INDEX2]];
            }
            
            out.push({
                generated,
                source,
                original,
                name,
            });
        }
    }
    
    return out;
}

function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
    const {
        _mappings: mappings,
        _sources: sources,
        _sourcesContent: sourcesContent,
        _names: names2,
    } = cast22(map);
    
    const line = getIndex(mappings, genLine);
    const index2 = getColumnIndex(line, genColumn);
    
    if (!source) {
        if (skipSourceless(line, index2))
            return;
        
        return insert$1(line, index2, [genColumn]);
    }
    const sourcesIndex = put(sources, source);
    const namesIndex = name ? put(names2, name) : NO_NAME;
    
    if (sourcesIndex === sourcesContent.length)
        sourcesContent[sourcesIndex] = content != null ? content : null;
    
    if (skipSource(line, index2, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
        return;
    }
    
    return insert$1(line, index2, name ? [
        genColumn,
        sourcesIndex,
        sourceLine,
        sourceColumn,
        namesIndex,
    ] : [
        genColumn,
        sourcesIndex,
        sourceLine,
        sourceColumn,
    ]);
}

function getIndex(arr, index2) {
    for (let i = arr.length; i <= index2; i++) {
        arr[i] = [];
    }
    
    return arr[index2];
}

function getColumnIndex(line, genColumn) {
    let index2 = line.length;
    
    for (let i = index2 - 1; i >= 0; index2 = i--) {
        const current = line[i];
        
        if (genColumn >= current[COLUMN2])
            break;
    }
    
    return index2;
}

function insert$1(array, index2, value) {
    for (let i = array.length; i > index2; i--) {
        array[i] = array[i - 1];
    }
    
    array[index2] = value;
}

function removeEmptyFinalLines(mappings) {
    const {length} = mappings;
    let len = length;
    
    for (let i = len - 1; i >= 0; (len = i, i--)) {
        if (mappings[i].length > 0)
            break;
    }
    
    if (len < length)
        mappings.length = len;
}

function skipSourceless(line, index2) {
    if (index2 === 0)
        return true;
    
    const prev = line[index2 - 1];
    
    return prev.length === 1;
}

function skipSource(line, index2, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
    if (index2 === 0)
        return false;
    
    const prev = line[index2 - 1];
    
    if (prev.length === 1)
        return false;
    
    return sourcesIndex === prev[SOURCES_INDEX2]
        && sourceLine === prev[SOURCE_LINE2]
        && sourceColumn === prev[SOURCE_COLUMN2]
        && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX2] : NO_NAME);
}

function addMappingInternal(skipable, map, mapping) {
    const {
        generated,
        source,
        original,
        name,
        content,
    } = mapping;
    
    if (!source) {
        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
    }
    return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name, content);
}

// ../babel-babel/packages/babel-generator/lib/index.js
var import_jsesc = __toESM(require_jsesc());

var SourceMap = class {
    _map;
    _rawMappings;
    _sourceFileName;
    _lastGenLine = 0;
    _lastSourceLine = 0;
    _lastSourceColumn = 0;
    _inputMap = null;
    constructor(opts, code2) {
        const map = this._map = new GenMapping({
            sourceRoot: opts.sourceRoot,
        });
        
        this._sourceFileName = opts.sourceFileName?.replace(/\\/g, '/');
        this._rawMappings = void 0;
        
        if (opts.inputSourceMap) {
            this._inputMap = new TraceMap(opts.inputSourceMap);
            const resolvedSources = this._inputMap.resolvedSources;
            
            if (resolvedSources.length) {
                for (let i = 0; i < resolvedSources.length; i++) {
                    setSourceContent(map, resolvedSources[i], this._inputMap.sourcesContent?.[i]);
                }
            }
        }
        
        if (typeof code2 === 'string' && !opts.inputSourceMap) {
            setSourceContent(map, this._sourceFileName, code2);
        } else if (typeof code2 === 'object') {
            for (const sourceFileName of Object.keys(code2)) {
                setSourceContent(map, sourceFileName.replace(/\\/g, '/'), code2[sourceFileName]);
            }
        }
    }
    
    get() {
        return toEncodedMap(this._map);
    }
    
    getDecoded() {
        return toDecodedMap(this._map);
    }
    
    getRawMappings() {
        return this._rawMappings ||= allMappings(this._map);
    }
    
    mark(generated, line, column, identifierName, identifierNamePos, filename) {
        this._rawMappings = void 0;
        let originalMapping;
        
        if (line != null) {
            if (this._inputMap) {
                originalMapping = originalPositionFor(this._inputMap, {
                    line,
                    column,
                });
                
                if (!originalMapping.name && identifierNamePos) {
                    const originalIdentifierMapping = originalPositionFor(this._inputMap, identifierNamePos);
                    
                    if (originalIdentifierMapping.name) {
                        identifierName = originalIdentifierMapping.name;
                    }
                }
            } else {
                originalMapping = {
                    name: null,
                    source: filename?.replace(/\\/g, '/') || this._sourceFileName,
                    line,
                    column,
                };
            }
        }
        
        maybeAddMapping(this._map, {
            name: identifierName,
            generated,
            source: originalMapping?.source,
            original: originalMapping,
        });
    }
};

var Buffer2 = class {
    constructor(map, indentChar) {
        this._map = map;
        this._indentChar = indentChar;
        for (let i = 0; i < 64; i++) {
            this._fastIndentations.push(indentChar.repeat(i));
        }
        
        this._allocQueue();
    }
    
    _map = null;
    _buf = '';
    _str = '';
    _appendCount = 0;
    _last = 0;
    _queue = [];
    _queueCursor = 0;
    _canMarkIdName = true;
    _indentChar = '';
    _fastIndentations = [];
    _position = {
        line: 1,
        column: 0,
    };
    _sourcePosition = {
        identifierName: void 0,
        identifierNamePos: void 0,
        line: void 0,
        column: void 0,
        filename: void 0,
    };
    _allocQueue() {
        const queue = this._queue;
        
        for (let i = 0; i < 16; i++) {
            queue.push({
                char: 0,
                repeat: 1,
                line: void 0,
                column: void 0,
                identifierName: void 0,
                identifierNamePos: void 0,
                filename: '',
            });
        }
    }
    
    _pushQueue(char, repeat, line, column, filename) {
        const cursor = this._queueCursor;
        
        if (cursor === this._queue.length) {
            this._allocQueue();
        }
        
        const item = this._queue[cursor];
        
        item.char = char;
        item.repeat = repeat;
        item.line = line;
        item.column = column;
        item.filename = filename;
        this._queueCursor++;
    }
    
    _popQueue() {
        if (this._queueCursor === 0) {
            throw new Error('Cannot pop from empty queue');
        }
        
        return this._queue[--this._queueCursor];
    }
    
    get() {
        this._flush();
        const map = this._map;
        const result = {
            code: (this._buf + this._str).trimRight(),
            decodedMap: map?.getDecoded(),
            get __mergedMap() {
                return this.map;
            },
            get map() {
                const resultMap = map ? map.get() : null;
                
                result.map = resultMap;
                return resultMap;
            },
            set map(value) {
                Object.defineProperty(result, 'map', {
                    value,
                    writable: true,
                });
            },
            get rawMappings() {
                const mappings = map?.getRawMappings();
                
                result.rawMappings = mappings;
                return mappings;
            },
            set rawMappings(value) {
                Object.defineProperty(result, 'rawMappings', {
                    value,
                    writable: true,
                });
            },
        };
        
        return result;
    }
    
    append(str, maybeNewline) {
        this._flush();
        this._append(str, this._sourcePosition, maybeNewline);
    }
    
    appendChar(char) {
        this._flush();
        this._appendChar(char, 1, this._sourcePosition);
    }
    
    queue(char) {
        if (char === 10) {
            while (this._queueCursor !== 0) {
                const char2 = this._queue[this._queueCursor - 1].char;
                
                if (char2 !== 32 && char2 !== 9) {
                    break;
                }
                
                this._queueCursor--;
            }
        }
        
        const sourcePosition = this._sourcePosition;
        this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);
    }
    
    queueIndentation(repeat) {
        if (repeat === 0)
            return;
        
        this._pushQueue(-1, repeat, void 0, void 0, void 0);
    }
    
    _flush() {
        const queueCursor = this._queueCursor;
        const queue = this._queue;
        
        for (let i = 0; i < queueCursor; i++) {
            const item = queue[i];
            this._appendChar(item.char, item.repeat, item);
        }
        
        this._queueCursor = 0;
    }
    
    _appendChar(char, repeat, sourcePos) {
        this._last = char;
        
        if (char === -1) {
            const fastIndentation = this._fastIndentations[repeat];
            
            if (fastIndentation !== void 0) {
                this._str += fastIndentation;
            } else {
                this._str += repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;
            }
        } else {
            this._str += repeat > 1 ? String
                .fromCharCode(char)
                .repeat(repeat) : String.fromCharCode(char);
        }
        
        if (char !== 10) {
            this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename);
            this._position.column += repeat;
        } else {
            this._position.line++;
            this._position.column = 0;
        }
        
        if (this._canMarkIdName) {
            sourcePos.identifierName = void 0;
            sourcePos.identifierNamePos = void 0;
        }
    }
    
    _append(str, sourcePos, maybeNewline) {
        const len = str.length;
        const position = this._position;
        
        this._last = str.charCodeAt(len - 1);
        
        if (++this._appendCount > 4096) {
            +this._str;
            this._buf += this._str;
            this._str = str;
            this._appendCount = 0;
        } else {
            this._str += str;
        }
        
        if (!maybeNewline && !this._map) {
            position.column += len;
            return;
        }
        
        const {
            column,
            identifierName,
            identifierNamePos,
            filename,
        } = sourcePos;
        
        let line = sourcePos.line;
        
        if ((identifierName != null || identifierNamePos != null) && this._canMarkIdName) {
            sourcePos.identifierName = void 0;
            sourcePos.identifierNamePos = void 0;
        }
        
        let i = str.indexOf('\n');
        let last2 = 0;
        
        if (i !== 0) {
            this._mark(line, column, identifierName, identifierNamePos, filename);
        }
        
        while (i !== -1) {
            position.line++;
            position.column = 0;
            last2 = i + 1;
            
            if (last2 < len && line !== void 0) {
                this._mark(++line, 0, void 0, void 0, filename);
            }
            
            i = str.indexOf('\n', last2);
        }
        
        position.column += len - last2;
    }
    
    _mark(line, column, identifierName, identifierNamePos, filename) {
        this._map?.mark(this._position, line, column, identifierName, identifierNamePos, filename);
    }
    
    removeTrailingNewline() {
        const queueCursor = this._queueCursor;
        
        if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {
            this._queueCursor--;
        }
    }
    
    removeLastSemicolon() {
        const queueCursor = this._queueCursor;
        
        if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {
            this._queueCursor--;
        }
    }
    
    getLastChar() {
        const queueCursor = this._queueCursor;
        return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;
    }
    
    getNewlineCount() {
        const queueCursor = this._queueCursor;
        let count = 0;
        
        if (queueCursor === 0)
            return this._last === 10 ? 1 : 0;
        
        for (let i = queueCursor - 1; i >= 0; i--) {
            if (this._queue[i].char !== 10) {
                break;
            }
            
            count++;
        }
        
        return count === queueCursor && this._last === 10 ? count + 1 : count;
    }
    
    endsWithCharAndNewline() {
        const queue = this._queue;
        const queueCursor = this._queueCursor;
        
        if (queueCursor !== 0) {
            const lastCp = queue[queueCursor - 1].char;
            
            if (lastCp !== 10)
                return;
            
            if (queueCursor > 1) {
                return queue[queueCursor - 2].char;
            } else {
                return this._last;
            }
        }
    }
    
    hasContent() {
        return this._queueCursor !== 0 || !!this._last;
    }
    
    exactSource(loc, cb) {
        if (!this._map) {
            cb();
            return;
        }
        
        this.source('start', loc);
        const identifierName = loc.identifierName;
        const sourcePos = this._sourcePosition;
        
        if (identifierName) {
            this._canMarkIdName = false;
            sourcePos.identifierName = identifierName;
        }
        
        cb();
        
        if (identifierName) {
            this._canMarkIdName = true;
            sourcePos.identifierName = void 0;
            sourcePos.identifierNamePos = void 0;
        }
        
        this.source('end', loc);
    }
    
    source(prop, loc) {
        if (!this._map)
            return;
        
        this._normalizePosition(prop, loc, 0);
    }
    
    sourceWithOffset(prop, loc, columnOffset) {
        if (!this._map)
            return;
        
        this._normalizePosition(prop, loc, columnOffset);
    }
    
    _normalizePosition(prop, loc, columnOffset) {
        const pos = loc[prop];
        const target = this._sourcePosition;
        
        if (pos) {
            target.line = pos.line;
            target.column = Math.max(pos.column + columnOffset, 0);
            target.filename = loc.filename;
        }
    }
    
    getCurrentColumn() {
        const queue = this._queue;
        const queueCursor = this._queueCursor;
        let lastIndex = -1;
        let len = 0;
        
        for (let i = 0; i < queueCursor; i++) {
            const item = queue[i];
            
            if (item.char === 10) {
                lastIndex = len;
            }
            
            len += item.repeat;
        }
        
        return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;
    }
    
    getCurrentLine() {
        let count = 0;
        const queue = this._queue;
        
        for (let i = 0; i < this._queueCursor; i++) {
            if (queue[i].char === 10) {
                count++;
            }
        }
        
        return this._position.line + count;
    }
};

var {
    FLIPPED_ALIAS_KEYS: FLIPPED_ALIAS_KEYS$1,
    isArrayExpression: isArrayExpression2,
    isAssignmentExpression: isAssignmentExpression2,
    isBinary: isBinary2,
    isBlockStatement: isBlockStatement2,
    isCallExpression: isCallExpression$3$1,
    isFunction: isFunction$1$1,
    isIdentifier: isIdentifier$2$1,
    isLiteral: isLiteral$1$1,
    isMemberExpression: isMemberExpression$3$1,
    isObjectExpression: isObjectExpression2,
    isOptionalCallExpression: isOptionalCallExpression2,
    isOptionalMemberExpression: isOptionalMemberExpression$1$1,
    isStringLiteral: isStringLiteral3,
} = lib_exports;

function crawlInternal(node, state) {
    if (!node)
        return state;
    
    if (isMemberExpression$3$1(node) || isOptionalMemberExpression$1$1(node)) {
        crawlInternal(node.object, state);
        
        if (node.computed)
            crawlInternal(node.property, state);
    } else if (isBinary2(node) || isAssignmentExpression2(node)) {
        crawlInternal(node.left, state);
        crawlInternal(node.right, state);
    } else if (isCallExpression$3$1(node) || isOptionalCallExpression2(node)) {
        state.hasCall = true;
        crawlInternal(node.callee, state);
    } else if (isFunction$1$1(node)) {
        state.hasFunction = true;
    } else if (isIdentifier$2$1(node)) {
        state.hasHelper = state.hasHelper || node.callee && isHelper(node.callee);
    }


    
    return state;
}

function crawl(node) {
    return crawlInternal(node, {
        hasCall: false,
        hasFunction: false,
        hasHelper: false,
    });
}

function isHelper(node) {
    if (!node)
        return false;
    
    if (isMemberExpression$3$1(node)) {
        return isHelper(node.object) || isHelper(node.property);
    } else if (isIdentifier$2$1(node)) {
        return node.name === 'require' || node.name.charCodeAt(0) === 95;
    } else if (isCallExpression$3$1(node)) {
        return isHelper(node.callee);
    } else if (isBinary2(node) || isAssignmentExpression2(node)) {
        return isIdentifier$2$1(node.left) && isHelper(node.left) || isHelper(node.right);
    } else {
        return false;
    }


}

function isType2(node) {
    return isLiteral$1$1(node)
        || isObjectExpression2(node)
        || isArrayExpression2(node)
        || isIdentifier$2$1(node)
        || isMemberExpression$3$1(node);
}

var nodes = {
    AssignmentExpression(node) {
        const state = crawl(node.right);
        
        if (state.hasCall && state.hasHelper || state.hasFunction) {
            return state.hasFunction ? 1 | 2 : 2;
        }
        
        return 0;
    },
    SwitchCase(node, parent) {
        return (!!node.consequent.length || parent.cases[0] === node ? 1 : 0) | (!node.consequent.length && parent.cases[parent.cases.length - 1] === node ? 2 : 0);
    },
    LogicalExpression(node) {
        if (isFunction$1$1(node.left) || isFunction$1$1(node.right)) {
            return 2;
        }
        
        return 0;
    },
    Literal(node) {
        if (isStringLiteral3(node) && node.value === 'use strict') {
            return 2;
        }
        
        return 0;
    },
    CallExpression(node) {
        if (isFunction$1$1(node.callee) || isHelper(node)) {
            return 1 | 2;
        }
        
        return 0;
    },
    OptionalCallExpression(node) {
        if (isFunction$1$1(node.callee)) {
            return 1 | 2;
        }
        
        return 0;
    },
    VariableDeclaration(node) {
        for (let i = 0; i < node.declarations.length; i++) {
            const declar = node.declarations[i];
            let enabled2 = isHelper(declar.id) && !isType2(declar.init);
            
            if (!enabled2 && declar.init) {
                const state = crawl(declar.init);
                enabled2 = isHelper(declar.init) && state.hasCall || state.hasFunction;
            }
            
            if (enabled2) {
                return 1 | 2;
            }
        }
        
        return 0;
    },
    IfStatement(node) {
        if (isBlockStatement2(node.consequent)) {
            return 1 | 2;
        }
        
        return 0;
    },
};

nodes.ObjectProperty =
nodes.ObjectTypeProperty =
nodes.ObjectMethod = function(node, parent) {
    if (parent.properties[0] === node) {
        return 1;
    }
    
    return 0;
};
nodes.ObjectTypeCallProperty = function(node, parent) {
    if (parent.callProperties[0] === node && !parent.properties?.length) {
        return 1;
    }
    
    return 0;
};
nodes.ObjectTypeIndexer = function(node, parent) {
    if (parent.indexers[0] === node && !parent.properties?.length && !parent.callProperties?.length) {
        return 1;
    }
    
    return 0;
};
nodes.ObjectTypeInternalSlot = function(node, parent) {
    if (parent.internalSlots[0] === node && !parent.properties?.length && !parent.callProperties?.length && !parent.indexers?.length) {
        return 1;
    }
    
    return 0;
};
[
    ['Function', true],
    ['Class', true],
    ['Loop', true],
    ['LabeledStatement', true],
    ['SwitchStatement', true],
    ['TryStatement', true],
].forEach(function([type, amounts]) {
    [type]
        .concat(FLIPPED_ALIAS_KEYS$1[type] || [])
        .forEach(function(type2) {
            const ret = amounts ? 1 | 2 : 0;
            nodes[type2] = () => ret;
        });
});
var {
    isArrayTypeAnnotation: isArrayTypeAnnotation2,
    isBinaryExpression: isBinaryExpression2,
    isCallExpression: isCallExpression$2$1,
    isForOfStatement: isForOfStatement2,
    isIndexedAccessType: isIndexedAccessType2,
    isMemberExpression: isMemberExpression$2$1,
    isObjectPattern: isObjectPattern2,
    isOptionalMemberExpression: isOptionalMemberExpression2,
    isYieldExpression: isYieldExpression2,
    isStatement: isStatement$4$1,
} = lib_exports;

var PRECEDENCE = /* @__PURE__ */new Map([
    ['||', 0],
    ['??', 0],
    ['|>', 0],
    ['&&', 1],
    ['|', 2],
    ['^', 3],
    ['&', 4],
    ['==', 5],
    ['===', 5],
    ['!=', 5],
    ['!==', 5],
    ['<', 6],
    ['>', 6],
    ['<=', 6],
    ['>=', 6],
    ['in', 6],
    ['instanceof', 6],
    ['>>', 7],
    ['<<', 7],
    ['>>>', 7],
    ['+', 8],
    ['-', 8],
    ['*', 9],
    ['/', 9],
    ['%', 9],
    ['**', 10],
]);

function getBinaryPrecedence(node, nodeType) {
    if (nodeType === 'BinaryExpression' || nodeType === 'LogicalExpression') {
        return PRECEDENCE.get(node.operator);
    }
    
    if (nodeType === 'TSAsExpression' || nodeType === 'TSSatisfiesExpression') {
        return PRECEDENCE.get('in');
    }
}

function isTSTypeExpression(nodeType) {
    return nodeType === 'TSAsExpression' || nodeType === 'TSSatisfiesExpression' || nodeType === 'TSTypeAssertion';
}

var isClassExtendsClause = (node, parent) => {
    const parentType = parent.type;
    return (parentType === 'ClassDeclaration' || parentType === 'ClassExpression') && parent.superClass === node;
};

var hasPostfixPart = (node, parent) => {
    const parentType = parent.type;
    return (parentType === 'MemberExpression'
        || parentType === 'OptionalMemberExpression')
        && parent.object === node
        || (parentType === 'CallExpression'
        || parentType === 'OptionalCallExpression'
        || parentType === 'NewExpression')
        && parent.callee === node
        || parentType === 'TaggedTemplateExpression'
        && parent.tag === node
        || parentType === 'TSNonNullExpression';
};

function NullableTypeAnnotation$1(node, parent) {
    return isArrayTypeAnnotation2(parent);
}

function FunctionTypeAnnotation$1(node, parent, tokenContext) {
    const parentType = parent.type;
    return parentType === 'UnionTypeAnnotation'
        || parentType === 'IntersectionTypeAnnotation'
        || parentType === 'ArrayTypeAnnotation'
        || Boolean(tokenContext & TokenContext.arrowFlowReturnType);
}

function UpdateExpression$1$1(node, parent) {
    return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
}

function needsParenBeforeExpressionBrace(tokenContext) {
    return Boolean(tokenContext & (TokenContext.expressionStatement | TokenContext.arrowBody));
}

function ObjectExpression$1$1(node, parent, tokenContext) {
    return needsParenBeforeExpressionBrace(tokenContext);
}

function DoExpression$1(node, parent, tokenContext) {
    return !node.async && Boolean(tokenContext & TokenContext.expressionStatement);
}

function Binary(node, parent) {
    const parentType = parent.type;
    
    if (node.type === 'BinaryExpression' && node.operator === '**' && parentType === 'BinaryExpression' && parent.operator === '**') {
        return parent.left === node;
    }
    
    if (isClassExtendsClause(node, parent)) {
        return true;
    }
    
    if (hasPostfixPart(node, parent) || parentType === 'UnaryExpression' || parentType === 'SpreadElement' || parentType === 'AwaitExpression') {
        return true;
    }
    
    const parentPos = getBinaryPrecedence(parent, parentType);
    
    if (parentPos != null) {
        const nodePos = getBinaryPrecedence(node, node.type);
        
        if (parentPos === nodePos && parentType === 'BinaryExpression' && parent.right === node || parentPos > nodePos) {
            return true;
        }
    }
}

function UnionTypeAnnotation$1(node, parent) {
    const parentType = parent.type;
    return parentType === 'ArrayTypeAnnotation'
        || parentType === 'NullableTypeAnnotation'
        || parentType === 'IntersectionTypeAnnotation'
        || parentType === 'UnionTypeAnnotation';
}

function OptionalIndexedAccessType$1(node, parent) {
    return isIndexedAccessType2(parent) && parent.objectType === node;
}

function TSAsExpression2(node, parent) {
    if ((parent.type === 'AssignmentExpression' || parent.type === 'AssignmentPattern') && parent.left === node) {
        return true;
    }
    
    if (parent.type === 'BinaryExpression' && (parent.operator === '|' || parent.operator === '&') && node === parent.left) {
        return true;
    }
    
    return Binary(node, parent);
}

function TSConditionalType$1$1(node, parent) {
    const parentType = parent.type;
    
    if (parentType === 'TSArrayType' || parentType === 'TSIndexedAccessType' && parent.objectType === node || parentType === 'TSOptionalType' || parentType === 'TSTypeOperator' || parentType === 'TSTypeParameter') {
        return true;
    }
    
    if ((parentType === 'TSIntersectionType' || parentType === 'TSUnionType') && parent.types[0] === node) {
        return true;
    }
    
    if (parentType === 'TSConditionalType' && (parent.checkType === node || parent.extendsType === node)) {
        return true;
    }
    
    return false;
}

function TSUnionType$1$1(node, parent) {
    const parentType = parent.type;
    return parentType === 'TSIntersectionType'
        || parentType === 'TSTypeOperator'
        || parentType === 'TSArrayType'
        || parentType === 'TSIndexedAccessType'
        && parent.objectType === node
        || parentType === 'TSOptionalType';
}

function TSIntersectionType$1$1(node, parent) {
    const parentType = parent.type;
    return parentType === 'TSTypeOperator'
        || parentType === 'TSArrayType'
        || parentType === 'TSIndexedAccessType'
        && parent.objectType === node
        || parentType === 'TSOptionalType';
}

function TSInferType$1$1(node, parent) {
    const parentType = parent.type;
    
    if (parentType === 'TSArrayType' || parentType === 'TSIndexedAccessType' && parent.objectType === node || parentType === 'TSOptionalType') {
        return true;
    }
    
    if (node.typeParameter.constraint) {
        if ((parentType === 'TSIntersectionType' || parentType === 'TSUnionType') && parent.types[0] === node) {
            return true;
        }
    }
    
    return false;
}

function TSTypeOperator$1$1(node, parent) {
    const parentType = parent.type;
    return parentType === 'TSArrayType'
        || parentType === 'TSIndexedAccessType'
        && parent.objectType === node
        || parentType === 'TSOptionalType';
}

function TSInstantiationExpression$1$1(node, parent) {
    const parentType = parent.type;
    return (parentType === 'CallExpression'
        || parentType === 'OptionalCallExpression'
        || parentType === 'NewExpression'
        || parentType === 'TSInstantiationExpression')
        && !!parent.typeArguments;
}

function TSFunctionType$1$1(node, parent) {
    const parentType = parent.type;
    return parentType === 'TSIntersectionType'
        || parentType === 'TSUnionType'
        || parentType === 'TSTypeOperator'
        || parentType === 'TSOptionalType'
        || parentType === 'TSArrayType'
        || parentType === 'TSIndexedAccessType'
        && parent.objectType === node
        || parentType === 'TSConditionalType'
        && (parent.checkType === node
        || parent.extendsType === node);
}

function BinaryExpression2(node, parent, tokenContext) {
    return node.operator === 'in' && Boolean(tokenContext & TokenContext.forInOrInitHeadAccumulate);
}

function SequenceExpression$1$1(node, parent) {
    const parentType = parent.type;
    
    if (parentType === 'SequenceExpression' || parentType === 'ParenthesizedExpression' || parentType === 'MemberExpression' && parent.property === node || parentType === 'OptionalMemberExpression' && parent.property === node || parentType === 'TemplateLiteral') {
        return false;
    }
    
    if (parentType === 'ClassDeclaration') {
        return true;
    }
    
    if (parentType === 'ForOfStatement') {
        return parent.right === node;
    }
    
    if (parentType === 'ExportDefaultDeclaration') {
        return true;
    }
    
    return !isStatement$4$1(parent);
}

function YieldExpression$1$1(node, parent) {
    const parentType = parent.type;
    return parentType === 'BinaryExpression'
        || parentType === 'LogicalExpression'
        || parentType === 'UnaryExpression'
        || parentType === 'SpreadElement'
        || hasPostfixPart(node, parent)
        || parentType === 'AwaitExpression'
        && isYieldExpression2(node)
        || parentType === 'ConditionalExpression'
        && node === parent.test
        || isClassExtendsClause(node, parent)
        || isTSTypeExpression(parentType);
}

function ClassExpression2(node, parent, tokenContext) {
    return Boolean(tokenContext & (TokenContext.expressionStatement | TokenContext.exportDefault));
}

function UnaryLike(node, parent) {
    return hasPostfixPart(node, parent)
        || isBinaryExpression2(parent)
        && parent.operator === '**'
        && parent.left === node
        || isClassExtendsClause(node, parent);
}

function FunctionExpression$1$1(node, parent, tokenContext) {
    return Boolean(tokenContext & (TokenContext.expressionStatement | TokenContext.exportDefault));
}

function ConditionalExpression$1$1(node, parent) {
    const parentType = parent.type;
    
    if (parentType === 'UnaryExpression' || parentType === 'SpreadElement' || parentType === 'BinaryExpression' || parentType === 'LogicalExpression' || parentType === 'ConditionalExpression' && parent.test === node || parentType === 'AwaitExpression' || isTSTypeExpression(parentType)) {
        return true;
    }
    
    return UnaryLike(node, parent);
}

function OptionalMemberExpression$1$1(node, parent) {
    return isCallExpression$2$1(parent) && parent.callee === node
        || isMemberExpression$2$1(parent) && parent.object === node;
}

function AssignmentExpression$1$1(node, parent, tokenContext) {
    if (needsParenBeforeExpressionBrace(tokenContext) && isObjectPattern2(node.left)) {
        return true;
    } else {
        return ConditionalExpression$1$1(node, parent);
    }
}

function LogicalExpression2(node, parent) {
    const parentType = parent.type;
    
    if (isTSTypeExpression(parentType))
        return true;
    
    if (parentType !== 'LogicalExpression')
        return false;
    
    switch(node.operator) {
    case '||':
        return parent.operator === '??' || parent.operator === '&&';
    
    case '&&':
        return parent.operator === '??';
    
    case '??':
        return parent.operator !== '??';
    }
}

function Identifier$1$1(node, parent, tokenContext, getRawIdentifier) {
    const parentType = parent.type;
    
    if (node.extra?.parenthesized && parentType === 'AssignmentExpression' && parent.left === node) {
        const rightType = parent.right.type;
        
        if ((rightType === 'FunctionExpression' || rightType === 'ClassExpression') && parent.right.id == null) {
            return true;
        }
    }
    
    if (getRawIdentifier && getRawIdentifier(node) !== node.name) {
        return false;
    }
    
    if (node.name === 'let') {
        const isFollowedByBracket = isMemberExpression$2$1(parent, {
            object: node,
            computed: true,
        }) || isOptionalMemberExpression2(parent, {
            object: node,
            computed: true,
            optional: false,
        });
        
        if (isFollowedByBracket && tokenContext & (TokenContext.expressionStatement | TokenContext.forInitHead | TokenContext.forInHead)) {
            return true;
        }
        
        return Boolean(tokenContext & TokenContext.forOfHead);
    }
    
    return node.name === 'async' && isForOfStatement2(parent, {
        left: node,
        await: false,
    });
}

var parens = /* @__PURE__ */Object.freeze({
    __proto__: null,
    ArrowFunctionExpression: ConditionalExpression$1$1,
    AssignmentExpression: AssignmentExpression$1$1,
    AwaitExpression: YieldExpression$1$1,
    Binary,
    BinaryExpression: BinaryExpression2,
    ClassExpression: ClassExpression2,
    ConditionalExpression: ConditionalExpression$1$1,
    DoExpression: DoExpression$1,
    FunctionExpression: FunctionExpression$1$1,
    FunctionTypeAnnotation: FunctionTypeAnnotation$1,
    Identifier: Identifier$1$1,
    IntersectionTypeAnnotation: UnionTypeAnnotation$1,
    LogicalExpression: LogicalExpression2,
    NullableTypeAnnotation: NullableTypeAnnotation$1,
    ObjectExpression: ObjectExpression$1$1,
    OptionalCallExpression: OptionalMemberExpression$1$1,
    OptionalIndexedAccessType: OptionalIndexedAccessType$1,
    OptionalMemberExpression: OptionalMemberExpression$1$1,
    SequenceExpression: SequenceExpression$1$1,
    TSAsExpression: TSAsExpression2,
    TSConditionalType: TSConditionalType$1$1,
    TSConstructorType: TSFunctionType$1$1,
    TSFunctionType: TSFunctionType$1$1,
    TSInferType: TSInferType$1$1,
    TSInstantiationExpression: TSInstantiationExpression$1$1,
    TSIntersectionType: TSIntersectionType$1$1,
    TSSatisfiesExpression: TSAsExpression2,
    TSTypeAssertion: UnaryLike,
    TSTypeOperator: TSTypeOperator$1$1,
    TSUnionType: TSUnionType$1$1,
    UnaryLike,
    UnionTypeAnnotation: UnionTypeAnnotation$1,
    UpdateExpression: UpdateExpression$1$1,
    YieldExpression: YieldExpression$1$1,
});

var {
    FLIPPED_ALIAS_KEYS: FLIPPED_ALIAS_KEYS2,
    VISITOR_KEYS: VISITOR_KEYS$1,
    isCallExpression: isCallExpression$1$1,
    isDecorator: isDecorator2,
    isExpressionStatement: isExpressionStatement3,
    isMemberExpression: isMemberExpression$1$1,
    isNewExpression: isNewExpression$1,
    isParenthesizedExpression: isParenthesizedExpression2,
} = lib_exports;

var TokenContext = {
    normal: 0,
    expressionStatement: 1,
    arrowBody: 2,
    exportDefault: 4,
    arrowFlowReturnType: 8,
    forInitHead: 16,
    forInHead: 32,
    forOfHead: 64,
    forInOrInitHeadAccumulate: 128,
    forInOrInitHeadAccumulatePassThroughMask: 128,
};

function expandAliases(obj) {
    const map =     /* @__PURE__ */new Map();
    
    function add(type, func) {
        const fn = map.get(type);
        
        map.set(type, fn ? function(node, parent, stack, getRawIdentifier) {
            return fn(node, parent, stack, getRawIdentifier) ?? func(node, parent, stack, getRawIdentifier);
        } : func);
    }
    
    for (const type of Object.keys(obj)) {
        const aliases = FLIPPED_ALIAS_KEYS2[type];
        
        if (aliases) {
            for (const alias2 of aliases) {
                add(alias2, obj[type]);
            }
        } else {
            add(type, obj[type]);
        }
    }
    
    return map;
}

var expandedParens = expandAliases(parens);
var expandedWhitespaceNodes = expandAliases(nodes);

function isOrHasCallExpression(node) {
    if (isCallExpression$1$1(node)) {
        return true;
    }
    
    return isMemberExpression$1$1(node) && isOrHasCallExpression(node.object);
}

function needsWhitespace(node, parent, type) {
    if (!node)
        return false;
    
    if (isExpressionStatement3(node)) {
        node = node.expression;
    }
    
    const flag = expandedWhitespaceNodes.get(node.type)?.(node, parent);
    
    if (typeof flag === 'number') {
        return (flag & type) !== 0;
    }
    
    return false;
}

function needsWhitespaceBefore(node, parent) {
    return needsWhitespace(node, parent, 1);
}

function needsWhitespaceAfter(node, parent) {
    return needsWhitespace(node, parent, 2);
}

function needsParens$1(node, parent, tokenContext, getRawIdentifier) {
    if (!parent)
        return false;
    
    if (isNewExpression$1(parent) && parent.callee === node) {
        if (isOrHasCallExpression(node))
            return true;
    }
    
    if (isDecorator2(parent)) {
        return !isDecoratorMemberExpression(node) && !(isCallExpression$1$1(node) && isDecoratorMemberExpression(node.callee)) && !isParenthesizedExpression2(node);
    }
    
    return expandedParens.get(node.type)?.(node, parent, tokenContext, getRawIdentifier) || false;
}

function isDecoratorMemberExpression(node) {
    switch(node.type) {
    case 'Identifier':
        return true;
    
    case 'MemberExpression':
        return !node.computed && node.property.type === 'Identifier' && isDecoratorMemberExpression(node.object);
    
    default:
        return false;
    }
}

function isLastChild(parent, child) {
    const visitorKeys = VISITOR_KEYS$1[parent.type];
    
    for (let i = visitorKeys.length - 1; i >= 0; i--) {
        const val = parent[visitorKeys[i]];
        
        if (val === child) {
            return true;
        } else if (Array.isArray(val)) {
            let j = val.length - 1;
            while (j >= 0 && val[j] === null)
                j--;
            
            return j >= 0 && val[j] === child;
        } else if (val) {
            return false;
        }

    }
    
    return false;
}

var n = /* @__PURE__ */Object.freeze({
    __proto__: null,
    TokenContext,
    isLastChild,
    needsParens: needsParens$1,
    needsWhitespace,
    needsWhitespaceAfter,
    needsWhitespaceBefore,
});

var {traverseFast: traverseFast2, VISITOR_KEYS: VISITOR_KEYS2} = lib_exports;

var TokenMap = class {
    _tokens;
    _source;
    _nodesToTokenIndexes =     /* @__PURE__ */new Map();
    _nodesOccurrencesCountCache =     /* @__PURE__ */new Map();
    _tokensCache =     /* @__PURE__ */new Map();
    constructor(ast, tokens, source) {
        this._tokens = tokens;
        this._source = source;
        traverseFast2(ast, (node) => {
            const indexes = this._getTokensIndexesOfNode(node);
            
            if (indexes.length > 0)
                this._nodesToTokenIndexes.set(node, indexes);
        });
        this._tokensCache.clear();
    }
    
    has(node) {
        return this._nodesToTokenIndexes.has(node);
    }
    
    getIndexes(node) {
        return this._nodesToTokenIndexes.get(node);
    }
    
    find(node, condition) {
        const indexes = this._nodesToTokenIndexes.get(node);
        
        if (indexes) {
            for (let k = 0; k < indexes.length; k++) {
                const index2 = indexes[k];
                const tok = this._tokens[index2];
                
                if (condition(tok, index2))
                    return tok;
            }
        }
        
        return null;
    }
    
    findLastIndex(node, condition) {
        const indexes = this._nodesToTokenIndexes.get(node);
        
        if (indexes) {
            for (let k = indexes.length - 1; k >= 0; k--) {
                const index2 = indexes[k];
                const tok = this._tokens[index2];
                
                if (condition(tok, index2))
                    return index2;
            }
        }
        
        return -1;
    }
    
    findMatching(node, test, occurrenceCount = 0) {
        const indexes = this._nodesToTokenIndexes.get(node);
        
        if (indexes) {
            let i = 0;
            const count = occurrenceCount;
            
            if (count > 1) {
                const cache2 = this._nodesOccurrencesCountCache.get(node);
                
                if (cache2?.test === test && cache2.count < count) {
                    i = cache2.i + 1;
                    occurrenceCount -= cache2.count + 1;
                }
            }
            
            for (; i < indexes.length; i++) {
                const tok = this._tokens[indexes[i]];
                
                if (this.matchesOriginal(tok, test)) {
                    if (occurrenceCount === 0) {
                        if (count > 0) {
                            this._nodesOccurrencesCountCache.set(node, {
                                test,
                                count,
                                i,
                            });
                        }
                        
                        return tok;
                    }
                    
                    occurrenceCount--;
                }
            }
        }
        
        return null;
    }
    
    matchesOriginal(token, test) {
        if (token.end - token.start !== test.length)
            return false;
        
        if (token.value != null)
            return token.value === test;
        
        return this._source.startsWith(test, token.start);
    }
    
    startMatches(node, test) {
        const indexes = this._nodesToTokenIndexes.get(node);
        
        if (!indexes)
            return false;
        
        const tok = this._tokens[indexes[0]];
        
        if (tok.start !== node.start)
            return false;
        
        return this.matchesOriginal(tok, test);
    }
    
    endMatches(node, test) {
        const indexes = this._nodesToTokenIndexes.get(node);
        
        if (!indexes)
            return false;
        
        const tok = this._tokens[indexes[indexes.length - 1]];
        
        if (tok.end !== node.end)
            return false;
        
        return this.matchesOriginal(tok, test);
    }
    
    _getTokensIndexesOfNode(node) {
        if (node.start == null || node.end == null)
            return [];
        
        const {first, last: last2} = this._findTokensOfNode(node, 0, this._tokens.length - 1);
        
        let low = first;
        const children = childrenIterator(node);
        
        if ((node.type === 'ExportNamedDeclaration' || node.type === 'ExportDefaultDeclaration') && node.declaration?.type === 'ClassDeclaration') {
            children.next();
        }
        
        const indexes = [];
        
        for (const child of children) {
            if (child == null)
                continue;
            
            if (child.start == null || child.end == null)
                continue;
            
            const childTok = this._findTokensOfNode(child, low, last2);
            const high = childTok.first;
            
            for (let k = low; k < high; k++)
                indexes.push(k);
            
            low = childTok.last + 1;
        }
        
        for (let k = low; k <= last2; k++)
            indexes.push(k);
        
        return indexes;
    }
    
    _findTokensOfNode(node, low, high) {
        const cached = this._tokensCache.get(node);
        
        if (cached)
            return cached;
        
        const first = this._findFirstTokenOfNode(node.start, low, high);
        const last2 = this._findLastTokenOfNode(node.end, first, high);
        
        this._tokensCache.set(node, {
            first,
            last: last2,
        });
        return {
            first,
            last: last2,
        };
    }
    
    _findFirstTokenOfNode(start, low, high) {
        while (low <= high) {
            const mid = high + low >> 1;
            
            if (start < this._tokens[mid].start) {
                high = mid - 1;
            } else if (start > this._tokens[mid].start) {
                low = mid + 1;
            } else {
                return mid;
            }
        }
        
        return low;
    }
    
    _findLastTokenOfNode(end, low, high) {
        while (low <= high) {
            const mid = high + low >> 1;
            
            if (end < this._tokens[mid].end) {
                high = mid - 1;
            } else if (end > this._tokens[mid].end) {
                low = mid + 1;
            } else {
                return mid;
            }
        }
        
        return high;
    }
};

function* childrenIterator(node) {
    if (node.type === 'TemplateLiteral') {
        yield node.quasis[0];
        for (let i = 1; i < node.quasis.length; i++) {
            yield node.expressions[i - 1];
            yield node.quasis[i];
        }
        
        return;
    }
    
    const keys2 = VISITOR_KEYS2[node.type];
    
    for (const key of keys2) {
        const child = node[key];
        
        if (!child)
            continue;
        
        if (Array.isArray(child)) {
            yield* child;
        } else {
            yield child;
        }
    }
}

function TaggedTemplateExpression2(node) {
    this.print(node.tag);
    this.print(node.typeArguments);
    this.print(node.quasi);
}

function TemplateElement2() {
    throw new Error('TemplateElement printing is handled in TemplateLiteral');
}

function _printTemplate(node, substitutions) {
    const quasis = node.quasis;
    let partRaw = '`';
    
    for (let i = 0; i < quasis.length - 1; i++) {
        partRaw += quasis[i].value.raw;
        this.token(partRaw + '${', true);
        this.print(substitutions[i]);
        partRaw = '}';
    }
    
    partRaw += quasis[quasis.length - 1].value.raw;
    this.token(partRaw + '`', true);
}

function TemplateLiteral2(node) {
    this._printTemplate(node, node.expressions);
}

var {
    isCallExpression: isCallExpression3,
    isLiteral: isLiteral2,
    isMemberExpression: isMemberExpression2,
    isNewExpression: isNewExpression3,
    isPattern: isPattern2,
} = lib_exports;

function UnaryExpression2(node) {
    const {operator} = node;
    
    if (operator === 'void' || operator === 'delete' || operator === 'typeof' || operator === 'throw') {
        this.word(operator);
        this.space();
    } else {
        this.token(operator);
    }
    
    this.print(node.argument);
}

function DoExpression2(node) {
    if (node.async) {
        this.word('async', true);
        this.space();
    }
    
    this.word('do');
    this.space();
    this.print(node.body);
}

function ParenthesizedExpression2(node) {
    this.tokenChar(40);
    const exit = this.enterDelimited();
    this.print(node.expression);
    exit();
    this.rightParens(node);
}

function UpdateExpression2(node) {
    if (node.prefix) {
        this.token(node.operator);
        this.print(node.argument);
    } else {
        this.print(node.argument, true);
        this.token(node.operator);
    }
}

function ConditionalExpression2(node) {
    this.print(node.test);
    this.space();
    this.tokenChar(63);
    this.space();
    this.print(node.consequent);
    this.space();
    this.tokenChar(58);
    this.space();
    this.print(node.alternate);
}

function NewExpression2(node, parent) {
    this.word('new');
    this.space();
    this.print(node.callee);
    
    if (this.format.minified && node.arguments.length === 0 && !isCallExpression3(parent, {callee: node}) && !isMemberExpression2(parent) && !isNewExpression3(parent)) {
        return;
    }
    
    this.print(node.typeArguments);
    
    if (node.arguments.length === 0 && this.tokenMap && !this.tokenMap.endMatches(node, ')')) {
        return;
    }
    
    this.tokenChar(40);
    const exit = this.enterDelimited();
    this.printList(node.arguments, this.shouldPrintTrailingComma(')'));
    exit();
    this.rightParens(node);
}

function SequenceExpression2(node) {
    this.printList(node.expressions);
}

function ThisExpression2() {
    this.word('this');
}

function Super2() {
    this.word('super');
}

function _shouldPrintDecoratorsBeforeExport(node) {
    return typeof node.start === 'number' && node.start === node.declaration.start;
}

function Decorator2(node) {
    this.tokenChar(64);
    this.print(node.expression);
    this.newline();
}

function OptionalMemberExpression2(node) {
    let {computed} = node;
    
    const {optional, property} = node;
    
    this.print(node.object);
    
    if (!computed && isMemberExpression2(property)) {
        throw new TypeError('Got a MemberExpression for MemberExpression property');
    }
    
    if (isLiteral2(property) && typeof property.value === 'number') {
        computed = true;
    }
    
    if (optional) {
        this.token('?.');
    }
    
    if (computed) {
        this.tokenChar(91);
        this.print(property);
        this.tokenChar(93);
    } else {
        if (!optional) {
            this.tokenChar(46);
        }
        
        this.print(property);
    }
}

function OptionalCallExpression2(node) {
    this.print(node.callee);
    
    if (node.optional) {
        this.token('?.');
    }
    
    this.print(node.typeArguments);
    this.tokenChar(40);
    const exit = this.enterDelimited();
    this.printList(node.arguments);
    exit();
    this.rightParens(node);
}

function CallExpression2(node) {
    this.print(node.callee);
    this.print(node.typeArguments);
    this.tokenChar(40);
    const exit = this.enterDelimited();
    this.printList(node.arguments, this.shouldPrintTrailingComma(')'));
    exit();
    this.rightParens(node);
}

function Import2() {
    this.word('import');
}

function AwaitExpression2(node) {
    this.word('await');
    this.space();
    this.print(node.argument);
}

function YieldExpression2(node) {
    if (node.delegate) {
        this.word('yield', true);
        this.tokenChar(42);
        
        if (node.argument) {
            this.space();
            this.print(node.argument);
        }
    } else if (node.argument) {
        this.word('yield', true);
        this.space();
        this.print(node.argument);
    } else {
        this.word('yield');
    }
}

function EmptyStatement2() {
    this.semicolon(true);
}

function ExpressionStatement2(node) {
    this.tokenContext |= TokenContext.expressionStatement;
    this.print(node.expression);
    this.semicolon();
}

function AssignmentPattern2(node) {
    this.print(node.left);
    
    if (node.left.type === 'Identifier' || isPattern2(node.left)) {
        if (node.left.optional)
            this.tokenChar(63);
        
        this.print(node.left.typeAnnotation);
    }
    
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node.right);
}

function AssignmentExpression2(node) {
    this.print(node.left);
    this.space();
    
    if (node.operator === 'in' || node.operator === 'instanceof') {
        this.word(node.operator);
    } else {
        this.token(node.operator);
        this._endsWithDiv = node.operator === '/';
    }
    
    this.space();
    this.print(node.right);
}

function BindExpression2(node) {
    this.print(node.object);
    this.token('::');
    this.print(node.callee);
}

function MemberExpression2(node) {
    this.print(node.object);
    
    if (!node.computed && isMemberExpression2(node.property)) {
        throw new TypeError('Got a MemberExpression for MemberExpression property');
    }
    
    let computed = node.computed;
    
    if (isLiteral2(node.property) && typeof node.property.value === 'number') {
        computed = true;
    }
    
    if (computed) {
        const exit = this.enterDelimited();
        this.tokenChar(91);
        this.print(node.property);
        this.tokenChar(93);
        exit();
    } else {
        this.tokenChar(46);
        this.print(node.property);
    }
}

function MetaProperty2(node) {
    this.print(node.meta);
    this.tokenChar(46);
    this.print(node.property);
}

function PrivateName2(node) {
    this.tokenChar(35);
    this.print(node.id);
}

function V8IntrinsicIdentifier2(node) {
    this.tokenChar(37);
    this.word(node.name);
}

function ModuleExpression2(node) {
    this.word('module', true);
    this.space();
    this.tokenChar(123);
    this.indent();
    const {body} = node;
    
    if (body.body.length || body.directives.length) {
        this.newline();
    }
    
    this.print(body);
    this.dedent();
    this.rightBrace(node);
}

var {
    isFor: isFor2,
    isForStatement: isForStatement2,
    isIfStatement: isIfStatement2,
    isStatement: isStatement$3$1,
    isVoidPattern: isVoidPattern2,
} = lib_exports;

function WithStatement2(node) {
    this.word('with');
    this.space();
    this.tokenChar(40);
    this.print(node.object);
    this.tokenChar(41);
    this.printBlock(node);
}

function IfStatement2(node) {
    this.word('if');
    this.space();
    this.tokenChar(40);
    this.print(node.test);
    this.tokenChar(41);
    this.space();
    const needsBlock = node.alternate && isIfStatement2(getLastStatement(node.consequent));
    
    if (needsBlock) {
        this.tokenChar(123);
        this.newline();
        this.indent();
    }
    
    this.printAndIndentOnComments(node.consequent);
    
    if (needsBlock) {
        this.dedent();
        this.newline();
        this.tokenChar(125);
    }
    
    if (node.alternate) {
        if (this.endsWith(125))
            this.space();
        
        this.word('else');
        this.space();
        this.printAndIndentOnComments(node.alternate);
    }
}

function getLastStatement(statement2) {
    const {body} = statement2;
    
    if (isStatement$3$1(body) === false) {
        return statement2;
    }
    
    return getLastStatement(body);
}

function ForStatement2(node) {
    this.word('for');
    this.space();
    this.tokenChar(40);
    {
        const exit = this.enterForStatementInit();
        this.print(node.init);
        exit();
    }
    this.tokenChar(59);
    
    if (node.test) {
        this.space();
        this.print(node.test);
    }
    
    this.token(';', false, 1);
    
    if (node.update) {
        this.space();
        this.print(node.update);
    }
    
    this.tokenChar(41);
    this.printBlock(node);
}

function WhileStatement2(node) {
    this.word('while');
    this.space();
    this.tokenChar(40);
    this.print(node.test);
    this.tokenChar(41);
    this.printBlock(node);
}

function ForXStatement(node) {
    this.word('for');
    this.space();
    const isForOf = node.type === 'ForOfStatement';
    
    if (isForOf && node.await) {
        this.word('await');
        this.space();
    }
    
    this.noIndentInnerCommentsHere();
    this.tokenChar(40);
    {
        const exit = this.enterForXStatementInit(isForOf);
        this.print(node.left);
        exit?.();
    }
    this.space();
    this.word(isForOf ? 'of' : 'in');
    this.space();
    this.print(node.right);
    this.tokenChar(41);
    this.printBlock(node);
}

var ForInStatement2 = ForXStatement;
var ForOfStatement2 = ForXStatement;

function DoWhileStatement2(node) {
    this.word('do');
    this.space();
    this.print(node.body);
    this.space();
    this.word('while');
    this.space();
    this.tokenChar(40);
    this.print(node.test);
    this.tokenChar(41);
    this.semicolon();
}

function printStatementAfterKeyword(printer, node) {
    if (node) {
        printer.space();
        printer.printTerminatorless(node);
    }
    
    printer.semicolon();
}

function BreakStatement2(node) {
    this.word('break');
    printStatementAfterKeyword(this, node.label);
}

function ContinueStatement2(node) {
    this.word('continue');
    printStatementAfterKeyword(this, node.label);
}

function ReturnStatement2(node) {
    this.word('return');
    printStatementAfterKeyword(this, node.argument);
}

function ThrowStatement2(node) {
    this.word('throw');
    printStatementAfterKeyword(this, node.argument);
}

function LabeledStatement2(node) {
    this.print(node.label);
    this.tokenChar(58);
    this.space();
    this.print(node.body);
}

function TryStatement2(node) {
    this.word('try');
    this.space();
    this.print(node.block);
    this.space();
    
    if (node.handlers) {
        this.print(node.handlers[0]);
    } else {
        this.print(node.handler);
    }
    
    if (node.finalizer) {
        this.space();
        this.word('finally');
        this.space();
        this.print(node.finalizer);
    }
}

function CatchClause2(node) {
    this.word('catch');
    this.space();
    
    if (node.param) {
        this.tokenChar(40);
        this.print(node.param);
        this.print(node.param.typeAnnotation);
        this.tokenChar(41);
        this.space();
    }
    
    this.print(node.body);
}

function SwitchStatement2(node) {
    this.word('switch');
    this.space();
    this.tokenChar(40);
    this.print(node.discriminant);
    this.tokenChar(41);
    this.space();
    this.tokenChar(123);
    this.printSequence(node.cases, true);
    this.rightBrace(node);
}

function SwitchCase2(node) {
    if (node.test) {
        this.word('case');
        this.space();
        this.print(node.test);
        this.tokenChar(58);
    } else {
        this.word('default');
        this.tokenChar(58);
    }
    
    if (node.consequent.length) {
        this.newline();
        this.printSequence(node.consequent, true);
    }
}

function DebuggerStatement2() {
    this.word('debugger');
    this.semicolon();
}

function VariableDeclaration2(node, parent) {
    if (node.declare) {
        this.word('declare');
        this.space();
    }
    
    const {kind} = node;
    
    if (kind === 'await using') {
        this.word('await');
        this.space();
        this.word('using', true);
    } else {
        this.word(kind, kind === 'using');
    }
    
    this.space();
    let hasInits = false;
    
    if (!isFor2(parent)) {
        for (const declar of node.declarations) {
            if (declar.init) {
                hasInits = true;
            }
        }
    }
    
    this.printList(node.declarations, void 0, void 0, node.declarations.length > 1, hasInits ? function(occurrenceCount) {
        this.token(',', false, occurrenceCount);
        this.newline();
    } : void 0);
    
    if (isFor2(parent)) {
        if (isForStatement2(parent)) {
            if (parent.init === node)
                return;
        } else {
            if (parent.left === node)
                return;
        }
    }
    
    this.semicolon();
}

function VariableDeclarator2(node) {
    this.print(node.id);
    
    if (node.definite)
        this.tokenChar(33);
    
    if (!isVoidPattern2(node.id)) {
        this.print(node.id.typeAnnotation);
    }
    
    if (node.init) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.init);
    }
}

var {
    isExportDefaultDeclaration: isExportDefaultDeclaration2,
    isExportNamedDeclaration: isExportNamedDeclaration2,
} = lib_exports;

function ClassDeclaration2(node, parent) {
    const inExport = isExportDefaultDeclaration2(parent) || isExportNamedDeclaration2(parent);
    
    if (!inExport || !this._shouldPrintDecoratorsBeforeExport(parent)) {
        this.printJoin(node.decorators);
    }
    
    if (node.declare) {
        this.word('declare');
        this.space();
    }
    
    if (node.abstract) {
        this.word('abstract');
        this.space();
    }
    
    this.word('class');
    
    if (node.id) {
        this.space();
        this.print(node.id);
    }
    
    this.print(node.typeParameters);
    
    if (node.superClass) {
        this.space();
        this.word('extends');
        this.space();
        this.print(node.superClass);
        this.print(node.superTypeArguments);
    }
    
    if (node.implements) {
        this.space();
        this.word('implements');
        this.space();
        this.printList(node.implements);
    }
    
    this.space();
    this.print(node.body);
}

function ClassBody2(node) {
    this.tokenChar(123);
    
    if (node.body.length === 0) {
        this.tokenChar(125);
    } else {
        this.newline();
        const separator = classBodyEmptySemicolonsPrinter(this, node);
        separator?.(-1);
        const exit = this.enterDelimited();
        this.printJoin(node.body, true, true, separator, true);
        exit();
        
        if (!this.endsWith(10))
            this.newline();
        
        this.rightBrace(node);
    }
}

function classBodyEmptySemicolonsPrinter(printer, node) {
    if (!printer.tokenMap || node.start == null || node.end == null) {
        return null;
    }
    
    const indexes = printer.tokenMap.getIndexes(node);
    
    if (!indexes)
        return null;
    
    let k = 1;
    let occurrenceCount = 0;
    let nextLocIndex = 0;
    
    const advanceNextLocIndex = () => {
        while (nextLocIndex < node.body.length && node.body[nextLocIndex].start == null) {
            nextLocIndex++;
        }
    };
    
    advanceNextLocIndex();
    return (i) => {
        if (nextLocIndex <= i) {
            nextLocIndex = i + 1;
            advanceNextLocIndex();
        }
        
        const end = nextLocIndex === node.body.length ? node.end : node.body[nextLocIndex].start;
        let tok;
        
        while (k < indexes.length && printer.tokenMap.matchesOriginal(tok = printer._tokens[indexes[k]], ';') && tok.start < end) {
            printer.token(';', void 0, occurrenceCount++);
            k++;
        }
    };
}

function ClassProperty2(node) {
    this.printJoin(node.decorators);
    
    if (!node.static && !this.format.preserveFormat) {
        const endLine = node.key.loc?.end?.line;
        
        if (endLine)
            this.catchUp(endLine);
    }
    
    this.tsPrintClassMemberModifiers(node);
    
    if (node.computed) {
        this.tokenChar(91);
        this.print(node.key);
        this.tokenChar(93);
    } else {
        this._variance(node);
        this.print(node.key);
    }
    
    if (node.optional) {
        this.tokenChar(63);
    }
    
    if (node.definite) {
        this.tokenChar(33);
    }
    
    this.print(node.typeAnnotation);
    
    if (node.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.value);
    }
    
    this.semicolon();
}

function ClassAccessorProperty2(node) {
    this.printJoin(node.decorators);
    const endLine = node.key.loc?.end?.line;
    
    if (endLine)
        this.catchUp(endLine);
    
    this.tsPrintClassMemberModifiers(node);
    this.word('accessor', true);
    this.space();
    
    if (node.computed) {
        this.tokenChar(91);
        this.print(node.key);
        this.tokenChar(93);
    } else {
        this._variance(node);
        this.print(node.key);
    }
    
    if (node.optional) {
        this.tokenChar(63);
    }
    
    if (node.definite) {
        this.tokenChar(33);
    }
    
    this.print(node.typeAnnotation);
    
    if (node.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.value);
    }
    
    this.semicolon();
}

function ClassPrivateProperty2(node) {
    this.printJoin(node.decorators);
    this.tsPrintClassMemberModifiers(node);
    this.print(node.key);
    
    if (node.optional) {
        this.tokenChar(63);
    }
    
    if (node.definite) {
        this.tokenChar(33);
    }
    
    this.print(node.typeAnnotation);
    
    if (node.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.value);
    }
    
    this.semicolon();
}

function ClassMethod2(node) {
    this._classMethodHead(node);
    this.space();
    this.print(node.body);
}

function ClassPrivateMethod2(node) {
    this._classMethodHead(node);
    this.space();
    this.print(node.body);
}

function _classMethodHead(node) {
    this.printJoin(node.decorators);
    
    if (!this.format.preserveFormat) {
        const endLine = node.key.loc?.end?.line;
        
        if (endLine)
            this.catchUp(endLine);
    }
    
    this.tsPrintClassMemberModifiers(node);
    this._methodHead(node);
}

function StaticBlock2(node) {
    this.word('static');
    this.space();
    this.tokenChar(123);
    
    if (node.body.length === 0) {
        this.tokenChar(125);
    } else {
        this.newline();
        this.printSequence(node.body, true);
        this.rightBrace(node);
    }
}

var {isIdentifier: isIdentifier$1$1} = lib_exports;

function _params(node, idNode, parentNode) {
    this.print(node.typeParameters);
    const nameInfo = _getFuncIdName.call(this, idNode, parentNode);
    
    if (nameInfo) {
        this.sourceIdentifierName(nameInfo.name, nameInfo.pos);
    }
    
    this.tokenChar(40);
    this._parameters(node.params, ')');
    const noLineTerminator = node.type === 'ArrowFunctionExpression';
    this.print(node.returnType, noLineTerminator);
    this._noLineTerminator = noLineTerminator;
}

function _parameters(parameters, endToken) {
    const exit = this.enterDelimited();
    const trailingComma = this.shouldPrintTrailingComma(endToken);
    const paramLength = parameters.length;
    
    for (let i = 0; i < paramLength; i++) {
        this._param(parameters[i]);
        
        if (trailingComma || i < paramLength - 1) {
            this.token(',', void 0, i);
            this.space();
        }
    }
    
    this.token(endToken);
    exit();
}

function _param(parameter) {
    this.printJoin(parameter.decorators);
    this.print(parameter);
    
    if (parameter.optional) {
        this.tokenChar(63);
    }
    
    this.print(parameter.typeAnnotation);
}

function _methodHead(node) {
    const kind = node.kind;
    const key = node.key;
    
    if (kind === 'get' || kind === 'set') {
        this.word(kind);
        this.space();
    }
    
    if (node.async) {
        this.word('async', true);
        this.space();
    }
    
    if (kind === 'method' || kind === 'init') {
        if (node.generator) {
            this.tokenChar(42);
        }
    }
    
    if (node.computed) {
        this.tokenChar(91);
        this.print(key);
        this.tokenChar(93);
    } else {
        this.print(key);
    }
    
    if (node.optional) {
        this.tokenChar(63);
    }
    
    this._params(node, node.computed && node.key.type !== 'StringLiteral' ? void 0 : node.key);
}

function _predicate(node, noLineTerminatorAfter) {
    if (node.predicate) {
        if (!node.returnType) {
            this.tokenChar(58);
        }
        
        this.space();
        this.print(node.predicate, noLineTerminatorAfter);
    }
}

function _functionHead(node, parent) {
    if (node.async) {
        this.word('async');
        
        if (!this.format.preserveFormat) {
            this._endsWithInnerRaw = false;
        }
        
        this.space();
    }
    
    this.word('function');
    
    if (node.generator) {
        if (!this.format.preserveFormat) {
            this._endsWithInnerRaw = false;
        }
        
        this.tokenChar(42);
    }
    
    this.space();
    
    if (node.id) {
        this.print(node.id);
    }
    
    this._params(node, node.id, parent);
    
    if (node.type !== 'TSDeclareFunction') {
        this._predicate(node);
    }
}

function FunctionExpression2(node, parent) {
    this._functionHead(node, parent);
    this.space();
    this.print(node.body);
}

function ArrowFunctionExpression2(node, parent) {
    if (node.async) {
        this.word('async', true);
        this.space();
    }
    
    if (this._shouldPrintArrowParamsParens(node)) {
        this._params(node, void 0, parent);
    } else {
        this.print(node.params[0], true);
    }
    
    this._predicate(node, true);
    this.space();
    this.printInnerComments();
    this.token('=>');
    this.space();
    this.tokenContext |= TokenContext.arrowBody;
    this.print(node.body);
}

function _shouldPrintArrowParamsParens(node) {
    if (node.params.length !== 1)
        return true;
    
    if (node.typeParameters || node.returnType || node.predicate) {
        return true;
    }
    
    const firstParam = node.params[0];
    
    if (!isIdentifier$1$1(firstParam) || firstParam.typeAnnotation || firstParam.optional || firstParam.leadingComments?.length || firstParam.trailingComments?.length) {
        return true;
    }
    
    if (this.tokenMap) {
        if (node.loc == null)
            return true;
        
        if (this.tokenMap.findMatching(node, '(') !== null)
            return true;
        
        const arrowToken = this.tokenMap.findMatching(node, '=>');
        
        if (arrowToken?.loc == null)
            return true;
        
        return arrowToken.loc.start.line !== node.loc.start.line;
    }
    
    if (this.format.retainLines)
        return true;
    
    return false;
}

function _getFuncIdName(idNode, parent) {
    let id = idNode;
    
    if (!id && parent) {
        const parentType = parent.type;
        
        if (parentType === 'VariableDeclarator') {
            id = parent.id;
        } else if (parentType === 'AssignmentExpression' || parentType === 'AssignmentPattern') {
            id = parent.left;
        } else if (parentType === 'ObjectProperty' || parentType === 'ClassProperty') {
            if (!parent.computed || parent.key.type === 'StringLiteral') {
                id = parent.key;
            }
        } else if (parentType === 'ClassPrivateProperty' || parentType === 'ClassAccessorProperty') {
            id = parent.key;
        }


    }
    
    if (!id)
        return;
    
    let nameInfo;
    
    if (id.type === 'Identifier') {
        nameInfo = {
            pos: id.loc?.start,
            name: id.loc?.identifierName || id.name,
        };
    } else if (id.type === 'PrivateName') {
        nameInfo = {
            pos: id.loc?.start,
            name: '#' + id.id.name,
        };
    } else if (id.type === 'StringLiteral') {
        nameInfo = {
            pos: id.loc?.start,
            name: id.value,
        };
    }
    
    return nameInfo;
}

var {
    isClassDeclaration: isClassDeclaration2,
    isExportDefaultSpecifier: isExportDefaultSpecifier2,
    isExportNamespaceSpecifier: isExportNamespaceSpecifier2,
    isImportDefaultSpecifier: isImportDefaultSpecifier2,
    isImportNamespaceSpecifier: isImportNamespaceSpecifier2,
    isStatement: isStatement$2$1,
} = lib_exports;

function ImportSpecifier2(node) {
    if (node.importKind === 'type' || node.importKind === 'typeof') {
        this.word(node.importKind);
        this.space();
    }
    
    this.print(node.imported);
    
    if (node.local && node.local.name !== node.imported.name) {
        this.space();
        this.word('as');
        this.space();
        this.print(node.local);
    }
}

function ImportDefaultSpecifier2(node) {
    this.print(node.local);
}

function ExportDefaultSpecifier2(node) {
    this.print(node.exported);
}

function ExportSpecifier2(node) {
    if (node.exportKind === 'type') {
        this.word('type');
        this.space();
    }
    
    this.print(node.local);
    
    if (node.exported && node.local.name !== node.exported.name) {
        this.space();
        this.word('as');
        this.space();
        this.print(node.exported);
    }
}

function ExportNamespaceSpecifier2(node) {
    this.tokenChar(42);
    this.space();
    this.word('as');
    this.space();
    this.print(node.exported);
}

function _printAttributes(node, hasPreviousBrace) {
    const {attributes} = node;
    
    this.word('with');
    this.space();
    const occurrenceCount = hasPreviousBrace ? 1 : 0;
    this.token('{', void 0, occurrenceCount);
    this.space();
    this.printList(attributes, this.shouldPrintTrailingComma('}'));
    this.space();
    this.token('}', void 0, occurrenceCount);
}

function ExportAllDeclaration2(node) {
    this.word('export');
    this.space();
    
    if (node.exportKind === 'type') {
        this.word('type');
        this.space();
    }
    
    this.tokenChar(42);
    this.space();
    this.word('from');
    this.space();
    
    if (node.attributes?.length) {
        this.print(node.source, true);
        this.space();
        this._printAttributes(node, false);
    } else {
        this.print(node.source);
    }
    
    this.semicolon();
}

function maybePrintDecoratorsBeforeExport(printer, node) {
    if (isClassDeclaration2(node.declaration) && printer._shouldPrintDecoratorsBeforeExport(node)) {
        printer.printJoin(node.declaration.decorators);
    }
}

function ExportNamedDeclaration2(node) {
    maybePrintDecoratorsBeforeExport(this, node);
    this.word('export');
    this.space();
    
    if (node.declaration) {
        const declar = node.declaration;
        this.print(declar);
        
        if (!isStatement$2$1(declar))
            this.semicolon();
    } else {
        if (node.exportKind === 'type') {
            this.word('type');
            this.space();
        }
        
        const specifiers = node.specifiers.slice(0);
        let hasSpecial = false;
        
        for (;;) {
            const first = specifiers[0];
            
            if (isExportDefaultSpecifier2(first) || isExportNamespaceSpecifier2(first)) {
                hasSpecial = true;
                this.print(specifiers.shift());
                
                if (specifiers.length) {
                    this.tokenChar(44);
                    this.space();
                }
            } else {
                break;
            }
        }
        
        let hasBrace = false;
        
        if (specifiers.length || !specifiers.length && !hasSpecial) {
            hasBrace = true;
            this.tokenChar(123);
            
            if (specifiers.length) {
                this.space();
                this.printList(specifiers, this.shouldPrintTrailingComma('}'));
                this.space();
            }
            
            this.tokenChar(125);
        }
        
        if (node.source) {
            this.space();
            this.word('from');
            this.space();
            
            if (node.attributes?.length) {
                this.print(node.source, true);
                this.space();
                this._printAttributes(node, hasBrace);
            } else {
                this.print(node.source);
            }
        }
        
        this.semicolon();
    }
}

function ExportDefaultDeclaration2(node) {
    maybePrintDecoratorsBeforeExport(this, node);
    this.word('export');
    this.noIndentInnerCommentsHere();
    this.space();
    this.word('default');
    this.space();
    this.tokenContext |= TokenContext.exportDefault;
    const declar = node.declaration;
    this.print(declar);
    
    if (!isStatement$2$1(declar))
        this.semicolon();
}

function ImportDeclaration2(node) {
    this.word('import');
    this.space();
    const isTypeKind = node.importKind === 'type' || node.importKind === 'typeof';
    
    if (isTypeKind) {
        this.noIndentInnerCommentsHere();
        this.word(node.importKind);
        this.space();
    } else if (node.module) {
        this.noIndentInnerCommentsHere();
        this.word('module');
        this.space();
    } else if (node.phase) {
        this.noIndentInnerCommentsHere();
        this.word(node.phase);
        this.space();
    }
    
    const specifiers = node.specifiers.slice(0);
    const hasSpecifiers = !!specifiers.length;
    
    while (hasSpecifiers) {
        const first = specifiers[0];
        
        if (isImportDefaultSpecifier2(first) || isImportNamespaceSpecifier2(first)) {
            this.print(specifiers.shift());
            
            if (specifiers.length) {
                this.tokenChar(44);
                this.space();
            }
        } else {
            break;
        }
    }
    
    let hasBrace = false;
    
    if (specifiers.length) {
        hasBrace = true;
        this.tokenChar(123);
        this.space();
        this.printList(specifiers, this.shouldPrintTrailingComma('}'));
        this.space();
        this.tokenChar(125);
    } else if (isTypeKind && !hasSpecifiers) {
        hasBrace = true;
        this.tokenChar(123);
        this.tokenChar(125);
    }
    
    if (hasSpecifiers || isTypeKind) {
        this.space();
        this.word('from');
        this.space();
    }
    
    if (node.attributes?.length) {
        this.print(node.source, true);
        this.space();
        this._printAttributes(node, hasBrace);
    } else {
        this.print(node.source);
    }
    
    this.semicolon();
}

function ImportAttribute2(node) {
    this.print(node.key);
    this.tokenChar(58);
    this.space();
    this.print(node.value);
}

function ImportNamespaceSpecifier2(node) {
    this.tokenChar(42);
    this.space();
    this.word('as');
    this.space();
    this.print(node.local);
}

function ImportExpression2(node) {
    this.word('import');
    
    if (node.phase) {
        this.tokenChar(46);
        this.word(node.phase);
    }
    
    this.tokenChar(40);
    const shouldPrintTrailingComma = this.shouldPrintTrailingComma(')');
    this.print(node.source);
    
    if (node.options != null) {
        this.tokenChar(44);
        this.space();
        this.print(node.options);
    }
    
    if (shouldPrintTrailingComma) {
        this.tokenChar(44);
    }
    
    this.rightParens(node);
}

var {
    isAssignmentPattern: isAssignmentPattern2,
    isIdentifier: isIdentifier3,
} = lib_exports;

var lastRawIdentNode = null;
var lastRawIdentResult = '';

function _getRawIdentifier(node) {
    if (node === lastRawIdentNode)
        return lastRawIdentResult;
    
    lastRawIdentNode = node;
    const {name} = node;
    
    const token = this.tokenMap.find(node, (tok) => tok.value === name);
    
    if (token) {
        lastRawIdentResult = this._originalCode.slice(token.start, token.end);
        return lastRawIdentResult;
    }
    
    return lastRawIdentResult = node.name;
}

function Identifier3(node) {
    this.sourceIdentifierName(node.loc?.identifierName || node.name);
    this.word(this.tokenMap ? this._getRawIdentifier(node) : node.name);
}

function ArgumentPlaceholder2() {
    this.tokenChar(63);
}

function RestElement2(node) {
    this.token('...');
    this.print(node.argument);
}

function ObjectExpression2(node) {
    const props = node.properties;
    this.tokenChar(123);
    
    if (props.length) {
        const exit = this.enterDelimited();
        this.space();
        this.printList(props, this.shouldPrintTrailingComma('}'), true, true);
        this.space();
        exit();
    }
    
    this.sourceWithOffset('end', node.loc, -1);
    this.tokenChar(125);
}

function ObjectMethod2(node) {
    this.printJoin(node.decorators);
    this._methodHead(node);
    this.space();
    this.print(node.body);
}

function ObjectProperty2(node) {
    this.printJoin(node.decorators);
    
    if (node.computed) {
        this.tokenChar(91);
        this.print(node.key);
        this.tokenChar(93);
    } else {
        if (isAssignmentPattern2(node.value) && isIdentifier3(node.key) && node.key.name === node.value.left.name) {
            this.print(node.value);
            return;
        }
        
        this.print(node.key);
        
        if (node.shorthand && isIdentifier3(node.key) && isIdentifier3(node.value) && node.key.name === node.value.name) {
            return;
        }
    }
    
    this.tokenChar(58);
    this.space();
    this.print(node.value);
}

function ArrayExpression2(node) {
    const elems = node.elements;
    const len = elems.length;
    this.tokenChar(91);
    const exit = this.enterDelimited();
    
    for (let i = 0; i < elems.length; i++) {
        const elem = elems[i];
        
        if (elem) {
            if (i > 0)
                this.space();
            
            this.print(elem);
            
            if (i < len - 1 || this.shouldPrintTrailingComma(']')) {
                this.token(',', false, i);
            }
        } else {
            this.token(',', false, i);
        }
    }
    
    exit();
    this.tokenChar(93);
}

function RegExpLiteral2(node) {
    this.word(`/${node.pattern}/${node.flags}`);
}

function BooleanLiteral2(node) {
    this.word(node.value ? 'true' : 'false');
}

function NullLiteral2() {
    this.word('null');
}

function NumericLiteral3(node) {
    const raw = this.getPossibleRaw(node);
    const opts = this.format.jsescOption;
    const value = node.value;
    const str = value + '';
    
    if (opts.numbers) {
        this.number((0, import_jsesc.default)(value, opts), value);
    } else if (raw == null) {
        this.number(str, value);
    } else if (this.format.minified) {
        this.number(raw.length < str.length ? raw : str, value);
    } else {
        this.number(raw, value);
    }

}

function StringLiteral3(node) {
    const raw = this.getPossibleRaw(node);
    
    if (!this.format.minified && raw !== void 0) {
        this.token(raw);
        return;
    }
    
    const val = (0, import_jsesc.default)(node.value, this.format.jsescOption);
    this.token(val);
}

function BigIntLiteral2(node) {
    const raw = this.getPossibleRaw(node);
    
    if (!this.format.minified && raw !== void 0) {
        this.word(raw);
        return;
    }
    
    this.word(node.value + 'n');
}

var validTopicTokenSet = /* @__PURE__ */new Set([
    '^^',
    '@@',
    '^',
    '%',
    '#',
]);

function TopicReference2() {
    const {topicToken} = this.format;
    
    if (validTopicTokenSet.has(topicToken)) {
        this.token(topicToken);
    } else {
        const givenTopicTokenJSON = JSON.stringify(topicToken);
        const validTopics = Array.from(validTopicTokenSet, (v) => JSON.stringify(v));
        throw new Error(`The "topicToken" generator option must be one of ${validTopics.join(', ')} (${givenTopicTokenJSON} received instead).`);
    }
}

function PipelineTopicExpression2(node) {
    this.print(node.expression);
}

function PipelineBareFunction2(node) {
    this.print(node.callee);
}

function PipelinePrimaryTopicReference2() {
    this.tokenChar(35);
}

function VoidPattern2() {
    this.word('void');
}

var {isDeclareExportDeclaration: isDeclareExportDeclaration2} = lib_exports;

function AnyTypeAnnotation2() {
    this.word('any');
}

function ArrayTypeAnnotation2(node) {
    this.print(node.elementType, true);
    this.tokenChar(91);
    this.tokenChar(93);
}

function BooleanTypeAnnotation2() {
    this.word('boolean');
}

function BooleanLiteralTypeAnnotation2(node) {
    this.word(node.value ? 'true' : 'false');
}

function NullLiteralTypeAnnotation2() {
    this.word('null');
}

function DeclareClass2(node, parent) {
    if (!isDeclareExportDeclaration2(parent)) {
        this.word('declare');
        this.space();
    }
    
    this.word('class');
    this.space();
    this._interfaceish(node);
}

function DeclareFunction2(node, parent) {
    if (!isDeclareExportDeclaration2(parent)) {
        this.word('declare');
        this.space();
    }
    
    this.word('function');
    this.space();
    this.print(node.id);
    this.print(node.id.typeAnnotation?.typeAnnotation);
    
    if (node.predicate) {
        this.space();
        this.print(node.predicate);
    }
    
    this.semicolon();
}

function InferredPredicate2() {
    this.tokenChar(37);
    this.word('checks');
}

function DeclaredPredicate2(node) {
    this.tokenChar(37);
    this.word('checks');
    this.tokenChar(40);
    this.print(node.value);
    this.tokenChar(41);
}

function DeclareInterface2(node) {
    this.word('declare');
    this.space();
    this.InterfaceDeclaration(node);
}

function DeclareModule2(node) {
    this.word('declare');
    this.space();
    this.word('module');
    this.space();
    this.print(node.id);
    this.space();
    this.print(node.body);
}

function DeclareModuleExports2(node) {
    this.word('declare');
    this.space();
    this.word('module');
    this.tokenChar(46);
    this.word('exports');
    this.print(node.typeAnnotation);
}

function DeclareTypeAlias2(node) {
    this.word('declare');
    this.space();
    this.TypeAlias(node);
}

function DeclareOpaqueType2(node, parent) {
    if (!isDeclareExportDeclaration2(parent)) {
        this.word('declare');
        this.space();
    }
    
    this.OpaqueType(node);
}

function DeclareVariable2(node, parent) {
    if (!isDeclareExportDeclaration2(parent)) {
        this.word('declare');
        this.space();
    }
    
    this.word('var');
    this.space();
    this.print(node.id);
    this.print(node.id.typeAnnotation);
    this.semicolon();
}

function DeclareExportDeclaration2(node) {
    this.word('declare');
    this.space();
    this.word('export');
    this.space();
    
    if (node.default) {
        this.word('default');
        this.space();
    }
}

function DeclareExportAllDeclaration2(node) {
    this.word('declare');
    this.space();
    ExportAllDeclaration2.call(this, node);
}

function EnumDeclaration2(node) {
    const {id, body} = node;
    
    this.word('enum');
    this.space();
    this.print(id);
    this.print(body);
}

function enumExplicitType(context, name, hasExplicitType) {
    if (hasExplicitType) {
        context.space();
        context.word('of');
        context.space();
        context.word(name);
    }
    
    context.space();
}

function enumBody(context, node) {
    const {members} = node;
    
    context.token('{');
    context.indent();
    context.newline();
    for (const member of members) {
        context.print(member);
        context.newline();
    }
    
    if (node.hasUnknownMembers) {
        context.token('...');
        context.newline();
    }
    
    context.dedent();
    context.token('}');
}

function EnumBooleanBody2(node) {
    const {explicitType} = node;
    
    enumExplicitType(this, 'boolean', explicitType);
    enumBody(this, node);
}

function EnumNumberBody2(node) {
    const {explicitType} = node;
    
    enumExplicitType(this, 'number', explicitType);
    enumBody(this, node);
}

function EnumStringBody2(node) {
    const {explicitType} = node;
    
    enumExplicitType(this, 'string', explicitType);
    enumBody(this, node);
}

function EnumSymbolBody2(node) {
    enumExplicitType(this, 'symbol', true);
    enumBody(this, node);
}

function EnumDefaultedMember2(node) {
    const {id} = node;
    
    this.print(id);
    this.tokenChar(44);
}

function enumInitializedMember(context, node) {
    context.print(node.id);
    context.space();
    context.token('=');
    context.space();
    context.print(node.init);
    context.token(',');
}

function EnumBooleanMember2(node) {
    enumInitializedMember(this, node);
}

function EnumNumberMember2(node) {
    enumInitializedMember(this, node);
}

function EnumStringMember2(node) {
    enumInitializedMember(this, node);
}

function ExistsTypeAnnotation2() {
    this.tokenChar(42);
}

function FunctionTypeAnnotation2(node, parent) {
    this.print(node.typeParameters);
    this.tokenChar(40);
    
    if (node.this) {
        this.word('this');
        this.tokenChar(58);
        this.space();
        this.print(node.this.typeAnnotation);
        
        if (node.params.length || node.rest) {
            this.tokenChar(44);
            this.space();
        }
    }
    
    this.printList(node.params);
    
    if (node.rest) {
        if (node.params.length) {
            this.tokenChar(44);
            this.space();
        }
        
        this.token('...');
        this.print(node.rest);
    }
    
    this.tokenChar(41);
    const type = parent?.type;
    
    if (type != null && (type === 'ObjectTypeCallProperty' || type === 'ObjectTypeInternalSlot' || type === 'DeclareFunction' || type === 'ObjectTypeProperty' && parent.method)) {
        this.tokenChar(58);
    } else {
        this.space();
        this.token('=>');
    }
    
    this.space();
    this.print(node.returnType);
}

function FunctionTypeParam2(node) {
    this.print(node.name);
    
    if (node.optional)
        this.tokenChar(63);
    
    if (node.name) {
        this.tokenChar(58);
        this.space();
    }
    
    this.print(node.typeAnnotation);
}

function InterfaceExtends2(node) {
    this.print(node.id);
    this.print(node.typeParameters, true);
}

function _interfaceish(node) {
    this.print(node.id);
    this.print(node.typeParameters);
    
    if (node.extends?.length) {
        this.space();
        this.word('extends');
        this.space();
        this.printList(node.extends);
    }
    
    if (node.type === 'DeclareClass') {
        if (node.mixins?.length) {
            this.space();
            this.word('mixins');
            this.space();
            this.printList(node.mixins);
        }
        
        if (node.implements?.length) {
            this.space();
            this.word('implements');
            this.space();
            this.printList(node.implements);
        }
    }
    
    this.space();
    this.print(node.body);
}

function _variance(node) {
    const kind = node.variance?.kind;
    
    if (kind != null) {
        if (kind === 'plus') {
            this.tokenChar(43);
        } else if (kind === 'minus') {
            this.tokenChar(45);
        }
    }
}

function InterfaceDeclaration2(node) {
    this.word('interface');
    this.space();
    this._interfaceish(node);
}

function andSeparator(occurrenceCount) {
    this.space();
    this.token('&', false, occurrenceCount);
    this.space();
}

function InterfaceTypeAnnotation2(node) {
    this.word('interface');
    
    if (node.extends?.length) {
        this.space();
        this.word('extends');
        this.space();
        this.printList(node.extends);
    }
    
    this.space();
    this.print(node.body);
}

function IntersectionTypeAnnotation2(node) {
    this.printJoin(node.types, void 0, void 0, andSeparator);
}

function MixedTypeAnnotation2() {
    this.word('mixed');
}

function EmptyTypeAnnotation2() {
    this.word('empty');
}

function NullableTypeAnnotation2(node) {
    this.tokenChar(63);
    this.print(node.typeAnnotation);
}

function NumberTypeAnnotation2() {
    this.word('number');
}

function StringTypeAnnotation2() {
    this.word('string');
}

function ThisTypeAnnotation2() {
    this.word('this');
}

function TupleTypeAnnotation2(node) {
    this.tokenChar(91);
    this.printList(node.types);
    this.tokenChar(93);
}

function TypeofTypeAnnotation2(node) {
    this.word('typeof');
    this.space();
    this.print(node.argument);
}

function TypeAlias2(node) {
    this.word('type');
    this.space();
    this.print(node.id);
    this.print(node.typeParameters);
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node.right);
    this.semicolon();
}

function TypeAnnotation2(node, parent) {
    this.tokenChar(58);
    this.space();
    
    if (parent.type === 'ArrowFunctionExpression') {
        this.tokenContext |= TokenContext.arrowFlowReturnType;
    } else if (node.optional) {
        this.tokenChar(63);
    }
    
    this.print(node.typeAnnotation);
}

function TypeParameterInstantiation2(node) {
    this.tokenChar(60);
    this.printList(node.params);
    this.tokenChar(62);
}

function TypeParameter2(node) {
    this._variance(node);
    this.word(node.name);
    
    if (node.bound) {
        this.print(node.bound);
    }
    
    if (node.default) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.default);
    }
}

function OpaqueType2(node) {
    this.word('opaque');
    this.space();
    this.word('type');
    this.space();
    this.print(node.id);
    this.print(node.typeParameters);
    
    if (node.supertype) {
        this.tokenChar(58);
        this.space();
        this.print(node.supertype);
    }
    
    if (node.impltype) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.impltype);
    }
    
    this.semicolon();
}

function ObjectTypeAnnotation2(node) {
    if (node.exact) {
        this.token('{|');
    } else {
        this.tokenChar(123);
    }
    
    const props = [
        ...node.properties,
        ...node.callProperties || [],
        ...node.indexers || [],
        ...node.internalSlots || [],
    ];
    
    if (props.length) {
        this.newline();
        this.space();
        this.printJoin(props, true, true, void 0, void 0, () => {
            if (props.length !== 1 || node.inexact) {
                this.tokenChar(44);
                this.space();
            }
        });
        this.space();
    }
    
    if (node.inexact) {
        this.indent();
        this.token('...');
        
        if (props.length) {
            this.newline();
        }
        
        this.dedent();
    }
    
    if (node.exact) {
        this.token('|}');
    } else {
        this.tokenChar(125);
    }
}

function ObjectTypeInternalSlot2(node) {
    if (node.static) {
        this.word('static');
        this.space();
    }
    
    this.tokenChar(91);
    this.tokenChar(91);
    this.print(node.id);
    this.tokenChar(93);
    this.tokenChar(93);
    
    if (node.optional)
        this.tokenChar(63);
    
    if (!node.method) {
        this.tokenChar(58);
        this.space();
    }
    
    this.print(node.value);
}

function ObjectTypeCallProperty2(node) {
    if (node.static) {
        this.word('static');
        this.space();
    }
    
    this.print(node.value);
}

function ObjectTypeIndexer2(node) {
    if (node.static) {
        this.word('static');
        this.space();
    }
    
    this._variance(node);
    this.tokenChar(91);
    
    if (node.id) {
        this.print(node.id);
        this.tokenChar(58);
        this.space();
    }
    
    this.print(node.key);
    this.tokenChar(93);
    this.tokenChar(58);
    this.space();
    this.print(node.value);
}

function ObjectTypeProperty2(node) {
    if (node.proto) {
        this.word('proto');
        this.space();
    }
    
    if (node.static) {
        this.word('static');
        this.space();
    }
    
    if (node.kind === 'get' || node.kind === 'set') {
        this.word(node.kind);
        this.space();
    }
    
    this._variance(node);
    this.print(node.key);
    
    if (node.optional)
        this.tokenChar(63);
    
    if (!node.method) {
        this.tokenChar(58);
        this.space();
    }
    
    this.print(node.value);
}

function ObjectTypeSpreadProperty2(node) {
    this.token('...');
    this.print(node.argument);
}

function QualifiedTypeIdentifier2(node) {
    this.print(node.qualification);
    this.tokenChar(46);
    this.print(node.id);
}

function SymbolTypeAnnotation2() {
    this.word('symbol');
}

function orSeparator(occurrenceCount) {
    this.space();
    this.token('|', false, occurrenceCount);
    this.space();
}

function UnionTypeAnnotation2(node) {
    this.printJoin(node.types, void 0, void 0, orSeparator);
}

function TypeCastExpression2(node) {
    this.tokenChar(40);
    this.print(node.expression);
    this.print(node.typeAnnotation);
    this.tokenChar(41);
}

function Variance2(node) {
    if (node.kind === 'plus') {
        this.tokenChar(43);
    } else {
        this.tokenChar(45);
    }
}

function VoidTypeAnnotation2() {
    this.word('void');
}

function IndexedAccessType2(node) {
    this.print(node.objectType, true);
    this.tokenChar(91);
    this.print(node.indexType);
    this.tokenChar(93);
}

function OptionalIndexedAccessType2(node) {
    this.print(node.objectType);
    
    if (node.optional) {
        this.token('?.');
    }
    
    this.tokenChar(91);
    this.print(node.indexType);
    this.tokenChar(93);
}

function File2(node) {
    if (node.program) {
        this.print(node.program.interpreter);
    }
    
    this.print(node.program);
}

function Program2(node) {
    this.noIndentInnerCommentsHere();
    this.printInnerComments();
    const directivesLen = node.directives?.length;
    
    if (directivesLen) {
        const newline = node.body.length ? 2 : 1;
        this.printSequence(node.directives, void 0, newline);
        
        if (!node.directives[directivesLen - 1].trailingComments?.length) {
            this.newline(newline);
        }
    }
    
    this.printSequence(node.body);
}

function BlockStatement2(node) {
    this.tokenChar(123);
    const exit = this.enterDelimited();
    const directivesLen = node.directives?.length;
    
    if (directivesLen) {
        const newline = node.body.length ? 2 : 1;
        this.printSequence(node.directives, true, newline);
        
        if (!node.directives[directivesLen - 1].trailingComments?.length) {
            this.newline(newline);
        }
    }
    
    this.printSequence(node.body, true);
    exit();
    this.rightBrace(node);
}

function Directive2(node) {
    this.print(node.value);
    this.semicolon();
}

var unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
var unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;

function DirectiveLiteral2(node) {
    const raw = this.getPossibleRaw(node);
    
    if (!this.format.minified && raw !== void 0) {
        this.token(raw);
        return;
    }
    
    const {value} = node;
    
    if (!unescapedDoubleQuoteRE.test(value)) {
        this.token(`"${value}"`);
    } else if (!unescapedSingleQuoteRE.test(value)) {
        this.token(`'${value}'`);
    } else {
        throw new Error('Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.');
    }
}

function InterpreterDirective2(node) {
    this.token(`#!${node.value}`);
    this.newline(1, true);
}

function Placeholder2(node) {
    this.token('%%');
    this.print(node.name);
    this.token('%%');
    
    if (node.expectedNode === 'Statement') {
        this.semicolon();
    }
}

function JSXAttribute2(node) {
    this.print(node.name);
    
    if (node.value) {
        this.tokenChar(61);
        this.print(node.value);
    }
}

function JSXIdentifier3(node) {
    this.word(node.name);
}

function JSXNamespacedName2(node) {
    this.print(node.namespace);
    this.tokenChar(58);
    this.print(node.name);
}

function JSXMemberExpression2(node) {
    this.print(node.object);
    this.tokenChar(46);
    this.print(node.property);
}

function JSXSpreadAttribute2(node) {
    this.tokenChar(123);
    this.token('...');
    this.print(node.argument);
    this.rightBrace(node);
}

function JSXExpressionContainer2(node) {
    this.tokenChar(123);
    this.print(node.expression);
    this.rightBrace(node);
}

function JSXSpreadChild2(node) {
    this.tokenChar(123);
    this.token('...');
    this.print(node.expression);
    this.rightBrace(node);
}

function JSXText3(node) {
    const raw = this.getPossibleRaw(node);
    
    if (raw !== void 0) {
        this.token(raw, true);
    } else {
        this.token(node.value, true);
    }
}

function JSXElement2(node) {
    const open = node.openingElement;
    this.print(open);
    
    if (open.selfClosing)
        return;
    
    this.indent();
    for (const child of node.children) {
        this.print(child);
    }
    
    this.dedent();
    this.print(node.closingElement);
}

function spaceSeparator() {
    this.space();
}

function JSXOpeningElement2(node) {
    this.tokenChar(60);
    this.print(node.name);
    this.print(node.typeArguments);
    
    if (node.attributes.length > 0) {
        this.space();
        this.printJoin(node.attributes, void 0, void 0, spaceSeparator);
    }
    
    if (node.selfClosing) {
        this.space();
        this.tokenChar(47);
    }
    
    this.tokenChar(62);
}

function JSXClosingElement2(node) {
    this.tokenChar(60);
    this.tokenChar(47);
    this.print(node.name);
    this.tokenChar(62);
}

function JSXEmptyExpression2() {
    this.printInnerComments();
}

function JSXFragment2(node) {
    this.print(node.openingFragment);
    this.indent();
    for (const child of node.children) {
        this.print(child);
    }
    
    this.dedent();
    this.print(node.closingFragment);
}

function JSXOpeningFragment2() {
    this.tokenChar(60);
    this.tokenChar(62);
}

function JSXClosingFragment2() {
    this.token('</');
    this.tokenChar(62);
}

function TSTypeAnnotation2(node, parent) {
    this.token((parent.type === 'TSFunctionType' || parent.type === 'TSConstructorType') && parent.returnType === node ? '=>' : ':');
    this.space();
    
    if (node.optional)
        this.tokenChar(63);
    
    this.print(node.typeAnnotation);
}

function TSTypeParameterInstantiation2(node, parent) {
    this.tokenChar(60);
    let printTrailingSeparator = parent.type === 'ArrowFunctionExpression' && node.params.length === 1;
    
    if (this.tokenMap && node.start != null && node.end != null) {
        printTrailingSeparator &&= !!this.tokenMap.find(node, (t) => this.tokenMap.matchesOriginal(t, ','));
        printTrailingSeparator ||= this.shouldPrintTrailingComma('>');
    }
    
    this.printList(node.params, printTrailingSeparator);
    this.tokenChar(62);
}

function TSTypeParameter2(node) {
    if (node.const) {
        this.word('const');
        this.space();
    }
    
    if (node.in) {
        this.word('in');
        this.space();
    }
    
    if (node.out) {
        this.word('out');
        this.space();
    }
    
    this.word(node.name.name);
    
    if (node.constraint) {
        this.space();
        this.word('extends');
        this.space();
        this.print(node.constraint);
    }
    
    if (node.default) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.default);
    }
}

function TSParameterProperty2(node) {
    if (node.accessibility) {
        this.word(node.accessibility);
        this.space();
    }
    
    if (node.readonly) {
        this.word('readonly');
        this.space();
    }
    
    this._param(node.parameter);
}

function TSDeclareFunction2(node, parent) {
    if (node.declare) {
        this.word('declare');
        this.space();
    }
    
    this._functionHead(node, parent);
    this.semicolon();
}

function TSDeclareMethod2(node) {
    this._classMethodHead(node);
    this.semicolon();
}

function TSQualifiedName2(node) {
    this.print(node.left);
    this.tokenChar(46);
    this.print(node.right);
}

function TSCallSignatureDeclaration2(node) {
    this.tsPrintSignatureDeclarationBase(node);
    maybePrintTrailingCommaOrSemicolon(this, node);
}

function maybePrintTrailingCommaOrSemicolon(printer, node) {
    if (!printer.tokenMap || !node.start || !node.end) {
        printer.semicolon();
        return;
    }
    
    if (printer.tokenMap.endMatches(node, ',')) {
        printer.token(',');
    } else if (printer.tokenMap.endMatches(node, ';')) {
        printer.semicolon();
    }
}

function TSConstructSignatureDeclaration2(node) {
    this.word('new');
    this.space();
    this.tsPrintSignatureDeclarationBase(node);
    maybePrintTrailingCommaOrSemicolon(this, node);
}

function TSPropertySignature2(node) {
    const {readonly} = node;
    
    if (readonly) {
        this.word('readonly');
        this.space();
    }
    
    this.tsPrintPropertyOrMethodName(node);
    this.print(node.typeAnnotation);
    maybePrintTrailingCommaOrSemicolon(this, node);
}

function tsPrintPropertyOrMethodName(node) {
    if (node.computed) {
        this.tokenChar(91);
    }
    
    this.print(node.key);
    
    if (node.computed) {
        this.tokenChar(93);
    }
    
    if (node.optional) {
        this.tokenChar(63);
    }
}

function TSMethodSignature2(node) {
    const {kind} = node;
    
    if (kind === 'set' || kind === 'get') {
        this.word(kind);
        this.space();
    }
    
    this.tsPrintPropertyOrMethodName(node);
    this.tsPrintSignatureDeclarationBase(node);
    maybePrintTrailingCommaOrSemicolon(this, node);
}

function TSIndexSignature2(node) {
    const {readonly, static: isStatic2} = node;
    
    if (isStatic2) {
        this.word('static');
        this.space();
    }
    
    if (readonly) {
        this.word('readonly');
        this.space();
    }
    
    this.tokenChar(91);
    this._parameters(node.parameters, ']');
    this.print(node.typeAnnotation);
    maybePrintTrailingCommaOrSemicolon(this, node);
}

function TSAnyKeyword2() {
    this.word('any');
}

function TSBigIntKeyword2() {
    this.word('bigint');
}

function TSUnknownKeyword2() {
    this.word('unknown');
}

function TSNumberKeyword2() {
    this.word('number');
}

function TSObjectKeyword2() {
    this.word('object');
}

function TSBooleanKeyword2() {
    this.word('boolean');
}

function TSStringKeyword2() {
    this.word('string');
}

function TSSymbolKeyword2() {
    this.word('symbol');
}

function TSVoidKeyword2() {
    this.word('void');
}

function TSUndefinedKeyword2() {
    this.word('undefined');
}

function TSNullKeyword2() {
    this.word('null');
}

function TSNeverKeyword2() {
    this.word('never');
}

function TSIntrinsicKeyword2() {
    this.word('intrinsic');
}

function TSThisType2() {
    this.word('this');
}

function TSFunctionType2(node) {
    this.tsPrintFunctionOrConstructorType(node);
}

function TSConstructorType2(node) {
    if (node.abstract) {
        this.word('abstract');
        this.space();
    }
    
    this.word('new');
    this.space();
    this.tsPrintFunctionOrConstructorType(node);
}

function tsPrintFunctionOrConstructorType(node) {
    const {typeParameters} = node;
    
    const parameters = node.params;
    this.print(typeParameters);
    this.tokenChar(40);
    this._parameters(parameters, ')');
    this.space();
    const returnType = node.returnType;
    this.print(returnType);
}

function TSTypeReference2(node) {
    const typeArguments = node.typeArguments;
    this.print(node.typeName, !!typeArguments);
    this.print(typeArguments);
}

function TSTypePredicate2(node) {
    if (node.asserts) {
        this.word('asserts');
        this.space();
    }
    
    this.print(node.parameterName);
    
    if (node.typeAnnotation) {
        this.space();
        this.word('is');
        this.space();
        this.print(node.typeAnnotation.typeAnnotation);
    }
}

function TSTypeQuery2(node) {
    this.word('typeof');
    this.space();
    this.print(node.exprName);
    const typeArguments = node.typeArguments;
    
    if (typeArguments) {
        this.print(typeArguments);
    }
}

function TSTypeLiteral2(node) {
    printBraced(this, node, () => this.printJoin(node.members, true, true));
}

function TSArrayType2(node) {
    this.print(node.elementType, true);
    this.tokenChar(91);
    this.tokenChar(93);
}

function TSTupleType2(node) {
    this.tokenChar(91);
    this.printList(node.elementTypes, this.shouldPrintTrailingComma(']'));
    this.tokenChar(93);
}

function TSOptionalType2(node) {
    this.print(node.typeAnnotation);
    this.tokenChar(63);
}

function TSRestType2(node) {
    this.token('...');
    this.print(node.typeAnnotation);
}

function TSNamedTupleMember2(node) {
    this.print(node.label);
    
    if (node.optional)
        this.tokenChar(63);
    
    this.tokenChar(58);
    this.space();
    this.print(node.elementType);
}

function TSUnionType2(node) {
    tsPrintUnionOrIntersectionType(this, node, '|');
}

function TSIntersectionType2(node) {
    tsPrintUnionOrIntersectionType(this, node, '&');
}

function tsPrintUnionOrIntersectionType(printer, node, sep) {
    let hasLeadingToken = 0;
    
    if (printer.tokenMap?.startMatches(node, sep)) {
        hasLeadingToken = 1;
        printer.token(sep);
    }
    
    printer.printJoin(node.types, void 0, void 0, function(i) {
        this.space();
        this.token(sep, void 0, i + hasLeadingToken);
        this.space();
    });
}

function TSConditionalType2(node) {
    this.print(node.checkType);
    this.space();
    this.word('extends');
    this.space();
    this.print(node.extendsType);
    this.space();
    this.tokenChar(63);
    this.space();
    this.print(node.trueType);
    this.space();
    this.tokenChar(58);
    this.space();
    this.print(node.falseType);
}

function TSInferType2(node) {
    this.word('infer');
    this.print(node.typeParameter);
}

function TSParenthesizedType2(node) {
    this.tokenChar(40);
    this.print(node.typeAnnotation);
    this.tokenChar(41);
}

function TSTypeOperator2(node) {
    this.word(node.operator);
    this.space();
    this.print(node.typeAnnotation);
}

function TSIndexedAccessType2(node) {
    this.print(node.objectType, true);
    this.tokenChar(91);
    this.print(node.indexType);
    this.tokenChar(93);
}

function TSMappedType2(node) {
    const {
        nameType,
        optional,
        readonly,
        typeAnnotation: typeAnnotation2,
    } = node;
    
    this.tokenChar(123);
    const exit = this.enterDelimited();
    this.space();
    
    if (readonly) {
        tokenIfPlusMinus(this, readonly);
        this.word('readonly');
        this.space();
    }
    
    this.tokenChar(91);
    this.word(node.key.name);
    this.space();
    this.word('in');
    this.space();
    this.print(node.constraint);
    
    if (nameType) {
        this.space();
        this.word('as');
        this.space();
        this.print(nameType);
    }
    
    this.tokenChar(93);
    
    if (optional) {
        tokenIfPlusMinus(this, optional);
        this.tokenChar(63);
    }
    
    if (typeAnnotation2) {
        this.tokenChar(58);
        this.space();
        this.print(typeAnnotation2);
    }
    
    this.space();
    exit();
    this.tokenChar(125);
}

function tokenIfPlusMinus(self, tok) {
    if (tok !== true) {
        self.token(tok);
    }
}

function TSTemplateLiteralType2(node) {
    this._printTemplate(node, node.types);
}

function TSLiteralType2(node) {
    this.print(node.literal);
}

function TSClassImplements2(node) {
    this.print(node.expression);
    this.print(node.typeArguments);
}

function TSInterfaceDeclaration2(node) {
    const {
        declare,
        id,
        typeParameters,
        extends: extendz,
        body,
    } = node;
    
    if (declare) {
        this.word('declare');
        this.space();
    }
    
    this.word('interface');
    this.space();
    this.print(id);
    this.print(typeParameters);
    
    if (extendz?.length) {
        this.space();
        this.word('extends');
        this.space();
        this.printList(extendz);
    }
    
    this.space();
    this.print(body);
}

function TSInterfaceBody2(node) {
    printBraced(this, node, () => this.printJoin(node.body, true, true));
}

function TSTypeAliasDeclaration2(node) {
    const {
        declare,
        id,
        typeParameters,
        typeAnnotation: typeAnnotation2,
    } = node;
    
    if (declare) {
        this.word('declare');
        this.space();
    }
    
    this.word('type');
    this.space();
    this.print(id);
    this.print(typeParameters);
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(typeAnnotation2);
    this.semicolon();
}

function TSTypeExpression2(node) {
    const {
        type,
        expression: expression2,
        typeAnnotation: typeAnnotation2,
    } = node;
    
    this.print(expression2, true);
    this.space();
    this.word(type === 'TSAsExpression' ? 'as' : 'satisfies');
    this.space();
    this.print(typeAnnotation2);
}

function TSTypeAssertion2(node) {
    const {typeAnnotation: typeAnnotation2, expression: expression2} = node;
    
    this.tokenChar(60);
    this.print(typeAnnotation2);
    this.tokenChar(62);
    this.space();
    this.print(expression2);
}

function TSInstantiationExpression2(node) {
    this.print(node.expression);
    this.print(node.typeArguments);
}

function TSEnumDeclaration2(node) {
    const {
        declare,
        const: isConst,
        id,
    } = node;
    
    if (declare) {
        this.word('declare');
        this.space();
    }
    
    if (isConst) {
        this.word('const');
        this.space();
    }
    
    this.word('enum');
    this.space();
    this.print(id);
    this.space();
    this.print(node.body);
}

function TSEnumBody2(node) {
    printBraced(this, node, () => this.printList(node.members, this.shouldPrintTrailingComma('}') ?? false, true, true));
}

function TSEnumMember2(node) {
    const {id, initializer} = node;
    
    this.print(id);
    
    if (initializer) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(initializer);
    }
}

function TSModuleDeclaration2(node) {
    const {declare, kind} = node;
    
    if (declare) {
        this.word('declare');
        this.space();
    }
    
    if (kind !== 'global') {
        this.word(kind);
        this.space();
    }
    
    this.print(node.id);
    
    if (!node.body) {
        this.semicolon();
        return;
    }
    
    this.space();
    this.print(node.body);
}

function TSModuleBlock2(node) {
    printBraced(this, node, () => this.printSequence(node.body, true));
}

function TSImportType2(node) {
    const {qualifier, options} = node;
    
    this.word('import');
    this.tokenChar(40);
    this.print(node.source);
    
    if (options) {
        this.tokenChar(44);
        this.print(options);
    }
    
    this.tokenChar(41);
    
    if (qualifier) {
        this.tokenChar(46);
        this.print(qualifier);
    }
    
    const typeArguments = node.typeArguments;
    
    if (typeArguments) {
        this.print(typeArguments);
    }
}

function TSImportEqualsDeclaration2(node) {
    const {
        id,
        moduleReference,
    } = node;
    
    this.word('import');
    this.space();
    this.print(id);
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(moduleReference);
    this.semicolon();
}

function TSExternalModuleReference2(node) {
    this.token('require(');
    this.print(node.expression);
    this.tokenChar(41);
}

function TSNonNullExpression2(node) {
    this.print(node.expression);
    this.tokenChar(33);
}

function TSExportAssignment2(node) {
    this.word('export');
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node.expression);
    this.semicolon();
}

function TSNamespaceExportDeclaration2(node) {
    this.word('export');
    this.space();
    this.word('as');
    this.space();
    this.word('namespace');
    this.space();
    this.print(node.id);
    this.semicolon();
}

function tsPrintSignatureDeclarationBase(node) {
    const {typeParameters} = node;
    
    const parameters = node.params;
    this.print(typeParameters);
    this.tokenChar(40);
    this._parameters(parameters, ')');
    const returnType = node.returnType;
    this.print(returnType);
}

function tsPrintClassMemberModifiers(node) {
    const isPrivateField = node.type === 'ClassPrivateProperty';
    const isPublicField = node.type === 'ClassAccessorProperty' || node.type === 'ClassProperty';
    printModifiersList(this, node, [isPublicField && node.declare && 'declare', !isPrivateField && node.accessibility]);
    
    if (node.static) {
        this.word('static');
        this.space();
    }
    
    printModifiersList(this, node, [!isPrivateField && node.abstract && 'abstract', !isPrivateField && node.override && 'override', (isPublicField || isPrivateField) && node.readonly && 'readonly']);
}

function printBraced(printer, node, cb) {
    printer.token('{');
    const exit = printer.enterDelimited();
    cb();
    exit();
    printer.rightBrace(node);
}

function printModifiersList(printer, node, modifiers) {
    const modifiersSet =     /* @__PURE__ */new Set();
    
    for (const modifier of modifiers) {
        if (modifier)
            modifiersSet.add(modifier);
    }
    
    printer.tokenMap?.find(node, (tok) => {
        if (modifiersSet.has(tok.value)) {
            printer.token(tok.value);
            printer.space();
            modifiersSet.delete(tok.value);
            
            return modifiersSet.size === 0;
        }
        
        return false;
    });
    
    for (const modifier of modifiersSet) {
        printer.word(modifier);
        printer.space();
    }
}

var generatorFunctions = /* @__PURE__ */Object.freeze({
    __proto__: null,
    AnyTypeAnnotation: AnyTypeAnnotation2,
    ArgumentPlaceholder: ArgumentPlaceholder2,
    ArrayExpression: ArrayExpression2,
    ArrayPattern: ArrayExpression2,
    ArrayTypeAnnotation: ArrayTypeAnnotation2,
    ArrowFunctionExpression: ArrowFunctionExpression2,
    AssignmentExpression: AssignmentExpression2,
    AssignmentPattern: AssignmentPattern2,
    AwaitExpression: AwaitExpression2,
    BigIntLiteral: BigIntLiteral2,
    BinaryExpression: AssignmentExpression2,
    BindExpression: BindExpression2,
    BlockStatement: BlockStatement2,
    BooleanLiteral: BooleanLiteral2,
    BooleanLiteralTypeAnnotation: BooleanLiteralTypeAnnotation2,
    BooleanTypeAnnotation: BooleanTypeAnnotation2,
    BreakStatement: BreakStatement2,
    CallExpression: CallExpression2,
    CatchClause: CatchClause2,
    ClassAccessorProperty: ClassAccessorProperty2,
    ClassBody: ClassBody2,
    ClassDeclaration: ClassDeclaration2,
    ClassExpression: ClassDeclaration2,
    ClassImplements: InterfaceExtends2,
    ClassMethod: ClassMethod2,
    ClassPrivateMethod: ClassPrivateMethod2,
    ClassPrivateProperty: ClassPrivateProperty2,
    ClassProperty: ClassProperty2,
    ConditionalExpression: ConditionalExpression2,
    ContinueStatement: ContinueStatement2,
    DebuggerStatement: DebuggerStatement2,
    DeclareClass: DeclareClass2,
    DeclareExportAllDeclaration: DeclareExportAllDeclaration2,
    DeclareExportDeclaration: DeclareExportDeclaration2,
    DeclareFunction: DeclareFunction2,
    DeclareInterface: DeclareInterface2,
    DeclareModule: DeclareModule2,
    DeclareModuleExports: DeclareModuleExports2,
    DeclareOpaqueType: DeclareOpaqueType2,
    DeclareTypeAlias: DeclareTypeAlias2,
    DeclareVariable: DeclareVariable2,
    DeclaredPredicate: DeclaredPredicate2,
    Decorator: Decorator2,
    Directive: Directive2,
    DirectiveLiteral: DirectiveLiteral2,
    DoExpression: DoExpression2,
    DoWhileStatement: DoWhileStatement2,
    EmptyStatement: EmptyStatement2,
    EmptyTypeAnnotation: EmptyTypeAnnotation2,
    EnumBooleanBody: EnumBooleanBody2,
    EnumBooleanMember: EnumBooleanMember2,
    EnumDeclaration: EnumDeclaration2,
    EnumDefaultedMember: EnumDefaultedMember2,
    EnumNumberBody: EnumNumberBody2,
    EnumNumberMember: EnumNumberMember2,
    EnumStringBody: EnumStringBody2,
    EnumStringMember: EnumStringMember2,
    EnumSymbolBody: EnumSymbolBody2,
    ExistsTypeAnnotation: ExistsTypeAnnotation2,
    ExportAllDeclaration: ExportAllDeclaration2,
    ExportDefaultDeclaration: ExportDefaultDeclaration2,
    ExportDefaultSpecifier: ExportDefaultSpecifier2,
    ExportNamedDeclaration: ExportNamedDeclaration2,
    ExportNamespaceSpecifier: ExportNamespaceSpecifier2,
    ExportSpecifier: ExportSpecifier2,
    ExpressionStatement: ExpressionStatement2,
    File: File2,
    ForInStatement: ForInStatement2,
    ForOfStatement: ForOfStatement2,
    ForStatement: ForStatement2,
    FunctionDeclaration: FunctionExpression2,
    FunctionExpression: FunctionExpression2,
    FunctionTypeAnnotation: FunctionTypeAnnotation2,
    FunctionTypeParam: FunctionTypeParam2,
    GenericTypeAnnotation: InterfaceExtends2,
    Identifier: Identifier3,
    IfStatement: IfStatement2,
    Import: Import2,
    ImportAttribute: ImportAttribute2,
    ImportDeclaration: ImportDeclaration2,
    ImportDefaultSpecifier: ImportDefaultSpecifier2,
    ImportExpression: ImportExpression2,
    ImportNamespaceSpecifier: ImportNamespaceSpecifier2,
    ImportSpecifier: ImportSpecifier2,
    IndexedAccessType: IndexedAccessType2,
    InferredPredicate: InferredPredicate2,
    InterfaceDeclaration: InterfaceDeclaration2,
    InterfaceExtends: InterfaceExtends2,
    InterfaceTypeAnnotation: InterfaceTypeAnnotation2,
    InterpreterDirective: InterpreterDirective2,
    IntersectionTypeAnnotation: IntersectionTypeAnnotation2,
    JSXAttribute: JSXAttribute2,
    JSXClosingElement: JSXClosingElement2,
    JSXClosingFragment: JSXClosingFragment2,
    JSXElement: JSXElement2,
    JSXEmptyExpression: JSXEmptyExpression2,
    JSXExpressionContainer: JSXExpressionContainer2,
    JSXFragment: JSXFragment2,
    JSXIdentifier: JSXIdentifier3,
    JSXMemberExpression: JSXMemberExpression2,
    JSXNamespacedName: JSXNamespacedName2,
    JSXOpeningElement: JSXOpeningElement2,
    JSXOpeningFragment: JSXOpeningFragment2,
    JSXSpreadAttribute: JSXSpreadAttribute2,
    JSXSpreadChild: JSXSpreadChild2,
    JSXText: JSXText3,
    LabeledStatement: LabeledStatement2,
    LogicalExpression: AssignmentExpression2,
    MemberExpression: MemberExpression2,
    MetaProperty: MetaProperty2,
    MixedTypeAnnotation: MixedTypeAnnotation2,
    ModuleExpression: ModuleExpression2,
    NewExpression: NewExpression2,
    NullLiteral: NullLiteral2,
    NullLiteralTypeAnnotation: NullLiteralTypeAnnotation2,
    NullableTypeAnnotation: NullableTypeAnnotation2,
    NumberLiteralTypeAnnotation: NumericLiteral3,
    NumberTypeAnnotation: NumberTypeAnnotation2,
    NumericLiteral: NumericLiteral3,
    ObjectExpression: ObjectExpression2,
    ObjectMethod: ObjectMethod2,
    ObjectPattern: ObjectExpression2,
    ObjectProperty: ObjectProperty2,
    ObjectTypeAnnotation: ObjectTypeAnnotation2,
    ObjectTypeCallProperty: ObjectTypeCallProperty2,
    ObjectTypeIndexer: ObjectTypeIndexer2,
    ObjectTypeInternalSlot: ObjectTypeInternalSlot2,
    ObjectTypeProperty: ObjectTypeProperty2,
    ObjectTypeSpreadProperty: ObjectTypeSpreadProperty2,
    OpaqueType: OpaqueType2,
    OptionalCallExpression: OptionalCallExpression2,
    OptionalIndexedAccessType: OptionalIndexedAccessType2,
    OptionalMemberExpression: OptionalMemberExpression2,
    ParenthesizedExpression: ParenthesizedExpression2,
    PipelineBareFunction: PipelineBareFunction2,
    PipelinePrimaryTopicReference: PipelinePrimaryTopicReference2,
    PipelineTopicExpression: PipelineTopicExpression2,
    Placeholder: Placeholder2,
    PrivateName: PrivateName2,
    Program: Program2,
    QualifiedTypeIdentifier: QualifiedTypeIdentifier2,
    RegExpLiteral: RegExpLiteral2,
    RestElement: RestElement2,
    ReturnStatement: ReturnStatement2,
    SequenceExpression: SequenceExpression2,
    SpreadElement: RestElement2,
    StaticBlock: StaticBlock2,
    StringLiteral: StringLiteral3,
    StringLiteralTypeAnnotation: StringLiteral3,
    StringTypeAnnotation: StringTypeAnnotation2,
    Super: Super2,
    SwitchCase: SwitchCase2,
    SwitchStatement: SwitchStatement2,
    SymbolTypeAnnotation: SymbolTypeAnnotation2,
    TSAnyKeyword: TSAnyKeyword2,
    TSArrayType: TSArrayType2,
    TSAsExpression: TSTypeExpression2,
    TSBigIntKeyword: TSBigIntKeyword2,
    TSBooleanKeyword: TSBooleanKeyword2,
    TSCallSignatureDeclaration: TSCallSignatureDeclaration2,
    TSClassImplements: TSClassImplements2,
    TSConditionalType: TSConditionalType2,
    TSConstructSignatureDeclaration: TSConstructSignatureDeclaration2,
    TSConstructorType: TSConstructorType2,
    TSDeclareFunction: TSDeclareFunction2,
    TSDeclareMethod: TSDeclareMethod2,
    TSEnumBody: TSEnumBody2,
    TSEnumDeclaration: TSEnumDeclaration2,
    TSEnumMember: TSEnumMember2,
    TSExportAssignment: TSExportAssignment2,
    TSExternalModuleReference: TSExternalModuleReference2,
    TSFunctionType: TSFunctionType2,
    TSImportEqualsDeclaration: TSImportEqualsDeclaration2,
    TSImportType: TSImportType2,
    TSIndexSignature: TSIndexSignature2,
    TSIndexedAccessType: TSIndexedAccessType2,
    TSInferType: TSInferType2,
    TSInstantiationExpression: TSInstantiationExpression2,
    TSInterfaceBody: TSInterfaceBody2,
    TSInterfaceDeclaration: TSInterfaceDeclaration2,
    TSInterfaceHeritage: TSClassImplements2,
    TSIntersectionType: TSIntersectionType2,
    TSIntrinsicKeyword: TSIntrinsicKeyword2,
    TSLiteralType: TSLiteralType2,
    TSMappedType: TSMappedType2,
    TSMethodSignature: TSMethodSignature2,
    TSModuleBlock: TSModuleBlock2,
    TSModuleDeclaration: TSModuleDeclaration2,
    TSNamedTupleMember: TSNamedTupleMember2,
    TSNamespaceExportDeclaration: TSNamespaceExportDeclaration2,
    TSNeverKeyword: TSNeverKeyword2,
    TSNonNullExpression: TSNonNullExpression2,
    TSNullKeyword: TSNullKeyword2,
    TSNumberKeyword: TSNumberKeyword2,
    TSObjectKeyword: TSObjectKeyword2,
    TSOptionalType: TSOptionalType2,
    TSParameterProperty: TSParameterProperty2,
    TSParenthesizedType: TSParenthesizedType2,
    TSPropertySignature: TSPropertySignature2,
    TSQualifiedName: TSQualifiedName2,
    TSRestType: TSRestType2,
    TSSatisfiesExpression: TSTypeExpression2,
    TSStringKeyword: TSStringKeyword2,
    TSSymbolKeyword: TSSymbolKeyword2,
    TSTemplateLiteralType: TSTemplateLiteralType2,
    TSThisType: TSThisType2,
    TSTupleType: TSTupleType2,
    TSTypeAliasDeclaration: TSTypeAliasDeclaration2,
    TSTypeAnnotation: TSTypeAnnotation2,
    TSTypeAssertion: TSTypeAssertion2,
    TSTypeLiteral: TSTypeLiteral2,
    TSTypeOperator: TSTypeOperator2,
    TSTypeParameter: TSTypeParameter2,
    TSTypeParameterDeclaration: TSTypeParameterInstantiation2,
    TSTypeParameterInstantiation: TSTypeParameterInstantiation2,
    TSTypePredicate: TSTypePredicate2,
    TSTypeQuery: TSTypeQuery2,
    TSTypeReference: TSTypeReference2,
    TSUndefinedKeyword: TSUndefinedKeyword2,
    TSUnionType: TSUnionType2,
    TSUnknownKeyword: TSUnknownKeyword2,
    TSVoidKeyword: TSVoidKeyword2,
    TaggedTemplateExpression: TaggedTemplateExpression2,
    TemplateElement: TemplateElement2,
    TemplateLiteral: TemplateLiteral2,
    ThisExpression: ThisExpression2,
    ThisTypeAnnotation: ThisTypeAnnotation2,
    ThrowStatement: ThrowStatement2,
    TopicReference: TopicReference2,
    TryStatement: TryStatement2,
    TupleTypeAnnotation: TupleTypeAnnotation2,
    TypeAlias: TypeAlias2,
    TypeAnnotation: TypeAnnotation2,
    TypeCastExpression: TypeCastExpression2,
    TypeParameter: TypeParameter2,
    TypeParameterDeclaration: TypeParameterInstantiation2,
    TypeParameterInstantiation: TypeParameterInstantiation2,
    TypeofTypeAnnotation: TypeofTypeAnnotation2,
    UnaryExpression: UnaryExpression2,
    UnionTypeAnnotation: UnionTypeAnnotation2,
    UpdateExpression: UpdateExpression2,
    V8IntrinsicIdentifier: V8IntrinsicIdentifier2,
    VariableDeclaration: VariableDeclaration2,
    VariableDeclarator: VariableDeclarator2,
    Variance: Variance2,
    VoidPattern: VoidPattern2,
    VoidTypeAnnotation: VoidTypeAnnotation2,
    WhileStatement: WhileStatement2,
    WithStatement: WithStatement2,
    YieldExpression: YieldExpression2,
    _classMethodHead,
    _functionHead,
    _getRawIdentifier,
    _interfaceish,
    _methodHead,
    _param,
    _parameters,
    _params,
    _predicate,
    _printAttributes,
    _printTemplate,
    _shouldPrintArrowParamsParens,
    _shouldPrintDecoratorsBeforeExport,
    _variance,
    tsPrintClassMemberModifiers,
    tsPrintFunctionOrConstructorType,
    tsPrintPropertyOrMethodName,
    tsPrintSignatureDeclarationBase,
});

var {
    isExpression: isExpression2,
    isFunction: isFunction3,
    isStatement: isStatement3,
    isClassBody: isClassBody2,
    isTSInterfaceBody: isTSInterfaceBody2,
    isTSEnumMember: isTSEnumMember2,
} = lib_exports;

var SCIENTIFIC_NOTATION = /e/i;
var ZERO_DECIMAL_INTEGER = /\.0+$/;
var HAS_NEWLINE = /[\n\r\u2028\u2029]/;
var HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\n\r\u2028\u2029]|\*\//;

function commentIsNewline(c) {
    return c.type === 'CommentLine' || HAS_NEWLINE.test(c.value);
}

var {needsParens} = n;

var Printer = class {
    constructor(format, map, tokens = null, originalCode = null) {
        this.format = format;
        this._tokens = tokens;
        this._originalCode = originalCode;
        this._indentRepeat = format.indent.style.length;
        this._inputMap = map?._inputMap || null;
        this._buf = new Buffer2(map, format.indent.style[0]);
    }
    
    enterForStatementInit() {
        this.tokenContext |= TokenContext.forInitHead | TokenContext.forInOrInitHeadAccumulate;
        return () => this.tokenContext = TokenContext.normal;
    }
    
    enterForXStatementInit(isForOf) {
        if (isForOf) {
            this.tokenContext |= TokenContext.forOfHead;
            return null;
        } else {
            this.tokenContext |= TokenContext.forInHead | TokenContext.forInOrInitHeadAccumulate;
            return () => this.tokenContext = TokenContext.normal;
        }
    }
    
    enterDelimited() {
        const oldTokenContext = this.tokenContext;
        const oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
        
        if (!(oldTokenContext & TokenContext.forInOrInitHeadAccumulate) && oldNoLineTerminatorAfterNode === null) {
            return () => {};
        }
        
        this._noLineTerminatorAfterNode = null;
        this.tokenContext = TokenContext.normal;
        return () => {
            this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
            this.tokenContext = oldTokenContext;
        };
    }
    
    tokenContext = TokenContext.normal;
    _tokens = null;
    _originalCode = null;
    _currentNode = null;
    _indent = 0;
    _indentRepeat = 0;
    _insideAux = false;
    _noLineTerminator = false;
    _noLineTerminatorAfterNode = null;
    _printAuxAfterOnNextUserNode = false;
    _printedComments =     /* @__PURE__ */new Set();
    _endsWithInteger = false;
    _endsWithWord = false;
    _endsWithDiv = false;
    _lastCommentLine = 0;
    _endsWithInnerRaw = false;
    _indentInnerComments = true;
    tokenMap = null;
    _boundGetRawIdentifier = this._getRawIdentifier.bind(this);
    generate(ast) {
        if (this.format.preserveFormat) {
            this.tokenMap = new TokenMap(ast, this._tokens, this._originalCode);
        }
        
        this.print(ast);
        this._maybeAddAuxComment();
        return this._buf.get();
    }
    
    indent() {
        const {format} = this;
        
        if (format.preserveFormat || format.compact || format.concise) {
            return;
        }
        
        this._indent++;
    }
    
    dedent() {
        const {format} = this;
        
        if (format.preserveFormat || format.compact || format.concise) {
            return;
        }
        
        this._indent--;
    }
    
    _printSemicolonBeforeNextNode = -1;
    _printSemicolonBeforeNextToken = -1;
    semicolon(force = false) {
        this._maybeAddAuxComment();
        
        if (force) {
            this._appendChar(59);
            this._noLineTerminator = false;
            return;
        }
        
        if (this.tokenMap) {
            const node = this._currentNode;
            
            if (node.start != null && node.end != null) {
                if (!this.tokenMap.endMatches(node, ';')) {
                    this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();
                    return;
                }
                
                const indexes = this.tokenMap.getIndexes(this._currentNode);
                this._catchUpTo(this._tokens[indexes[indexes.length - 1]].loc.start);
            }
        }
        
        this._queue(59);
        this._noLineTerminator = false;
    }
    
    rightBrace(node) {
        if (this.format.minified) {
            this._buf.removeLastSemicolon();
        }
        
        this.sourceWithOffset('end', node.loc, -1);
        this.tokenChar(125);
    }
    
    rightParens(node) {
        this.sourceWithOffset('end', node.loc, -1);
        this.tokenChar(41);
    }
    
    space(force = false) {
        const {format} = this;
        
        if (format.compact || format.preserveFormat)
            return;
        
        if (force) {
            this._space();
        } else if (this._buf.hasContent()) {
            const lastCp = this.getLastChar();
            
            if (lastCp !== 32 && lastCp !== 10) {
                this._space();
            }
        }
    }
    
    word(str, noLineTerminatorAfter = false) {
        this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;
        this._maybePrintInnerComments(str);
        this._maybeAddAuxComment();
        
        if (this.tokenMap)
            this._catchUpToCurrentToken(str);
        
        if (this._endsWithWord || this._endsWithDiv && str.charCodeAt(0) === 47) {
            this._space();
        }
        
        this._append(str, false);
        this._endsWithWord = true;
        this._noLineTerminator = noLineTerminatorAfter;
    }
    
    number(str, number) {
        function isNonDecimalLiteral(str2) {
            if (str2.length > 2 && str2.charCodeAt(0) === 48) {
                const secondChar = str2.charCodeAt(1);
                return secondChar === 98 || secondChar === 111 || secondChar === 120;
            }
            
            return false;
        }
        
        this.word(str);
        this._endsWithInteger = Number.isInteger(number) && !isNonDecimalLiteral(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;
    }
    
    token(str, maybeNewline = false, occurrenceCount = 0) {
        this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;
        this._maybePrintInnerComments(str, occurrenceCount);
        this._maybeAddAuxComment();
        
        if (this.tokenMap)
            this._catchUpToCurrentToken(str, occurrenceCount);
        
        const lastChar = this.getLastChar();
        const strFirst = str.charCodeAt(0);
        
        if (lastChar === 33 && (str === '--' || strFirst === 61) || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {
            this._space();
        }
        
        this._append(str, maybeNewline);
        this._noLineTerminator = false;
    }
    
    tokenChar(char) {
        this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;
        const str = String.fromCharCode(char);
        this._maybePrintInnerComments(str);
        this._maybeAddAuxComment();
        
        if (this.tokenMap)
            this._catchUpToCurrentToken(str);
        
        const lastChar = this.getLastChar();
        
        if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {
            this._space();
        }
        
        this._appendChar(char);
        this._noLineTerminator = false;
    }
    
    newline(i = 1, force) {
        if (i <= 0)
            return;
        
        if (!force) {
            if (this.format.retainLines || this.format.compact)
                return;
            
            if (this.format.concise) {
                this.space();
                return;
            }
        }
        
        if (i > 2)
            i = 2;
        
        i -= this._buf.getNewlineCount();
        for (let j = 0; j < i; j++) {
            this._newline();
        }
        
        return;
    }
    
    endsWith(char) {
        return this.getLastChar() === char;
    }
    
    getLastChar() {
        return this._buf.getLastChar();
    }
    
    endsWithCharAndNewline() {
        return this._buf.endsWithCharAndNewline();
    }
    
    removeTrailingNewline() {
        this._buf.removeTrailingNewline();
    }
    
    exactSource(loc, cb) {
        if (!loc) {
            cb();
            return;
        }
        
        this._catchUp('start', loc);
        this._buf.exactSource(loc, cb);
    }
    
    source(prop, loc) {
        if (!loc)
            return;
        
        this._catchUp(prop, loc);
        this._buf.source(prop, loc);
    }
    
    sourceWithOffset(prop, loc, columnOffset) {
        if (!loc || this.format.preserveFormat)
            return;
        
        this._catchUp(prop, loc);
        this._buf.sourceWithOffset(prop, loc, columnOffset);
    }
    
    sourceIdentifierName(identifierName, pos) {
        if (!this._buf._canMarkIdName)
            return;
        
        const sourcePosition = this._buf._sourcePosition;
        
        sourcePosition.identifierNamePos = pos;
        sourcePosition.identifierName = identifierName;
    }
    
    _space() {
        this._queue(32);
    }
    
    _newline() {
        this._queue(10);
    }
    
    _catchUpToCurrentToken(str, occurrenceCount = 0) {
        const token = this.tokenMap.findMatching(this._currentNode, str, occurrenceCount);
        
        if (token)
            this._catchUpTo(token.loc.start);
        
        if (this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine()) {
            this._buf.appendChar(59);
            this._endsWithWord = false;
            this._endsWithInteger = false;
            this._endsWithDiv = false;
        }
        
        this._printSemicolonBeforeNextToken = -1;
        this._printSemicolonBeforeNextNode = -1;
    }
    
    _append(str, maybeNewline) {
        this._maybeIndent(str.charCodeAt(0));
        this._buf.append(str, maybeNewline);
        this._endsWithWord = false;
        this._endsWithInteger = false;
        this._endsWithDiv = false;
    }
    
    _appendChar(char) {
        this._maybeIndent(char);
        this._buf.appendChar(char);
        this._endsWithWord = false;
        this._endsWithInteger = false;
        this._endsWithDiv = false;
    }
    
    _queue(char) {
        this._maybeIndent(char);
        this._buf.queue(char);
        this._endsWithWord = false;
        this._endsWithInteger = false;
    }
    
    _maybeIndent(firstChar) {
        if (this._indent && firstChar !== 10 && this.endsWith(10)) {
            this._buf.queueIndentation(this._getIndent());
        }
    }
    
    _shouldIndent(firstChar) {
        if (this._indent && firstChar !== 10 && this.endsWith(10)) {
            return true;
        }
    }
    
    catchUp(line) {
        if (!this.format.retainLines)
            return;
        
        const count = line - this._buf.getCurrentLine();
        
        for (let i = 0; i < count; i++) {
            this._newline();
        }
    }
    
    _catchUp(prop, loc) {
        const {format} = this;
        
        if (!format.preserveFormat) {
            if (format.retainLines && loc?.[prop]) {
                this.catchUp(loc[prop].line);
            }
            
            return;
        }
        
        const pos = loc?.[prop];
        
        if (pos != null)
            this._catchUpTo(pos);
    }
    
    _catchUpTo({line, column, index: index2}) {
        const count = line - this._buf.getCurrentLine();
        
        if (count > 0 && this._noLineTerminator) {
            return;
        }
        
        for (let i = 0; i < count; i++) {
            this._newline();
        }
        
        const spacesCount = count > 0 ? column : column - this._buf.getCurrentColumn();
        
        if (spacesCount > 0) {
            const spaces = this._originalCode ? this
                ._originalCode
                .slice(index2 - spacesCount, index2)
                .replace(/[^\t\v\f\uFEFF\p{Space_Separator}]/gu, ' ') : ' '.repeat(spacesCount);
            this._append(spaces, false);
        }
    }
    
    _getIndent() {
        return this._indentRepeat * this._indent;
    }
    
    printTerminatorless(node) {
        this._noLineTerminator = true;
        this.print(node);
    }
    
    print(node, noLineTerminatorAfter = false, trailingCommentsLineOffset) {
        if (!node)
            return;
        
        this._endsWithInnerRaw = false;
        const nodeType = node.type;
        const format = this.format;
        const oldConcise = format.concise;
        
        if (node._compact) {
            format.concise = true;
        }
        
        const printMethod = this[nodeType];
        
        if (printMethod === void 0) {
            throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node.constructor.name)}`);
        }
        
        const parent = this._currentNode;
        
        this._currentNode = node;
        
        if (this.tokenMap) {
            this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode;
        }
        
        const oldInAux = this._insideAux;
        
        this._insideAux = node.loc == null;
        this._maybeAddAuxComment(this._insideAux && !oldInAux);
        const parenthesized = node.extra?.parenthesized;
        let shouldPrintParens = parenthesized
            && format.preserveFormat
            || parenthesized
            && format.retainFunctionParens
            && nodeType === 'FunctionExpression'
            || needsParens(node, parent, this.tokenContext, format.preserveFormat ? this._boundGetRawIdentifier : void 0);
        
        if (!shouldPrintParens && parenthesized && node.leadingComments?.length && node.leadingComments[0].type === 'CommentBlock') {
            const parentType = parent?.type;
            
            switch(parentType) {
            case 'ExpressionStatement':            
            case 'VariableDeclarator':            
            case 'AssignmentExpression':            
            case 'ReturnStatement':
                break;
            
            case 'CallExpression':            
            case 'OptionalCallExpression':            
            case 'NewExpression':
                if (parent.callee !== node)
                    break;
            
            default:
                shouldPrintParens = true;
            }
        }
        
        let indentParenthesized = false;
        
        if (!shouldPrintParens && this._noLineTerminator && (node.leadingComments?.some(commentIsNewline) || this.format.retainLines && node.loc && node.loc.start.line > this._buf.getCurrentLine())) {
            shouldPrintParens = true;
            indentParenthesized = true;
        }
        
        let oldNoLineTerminatorAfterNode;
        let oldTokenContext;
        
        if (!shouldPrintParens) {
            noLineTerminatorAfter ||= !!parent && this._noLineTerminatorAfterNode === parent && isLastChild(parent, node);
            
            if (noLineTerminatorAfter) {
                if (node.trailingComments?.some(commentIsNewline)) {
                    if (isExpression2(node))
                        shouldPrintParens = true;
                } else {
                    oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
                    this._noLineTerminatorAfterNode = node;
                }
            }
        }
        
        if (shouldPrintParens) {
            this.tokenChar(40);
            
            if (indentParenthesized)
                this.indent();
            
            this._endsWithInnerRaw = false;
            
            if (this.tokenContext & TokenContext.forInOrInitHeadAccumulate) {
                oldTokenContext = this.tokenContext;
                this.tokenContext = TokenContext.normal;
            }
            
            oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
            this._noLineTerminatorAfterNode = null;
        }
        
        this._lastCommentLine = 0;
        this._printLeadingComments(node, parent);
        const loc = nodeType === 'Program' || nodeType === 'File' ? null : node.loc;
        this.exactSource(loc, printMethod.bind(this, node, parent));
        
        if (shouldPrintParens) {
            this._printTrailingComments(node, parent);
            
            if (indentParenthesized) {
                this.dedent();
                this.newline();
            }
            
            this.tokenChar(41);
            this._noLineTerminator = noLineTerminatorAfter;
            
            if (oldTokenContext)
                this.tokenContext = oldTokenContext;
        } else if (noLineTerminatorAfter && !this._noLineTerminator) {
            this._noLineTerminator = true;
            this._printTrailingComments(node, parent);
        } else {
            this._printTrailingComments(node, parent, trailingCommentsLineOffset);
        }
        
        this._currentNode = parent;
        format.concise = oldConcise;
        this._insideAux = oldInAux;
        
        if (oldNoLineTerminatorAfterNode !== void 0) {
            this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
        }
        
        this._endsWithInnerRaw = false;
    }
    
    _maybeAddAuxComment(enteredPositionlessNode) {
        if (enteredPositionlessNode)
            this._printAuxBeforeComment();
        
        if (!this._insideAux)
            this._printAuxAfterComment();
    }
    
    _printAuxBeforeComment() {
        if (this._printAuxAfterOnNextUserNode)
            return;
        
        this._printAuxAfterOnNextUserNode = true;
        const comment = this.format.auxiliaryCommentBefore;
        
        if (comment) {
            this._printComment({
                type: 'CommentBlock',
                value: comment,
            }, 0);
        }
    }
    
    _printAuxAfterComment() {
        if (!this._printAuxAfterOnNextUserNode)
            return;
        
        this._printAuxAfterOnNextUserNode = false;
        const comment = this.format.auxiliaryCommentAfter;
        
        if (comment) {
            this._printComment({
                type: 'CommentBlock',
                value: comment,
            }, 0);
        }
    }
    
    getPossibleRaw(node) {
        const extra = node.extra;
        
        if (extra?.raw != null && extra.rawValue != null && node.value === extra.rawValue) {
            return extra.raw;
        }
    }
    
    printJoin(nodes2, statement2, indent, separator, printTrailingSeparator, iterator, trailingCommentsLineOffset) {
        if (!nodes2?.length)
            return;
        
        if (indent == null && this.format.retainLines) {
            const startLine = nodes2[0].loc?.start.line;
            
            if (startLine != null && startLine !== this._buf.getCurrentLine()) {
                indent = true;
            }
        }
        
        if (indent)
            this.indent();
        
        const newlineOpts = {
            nextNodeStartLine: 0,
        };
        
        const boundSeparator = separator?.bind(this);
        const len = nodes2.length;
        
        for (let i = 0; i < len; i++) {
            const node = nodes2[i];
            
            if (!node)
                continue;
            
            if (statement2)
                this._printNewline(i === 0, newlineOpts);
            
            this.print(node, void 0, trailingCommentsLineOffset || 0);
            iterator?.(node, i);
            
            if (boundSeparator != null) {
                if (i < len - 1)
                    boundSeparator(i, false);
                else if (printTrailingSeparator)
                    boundSeparator(i, true);
            }
            
            if (statement2) {
                if (!node.trailingComments?.length) {
                    this._lastCommentLine = 0;
                }
                
                if (i + 1 === len) {
                    this.newline(1);
                } else {
                    const nextNode = nodes2[i + 1];
                    
                    newlineOpts.nextNodeStartLine = nextNode.loc?.start.line || 0;
                    this._printNewline(true, newlineOpts);
                }
            }
        }
        
        if (indent)
            this.dedent();
    }
    
    printAndIndentOnComments(node) {
        const indent = node.leadingComments && node.leadingComments.length > 0;
        
        if (indent)
            this.indent();
        
        this.print(node);
        
        if (indent)
            this.dedent();
    }
    
    printBlock(parent) {
        const node = parent.body;
        
        if (node.type !== 'EmptyStatement') {
            this.space();
        }
        
        this.print(node);
    }
    
    _printTrailingComments(node, parent, lineOffset) {
        const {
            innerComments,
            trailingComments,
        } = node;
        
        if (innerComments?.length) {
            this._printComments(2, innerComments, node, parent, lineOffset);
        }
        
        if (trailingComments?.length) {
            this._printComments(2, trailingComments, node, parent, lineOffset);
        }
    }
    
    _printLeadingComments(node, parent) {
        const comments = node.leadingComments;
        
        if (!comments?.length)
            return;
        
        this._printComments(0, comments, node, parent);
    }
    
    _maybePrintInnerComments(nextTokenStr, nextTokenOccurrenceCount) {
        if (this._endsWithInnerRaw) {
            this.printInnerComments(this.tokenMap?.findMatching(
                this._currentNode,
                nextTokenStr,
                nextTokenOccurrenceCount,
            ));
        }
        
        this._endsWithInnerRaw = true;
        this._indentInnerComments = true;
    }
    
    printInnerComments(nextToken) {
        const node = this._currentNode;
        const comments = node.innerComments;
        
        if (!comments?.length)
            return;
        
        const hasSpace = this.endsWith(32);
        const indent = this._indentInnerComments;
        const printedCommentsCount = this._printedComments.size;
        
        if (indent)
            this.indent();
        
        this._printComments(1, comments, node, void 0, void 0, nextToken);
        
        if (hasSpace && printedCommentsCount !== this._printedComments.size) {
            this.space();
        }
        
        if (indent)
            this.dedent();
    }
    
    noIndentInnerCommentsHere() {
        this._indentInnerComments = false;
    }
    
    printSequence(nodes2, indent, trailingCommentsLineOffset) {
        this.printJoin(nodes2, true, indent ?? false, void 0, void 0, void 0, trailingCommentsLineOffset);
    }
    
    printList(items, printTrailingSeparator, statement2, indent, separator, iterator) {
        this.printJoin(items, statement2, indent, separator ?? commaSeparator, printTrailingSeparator, iterator);
    }
    
    shouldPrintTrailingComma(listEnd) {
        if (!this.tokenMap)
            return null;
        
        const listEndIndex = this.tokenMap.findLastIndex(this._currentNode, (token) => this.tokenMap.matchesOriginal(token, listEnd));
        
        if (listEndIndex <= 0)
            return null;
        
        return this.tokenMap.matchesOriginal(this._tokens[listEndIndex - 1], ',');
    }
    
    _printNewline(newLine, opts) {
        const format = this.format;
        
        if (format.retainLines || format.compact)
            return;
        
        if (format.concise) {
            this.space();
            return;
        }
        
        if (!newLine) {
            return;
        }
        
        const startLine = opts.nextNodeStartLine;
        const lastCommentLine = this._lastCommentLine;
        
        if (startLine > 0 && lastCommentLine > 0) {
            const offset = startLine - lastCommentLine;
            
            if (offset >= 0) {
                this.newline(offset || 1);
                return;
            }
        }
        
        if (this._buf.hasContent()) {
            this.newline(1);
        }
    }
    
    _shouldPrintComment(comment, nextToken) {
        if (comment.ignore)
            return 0;
        
        if (this._printedComments.has(comment))
            return 0;
        
        if (this._noLineTerminator && HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)) {
            return 2;
        }
        
        if (nextToken && this.tokenMap) {
            const commentTok = this.tokenMap.find(this._currentNode, (token) => token.value === comment.value);
            
            if (commentTok && commentTok.start > nextToken.start) {
                return 2;
            }
        }
        
        this._printedComments.add(comment);
        
        if (!this.format.shouldPrintComment(comment.value)) {
            return 0;
        }
        
        return 1;
    }
    
    _printComment(comment, skipNewLines) {
        const noLineTerminator = this._noLineTerminator;
        const isBlockComment = comment.type === 'CommentBlock';
        const printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;
        
        if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {
            this.newline(1);
        }
        
        const lastCharCode = this.getLastChar();
        
        if (lastCharCode !== 91 && lastCharCode !== 123 && lastCharCode !== 40) {
            this.space();
        }
        
        let val;
        
        if (isBlockComment) {
            val = `/*${comment.value}*/`;
            
            if (this.format.indent.adjustMultilineComment) {
                const offset = comment.loc?.start.column;
                
                if (offset) {
                    const newlineRegex = new RegExp('\\n\\s{1,' + offset + '}', 'g');
                    val = val.replace(newlineRegex, '\n');
                }
                
                if (this.format.concise) {
                    val = val.replace(/\n(?!$)/g, `
`);
                } else {
                    let indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
                    
                    if (this._shouldIndent(47) || this.format.retainLines) {
                        indentSize += this._getIndent();
                    }
                    
                    val = val.replace(/\n(?!$)/g, `
${' '.repeat(indentSize)}`);
                }
            }
        } else if (!noLineTerminator) {
            val = `//${comment.value}`;
        } else {
            val = `/*${comment.value}*/`;
        }
        
        if (this._endsWithDiv)
            this._space();
        
        if (this.tokenMap) {
            const {
                _printSemicolonBeforeNextToken,
                _printSemicolonBeforeNextNode,
            } = this;
            
            this._printSemicolonBeforeNextToken = -1;
            this._printSemicolonBeforeNextNode = -1;
            this.source('start', comment.loc);
            this._append(val, isBlockComment);
            this._printSemicolonBeforeNextNode = _printSemicolonBeforeNextNode;
            this._printSemicolonBeforeNextToken = _printSemicolonBeforeNextToken;
        } else {
            this.source('start', comment.loc);
            this._append(val, isBlockComment);
        }
        
        if (!isBlockComment && !noLineTerminator) {
            this.newline(1, true);
        }
        
        if (printNewLines && skipNewLines !== 3) {
            this.newline(1);
        }
    }
    
    _printComments(type, comments, node, parent, lineOffset = 0, nextToken) {
        const nodeLoc = node.loc;
        const len = comments.length;
        let hasLoc = !!nodeLoc;
        const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;
        const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;
        let lastLine = 0;
        let leadingCommentNewline = 0;
        
        const maybeNewline = this._noLineTerminator ? function() {} : this.newline.bind(this);
        
        for (let i = 0; i < len; i++) {
            const comment = comments[i];
            const shouldPrint = this._shouldPrintComment(comment, nextToken);
            
            if (shouldPrint === 2) {
                hasLoc = false;
                break;
            }
            
            if (hasLoc && comment.loc && shouldPrint === 1) {
                const commentStartLine = comment.loc.start.line;
                const commentEndLine = comment.loc.end.line;
                
                if (type === 0) {
                    let offset = 0;
                    
                    if (i === 0) {
                        if (this._buf.hasContent() && (comment.type === 'CommentLine' || commentStartLine !== commentEndLine)) {
                            offset =
                            leadingCommentNewline = 1;
                        }
                    } else {
                        offset = commentStartLine - lastLine;
                    }
                    
                    lastLine = commentEndLine;
                    maybeNewline(offset);
                    this._printComment(comment, 1);
                    
                    if (i + 1 === len) {
                        maybeNewline(Math.max(
                            nodeStartLine - lastLine,
                            leadingCommentNewline,
                        ));
                        lastLine = nodeStartLine;
                    }
                } else if (type === 1) {
                    const offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);
                    
                    lastLine = commentEndLine;
                    maybeNewline(offset);
                    this._printComment(comment, 1);
                    
                    if (i + 1 === len) {
                        maybeNewline(Math.min(1, nodeEndLine - lastLine));
                        lastLine = nodeEndLine;
                    }
                } else {
                    const offset = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);
                    
                    lastLine = commentEndLine;
                    maybeNewline(offset);
                    this._printComment(comment, 1);
                }
            } else {
                hasLoc = false;
                
                if (shouldPrint !== 1) {
                    continue;
                }
                
                if (len === 1) {
                    const singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value);
                    const shouldSkipNewline = singleLine
                        && !isStatement3(node)
                        && !isClassBody2(parent)
                        && !isTSInterfaceBody2(parent)
                        && !isTSEnumMember2(node);
                    
                    if (type === 0) {
                        this._printComment(comment, shouldSkipNewline && node.type !== 'ObjectExpression' || singleLine && isFunction3(parent, {
                            body: node,
                        }) ? 1 : 0);
                    } else if (shouldSkipNewline && type === 2) {
                        this._printComment(comment, 1);
                    } else {
                        this._printComment(comment, 0);
                    }
                } else if (type === 1 && !(node.type === 'ObjectExpression' && node.properties.length > 1) && node.type !== 'ClassBody' && node.type !== 'TSInterfaceBody') {
                    this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0);
                } else {
                    this._printComment(comment, 0);
                }
            }
        }
        
        if (type === 2 && hasLoc && lastLine) {
            this._lastCommentLine = lastLine;
        }
    }
};

Object.assign(Printer.prototype, generatorFunctions);
function commaSeparator(occurrenceCount, last2) {
    this.token(',', false, occurrenceCount);
    
    if (!last2)
        this.space();
}

function normalizeOptions(code2, opts, ast) {
    if (opts.experimental_preserveFormat) {
        if (typeof code2 !== 'string') {
            throw new Error('`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string');
        }
        
        if (!opts.retainLines) {
            throw new Error('`experimental_preserveFormat` requires `retainLines` to be set to `true`');
        }
        
        if (opts.compact && opts.compact !== 'auto') {
            throw new Error('`experimental_preserveFormat` is not compatible with the `compact` option');
        }
        
        if (opts.minified) {
            throw new Error('`experimental_preserveFormat` is not compatible with the `minified` option');
        }
        
        if (opts.jsescOption) {
            throw new Error('`experimental_preserveFormat` is not compatible with the `jsescOption` option');
        }
        
        if (!Array.isArray(ast.tokens)) {
            throw new Error('`experimental_preserveFormat` requires the AST to have attached the token of the input code. Make sure to enable the `tokens: true` parser option.');
        }
    }
    
    const format = {
        auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
        auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
        shouldPrintComment: opts.shouldPrintComment,
        preserveFormat: opts.experimental_preserveFormat,
        retainLines: opts.retainLines,
        retainFunctionParens: opts.retainFunctionParens,
        comments: opts.comments == null || opts.comments,
        compact: opts.compact,
        minified: opts.minified,
        concise: opts.concise,
        indent: {
            adjustMultilineComment: true,
            style: '  ',
        },
        jsescOption: {
            quotes: 'double',
            wrap: true,
            minimal: true,
            ...opts.jsescOption,
        },
        topicToken: opts.topicToken,
    };
    
    if (format.minified) {
        format.compact = true;
        format.shouldPrintComment = format.shouldPrintComment || (() => format.comments);
    } else {
        format.shouldPrintComment = format.shouldPrintComment || ((value) => format.comments || value.includes('@license') || value.includes('@preserve'));
    }
    
    if (format.compact === 'auto') {
        format.compact = typeof code2 === 'string' && code2.length > 5e5;
        
        if (format.compact) {
            console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${opts.filename} as it exceeds the max of ${'500KB'}.`);
        }
    }
    
    if (format.compact || format.preserveFormat) {
        format.indent.adjustMultilineComment = false;
    }
    
    const {
        auxiliaryCommentBefore,
        auxiliaryCommentAfter,
        shouldPrintComment,
    } = format;
    
    if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {
        format.auxiliaryCommentBefore = void 0;
    }
    
    if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {
        format.auxiliaryCommentAfter = void 0;
    }
    
    return format;
}

function generate$1(ast, opts = {}, code2) {
    const format = normalizeOptions(code2, opts, ast);
    const map = opts.sourceMaps ? new SourceMap(opts, code2) : null;
    const printer = new Printer(format, map, ast.tokens, typeof code2 === 'string' ? code2 : null);
    
    return printer.generate(ast);
}

// ../babel-babel/node_modules/obug/dist/core.js
function selectColor(colors2, namespace) {
    let hash = 0;
    
    for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
    }
    
    return colors2[Math.abs(hash) % colors2.length];
}

function humanize(value) {
    if (value >= 1e3)
        return `${(value / 1e3).toFixed(1)}s`;
    
    return `${value}ms`;
}

var globalNamespaces = '';

function createDebug$4() {
    return {
        enabled: false,
    };
}

var names = [];
var skips = [];

function enable(namespaces$1) {
    globalNamespaces = namespaces$1;
    names = [];
    skips = [];
    const split = globalNamespaces
        .trim()
        .replace(/\s+/g, ',')
        .split(',')
        .filter(Boolean);
    
    for (const ns of split)
        if (ns[0] === '-')
            skips.push(ns.slice(1));
        else
            names.push(ns);
}

// ../babel-babel/node_modules/obug/dist/node.js
var colors = [];

var inspectOpts = {};

function useColors() {}

function formatArgs() {}

function log$5(...args) {
    browser$1.stderr.write(`${formatWithOptions(this.inspectOpts, ...args)}
`);
}

var defaultOptions$5 = {
    useColors: useColors(),
    formatArgs,
    formatters: {
        o(v) {
            this.inspectOpts.colors = this.useColors;
            return inspect(v, this
                .inspectOpts)
                .split('\n')
                .map((str) => str.trim())
                .join(' ');
        },
        O(v) {
            this.inspectOpts.colors = this.useColors;
            return inspect(v, this.inspectOpts);
        },
    },
    inspectOpts,
    log: log$5,
    humanize,
};

function createDebug2(namespace, options) {
    var _ref;
    const color = (_ref = options) !== null && _ref !== void 0 ? _ref : selectColor(colors, namespace);
    
    return createDebug$4(namespace, Object.assign(
        defaultOptions$5,{color},
        options,
    ));
}

enable(browser$1.env.DEBUG || '');
// ../babel-babel/packages/babel-helper-globals/data/builtin-lower.json

var builtin_lower_default = [
    'decodeURI',
    'decodeURIComponent',
    'encodeURI',
    'encodeURIComponent',
    'escape',
    'eval',
    'globalThis',
    'isFinite',
    'isNaN',
    'parseFloat',
    'parseInt',
    'undefined',
    'unescape',
];

// ../babel-babel/packages/babel-helper-globals/data/builtin-upper.json
var builtin_upper_default = [
    'AggregateError',
    'Array',
    'ArrayBuffer',
    'Atomics',
    'BigInt',
    'BigInt64Array',
    'BigUint64Array',
    'Boolean',
    'DataView',
    'Date',
    'Error',
    'EvalError',
    'FinalizationRegistry',
    'Float16Array',
    'Float32Array',
    'Float64Array',
    'Function',
    'Infinity',
    'Int16Array',
    'Int32Array',
    'Int8Array',
    'Intl',
    'Iterator',
    'JSON',
    'Map',
    'Math',
    'NaN',
    'Number',
    'Object',
    'Promise',
    'Proxy',
    'RangeError',
    'ReferenceError',
    'Reflect',
    'RegExp',
    'Set',
    'SharedArrayBuffer',
    'String',
    'Symbol',
    'SyntaxError',
    'TypeError',
    'Uint16Array',
    'Uint32Array',
    'Uint8Array',
    'Uint8ClampedArray',
    'URIError',
    'WeakMap',
    'WeakRef',
    'WeakSet',
];

// ../babel-babel/packages/babel-traverse/lib/index.js
var ReferencedIdentifier = [
    'Identifier',
    'JSXIdentifier',
];
var ReferencedMemberExpression = [
    'MemberExpression',
];
var BindingIdentifier = ['Identifier'];
var Statement = ['Statement'];
var Expression = ['Expression'];
var Scope$1 = [
    'Scopable',
    'Pattern',
];
var Referenced = null;
var BlockScoped = [
    'FunctionDeclaration',
    'ClassDeclaration',
    'VariableDeclaration',
];
var Var = [
    'VariableDeclaration',
];
var User = null;
var Generated = null;
var Pure = null;
var Flow = [
    'Flow',
    'ImportDeclaration',
    'ExportDeclaration',
    'ImportSpecifier',
];
var RestProperty2 = [
    'RestElement',
];
var SpreadProperty2 = [
    'RestElement',
];
var ExistentialTypeParam = [
    'ExistsTypeAnnotation',
];
var NumericLiteralTypeAnnotation = [
    'NumberLiteralTypeAnnotation',
];
var ForAwaitStatement = [
    'ForOfStatement',
];

var virtualTypes = /* @__PURE__ */Object.freeze({
    __proto__: null,
    BindingIdentifier,
    BlockScoped,
    ExistentialTypeParam,
    Expression,
    Flow,
    ForAwaitStatement,
    Generated,
    NumericLiteralTypeAnnotation,
    Pure,
    Referenced,
    ReferencedIdentifier,
    ReferencedMemberExpression,
    RestProperty: RestProperty2,
    Scope: Scope$1,
    SpreadProperty: SpreadProperty2,
    Statement,
    User,
    Var,
});

var {
    isBinding: isBinding2,
    isBlockScoped: nodeIsBlockScoped,
    isExportDeclaration: isExportDeclaration$1$1,
    isExpression: nodeIsExpression,
    isFlow: nodeIsFlow,
    isForStatement: isForStatement3,
    isForXStatement: isForXStatement2,
    isIdentifier: isIdentifier$6$1,
    isImportDeclaration: isImportDeclaration$1$1,
    isImportSpecifier: isImportSpecifier2,
    isJSXIdentifier: isJSXIdentifier3,
    isJSXMemberExpression: isJSXMemberExpression2,
    isMemberExpression: isMemberExpression$12,
    isRestElement: nodeIsRestElement,
    isReferenced: nodeIsReferenced,
    isScope: nodeIsScope,
    isStatement: nodeIsStatement,
    isVar: nodeIsVar,
    isVariableDeclaration: isVariableDeclaration$2$1,
    react: react2,
    isForOfStatement: isForOfStatement3,
} = lib_exports;

var {isCompatTag: isCompatTag2} = react2;

function isReferencedIdentifier(opts) {
    const {node, parent} = this;
    
    if (isIdentifier$6$1(node, opts)) {
        return nodeIsReferenced(node, parent, this.parentPath.parent);
    } else if (isJSXIdentifier3(node, opts)) {
        if (!isJSXMemberExpression2(parent) && isCompatTag2(node.name))
            return false;
        
        return nodeIsReferenced(node, parent, this.parentPath.parent);
    } else {
        return false;
    }
}

function isReferencedMemberExpression() {
    const {node, parent} = this;
    
    return isMemberExpression$12(node) && nodeIsReferenced(node, parent);
}

function isBindingIdentifier() {
    const {node, parent} = this;
    
    const grandparent = this.parentPath.parent;
    
    return isIdentifier$6$1(node) && isBinding2(node, parent, grandparent);
}

function isStatement$13() {
    const {node, parent} = this;
    
    if (nodeIsStatement(node)) {
        if (isVariableDeclaration$2$1(node)) {
            if (isForXStatement2(parent, {left: node}))
                return false;
            
            if (isForStatement3(parent, {init: node}))
                return false;
        }
        
        return true;
    } else {
        return false;
    }
}

function isExpression$3() {
    if (this.isIdentifier()) {
        return this.isReferencedIdentifier();
    } else {
        return nodeIsExpression(this.node);
    }
}

function isScope2() {
    return nodeIsScope(this.node, this.parent);
}

function isReferenced2() {
    return nodeIsReferenced(this.node, this.parent);
}

function isBlockScoped2() {
    return nodeIsBlockScoped(this.node);
}

function isVar2() {
    return nodeIsVar(this.node);
}

function isUser() {
    return !!this.node?.loc;
}

function isGenerated() {
    return !this.isUser();
}

function isPure(constantsOnly) {
    return this.scope.isPure(this.node, constantsOnly);
}

function isFlow2() {
    const {node} = this;
    
    if (nodeIsFlow(node)) {
        return true;
    } else if (isImportDeclaration$1$1(node)) {
        return node.importKind === 'type' || node.importKind === 'typeof';
    } else if (isExportDeclaration$1$1(node)) {
        return node.exportKind === 'type';
    } else if (isImportSpecifier2(node)) {
        return node.importKind === 'type' || node.importKind === 'typeof';
    } else {
        return false;
    }


}

function isRestProperty2() {
    return nodeIsRestElement(this.node) && this.parentPath?.isObjectPattern();
}

function isSpreadProperty2() {
    return nodeIsRestElement(this.node) && this.parentPath?.isObjectExpression();
}

function isForAwaitStatement() {
    return isForOfStatement3(this.node, {
        await: true,
    });
}

var NodePath_virtual_types_validator = /* @__PURE__ */Object.freeze({
    __proto__: null,
    isBindingIdentifier,
    isBlockScoped: isBlockScoped2,
    isExpression: isExpression$3,
    isFlow: isFlow2,
    isForAwaitStatement,
    isGenerated,
    isPure,
    isReferenced: isReferenced2,
    isReferencedIdentifier,
    isReferencedMemberExpression,
    isRestProperty: isRestProperty2,
    isScope: isScope2,
    isSpreadProperty: isSpreadProperty2,
    isStatement: isStatement$13,
    isUser,
    isVar: isVar2,
});

var {
    DEPRECATED_KEYS: DEPRECATED_KEYS2,
    DEPRECATED_ALIASES: DEPRECATED_ALIASES2,
    FLIPPED_ALIAS_KEYS: FLIPPED_ALIAS_KEYS3,
    TYPES: TYPES2,
    __internal__deprecationWarning: deprecationWarning2,
} = lib_exports;

function isVirtualType(type) {
    return type in virtualTypes;
}

function isExplodedVisitor(visitor) {
    return visitor?._exploded;
}

function explode$1(visitor) {
    if (isExplodedVisitor(visitor))
        return visitor;
    
    visitor._exploded = true;
    for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType))
            continue;
        
        const parts = nodeType.split('|');
        
        if (parts.length === 1)
            continue;
        
        const fns = visitor[nodeType];
        delete visitor[nodeType];
        for (const part of parts) {
            visitor[part] = fns;
        }
    }
    
    verify$1(visitor);
    delete visitor.__esModule;
    ensureEntranceObjects(visitor);
    ensureCallbackArrays(visitor);
    
    for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType))
            continue;
        
        if (!isVirtualType(nodeType))
            continue;
        
        const fns = visitor[nodeType];
        
        for (const type of Object.keys(fns)) {
            fns[type] = wrapCheck(nodeType, fns[type]);
        }
        
        delete visitor[nodeType];
        const types2 = virtualTypes[nodeType];
        
        if (types2 !== null) {
            for (const type of types2) {
                visitor[type] ??= {};
                mergePair(visitor[type], fns);
            }
        } else {
            mergePair(visitor, fns);
        }
    }
    
    for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType))
            continue;
        
        let aliases = FLIPPED_ALIAS_KEYS3[nodeType];
        
        if (nodeType in DEPRECATED_KEYS2) {
            const deprecatedKey = DEPRECATED_KEYS2[nodeType];
            deprecationWarning2(nodeType, deprecatedKey, 'Visitor ');
            aliases = [deprecatedKey];
        } else if (nodeType in DEPRECATED_ALIASES2) {
            const deprecatedAlias = DEPRECATED_ALIASES2[nodeType];
            deprecationWarning2(nodeType, deprecatedAlias, 'Visitor ');
            aliases = FLIPPED_ALIAS_KEYS3[deprecatedAlias];
        }
        
        if (!aliases)
            continue;
        
        const fns = visitor[nodeType];
        delete visitor[nodeType];
        for (const alias2 of aliases) {
            const existing = visitor[alias2];
            
            if (existing) {
                mergePair(existing, fns);
            } else {
                visitor[alias2] = {
                    ...fns,
                };
            }
        }
    }
    
    for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType))
            continue;
        
        ensureCallbackArrays(visitor[nodeType]);
    }
    
    return visitor;
}

function verify$1(visitor) {
    if (visitor._verified)
        return;
    
    if (typeof visitor === 'function') {
        throw new Error('You passed `traverse()` a function when it expected a visitor object, are you sure you didn\'t mean `{ enter: Function }`?');
    }
    
    for (const nodeType of Object.keys(visitor)) {
        if (nodeType === 'enter' || nodeType === 'exit') {
            validateVisitorMethods(nodeType, visitor[nodeType]);
        }
        
        if (shouldIgnoreKey(nodeType))
            continue;
        
        if (!TYPES2.includes(nodeType)) {
            throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type in @babel/traverse ${'8.0.0-beta.3'}`);
        }
        
        const visitors2 = visitor[nodeType];
        
        if (typeof visitors2 === 'object') {
            for (const visitorKey of Object.keys(visitors2)) {
                if (visitorKey === 'enter' || visitorKey === 'exit') {
                    validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors2[visitorKey]);
                } else {
                    throw new Error(`You passed \`traverse()\` a visitor object with the property ${nodeType} that has the invalid property ${visitorKey}`);
                }
            }
        }
    }
    
    visitor._verified = true;
}

function validateVisitorMethods(path, val) {
    const fns = [].concat(val);
    
    for (const fn of fns) {
        if (typeof fn !== 'function') {
            throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);
        }
    }
}

function merge2(visitors2, states = [], wrapper) {
    const mergedVisitor = {
        _verified: true,
        _exploded: true,
    };
    
    for (let i = 0; i < visitors2.length; i++) {
        const visitor = explode$1(visitors2[i]);
        const state = states[i];
        let topVisitor = visitor;
        
        if (state || wrapper) {
            topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper);
        }
        
        mergePair(mergedVisitor, topVisitor);
        for (const key of Object.keys(visitor)) {
            if (shouldIgnoreKey(key))
                continue;
            
            let typeVisitor = visitor[key];
            
            if (state || wrapper) {
                typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper);
            }
            
            const nodeVisitor = mergedVisitor[key] ||= {};
            mergePair(nodeVisitor, typeVisitor);
        }
    }
    
    return mergedVisitor;
}

function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
    const newVisitor = {};
    
    for (const phase of ['enter', 'exit']) {
        let fns = oldVisitor[phase];
        
        if (!Array.isArray(fns))
            continue;
        
        fns = fns.map(function(fn) {
            let newFn = fn;
            
            if (state) {
                newFn = function(path) {
                    fn.call(state, path, state);
                };
            }
            
            if (wrapper) {
                newFn = wrapper(state?.key, phase, newFn);
            }
            
            if (newFn !== fn) {
                newFn.toString = () => fn.toString();
            }
            
            return newFn;
        });
        newVisitor[phase] = fns;
    }
    
    return newVisitor;
}

function ensureEntranceObjects(obj) {
    for (const key of Object.keys(obj)) {
        if (shouldIgnoreKey(key))
            continue;
        
        const fns = obj[key];
        
        if (typeof fns === 'function') {
            obj[key] = {
                enter: fns,
            };
        }
    }
}

function ensureCallbackArrays(obj) {
    if (obj.enter && !Array.isArray(obj.enter))
        obj.enter = [obj.enter];
    
    if (obj.exit && !Array.isArray(obj.exit))
        obj.exit = [obj.exit];
}

function wrapCheck(nodeType, fn) {
    const fnKey = `is${nodeType}`;
    const validator = NodePath_virtual_types_validator[fnKey];
    const newFn = function(path) {
        if (validator.call(path)) {
            return fn.apply(this, arguments);
        }
    };
    
    newFn.toString = () => fn.toString();
    return newFn;
}

function shouldIgnoreKey(key) {
    if (key.startsWith('_'))
        return true;
    
    if (key === 'enter' || key === 'exit' || key === 'shouldSkip')
        return true;
    
    if (key === 'denylist' || key === 'noScope' || key === 'skipKeys') {
        return true;
    }
    
    return false;
}

function mergePair(dest, src) {
    for (const phase of ['enter', 'exit']) {
        if (!src[phase])
            continue;
        
        dest[phase] = [].concat(dest[phase] || [], src[phase]);
    }
}

var _environmentVisitor = {
    FunctionParent(path) {
        if (path.isArrowFunctionExpression())
            return;
        
        path.skip();
        
        if (path.isMethod()) {
            path.requeueComputedKeyAndDecorators();
        }
    },
    Property(path) {
        if (path.isObjectProperty())
            return;
        
        path.skip();
        path.requeueComputedKeyAndDecorators();
    },
};

function environmentVisitor(visitor) {
    return merge2([_environmentVisitor, visitor]);
}

var visitors = /* @__PURE__ */Object.freeze({
    __proto__: null,
    environmentVisitor,
    explode: explode$1,
    isExplodedVisitor,
    merge: merge2,
    verify: verify$1,
});

var {getAssignmentIdentifiers: getAssignmentIdentifiers$1} = lib_exports;

var renameVisitor = {
    ReferencedIdentifier({node}, state) {
        if (node.name === state.oldName) {
            node.name = state.newName;
        }
    },
    Scope(path, state) {
        if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
            path.skip();
            
            if (path.isMethod()) {
                path.requeueComputedKeyAndDecorators();
            }
            
            if (path.isSwitchStatement()) {
                path.context.maybeQueue(path.get('discriminant'));
            }
        }
    },
    ObjectProperty({node, scope: scope2}, state) {
        const {name} = node.key;
        
        if (node.shorthand && (name === state.oldName || name === state.newName) && scope2.getBindingIdentifier(name) === state.binding.identifier) {
            node.shorthand = false;
        }
    },
    'AssignmentExpression|Declaration|VariableDeclarator'(path, state) {
        if (path.isVariableDeclaration())
            return;
        
        const ids = path.isAssignmentExpression() ? getAssignmentIdentifiers$1(path.node) : path.getOuterBindingIdentifiers();
        
        for (const name in ids) {
            if (name === state.oldName)
                ids[name].name = state.newName;
        }
    },
};

var Renamer = class {
    constructor(binding, oldName, newName) {
        this.newName = newName;
        this.oldName = oldName;
        this.binding = binding;
    }
    
    maybeConvertFromExportDeclaration(parentDeclar) {
        const maybeExportDeclar = parentDeclar.parentPath;
        
        if (!maybeExportDeclar.isExportDeclaration()) {
            return;
        }
        
        if (maybeExportDeclar.isExportDefaultDeclaration()) {
            const {declaration} = maybeExportDeclar.node;
            
            if (isDeclaration(declaration) && !declaration.id) {
                return;
            }
        }
        
        if (maybeExportDeclar.isExportAllDeclaration()) {
            return;
        }
        
        maybeExportDeclar.splitExportDeclaration();
    }
    
    maybeConvertFromClassFunctionDeclaration(path) {
        return path;
    }
    
    maybeConvertFromClassFunctionExpression(path) {
        return path;
    }
    
    rename() {
        const {
            binding,
            oldName,
            newName,
        } = this;
        
        const {scope: scope2, path} = binding;
        
        const parentDeclar = path.find((path2) => path2.isDeclaration() || path2.isFunctionExpression() || path2.isClassExpression());
        
        if (parentDeclar) {
            const bindingIds = parentDeclar.getOuterBindingIdentifiers();
            
            if (bindingIds[oldName] === binding.identifier) {
                this.maybeConvertFromExportDeclaration(parentDeclar);
            }
        }
        
        const blockToTraverse = scope2.block;
        
        const skipKeys = {
            discriminant: true,
        };
        
        if (isMethod(blockToTraverse)) {
            if (blockToTraverse.computed) {
                skipKeys.key = true;
            }
            
            if (!isObjectMethod$1(blockToTraverse)) {
                skipKeys.decorators = true;
            }
        }
        
        traverseNode(blockToTraverse, explode$1(renameVisitor), scope2, this, scope2.path, skipKeys);
        scope2.removeOwnBinding(oldName);
        scope2.bindings[newName] = binding;
        this.binding.identifier.name = newName;
        
        if (parentDeclar) {
            this.maybeConvertFromClassFunctionDeclaration(path);
            this.maybeConvertFromClassFunctionExpression(path);
        }
    }
};

var {VISITOR_KEYS: VISITOR_KEYS$5} = lib_exports;

function traverseForScope(path, visitors2, state) {
    const exploded = explode$1(visitors2);
    
    if (exploded.enter || exploded.exit) {
        throw new Error('Should not be used with enter/exit visitors.');
    }
    
    _traverse(path.parentPath, path.parent, path.node, path.container, path.key, path.listKey, path.hub, path);
    function _traverse(parentPath, parent, node, container, key, listKey, hub, inPath) {
        if (!node) {
            return;
        }
        
        const path2 = inPath || NodePath_Final.get({
            hub,
            parentPath,
            parent,
            container,
            listKey,
            key,
        });
        
        _forceSetScope.call(path2);
        const visitor = exploded[node.type];
        
        if (visitor?.enter) {
            for (const visit2 of visitor.enter) {
                visit2.call(state, path2, state);
            }
        }
        
        if (path2.shouldSkip) {
            return;
        }
        
        const keys2 = VISITOR_KEYS$5[node.type];
        
        if (!keys2?.length) {
            return;
        }
        
        for (const key2 of keys2) {
            const prop = node[key2];
            
            if (!prop)
                continue;
            
            if (Array.isArray(prop)) {
                for (let i = 0; i < prop.length; i++) {
                    const value = prop[i];
                    _traverse(path2, node, value, prop, i, key2);
                }
            } else {
                _traverse(path2, node, prop, node, key2, null);
            }
        }
        
        if (visitor?.exit) {
            for (const visit2 of visitor.exit) {
                visit2.call(state, path2, state);
            }
        }
    }
}

var Binding = class {
    identifier;
    scope;
    path;
    kind;
    constructor({identifier: identifier4, scope: scope2, path, kind}) {
        this.identifier = identifier4;
        this.scope = scope2;
        this.path = path;
        this.kind = kind;
        
        if ((kind === 'var' || kind === 'hoisted') && isInitInLoop(path)) {
            this.reassign(path);
        }
        
        this.clearValue();
    }
    
    constantViolations = [];
    constant = true;
    referencePaths = [];
    referenced = false;
    references = 0;
    deoptValue() {
        this.clearValue();
        this.hasDeoptedValue = true;
    }
    
    setValue(value) {
        if (this.hasDeoptedValue)
            return;
        
        this.hasValue = true;
        this.value = value;
    }
    
    clearValue() {
        this.hasDeoptedValue = false;
        this.hasValue = false;
        this.value = null;
    }
    
    reassign(path) {
        this.constant = false;
        
        if (this.constantViolations.includes(path)) {
            return;
        }
        
        this.constantViolations.push(path);
    }
    
    reference(path) {
        if (this.referencePaths.includes(path)) {
            return;
        }
        
        this.referenced = true;
        this.references++;
        this.referencePaths.push(path);
    }
    
    dereference() {
        this.references--;
        this.referenced = !!this.references;
    }
};

function isInitInLoop(path) {
    const isFunctionDeclarationOrHasInit = !path.isVariableDeclarator() || path.node.init;
    
    for (let {parentPath, key} = path; parentPath; ({
        parentPath,
        key,
    } = parentPath)) {
        if (parentPath.isFunctionParent())
            return false;
        
        if (key === 'left' && parentPath.isForXStatement() || isFunctionDeclarationOrHasInit && key === 'body' && parentPath.isLoop()) {
            return true;
        }
    }
    
    return false;
}

var pathsCache = /* @__PURE__ */new WeakMap();
var scope = /* @__PURE__ */new WeakMap();

function clear() {
    clearPath();
    clearScope();
}

function clearPath() {
    pathsCache =     /* @__PURE__ */new WeakMap();
}

function clearScope() {
    scope =     /* @__PURE__ */new WeakMap();
}

function getCachedPaths(path) {
    const {parent, parentPath} = path;
    
    return parentPath ? parentPath._store : pathsCache.get(parent);
}

function getOrCreateCachedPaths(node, parentPath) {
    if (parentPath) {
        return parentPath._store ||=         /* @__PURE__ */new Map();
    }
    
    let paths = pathsCache.get(node);
    
    if (!paths)
        pathsCache.set(node, paths =         /* @__PURE__ */new Map());
    
    return paths;
}

var cache = /* @__PURE__ */Object.freeze({
    __proto__: null,
    clear,
    clearPath,
    clearScope,
    getCachedPaths,
    getOrCreateCachedPaths,
    get path() {
        return pathsCache;
    },
    get scope() {
        return scope;
    },
});

var {
    assignmentExpression: assignmentExpression$3,
    cloneNode: cloneNode$3,
    getBindingIdentifiers: getBindingIdentifiers$2,
    identifier: identifier$3,
    isArrayExpression: isArrayExpression3,
    isBinary: isBinary3,
    isCallExpression: isCallExpression$12,
    isClass: isClass2,
    isClassBody: isClassBody3,
    isClassDeclaration: isClassDeclaration3,
    isExportAllDeclaration: isExportAllDeclaration2,
    isExportDefaultDeclaration: isExportDefaultDeclaration3,
    isExportNamedDeclaration: isExportNamedDeclaration$1$1,
    isFunctionDeclaration: isFunctionDeclaration2,
    isIdentifier: isIdentifier$5$1,
    isImportDeclaration: isImportDeclaration2,
    isLiteral: isLiteral$12,
    isMemberExpression: isMemberExpression3,
    isMethod: isMethod2,
    isModuleSpecifier: isModuleSpecifier2,
    isNullLiteral: isNullLiteral2,
    isObjectExpression: isObjectExpression3,
    isProperty: isProperty2,
    isPureish: isPureish2,
    isRegExpLiteral: isRegExpLiteral2,
    isSuper: isSuper$1,
    isTaggedTemplateExpression: isTaggedTemplateExpression2,
    isTemplateLiteral: isTemplateLiteral2,
    isThisExpression: isThisExpression2,
    isUnaryExpression: isUnaryExpression2,
    isVariableDeclaration: isVariableDeclaration$1$1,
    expressionStatement: expressionStatement$3$1,
    matchesPattern: matchesPattern$1$1,
    toIdentifier: toIdentifier2,
    variableDeclaration: variableDeclaration$1,
    variableDeclarator: variableDeclarator$1,
    isObjectProperty: isObjectProperty2,
    isTopicReference: isTopicReference2,
    isMetaProperty: isMetaProperty2,
    isPrivateName: isPrivateName2,
    isExportDeclaration: isExportDeclaration2,
    buildUndefinedNode: buildUndefinedNode$1,
    sequenceExpression: sequenceExpression$2,
} = lib_exports;

function gatherNodeParts(node, parts) {
    switch(node?.type) {
    default:
        if (isImportDeclaration2(node) || isExportDeclaration2(node)) {
            if ((isExportAllDeclaration2(node) || isExportNamedDeclaration$1$1(node) || isImportDeclaration2(node)) && node.source) {
                gatherNodeParts(node.source, parts);
            } else if ((isExportNamedDeclaration$1$1(node) || isImportDeclaration2(node)) && node.specifiers?.length) {
                for (const e of node.specifiers)
                    gatherNodeParts(e, parts);
            } else if ((isExportDefaultDeclaration3(node) || isExportNamedDeclaration$1$1(node)) && node.declaration) {
                gatherNodeParts(node.declaration, parts);
            }

        } else if (isModuleSpecifier2(node)) {
            gatherNodeParts(node.local, parts);
        } else if (isLiteral$12(node) && !isNullLiteral2(node) && !isRegExpLiteral2(node) && !isTemplateLiteral2(node)) {
            parts.push(node.value);
        }
        
        break;
    
    case 'MemberExpression':    
    case 'OptionalMemberExpression':    
    case 'JSXMemberExpression':
        gatherNodeParts(node.object, parts);
        gatherNodeParts(node.property, parts);
        break;
    
    case 'Identifier':    
    case 'JSXIdentifier':
        parts.push(node.name);
        break;
    
    case 'CallExpression':    
    case 'OptionalCallExpression':    
    case 'NewExpression':
        gatherNodeParts(node.callee, parts);
        break;
    
    case 'ObjectExpression':    
    case 'ObjectPattern':
        
        for (const e of node.properties) {
            gatherNodeParts(e, parts);
        }
        
        break;
    
    case 'SpreadElement':    
    case 'RestElement':
        gatherNodeParts(node.argument, parts);
        break;
    
    case 'ObjectProperty':    
    case 'ObjectMethod':    
    case 'ClassProperty':    
    case 'ClassMethod':    
    case 'ClassPrivateProperty':    
    case 'ClassPrivateMethod':
        gatherNodeParts(node.key, parts);
        break;
    
    case 'ThisExpression':
        parts.push('this');
        break;
    
    case 'Super':
        parts.push('super');
        break;
    
    case 'Import':    
    case 'ImportExpression':
        parts.push('import');
        break;
    
    case 'DoExpression':
        parts.push('do');
        break;
    
    case 'YieldExpression':
        parts.push('yield');
        gatherNodeParts(node.argument, parts);
        break;
    
    case 'AwaitExpression':
        parts.push('await');
        gatherNodeParts(node.argument, parts);
        break;
    
    case 'AssignmentExpression':
        gatherNodeParts(node.left, parts);
        break;
    
    case 'VariableDeclarator':
        gatherNodeParts(node.id, parts);
        break;
    
    case 'FunctionExpression':    
    case 'FunctionDeclaration':    
    case 'ClassExpression':    
    case 'ClassDeclaration':
        gatherNodeParts(node.id, parts);
        break;
    
    case 'PrivateName':
        gatherNodeParts(node.id, parts);
        break;
    
    case 'ParenthesizedExpression':
        gatherNodeParts(node.expression, parts);
        break;
    
    case 'UnaryExpression':    
    case 'UpdateExpression':
        gatherNodeParts(node.argument, parts);
        break;
    
    case 'MetaProperty':
        gatherNodeParts(node.meta, parts);
        gatherNodeParts(node.property, parts);
        break;
    
    case 'JSXElement':
        gatherNodeParts(node.openingElement, parts);
        break;
    
    case 'JSXOpeningElement':
        gatherNodeParts(node.name, parts);
        break;
    
    case 'JSXFragment':
        gatherNodeParts(node.openingFragment, parts);
        break;
    
    case 'JSXOpeningFragment':
        parts.push('Fragment');
        break;
    
    case 'JSXNamespacedName':
        gatherNodeParts(node.namespace, parts);
        gatherNodeParts(node.name, parts);
        break;
    }
}

function resetScope(scope2) {
    if (scope2.path.type === 'Program') {
        scope2.referencesSet =         /* @__PURE__ */new Set();
        scope2.uidsSet =         /* @__PURE__ */new Set();
    }
    
    scope2.bindings =     /* @__PURE__ */Object.create(null);
    scope2.globals =     /* @__PURE__ */Object.create(null);
}

function isAnonymousFunctionExpression(path) {
    return path.isFunctionExpression() && !path.node.id || path.isArrowFunctionExpression();
}

var collectorVisitor = {
    ForStatement(path) {
        const declar = path.get('init');
        
        if (declar.isVar()) {
            const {scope: scope2} = path;
            
            const parentScope = scope2.getFunctionParent() || scope2.getProgramParent();
            parentScope.registerBinding('var', declar);
        }
    },
    Declaration(path) {
        if (path.isBlockScoped())
            return;
        
        if (path.isImportDeclaration())
            return;
        
        if (path.isExportDeclaration())
            return;
        
        const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();
        parent.registerDeclaration(path);
    },
    ImportDeclaration(path) {
        const parent = path.scope.getBlockParent();
        parent.registerDeclaration(path);
    },
    TSImportEqualsDeclaration(path) {
        const parent = path.scope.getBlockParent();
        parent.registerDeclaration(path);
    },
    ReferencedIdentifier(path, state) {
        if (isTSQualifiedName(path.parent) && path.parent.right === path.node) {
            return;
        }
        
        if (path.parentPath.isTSImportEqualsDeclaration())
            return;
        
        state.references.push(path);
    },
    ForXStatement(path, state) {
        const left = path.get('left');
        
        if (left.isPattern() || left.isIdentifier()) {
            state.constantViolations.push(path);
        } else if (left.isVar()) {
            const {scope: scope2} = path;
            
            const parentScope = scope2.getFunctionParent() || scope2.getProgramParent();
            parentScope.registerBinding('var', left);
        }
    },
    ExportDeclaration: {
        exit(path) {
            const {node, scope: scope2} = path;
            
            if (isExportAllDeclaration2(node))
                return;
            
            const declar = node.declaration;
            
            if (isClassDeclaration3(declar) || isFunctionDeclaration2(declar)) {
                const id = declar.id;
                
                if (!id)
                    return;
                
                const binding = scope2.getBinding(id.name);
                binding?.reference(path);
            } else if (isVariableDeclaration$1$1(declar)) {
                for (const decl of declar.declarations) {
                    for (const name of Object.keys(getBindingIdentifiers$2(decl))) {
                        const binding = scope2.getBinding(name);
                        binding?.reference(path);
                    }
                }
            }
        },
    },
    LabeledStatement(path) {
        path.scope
            .getBlockParent()
            .registerDeclaration(path);
    },
    AssignmentExpression(path, state) {
        state.assignments.push(path);
    },
    UpdateExpression(path, state) {
        state.constantViolations.push(path);
    },
    UnaryExpression(path, state) {
        if (path.node.operator === 'delete') {
            state.constantViolations.push(path);
        }
    },
    BlockScoped(path) {
        let scope2 = path.scope;
        
        if (scope2.path === path)
            scope2 = scope2.parent;
        
        const parent = scope2.getBlockParent();
        parent.registerDeclaration(path);
        
        if (path.isClassDeclaration() && path.node.id) {
            const id = path.node.id;
            const name = id.name;
            
            path.scope.bindings[name] = path.scope.parent.getBinding(name);
        }
    },
    CatchClause(path) {
        path.scope.registerBinding('let', path);
    },
    Function(path) {
        const params = path.get('params');
        
        for (const param of params) {
            path.scope.registerBinding('param', param);
        }
        
        if (path.isFunctionExpression() && path.node.id) {
            path.scope.registerBinding('local', path.get('id'), path);
        }
    },
    ClassExpression(path) {
        if (path.node.id) {
            path.scope.registerBinding('local', path.get('id'), path);
        }
    },
    TSTypeAnnotation(path) {
        path.skip();
    },
};

var scopeVisitor;
var uid = 0;

var Scope2 = class _Scope {
    uid;
    path;
    block;
    inited;
    labels;
    bindings;
    referencesSet;
    globals;
    uidsSet;
    data;
    crawling;
    constructor(path) {
        const {node} = path;
        
        const cached = scope.get(node);
        
        if (cached?.path === path) {
            return cached;
        }
        
        scope.set(node, this);
        this.uid = uid++;
        this.block = node;
        this.path = path;
        this.labels =         /* @__PURE__ */new Map();
        this.inited = false;
    }
    
    static globals = [
        ...builtin_lower_default,
        ...builtin_upper_default,
    ];
    static contextVariables = [
        'arguments',
        'undefined',
        'Infinity',
        'NaN',
    ];
    get parent() {
        let parent, path = this.path;
        
        do {
            const shouldSkip = path.key === 'key' || path.listKey === 'decorators';
            
            path = path.parentPath;
            
            if (shouldSkip && path.isMethod())
                path = path.parentPath;
            
            if (path?.isScope())
                parent = path;
        } while (path && !parent)
        
        return parent?.scope;
    }
    
    get references() {
        throw new Error('Scope#references is not available in Babel 8. Use Scope#referencesSet instead.');
    }
    
    get uids() {
        throw new Error('Scope#uids is not available in Babel 8. Use Scope#uidsSet instead.');
    }
    
    generateDeclaredUidIdentifier(name) {
        const id = this.generateUidIdentifier(name);
        
        this.push({
            id,
        });
        return cloneNode$3(id);
    }
    
    generateUidIdentifier(name) {
        return identifier$3(this.generateUid(name));
    }
    
    generateUid(name = 'temp') {
        name = toIdentifier2(name)
            .replace(/^_+/, '')
            .replace(/\d+$/g, '');
        let uid2;
        let i = 0;
        
        do {
            uid2 = `_${name}`;
            
            if (i >= 11)
                uid2 += i - 1;
            else if (i >= 9)
                uid2 += i - 9;
            else if (i >= 1)
                uid2 += i + 1;
            
            i++;
        } while (this.hasLabel(uid2) || this.hasBinding(uid2) || this.hasGlobal(uid2) || this.hasReference(uid2))
        const program3 = this.getProgramParent();
        program3.referencesSet.add(uid2);
        program3.uidsSet.add(uid2);
        return uid2;
    }
    
    generateUidBasedOnNode(node, defaultName) {
        const parts = [];
        gatherNodeParts(node, parts);
        let id = parts.join('$');
        
        id = id.replace(/^_/, '') || defaultName || 'ref';
        return this.generateUid(id.slice(0, 20));
    }
    
    generateUidIdentifierBasedOnNode(node, defaultName) {
        return identifier$3(this.generateUidBasedOnNode(
            node,
            defaultName,
        ));
    }
    
    isStatic(node) {
        if (isThisExpression2(node) || isSuper$1(node) || isTopicReference2(node)) {
            return true;
        }
        
        if (isIdentifier$5$1(node)) {
            const binding = this.getBinding(node.name);
            
            if (binding) {
                return binding.constant;
            } else {
                return this.hasBinding(node.name);
            }
        }
        
        return false;
    }
    
    maybeGenerateMemoised(node, dontPush) {
        if (this.isStatic(node)) {
            return null;
        } else {
            const id = this.generateUidIdentifierBasedOnNode(node);
            
            if (!dontPush) {
                this.push({
                    id,
                });
                return cloneNode$3(id);
            }
            
            return id;
        }
    }
    
    checkBlockScopedCollisions(local, kind, name) {
        if (kind === 'param')
            return;
        
        if (local.kind === 'local')
            return;
        
        const duplicate = kind === 'let'
            || local.kind === 'let'
            || local.kind === 'const'
            || local.kind === 'module'
            || local.kind === 'param' && kind === 'const';
        
        if (duplicate) {
            throw Error(`Duplicate declaration '${name}'`, TypeError);
        }
    }
    
    rename(oldName, newName) {
        const binding = this.getBinding(oldName);
        
        if (binding) {
            newName ||= this.generateUidIdentifier(oldName).name;
            const renamer = new Renamer(binding, oldName, newName);
            renamer.rename();
        }
    }
    
    dump() {
        const sep = '-'.repeat(60);
        console.log(sep);
        let scope2 = this;
        
        do {
            console.log('#', scope2.block.type);
            for (const name of Object.keys(scope2.bindings)) {
                const binding = scope2.bindings[name];
                
                console.log(' -', name, {
                    constant: binding.constant,
                    references: binding.references,
                    violations: binding.constantViolations.length,
                    kind: binding.kind,
                });
            }
        } while (scope2 = scope2.parent)
        console.log(sep);
    }
    
    hasLabel(name) {
        return !!this.getLabel(name);
    }
    
    getLabel(name) {
        return this.labels.get(name);
    }
    
    registerLabel(path) {
        this.labels.set(path.node.label.name, path);
    }
    
    registerDeclaration(path) {
        if (path.isLabeledStatement()) {
            this.registerLabel(path);
        } else if (path.isFunctionDeclaration()) {
            this.registerBinding('hoisted', path.get('id'), path);
        } else if (path.isVariableDeclaration()) {
            const declarations = path.get('declarations');
            const {kind} = path.node;
            
            for (const declar of declarations) {
                this.registerBinding(kind === 'using' || kind === 'await using' ? 'const' : kind, declar);
            }
        } else if (path.isClassDeclaration()) {
            if (path.node.declare)
                return;
            
            this.registerBinding('let', path);
        } else if (path.isImportDeclaration()) {
            const isTypeDeclaration = path.node.importKind === 'type' || path.node.importKind === 'typeof';
            const specifiers = path.get('specifiers');
            
            for (const specifier of specifiers) {
                const isTypeSpecifier = isTypeDeclaration
                    || specifier.isImportSpecifier()
                    && (specifier.node.importKind === 'type'
                    || specifier.node.importKind === 'typeof');
                this.registerBinding(isTypeSpecifier ? 'unknown' : 'module', specifier);
            }
        } else if (path.isExportDeclaration()) {
            const declar = path.get('declaration');
            
            if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {
                this.registerDeclaration(declar);
            }
        } else {
            this.registerBinding('unknown', path);
        }




    }
    
    buildUndefinedNode() {
        return buildUndefinedNode$1();
    }
    
    registerConstantViolation(path) {
        const ids = path.getAssignmentIdentifiers();
        
        for (const name of Object.keys(ids)) {
            this.getBinding(name)?.reassign(path);
        }
    }
    
    registerBinding(kind, path, bindingPath = path) {
        if (!kind)
            throw new ReferenceError('no `kind`');
        
        if (path.isVariableDeclaration()) {
            const declarators = path.get('declarations');
            
            for (const declar of declarators) {
                this.registerBinding(kind, declar);
            }
            
            return;
        }
        
        const parent = this.getProgramParent();
        const ids = path.getOuterBindingIdentifiers(true);
        
        for (const name of Object.keys(ids)) {
            parent.referencesSet.add(name);
            
            for (const id of ids[name]) {
                const local = this.getOwnBinding(name);
                
                if (local) {
                    if (local.identifier === id)
                        continue;
                    
                    this.checkBlockScopedCollisions(local, kind, name, id);
                }
                
                if (local) {
                    local.reassign(bindingPath);
                } else {
                    this.bindings[name] = new Binding({
                        identifier: id,
                        scope: this,
                        path: bindingPath,
                        kind,
                    });
                }
            }
        }
    }
    
    addGlobal(node) {
        this.globals[node.name] = node;
    }
    
    hasUid(name) {
        return this
            .getProgramParent()
            .uidsSet
            .has(name);
    }
    
    hasGlobal(name) {
        let scope2 = this;
        
        do {
            if (scope2.globals[name])
                return true;
        } while (scope2 = scope2.parent)
        
        return false;
    }
    
    hasReference(name) {
        return this
            .getProgramParent()
            .referencesSet
            .has(name);
    }
    
    isPure(node, constantsOnly) {
        if (isIdentifier$5$1(node)) {
            const binding = this.getBinding(node.name);
            
            if (!binding)
                return false;
            
            if (constantsOnly)
                return binding.constant;
            
            return true;
        } else if (isThisExpression2(node) || isMetaProperty2(node) || isTopicReference2(node) || isPrivateName2(node)) {
            return true;
        } else if (isClass2(node)) {
            if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
                return false;
            }
            
            if (node.decorators?.length > 0) {
                return false;
            }
            
            return this.isPure(node.body, constantsOnly);
        } else if (isClassBody3(node)) {
            for (const method of node.body) {
                if (!this.isPure(method, constantsOnly))
                    return false;
            }
            
            return true;
        } else if (isBinary3(node)) {
            return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
        } else if (isArrayExpression3(node)) {
            for (const elem of node.elements) {
                if (elem !== null && !this.isPure(elem, constantsOnly))
                    return false;
            }
            
            return true;
        } else if (isObjectExpression3(node)) {
            for (const prop of node.properties) {
                if (!this.isPure(prop, constantsOnly))
                    return false;
            }
            
            return true;
        } else if (isMethod2(node)) {
            if (node.computed && !this.isPure(node.key, constantsOnly))
                return false;
            
            if (node.decorators?.length > 0) {
                return false;
            }
            
            return true;
        } else if (isProperty2(node)) {
            if (node.computed && !this.isPure(node.key, constantsOnly))
                return false;
            
            if (node.decorators?.length > 0) {
                return false;
            }
            
            if (isObjectProperty2(node) || node.static) {
                if (node.value !== null && !this.isPure(node.value, constantsOnly)) {
                    return false;
                }
            }
            
            return true;
        } else if (isUnaryExpression2(node)) {
            return this.isPure(node.argument, constantsOnly);
        } else if (isTemplateLiteral2(node)) {
            for (const expression2 of node.expressions) {
                if (!this.isPure(expression2, constantsOnly))
                    return false;
            }
            
            return true;
        } else if (isTaggedTemplateExpression2(node)) {
            return matchesPattern$1$1(node.tag, 'String.raw') && !this.hasBinding('String', {
                noGlobals: true,
            }) && this.isPure(node.quasi, constantsOnly);
        } else if (isMemberExpression3(node)) {
            return !node.computed
                && isIdentifier$5$1(node.object)
                && node.object.name === 'Symbol'
                && isIdentifier$5$1(node.property)
                && node.property.name !== 'for'
                && !this.hasBinding('Symbol', {
                noGlobals: true,
            });
        } else if (isCallExpression$12(node)) {
            return matchesPattern$1$1(node.callee, 'Symbol.for')
                && !this.hasBinding('Symbol', {
                noGlobals: true,
            })
                && node.arguments.length === 1
                && isStringLiteral$a(node.arguments[0]);
        } else {
            return isPureish2(node);
        }












    }
    
    setData(key, val) {
        return this.data[key] = val;
    }
    
    getData(key) {
        let scope2 = this;
        
        do {
            const data = scope2.data[key];
            
            if (data != null)
                return data;
        } while (scope2 = scope2.parent)
    }
    
    removeData(key) {
        let scope2 = this;
        
        do {
            const data = scope2.data[key];
            
            if (data != null)
                scope2.data[key] = null;
        } while (scope2 = scope2.parent)
    }
    
    init() {
        if (!this.inited) {
            this.inited = true;
            this.crawl();
        }
    }
    
    crawl() {
        const path = this.path;
        resetScope(this);
        this.data =         /* @__PURE__ */Object.create(null);
        let scope2 = this;
        
        do {
            if (scope2.crawling)
                return;
            
            if (scope2.path.isProgram()) {
                break;
            }
        } while (scope2 = scope2.parent)
        const programParent = scope2;
        
        const state = {
            references: [],
            constantViolations: [],
            assignments: [],
        };
        
        this.crawling = true;
        scopeVisitor ||= traverse3.visitors.merge([{
            Scope(path2) {
                resetScope(path2.scope);
            },
        },
collectorVisitor]);
        
        if (path.type !== 'Program') {
            const typeVisitors = scopeVisitor[path.type];
            
            if (typeVisitors) {
                for (const visit2 of typeVisitors.enter) {
                    visit2.call(state, path, state);
                }
            }
        }
        
        traverseForScope(path, scopeVisitor, state);
        this.crawling = false;
        
        for (const path2 of state.assignments) {
            const ids = path2.getAssignmentIdentifiers();
            
            for (const name of Object.keys(ids)) {
                if (path2.scope.getBinding(name))
                    continue;
                
                programParent.addGlobal(ids[name]);
            }
            
            path2.scope.registerConstantViolation(path2);
        }
        
        for (const ref of state.references) {
            const binding = ref.scope.getBinding(ref.node.name);
            
            if (binding) {
                binding.reference(ref);
            } else {
                programParent.addGlobal(ref.node);
            }
        }
        
        for (const path2 of state.constantViolations) {
            path2.scope.registerConstantViolation(path2);
        }
    }
    
    push(opts) {
        let path = this.path;
        
        if (path.isPattern()) {
            path = this.getPatternParent().path;
        } else if (!path.isBlockStatement() && !path.isProgram()) {
            path = this.getBlockParent().path;
        }
        
        if (path.isSwitchStatement()) {
            path = (this.getFunctionParent() || this.getProgramParent()).path;
        }
        
        const {
            init,
            unique,
            kind = 'var',
            id,
        } = opts;
        
        if (!init && !unique && (kind === 'var' || kind === 'let') && isAnonymousFunctionExpression(path) && isCallExpression$12(path.parent, {callee: path.node}) && path.parent.arguments.length <= path.node.params.length && isIdentifier$5$1(id)) {
            path.pushContainer('params', id);
            path.scope.registerBinding('param', path.get('params')[path.node.params.length - 1]);
            return;
        }
        
        if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
            path.ensureBlock();
            path = path.get('body');
        }
        
        const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
        const dataKey = `declaration:${kind}:${blockHoist}`;
        let declarPath = !unique && path.getData(dataKey);
        
        if (!declarPath) {
            const declar = variableDeclaration$1(kind, []);
            
            declar._blockHoist = blockHoist;
            [declarPath] = path.unshiftContainer('body', [declar]);
            
            if (!unique)
                path.setData(dataKey, declarPath);
        }
        
        const declarator = variableDeclarator$1(id, init);
        const len = declarPath.node.declarations.push(declarator);
        
        path.scope.registerBinding(kind, declarPath.get('declarations')[len - 1]);
    }
    
    getProgramParent() {
        let scope2 = this;
        
        do {
            if (scope2.path.isProgram()) {
                return scope2;
            }
        } while (scope2 = scope2.parent)
        throw new Error('Couldn\'t find a Program');
    }
    
    getFunctionParent() {
        let scope2 = this;
        
        do {
            if (scope2.path.isFunctionParent()) {
                return scope2;
            }
        } while (scope2 = scope2.parent)
        
        return null;
    }
    
    getBlockParent() {
        let scope2 = this;
        
        do {
            if (scope2.path.isBlockParent()) {
                return scope2;
            }
        } while (scope2 = scope2.parent)
        throw new Error('We couldn\'t find a BlockStatement, For, Switch, Function, Loop or Program...');
    }
    
    getPatternParent() {
        let scope2 = this;
        
        do {
            if (!scope2.path.isPattern()) {
                return scope2.getBlockParent();
            }
        } while (scope2 = scope2.parent.parent)
        throw new Error('We couldn\'t find a BlockStatement, For, Switch, Function, Loop or Program...');
    }
    
    getAllBindings() {
        const ids =         /* @__PURE__ */Object.create(null);
        let scope2 = this;
        
        do {
            for (const key of Object.keys(scope2.bindings)) {
                if (key in ids === false) {
                    ids[key] = scope2.bindings[key];
                }
            }
            
            scope2 = scope2.parent;
        } while (scope2)
        
        return ids;
    }
    
    bindingIdentifierEquals(name, node) {
        return this.getBindingIdentifier(name) === node;
    }
    
    getBinding(name) {
        let scope2 = this;
        let previousPath;
        
        do {
            const binding = scope2.getOwnBinding(name);
            
            if (binding) {
                if (previousPath?.isPattern() && binding.kind !== 'param' && binding.kind !== 'local');
 else {
                    return binding;
                }
            } else if (!binding && name === 'arguments' && scope2.path.isFunction() && !scope2.path.isArrowFunctionExpression()) {
                break;
            }
            
            previousPath = scope2.path;
        } while (scope2 = scope2.parent)
    }
    
    getOwnBinding(name) {
        return this.bindings[name];
    }
    
    getBindingIdentifier(name) {
        return this.getBinding(name)?.identifier;
    }
    
    getOwnBindingIdentifier(name) {
        const binding = this.bindings[name];
        return binding?.identifier;
    }
    
    hasOwnBinding(name) {
        return !!this.getOwnBinding(name);
    }
    
    hasBinding(name, opts) {
        if (!name)
            return false;
        
        let noGlobals;
        let noUids;
        let upToScope;
        
        if (typeof opts === 'object') {
            noGlobals = opts.noGlobals;
            noUids = opts.noUids;
            upToScope = opts.upToScope;
        } else if (typeof opts === 'boolean') {
            noGlobals = opts;
        }
        
        let scope2 = this;
        
        do {
            if (upToScope === scope2) {
                break;
            }
            
            if (scope2.hasOwnBinding(name)) {
                return true;
            }
        } while (scope2 = scope2.parent)
        if (!noUids && this.hasUid(name))
            return true;
        
        if (!noGlobals && _Scope.globals.includes(name))
            return true;
        
        if (!noGlobals && _Scope.contextVariables.includes(name))
            return true;
        
        return false;
    }
    
    parentHasBinding(name, opts) {
        return this.parent?.hasBinding(name, opts);
    }
    
    moveBindingTo(name, scope2) {
        const info = this.getBinding(name);
        
        if (info) {
            info.scope.removeOwnBinding(name);
            info.scope = scope2;
            scope2.bindings[name] = info;
        }
    }
    
    removeOwnBinding(name) {
        delete this.bindings[name];
    }
    
    removeBinding(name) {
        this.getBinding(name)?.scope.removeOwnBinding(name);
        this
            .getProgramParent()
            .uidsSet
            .delete(name);
    }
    
    hoistVariables(emit = (id) => this.push({
        id,
    })) {
        this.crawl();
        const seen =         /* @__PURE__ */new Set();
        
        for (const name of Object.keys(this.bindings)) {
            const binding = this.bindings[name];
            
            if (!binding)
                continue;
            
            const {path} = binding;
            
            if (!path.isVariableDeclarator())
                continue;
            
            const {parent, parentPath} = path;
            
            if (parent.kind !== 'var' || seen.has(parent))
                continue;
            
            seen.add(path.parent);
            let firstId;
            const init = [];
            
            for (const decl of parent.declarations) {
                firstId ??= decl.id;
                
                if (decl.init) {
                    init.push(assignmentExpression$3('=', decl.id, decl.init));
                }
                
                const ids = Object.keys(getBindingIdentifiers$2(decl, false, true, true));
                
                for (const name2 of ids) {
                    emit(identifier$3(name2), decl.init != null);
                }
            }
            
            if (parentPath.parentPath.isForXStatement({left: parent})) {
                parentPath.replaceWith(firstId);
            } else if (init.length === 0) {
                parentPath.remove();
            } else {
                const expr = init.length === 1 ? init[0] : sequenceExpression$2(init);
                
                if (parentPath.parentPath.isForStatement({init: parent})) {
                    parentPath.replaceWith(expr);
                } else {
                    parentPath.replaceWith(expressionStatement$3$1(expr));
                }
            }
        }
    }
};

var {VISITOR_KEYS: VISITOR_KEYS$4} = lib_exports;

function findParent$1(callback) {
    let path = this;
    
    while (path = path.parentPath) {
        if (callback(path))
            return path;
    }
    
    return null;
}

function find(callback) {
    let path = this;
    
    do {
        if (callback(path))
            return path;
    } while (path = path.parentPath)
    
    return null;
}

function getFunctionParent() {
    return this.findParent((p) => p.isFunction());
}

function getStatementParent() {
    let path = this;
    
    do {
        if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
            break;
        } else {
            path = path.parentPath;
        }
    } while (path)
    if (path && (path.isProgram() || path.isFile())) {
        throw new Error('File/Program node, we can\'t possibly find a statement parent to this');
    }
    
    return path;
}

function getEarliestCommonAncestorFrom(paths) {
    return this.getDeepestCommonAncestorFrom(paths, function(deepest, i, ancestries) {
        let earliest;
        const keys2 = VISITOR_KEYS$4[deepest.type];
        
        for (const ancestry of ancestries) {
            const path = ancestry[i + 1];
            
            if (!earliest) {
                earliest = path;
                continue;
            }
            
            if (path.listKey && earliest.listKey === path.listKey) {
                if (path.key < earliest.key) {
                    earliest = path;
                    continue;
                }
            }
            
            const earliestKeyIndex = keys2.indexOf(earliest.parentKey);
            const currentKeyIndex = keys2.indexOf(path.parentKey);
            
            if (earliestKeyIndex > currentKeyIndex) {
                earliest = path;
            }
        }
        
        return earliest;
    });
}

function getDeepestCommonAncestorFrom(paths, filter) {
    if (!paths.length) {
        return this;
    }
    
    if (paths.length === 1) {
        return paths[0];
    }
    
    let minDepth = Infinity;
    let lastCommonIndex, lastCommon;
    
    const ancestries = paths.map((path) => {
        const ancestry = [];
        
        do {
            ancestry.unshift(path);
        } while ((path = path.parentPath) && path !== this)
        if (ancestry.length < minDepth) {
            minDepth = ancestry.length;
        }
        
        return ancestry;
    });
    
    const first = ancestries[0];
    
    depthLoop: for (let i = 0; i < minDepth; i++) {
        const shouldMatch = first[i];
        
        for (const ancestry of ancestries) {
            if (ancestry[i] !== shouldMatch) {
                break depthLoop;
            }
        }
        
        lastCommonIndex = i;
        lastCommon = shouldMatch;
    }
    if (lastCommon) {
        if (filter) {
            return filter(lastCommon, lastCommonIndex, ancestries);
        } else {
            return lastCommon;
        }
    } else {
        throw new Error('Couldn\'t find intersection');
    }
}

function getAncestry() {
    let path = this;
    const paths = [];
    
    do {
        paths.push(path);
    } while (path = path.parentPath)
    
    return paths;
}

function isAncestor(maybeDescendant) {
    return maybeDescendant.isDescendant(this);
}

function isDescendant(maybeAncestor) {
    return !!this.findParent((parent) => parent === maybeAncestor);
}

function inType(...candidateTypes) {
    let path = this;
    
    while (path) {
        if (candidateTypes.includes(path.node.type))
            return true;
        
        path = path.parentPath;
    }
    
    return false;
}

var {
    createFlowUnionType: createFlowUnionType2,
    createTSUnionType: createTSUnionType2,
    isFlowType: isFlowType2,
    isTSType: isTSType2,
} = lib_exports;

function createUnionType(types2) {
    if (types2.every((v) => isFlowType2(v))) {
        return createFlowUnionType2(types2);
    }
    
    if (types2.every((v) => isTSType2(v))) {
        return createTSUnionType2(types2);
    }
}

var {
    BOOLEAN_NUMBER_BINARY_OPERATORS: BOOLEAN_NUMBER_BINARY_OPERATORS2,
    createTypeAnnotationBasedOnTypeof: createTypeAnnotationBasedOnTypeof2,
    numberTypeAnnotation: numberTypeAnnotation$1,
    voidTypeAnnotation: voidTypeAnnotation$2,
} = lib_exports;

function infererReference(node) {
    if (!this.isReferenced())
        return;
    
    const binding = this.scope.getBinding(node.name);
    
    if (binding) {
        if (binding.identifier.typeAnnotation) {
            return binding.identifier.typeAnnotation;
        } else {
            return getTypeAnnotationBindingConstantViolations(binding, this, node.name);
        }
    }
    
    if (node.name === 'undefined') {
        return voidTypeAnnotation$2();
    } else if (node.name === 'NaN' || node.name === 'Infinity') {
        return numberTypeAnnotation$1();
    }    else if (node.name === 'arguments');

}

function getTypeAnnotationBindingConstantViolations(binding, path, name) {
    const types2 = [];
    const functionConstantViolations = [];
    let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
    const testType = getConditionalAnnotation(binding, path, name);
    
    if (testType) {
        const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
        
        constantViolations = constantViolations.filter((path2) => !testConstantViolations.includes(path2));
        types2.push(testType.typeAnnotation);
    }
    
    if (constantViolations.length) {
        constantViolations.push(...functionConstantViolations);
        for (const violation of constantViolations) {
            types2.push(violation.getTypeAnnotation());
        }
    }
    
    if (!types2.length) {
        return;
    }
    
    return createUnionType(types2);
}

function getConstantViolationsBefore(binding, path, functions) {
    const violations = binding.constantViolations.slice();
    violations.unshift(binding.path);
    return violations.filter((violation) => {
        violation = violation.resolve();
        const status = violation._guessExecutionStatusRelativeTo(path);
        
        if (functions && status === 'unknown')
            functions.push(violation);
        
        return status === 'before';
    });
}

function inferAnnotationFromBinaryExpression(name, path) {
    const operator = path.node.operator;
    const right = path.get('right').resolve();
    const left = path.get('left').resolve();
    let target;
    
    if (left.isIdentifier({name})) {
        target = right;
    } else if (right.isIdentifier({name})) {
        target = left;
    }
    
    if (target) {
        if (operator === '===') {
            return target.getTypeAnnotation();
        }
        
        if (BOOLEAN_NUMBER_BINARY_OPERATORS2.includes(operator)) {
            return numberTypeAnnotation$1();
        }
        
        return;
    }
    
    if (operator !== '===' && operator !== '==')
        return;
    
    let typeofPath;
    let typePath;
    
    if (left.isUnaryExpression({operator: 'typeof'})) {
        typeofPath = left;
        typePath = right;
    } else if (right.isUnaryExpression({operator: 'typeof'})) {
        typeofPath = right;
        typePath = left;
    }
    
    if (!typeofPath)
        return;
    
    if (!typeofPath.get('argument').isIdentifier({name}))
        return;
    
    typePath = typePath.resolve();
    
    if (!typePath.isLiteral())
        return;
    
    const typeValue = typePath.node.value;
    
    if (typeof typeValue !== 'string')
        return;
    
    return createTypeAnnotationBasedOnTypeof2(typeValue);
}

function getParentConditionalPath(binding, path, name) {
    let parentPath;
    
    while (parentPath = path.parentPath) {
        if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
            if (path.key === 'test') {
                return;
            }
            
            return parentPath;
        }
        
        if (parentPath.isFunction()) {
            if (name == null || parentPath.parentPath.scope.getBinding(name) !== binding)
                return;
        }
        
        path = parentPath;
    }
}

function getConditionalAnnotation(binding, path, name) {
    const ifStatement2 = getParentConditionalPath(binding, path, name);
    
    if (!ifStatement2)
        return;
    
    const test = ifStatement2.get('test');
    const paths = [test];
    const types2 = [];
    
    for (let i = 0; i < paths.length; i++) {
        const path2 = paths[i];
        
        if (path2.isLogicalExpression()) {
            if (path2.node.operator === '&&') {
                paths.push(path2.get('left'));
                paths.push(path2.get('right'));
            }
        } else if (path2.isBinaryExpression()) {
            const type = inferAnnotationFromBinaryExpression(name, path2);
            
            if (type)
                types2.push(type);
        }
    }
    
    if (types2.length) {
        return {
            typeAnnotation: createUnionType(types2),
            ifStatement: ifStatement2,
        };
    }
    
    return getConditionalAnnotation(binding, ifStatement2, name);
}

var {
    BOOLEAN_BINARY_OPERATORS: BOOLEAN_BINARY_OPERATORS2,
    BOOLEAN_UNARY_OPERATORS: BOOLEAN_UNARY_OPERATORS2,
    NUMBER_BINARY_OPERATORS: NUMBER_BINARY_OPERATORS2,
    NUMBER_UNARY_OPERATORS: NUMBER_UNARY_OPERATORS2,
    STRING_UNARY_OPERATORS: STRING_UNARY_OPERATORS2,
    anyTypeAnnotation: anyTypeAnnotation$1,
    arrayTypeAnnotation: arrayTypeAnnotation2,
    booleanTypeAnnotation: booleanTypeAnnotation2,
    buildMatchMemberExpression: buildMatchMemberExpression2,
    genericTypeAnnotation: genericTypeAnnotation2,
    identifier: identifier$2$1,
    nullLiteralTypeAnnotation: nullLiteralTypeAnnotation2,
    numberTypeAnnotation: numberTypeAnnotation2,
    stringTypeAnnotation: stringTypeAnnotation$1,
    tupleTypeAnnotation: tupleTypeAnnotation2,
    unionTypeAnnotation: unionTypeAnnotation2,
    voidTypeAnnotation: voidTypeAnnotation$1,
    isIdentifier: isIdentifier$4$1,
} = lib_exports;

function VariableDeclarator3() {
    if (!this.get('id').isIdentifier())
        return;
    
    return this
        .get('init')
        .getTypeAnnotation();
}

function TypeCastExpression3(node) {
    return node.typeAnnotation;
}

TypeCastExpression3.validParent = true;
function TSAsExpression3(node) {
    return node.typeAnnotation;
}

TSAsExpression3.validParent = true;
function TSNonNullExpression3() {
    return this
        .get('expression')
        .getTypeAnnotation();
}

function NewExpression3(node) {
    if (node.callee.type === 'Identifier') {
        return genericTypeAnnotation2(node.callee);
    }
}

function TemplateLiteral3() {
    return stringTypeAnnotation$1();
}

function UnaryExpression3(node) {
    const operator = node.operator;
    
    if (operator === 'void') {
        return voidTypeAnnotation$1();
    } else if (NUMBER_UNARY_OPERATORS2.includes(operator)) {
        return numberTypeAnnotation2();
    } else if (STRING_UNARY_OPERATORS2.includes(operator)) {
        return stringTypeAnnotation$1();
    } else if (BOOLEAN_UNARY_OPERATORS2.includes(operator)) {
        return booleanTypeAnnotation2();
    }


}

function BinaryExpression3(node) {
    const operator = node.operator;
    
    if (NUMBER_BINARY_OPERATORS2.includes(operator)) {
        return numberTypeAnnotation2();
    } else if (BOOLEAN_BINARY_OPERATORS2.includes(operator)) {
        return booleanTypeAnnotation2();
    } else if (operator === '+') {
        const right = this.get('right');
        const left = this.get('left');
        
        if (left.isBaseType('number') && right.isBaseType('number')) {
            return numberTypeAnnotation2();
        } else if (left.isBaseType('string') || right.isBaseType('string')) {
            return stringTypeAnnotation$1();
        }
        
        return unionTypeAnnotation2([stringTypeAnnotation$1(), numberTypeAnnotation2()]);
    }

}

function LogicalExpression3() {
    const argumentTypes = [
        this
            .get('left')
            .getTypeAnnotation(),
        this
            .get('right')
            .getTypeAnnotation(),
    ];
    return createUnionType(argumentTypes);
}

function ConditionalExpression3() {
    const argumentTypes = [
        this
            .get('consequent')
            .getTypeAnnotation(),
        this
            .get('alternate')
            .getTypeAnnotation(),
    ];
    return createUnionType(argumentTypes);
}

function SequenceExpression3() {
    return this
        .get('expressions')
        .pop()
        .getTypeAnnotation();
}

function ParenthesizedExpression3() {
    return this
        .get('expression')
        .getTypeAnnotation();
}

function AssignmentExpression3() {
    return this
        .get('right')
        .getTypeAnnotation();
}

function UpdateExpression3(node) {
    const operator = node.operator;
    
    if (operator === '++' || operator === '--') {
        return numberTypeAnnotation2();
    }
}

function StringLiteral4() {
    return stringTypeAnnotation$1();
}

function NumericLiteral4() {
    return numberTypeAnnotation2();
}

function BooleanLiteral3() {
    return booleanTypeAnnotation2();
}

function NullLiteral3() {
    return nullLiteralTypeAnnotation2();
}

function RegExpLiteral3() {
    return genericTypeAnnotation2(identifier$2$1('RegExp'));
}

function ObjectExpression3() {
    return genericTypeAnnotation2(identifier$2$1('Object'));
}

function ArrayExpression3() {
    return genericTypeAnnotation2(identifier$2$1('Array'));
}

function RestElement3() {
    return ArrayExpression3();
}

RestElement3.validParent = true;
function Func() {
    return genericTypeAnnotation2(identifier$2$1('Function'));
}

var isArrayFrom = buildMatchMemberExpression2('Array.from');
var isObjectKeys = buildMatchMemberExpression2('Object.keys');
var isObjectValues = buildMatchMemberExpression2('Object.values');
var isObjectEntries = buildMatchMemberExpression2('Object.entries');

function CallExpression3() {
    const {callee} = this.node;
    
    if (isObjectKeys(callee)) {
        return arrayTypeAnnotation2(stringTypeAnnotation$1());
    } else if (isArrayFrom(callee) || isObjectValues(callee) || isIdentifier$4$1(callee, {name: 'Array'})) {
        return arrayTypeAnnotation2(anyTypeAnnotation$1());
    } else if (isObjectEntries(callee)) {
        return arrayTypeAnnotation2(tupleTypeAnnotation2([stringTypeAnnotation$1(), anyTypeAnnotation$1()]));
    }
    
    return resolveCall(this.get('callee'));
}

function TaggedTemplateExpression3() {
    return resolveCall(this.get('tag'));
}

function resolveCall(callee) {
    callee = callee.resolve();
    
    if (callee.isFunction()) {
        const {node} = callee;
        
        if (node.async) {
            if (node.generator) {
                return genericTypeAnnotation2(identifier$2$1('AsyncIterator'));
            } else {
                return genericTypeAnnotation2(identifier$2$1('Promise'));
            }
        } else {
            if (node.generator) {
                return genericTypeAnnotation2(identifier$2$1('Iterator'));
            } else if (callee.node.returnType) {
                return callee.node.returnType;
            } else
;

        }
    }
}

var inferers = /* @__PURE__ */Object.freeze({
    __proto__: null,
    ArrayExpression: ArrayExpression3,
    ArrowFunctionExpression: Func,
    AssignmentExpression: AssignmentExpression3,
    BinaryExpression: BinaryExpression3,
    BooleanLiteral: BooleanLiteral3,
    CallExpression: CallExpression3,
    ClassDeclaration: Func,
    ClassExpression: Func,
    ConditionalExpression: ConditionalExpression3,
    FunctionDeclaration: Func,
    FunctionExpression: Func,
    Identifier: infererReference,
    LogicalExpression: LogicalExpression3,
    NewExpression: NewExpression3,
    NullLiteral: NullLiteral3,
    NumericLiteral: NumericLiteral4,
    ObjectExpression: ObjectExpression3,
    ParenthesizedExpression: ParenthesizedExpression3,
    RegExpLiteral: RegExpLiteral3,
    RestElement: RestElement3,
    SequenceExpression: SequenceExpression3,
    StringLiteral: StringLiteral4,
    TSAsExpression: TSAsExpression3,
    TSNonNullExpression: TSNonNullExpression3,
    TaggedTemplateExpression: TaggedTemplateExpression3,
    TemplateLiteral: TemplateLiteral3,
    TypeCastExpression: TypeCastExpression3,
    UnaryExpression: UnaryExpression3,
    UpdateExpression: UpdateExpression3,
    VariableDeclarator: VariableDeclarator3,
});

var {
    anyTypeAnnotation: anyTypeAnnotation2,
    isAnyTypeAnnotation: isAnyTypeAnnotation2,
    isArrayTypeAnnotation: isArrayTypeAnnotation3,
    isBooleanTypeAnnotation: isBooleanTypeAnnotation2,
    isEmptyTypeAnnotation: isEmptyTypeAnnotation2,
    isFlowBaseAnnotation: isFlowBaseAnnotation2,
    isGenericTypeAnnotation: isGenericTypeAnnotation2,
    isIdentifier: isIdentifier$3$1,
    isMixedTypeAnnotation: isMixedTypeAnnotation2,
    isNumberTypeAnnotation: isNumberTypeAnnotation2,
    isStringTypeAnnotation: isStringTypeAnnotation2,
    isTSArrayType: isTSArrayType2,
    isTSTypeAnnotation: isTSTypeAnnotation2,
    isTSTypeReference: isTSTypeReference2,
    isTupleTypeAnnotation: isTupleTypeAnnotation2,
    isTypeAnnotation: isTypeAnnotation2,
    isUnionTypeAnnotation: isUnionTypeAnnotation2,
    isVoidTypeAnnotation: isVoidTypeAnnotation2,
    stringTypeAnnotation: stringTypeAnnotation2,
    voidTypeAnnotation: voidTypeAnnotation2,
} = lib_exports;

function getTypeAnnotation() {
    let type = this.getData('typeAnnotation');
    
    if (type != null) {
        return type;
    }
    
    type = _getTypeAnnotation.call(this) || anyTypeAnnotation2();
    
    if (isTypeAnnotation2(type) || isTSTypeAnnotation2(type)) {
        type = type.typeAnnotation;
    }
    
    this.setData('typeAnnotation', type);
    return type;
}

var typeAnnotationInferringNodes = /* @__PURE__ */new WeakSet();

function _getTypeAnnotation() {
    const node = this.node;
    
    if (!node) {
        if (this.key === 'init' && this.parentPath.isVariableDeclarator()) {
            const declar = this.parentPath.parentPath;
            const declarParent = declar.parentPath;
            
            if (declar.key === 'left' && declarParent.isForInStatement()) {
                return stringTypeAnnotation2();
            }
            
            if (declar.key === 'left' && declarParent.isForOfStatement()) {
                return anyTypeAnnotation2();
            }
            
            return voidTypeAnnotation2();
        } else {
            return;
        }
    }
    
    if (node.typeAnnotation) {
        return node.typeAnnotation;
    }
    
    if (typeAnnotationInferringNodes.has(node)) {
        return;
    }
    
    typeAnnotationInferringNodes.add(node);
    try {
        let inferer = inferers[node.type];
        
        if (inferer) {
            return inferer.call(this, node);
        }
        
        inferer = inferers[this.parentPath.type];
        
        if (inferer?.validParent) {
            return this.parentPath.getTypeAnnotation();
        }
    } finally {
        typeAnnotationInferringNodes.delete(node);
    }
}

function isBaseType(baseName, soft) {
    return _isBaseType(baseName, this.getTypeAnnotation(), soft);
}

function _isBaseType(baseName, type, soft) {
    if (baseName === 'string') {
        return isStringTypeAnnotation2(type);
    } else if (baseName === 'number') {
        return isNumberTypeAnnotation2(type);
    } else if (baseName === 'boolean') {
        return isBooleanTypeAnnotation2(type);
    } else if (baseName === 'any') {
        return isAnyTypeAnnotation2(type);
    } else if (baseName === 'mixed') {
        return isMixedTypeAnnotation2(type);
    } else if (baseName === 'empty') {
        return isEmptyTypeAnnotation2(type);
    } else if (baseName === 'void') {
        return isVoidTypeAnnotation2(type);
    } else {
        if (soft) {
            return false;
        } else {
            throw new Error(`Unknown base type ${baseName}`);
        }
    }





}

function couldBeBaseType(name) {
    const type = this.getTypeAnnotation();
    
    if (isAnyTypeAnnotation2(type))
        return true;
    
    if (isUnionTypeAnnotation2(type)) {
        for (const type2 of type.types) {
            if (isAnyTypeAnnotation2(type2) || _isBaseType(name, type2, true)) {
                return true;
            }
        }
        
        return false;
    } else {
        return _isBaseType(name, type, true);
    }
}

function baseTypeStrictlyMatches(rightArg) {
    const left = this.getTypeAnnotation();
    const right = rightArg.getTypeAnnotation();
    
    if (!isAnyTypeAnnotation2(left) && isFlowBaseAnnotation2(left)) {
        return right.type === left.type;
    }
    
    return false;
}

function isGenericType(genericName) {
    const type = this.getTypeAnnotation();
    
    if (genericName === 'Array') {
        if (isTSArrayType2(type) || isArrayTypeAnnotation3(type) || isTupleTypeAnnotation2(type)) {
            return true;
        }
    }
    
    return isGenericTypeAnnotation2(type) && isIdentifier$3$1(type.id, {
        name: genericName,
    })
        || isTSTypeReference2(type) && isIdentifier$3$1(type.typeName, {
        name: genericName,
    });
}

var hooks = [
    function(self, parent) {
        const removeParent = self.key === 'test'
            && (parent.isWhile()
            || parent.isSwitchCase())
            || self.key === 'declaration'
            && parent.isExportDeclaration()
            || self.key === 'body'
            && parent.isLabeledStatement()
            || self.listKey === 'declarations'
            && parent.isVariableDeclaration()
            && parent.node.declarations.length === 1
            || self.key === 'expression' && parent.isExpressionStatement();
        
        if (removeParent) {
            parent.remove();
            return true;
        }
    },
    function(self, parent) {
        if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
            parent.replaceWith(parent.node.expressions[0]);
            return true;
        }
    },
    function(self, parent) {
        if (parent.isBinary()) {
            if (self.key === 'left') {
                parent.replaceWith(parent.node.right);
            } else {
                parent.replaceWith(parent.node.left);
            }
            
            return true;
        }
    },
    function(self, parent) {
        if (parent.isIfStatement() && self.key === 'consequent' || self.key === 'body' && (parent.isLoop() || parent.isArrowFunctionExpression())) {
            self.replaceWith({
                type: 'BlockStatement',
                directives: [],
                body: [],
            });
            return true;
        }
    },
];

function remove$1() {
    _assertUnremoved.call(this);
    resync.call(this);
    
    if (_callRemovalHooks.call(this)) {
        _markRemoved.call(this);
        return;
    }
    
    if (!this.opts?.noScope) {
        _removeFromScope.call(this);
    }
    
    this.shareCommentsWithSiblings();
    _remove.call(this);
    _markRemoved.call(this);
}

function _removeFromScope() {
    const bindings = getBindingIdentifiers(this.node, false, false, true);
    Object
        .keys(bindings)
        .forEach((name) => this.scope.removeBinding(name));
}

function _callRemovalHooks() {
    if (this.parentPath) {
        for (const fn of hooks) {
            if (fn(this, this.parentPath))
                return true;
        }
    }
}

function _remove() {
    if (Array.isArray(this.container)) {
        this.container.splice(this.key, 1);
        updateSiblingKeys.call(this, this.key, -1);
    } else {
        _replaceWith.call(this, null);
    }
}

function _markRemoved() {
    this._traverseFlags |= SHOULD_SKIP | REMOVED;
    
    if (this.parent) {
        getCachedPaths(this)?.delete(this.node);
    }
    
    this.node = null;
}

function _assertUnremoved() {
    if (this.removed) {
        throw this.buildCodeFrameError('NodePath has been removed so is read-only.');
    }
}

var {
    arrowFunctionExpression: arrowFunctionExpression$2,
    assertExpression: assertExpression2,
    assignmentExpression: assignmentExpression$2,
    blockStatement: blockStatement$2,
    callExpression: callExpression$2,
    cloneNode: cloneNode$2,
    expressionStatement: expressionStatement$2$1,
    isAssignmentExpression: isAssignmentExpression3,
    isCallExpression: isCallExpression4,
    isExportNamedDeclaration: isExportNamedDeclaration3,
    isExpression: isExpression$2$1,
    isIdentifier: isIdentifier$22,
    isSequenceExpression: isSequenceExpression2,
    isSuper: isSuper2,
    thisExpression: thisExpression$1,
} = lib_exports;

function insertBefore$1(nodes_) {
    _assertUnremoved.call(this);
    const nodes2 = _verifyNodeList.call(this, nodes_);
    const {parentPath, parent} = this;
    
    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration3(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
        return parentPath.insertBefore(nodes2);
    } else if (this.isNodeType('Expression') && !this.isJSXElement() || parentPath.isForStatement() && this.key === 'init') {
        if (this.node)
            nodes2.push(this.node);
        
        return this.replaceExpressionWithStatements(nodes2);
    } else if (Array.isArray(this.container)) {
        return _containerInsertBefore.call(this, nodes2);
    } else if (this.isStatementOrBlock()) {
        const node = this.node;
        const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
        const [blockPath] = this.replaceWith(blockStatement$2(shouldInsertCurrentNode ? [node] : []));
        
        return blockPath.unshiftContainer('body', nodes2);
    } else {
        throw new Error('We don\'t know what to do with this node type. We were previously a Statement but we can\'t fit in here?');
    }


}

function _containerInsert(from, nodes2) {
    updateSiblingKeys.call(this, from, nodes2.length);
    const paths = [];
    this.container.splice(from, 0, ...nodes2);
    for (let i = 0; i < nodes2.length; i++) {
        const to = from + i;
        const path = this.getSibling(to);
        paths.push(path);
        
        if (this.context?.queue) {
            pushContext.call(path, this.context);
        }
    }
    
    const contexts = _getQueueContexts.call(this);
    
    for (const path of paths) {
        setScope.call(path);
        path.debug('Inserted.');
        
        for (const context of contexts) {
            context.maybeQueue(path, true);
        }
    }
    
    return paths;
}

function _containerInsertBefore(nodes2) {
    return _containerInsert.call(this, this.key, nodes2);
}

function _containerInsertAfter(nodes2) {
    return _containerInsert.call(this, this.key + 1, nodes2);
}

var last = (arr) => arr[arr.length - 1];

function isHiddenInSequenceExpression(path) {
    return isSequenceExpression2(path.parent) && (last(path.parent.expressions) !== path.node || isHiddenInSequenceExpression(path.parentPath));
}

function isAlmostConstantAssignment(node, scope2) {
    if (!isAssignmentExpression3(node) || !isIdentifier$22(node.left)) {
        return false;
    }
    
    const blockScope = scope2.getBlockParent();
    
    return blockScope.hasOwnBinding(node.left.name) && blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1;
}

function insertAfter$1(nodes_) {
    _assertUnremoved.call(this);
    
    if (this.isSequenceExpression()) {
        return last(this.get('expressions')).insertAfter(nodes_);
    }
    
    const nodes2 = _verifyNodeList.call(this, nodes_);
    
    const {parentPath, parent} = this;
    
    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration3(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
        return parentPath.insertAfter(nodes2.map((node) => {
            return isExpression$2$1(node) ? expressionStatement$2$1(node) : node;
        }));
    } else if (this.isNodeType('Expression') && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === 'init') {
        const self = this;
        
        if (self.node) {
            const node = self.node;
            let {scope: scope2} = this;
            
            if (scope2.path.isPattern()) {
                assertExpression2(node);
                self.replaceWith(callExpression$2(arrowFunctionExpression$2([], node), []));
                self.get('callee.body').insertAfter(nodes2);
                return [self];
            }
            
            if (isHiddenInSequenceExpression(self)) {
                nodes2.unshift(node);
            } else if (isCallExpression4(node) && isSuper2(node.callee)) {
                nodes2.unshift(node);
                nodes2.push(thisExpression$1());
            } else if (isAlmostConstantAssignment(node, scope2)) {
                nodes2.unshift(node);
                nodes2.push(cloneNode$2(node.left));
            } else if (scope2.isPure(node, true)) {
                nodes2.push(node);
            } else {
                if (parentPath.isMethod({computed: true, key: node})) {
                    scope2 = scope2.parent;
                }
                
                const temp = scope2.generateDeclaredUidIdentifier();
                nodes2.unshift(expressionStatement$2$1(assignmentExpression$2('=', cloneNode$2(temp), node)));
                nodes2.push(expressionStatement$2$1(cloneNode$2(temp)));
            }


        }
        
        return this.replaceExpressionWithStatements(nodes2);
    } else if (Array.isArray(this.container)) {
        return _containerInsertAfter.call(this, nodes2);
    } else if (this.isStatementOrBlock()) {
        const node = this.node;
        const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
        const [blockPath] = this.replaceWith(blockStatement$2(shouldInsertCurrentNode ? [node] : []));
        
        return blockPath.pushContainer('body', nodes2);
    } else {
        throw new Error('We don\'t know what to do with this node type. We were previously a Statement but we can\'t fit in here?');
    }


}

function updateSiblingKeys(fromIndex, incrementBy) {
    if (!this.parent)
        return;
    
    const paths = getCachedPaths(this);
    
    if (!paths)
        return;
    
    for (const [, path] of paths) {
        if (typeof path.key === 'number' && path.container === this.container && path.key >= fromIndex) {
            path.key += incrementBy;
        }
    }
}

function _verifyNodeList(nodes2) {
    if (!nodes2) {
        return [];
    }
    
    if (!Array.isArray(nodes2)) {
        nodes2 = [nodes2];
    }
    
    for (let i = 0; i < nodes2.length; i++) {
        const node = nodes2[i];
        let msg;
        
        if (!node) {
            msg = 'has falsy node';
        } else if (typeof node !== 'object') {
            msg = 'contains a non-object node';
        } else if (!node.type) {
            msg = 'without a type';
        } else if (node instanceof NodePath_Final) {
            msg = 'has a NodePath when it expected a raw object';
        }

        
        if (msg) {
            const type = Array.isArray(node) ? 'array' : typeof node;
            throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);
        }
    }
    
    return nodes2;
}

function unshiftContainer(listKey, nodes2) {
    _assertUnremoved.call(this);
    const verifiedNodes = _verifyNodeList.call(this, nodes2);
    const container = this.node[listKey];
    
    const path = NodePath_Final.get({
        parentPath: this,
        parent: this.node,
        container,
        listKey,
        key: 0,
    }).setContext(this.context);
    
    return _containerInsertBefore.call(path, verifiedNodes);
}

function pushContainer(listKey, nodes2) {
    _assertUnremoved.call(this);
    const verifiedNodes = _verifyNodeList.call(this, nodes2);
    const container = this.node[listKey];
    
    const path = NodePath_Final.get({
        parentPath: this,
        parent: this.node,
        container,
        listKey,
        key: container.length,
    }).setContext(this.context);
    
    return path.replaceWithMultiple(verifiedNodes);
}

var {
    FUNCTION_TYPES: FUNCTION_TYPES2,
    arrowFunctionExpression: arrowFunctionExpression$1,
    assignmentExpression: assignmentExpression$1,
    awaitExpression: awaitExpression2,
    blockStatement: blockStatement$1$1,
    buildUndefinedNode: buildUndefinedNode2,
    callExpression: callExpression$1,
    cloneNode: cloneNode$1,
    conditionalExpression: conditionalExpression$1,
    expressionStatement: expressionStatement$1$1,
    getBindingIdentifiers: getBindingIdentifiers$1,
    identifier: identifier$1$1,
    inheritLeadingComments: inheritLeadingComments2,
    inheritTrailingComments: inheritTrailingComments2,
    inheritsComments: inheritsComments2,
    isBlockStatement: isBlockStatement$1$1,
    isEmptyStatement: isEmptyStatement2,
    isExpression: isExpression$1$1,
    isExpressionStatement: isExpressionStatement4,
    isIfStatement: isIfStatement3,
    isProgram: isProgram2,
    isStatement: isStatement4,
    isVariableDeclaration: isVariableDeclaration2,
    removeComments: removeComments2,
    returnStatement: returnStatement$1,
    sequenceExpression: sequenceExpression$1,
    validate: validate$13,
    yieldExpression: yieldExpression2,
} = lib_exports;

function replaceWithMultiple$1(nodes2) {
    resync.call(this);
    const verifiedNodes = _verifyNodeList.call(this, nodes2);
    inheritLeadingComments2(verifiedNodes[0], this.node);
    inheritTrailingComments2(verifiedNodes[verifiedNodes.length - 1], this.node);
    getCachedPaths(this)?.delete(this.node);
    this.node =
    this.container[this.key] = null;
    const paths = this.insertAfter(nodes2);
    
    if (this.node) {
        this.requeue();
    } else {
        this.remove();
    }
    
    return paths;
}

function replaceWithSourceString(replacement) {
    resync.call(this);
    let ast;
    
    try {
        replacement = `(${replacement})`;
        ast = parse$9(replacement);
    } catch(err) {
        const loc = err.loc;
        
        if (loc) {
            err.message += ' - make sure this is an expression.\n' + codeFrameColumns(replacement, {
                start: {
                    line: loc.line,
                    column: loc.column + 1,
                },
            });
            err.code = 'BABEL_REPLACE_SOURCE_ERROR';
        }
        
        throw err;
    }


        const expressionAST = ast.program.body[0].expression;
    traverse3.removeProperties(expressionAST);
    return this.replaceWith(expressionAST);
}

function replaceWith$3(replacementPath) {
    resync.call(this);
    
    if (this.removed) {
        throw new Error('You can\'t replace this node, we\'ve already removed it');
    }
    
    let replacement = replacementPath instanceof NodePath_Final ? replacementPath.node : replacementPath;
    
    if (!replacement) {
        throw new Error('You passed `path.replaceWith()` a falsy node, use `path.remove()` instead');
    }
    
    if (this.node === replacement) {
        return [
            this,
        ];
    }
    
    if (this.isProgram() && !isProgram2(replacement)) {
        throw new Error('You can only replace a Program root node with another Program node');
    }
    
    if (Array.isArray(replacement)) {
        throw new Error('Don\'t use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`');
    }
    
    if (typeof replacement === 'string') {
        throw new Error('Don\'t use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`');
    }
    
    let nodePath = '';
    
    if (this.isNodeType('Statement') && isExpression$1$1(replacement)) {
        if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
            replacement = expressionStatement$1$1(replacement);
            nodePath = 'expression';
        }
    }
    
    if (this.isNodeType('Expression') && isStatement4(replacement)) {
        if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
            return this.replaceExpressionWithStatements([replacement]);
        }
    }
    
    const oldNode = this.node;
    
    if (oldNode) {
        inheritsComments2(replacement, oldNode);
        removeComments2(oldNode);
    }
    
    _replaceWith.call(this, replacement);
    this.type = replacement.type;
    setScope.call(this);
    this.requeue();
    return [
        nodePath ? this.get(nodePath) : this,
    ];
}

function _replaceWith(node) {
    if (!this.container) {
        throw new ReferenceError('Container is falsy');
    }
    
    if (this.inList) {
        validate$13(this.parent, this.key, [node]);
    } else {
        validate$13(this.parent, this.key, node);
    }
    
    this.debug(`Replace with ${node?.type}`);
    getCachedPaths(this)?.set(node, this).delete(this.node);
    this.node = node;
    this.container[this.key] = node;
}

function replaceExpressionWithStatements(nodes2) {
    resync.call(this);
    const declars = [];
    const nodesAsSingleExpression = gatherSequenceExpressions(nodes2, declars);
    
    if (nodesAsSingleExpression) {
        for (const id of declars)
            this.scope.push({
                id,
            });
        
        return this
            .replaceWith(nodesAsSingleExpression)[0]
            .get('expressions');
    }
    
    const functionParent = this.getFunctionParent();
    const isParentAsync = functionParent?.node.async;
    const isParentGenerator = functionParent?.node.generator;
    const container = arrowFunctionExpression$1([], blockStatement$1$1(nodes2));
    
    this.replaceWith(callExpression$1(container, []));
    const callee = this.get('callee');
    
    callee.get('body').scope.hoistVariables((id) => this.scope.push({
        id,
    }));
    const completionRecords = callee.getCompletionRecords();
    
    for (const path of completionRecords) {
        if (!path.isExpressionStatement())
            continue;
        
        const loop = path.findParent((path2) => path2.isLoop());
        
        if (loop) {
            let uid2 = loop.getData('expressionReplacementReturnUid');
            
            if (!uid2) {
                uid2 = callee.scope.generateDeclaredUidIdentifier('ret');
                callee.get('body').pushContainer('body', returnStatement$1(cloneNode$1(uid2)));
                loop.setData('expressionReplacementReturnUid', uid2);
            } else {
                uid2 = identifier$1$1(uid2.name);
            }
            
            path.get('expression').replaceWith(assignmentExpression$1('=', cloneNode$1(uid2), path.node.expression));
        } else {
            path.replaceWith(returnStatement$1(path.node.expression));
        }
    }
    
    callee.arrowFunctionToExpression();
    const newCallee = callee;
    const needToAwaitFunction = isParentAsync && traverse3.hasType(newCallee.node.body, 'AwaitExpression', FUNCTION_TYPES2);
    const needToYieldFunction = isParentGenerator && traverse3.hasType(newCallee.node.body, 'YieldExpression', FUNCTION_TYPES2);
    
    if (needToAwaitFunction) {
        newCallee.set('async', true);
        
        if (!needToYieldFunction) {
            this.replaceWith(awaitExpression2(this.node));
        }
    }
    
    if (needToYieldFunction) {
        newCallee.set('generator', true);
        this.replaceWith(yieldExpression2(this.node, true));
    }
    
    return newCallee.get('body.body');
}

function gatherSequenceExpressions(nodes2, declars) {
    const exprs = [];
    let ensureLastUndefined = true;
    
    for (const node of nodes2) {
        if (!isEmptyStatement2(node)) {
            ensureLastUndefined = false;
        }
        
        if (isExpression$1$1(node)) {
            exprs.push(node);
        } else if (isExpressionStatement4(node)) {
            exprs.push(node.expression);
        } else if (isVariableDeclaration2(node)) {
            if (node.kind !== 'var')
                return;
            
            for (const declar of node.declarations) {
                const bindings = getBindingIdentifiers$1(declar);
                
                for (const key of Object.keys(bindings)) {
                    declars.push(cloneNode$1(bindings[key]));
                }
                
                if (declar.init) {
                    exprs.push(assignmentExpression$1('=', declar.id, declar.init));
                }
            }
            
            ensureLastUndefined = true;
        } else if (isIfStatement3(node)) {
            const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], declars) : buildUndefinedNode2();
            const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], declars) : buildUndefinedNode2();
            
            if (!consequent || !alternate)
                return;
            
            exprs.push(conditionalExpression$1(node.test, consequent, alternate));
        } else if (isBlockStatement$1$1(node)) {
            const body = gatherSequenceExpressions(node.body, declars);
            
            if (!body)
                return;
            
            exprs.push(body);
        } else if (isEmptyStatement2(node)) {
            if (nodes2.indexOf(node) === 0) {
                ensureLastUndefined = true;
            }
        } else {
            return;
        }




    }
    
    if (ensureLastUndefined)
        exprs.push(buildUndefinedNode2());
    
    if (exprs.length === 1) {
        return exprs[0];
    } else {
        return sequenceExpression$1(exprs);
    }
}

function replaceInline(nodes2) {
    resync.call(this);
    
    if (Array.isArray(nodes2)) {
        if (Array.isArray(this.container)) {
            nodes2 = _verifyNodeList.call(this, nodes2);
            const paths = _containerInsertAfter.call(this, nodes2);
            this.remove();
            return paths;
        } else {
            return this.replaceWithMultiple(nodes2);
        }
    } else {
        return this.replaceWith(nodes2);
    }
}

var VALID_OBJECT_CALLEES = [
    'Number',
    'String',
    'Math',
];
var VALID_IDENTIFIER_CALLEES = [
    'isFinite',
    'isNaN',
    'parseFloat',
    'parseInt',
    'decodeURI',
    'decodeURIComponent',
    'encodeURI',
    'encodeURIComponent',
    'btoa',
    'atob',
];
var INVALID_METHODS = ['random'];

function isValidObjectCallee(val) {
    return VALID_OBJECT_CALLEES.includes(val);
}

function isValidIdentifierCallee(val) {
    return VALID_IDENTIFIER_CALLEES.includes(val);
}

function isInvalidMethod(val) {
    return INVALID_METHODS.includes(val);
}

function evaluateTruthy() {
    const res = this.evaluate();
    
    if (res.confident)
        return !!res.value;
}

function deopt(path, state) {
    if (!state.confident)
        return;
    
    state.deoptPath = path;
    state.confident = false;
}

var Globals = /* @__PURE__ */new Map([
    ['undefined', void 0],
    ['Infinity', Infinity],
    ['NaN', NaN],
]);

function evaluateCached(path, state) {
    const {node} = path;
    
    const {seen} = state;
    
    if (seen.has(node)) {
        const existing = seen.get(node);
        
        if (existing.resolved) {
            return existing.value;
        } else {
            deopt(path, state);
            return;
        }
    } else {
        const item = {
            resolved: false,
        };
        
        seen.set(node, item);
        const val = _evaluate(path, state);
        
        if (state.confident) {
            item.resolved = true;
            item.value = val;
        }
        
        return val;
    }
}

function _evaluate(path, state) {
    if (!state.confident)
        return;
    
    if (path.isSequenceExpression()) {
        const exprs = path.get('expressions');
        return evaluateCached(exprs[exprs.length - 1], state);
    }
    
    if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
        return path.node.value;
    }
    
    if (path.isNullLiteral()) {
        return null;
    }
    
    if (path.isTemplateLiteral()) {
        return evaluateQuasis(path, path.node.quasis, state);
    }
    
    if (path.isTaggedTemplateExpression() && path.get('tag').isMemberExpression()) {
        const object = path.get('tag.object');
        const {
            node: {
                name,
            },
        } = object;
        
        const property = path.get('tag.property');
        
        if (object.isIdentifier() && name === 'String' && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === 'raw') {
            return evaluateQuasis(path, path.node.quasi.quasis, state, true);
        }
    }
    
    if (path.isConditionalExpression()) {
        const testResult = evaluateCached(path.get('test'), state);
        
        if (!state.confident)
            return;
        
        if (testResult) {
            return evaluateCached(path.get('consequent'), state);
        } else {
            return evaluateCached(path.get('alternate'), state);
        }
    }
    
    if (path.isExpressionWrapper()) {
        return evaluateCached(path.get('expression'), state);
    }
    
    if (path.isMemberExpression() && !path.parentPath.isCallExpression({callee: path.node})) {
        const property = path.get('property');
        const object = path.get('object');
        
        if (object.isLiteral()) {
            const value = object.node.value;
            const type = typeof value;
            let key = null;
            
            if (path.node.computed) {
                key = evaluateCached(property, state);
                
                if (!state.confident)
                    return;
            } else if (property.isIdentifier()) {
                key = property.node.name;
            }
            
            if ((type === 'number' || type === 'string') && key != null && (typeof key === 'number' || typeof key === 'string')) {
                return value[key];
            }
        }
    }
    
    if (path.isReferencedIdentifier()) {
        const binding = path.scope.getBinding(path.node.name);
        
        if (binding) {
            if (binding.constantViolations.length > 0 || path.node.start < binding.path.node.end) {
                deopt(binding.path, state);
                return;
            }
            
            const bindingPathScope = binding.path.scope;
            
            if (binding.kind === 'var' && bindingPathScope !== binding.scope) {
                let hasUnsafeBlock = !bindingPathScope.path.parentPath.isBlockStatement();
                
                for (let scope2 = bindingPathScope.parent; scope2; scope2 = scope2.parent) {
                    if (scope2 === path.scope) {
                        if (hasUnsafeBlock) {
                            deopt(binding.path, state);
                            return;
                        }
                        
                        break;
                    }
                    
                    if (scope2.path.parentPath?.isBlockStatement()) {
                        hasUnsafeBlock = true;
                    }
                }
            }
            
            if (binding.hasValue) {
                return binding.value;
            }
        }
        
        const name = path.node.name;
        
        if (Globals.has(name)) {
            if (!binding) {
                return Globals.get(name);
            }
            
            deopt(binding.path, state);
            return;
        }
        
        if (!binding) {
            deopt(path, state);
            return;
        }
        
        const bindingPath = binding.path;
        
        if (!bindingPath.isVariableDeclarator()) {
            deopt(bindingPath, state);
            return;
        }
        
        const initPath = bindingPath.get('init');
        const value = evaluateCached(initPath, state);
        
        if (typeof value === 'object' && value !== null && binding.references > 1) {
            deopt(initPath, state);
            return;
        }
        
        return value;
    }
    
    if (path.isUnaryExpression({prefix: true})) {
        if (path.node.operator === 'void') {
            return void 0;
        }
        
        const argument = path.get('argument');
        
        if (path.node.operator === 'typeof' && (argument.isFunction() || argument.isClass())) {
            return 'function';
        }
        
        const arg = evaluateCached(argument, state);
        
        if (!state.confident)
            return;
        
        switch(path.node.operator) {
        case '!':
            return !arg;
        
        case '+':
            return +arg;
        
        case '-':
            return -arg;
        
        case '~':
            return ~arg;
        
        case 'typeof':
            return typeof arg;
        }
    }
    
    if (path.isArrayExpression()) {
        const arr = [];
        const elems = path.get('elements');
        
        for (const elem of elems) {
            const elemValue = elem.evaluate();
            
            if (elemValue.confident) {
                arr.push(elemValue.value);
            } else {
                deopt(elemValue.deopt, state);
                return;
            }
        }
        
        return arr;
    }
    
    if (path.isObjectExpression()) {
        const obj = {};
        const props = path.get('properties');
        
        for (const prop of props) {
            if (prop.isObjectMethod() || prop.isSpreadElement()) {
                deopt(prop, state);
                return;
            }
            
            const keyPath = prop.get('key');
            let key;
            
            if (prop.node.computed) {
                key = keyPath.evaluate();
                
                if (!key.confident) {
                    deopt(key.deopt, state);
                    return;
                }
                
                key = key.value;
            } else if (keyPath.isIdentifier()) {
                key = keyPath.node.name;
            } else {
                key = keyPath.node.value;
            }
            
            const valuePath = prop.get('value');
            let value = valuePath.evaluate();
            
            if (!value.confident) {
                deopt(value.deopt, state);
                return;
            }
            
            value = value.value;
            obj[key] = value;
        }
        
        return obj;
    }
    
    if (path.isLogicalExpression()) {
        const wasConfident = state.confident;
        const left = evaluateCached(path.get('left'), state);
        const leftConfident = state.confident;
        
        state.confident = wasConfident;
        const right = evaluateCached(path.get('right'), state);
        const rightConfident = state.confident;
        
        switch(path.node.operator) {
        case '||':
            state.confident = leftConfident && (!!left || rightConfident);
            
            if (!state.confident)
                return;
            
            return left || right;
        
        case '&&':
            state.confident = leftConfident && (!left || rightConfident);
            
            if (!state.confident)
                return;
            
            return left && right;
        
        case '??':
            state.confident = leftConfident && (left != null || rightConfident);
            
            if (!state.confident)
                return;
            
            return left ?? right;
        }
    }
    
    if (path.isBinaryExpression()) {
        const left = evaluateCached(path.get('left'), state);
        
        if (!state.confident)
            return;
        
        const right = evaluateCached(path.get('right'), state);
        
        if (!state.confident)
            return;
        
        switch(path.node.operator) {
        case '-':
            return left - right;
        
        case '+':
            return left + right;
        
        case '/':
            return left / right;
        
        case '*':
            return left * right;
        
        case '%':
            return left % right;
        
        case '**':
            return left ** right;
        
        case '<':
            return left < right;
        
        case '>':
            return left > right;
        
        case '<=':
            return left <= right;
        
        case '>=':
            return left >= right;
        
        case '==':
            return left == right;
        
        case '!=':
            return left != right;
        
        case '===':
            return left === right;
        
        case '!==':
            return left !== right;
        
        case '|':
            return left | right;
        
        case '&':
            return left & right;
        
        case '^':
            return left ^ right;
        
        case '<<':
            return left << right;
        
        case '>>':
            return left >> right;
        
        case '>>>':
            return left >>> right;
        }
    }
    
    if (path.isCallExpression()) {
        const callee = path.get('callee');
        let context;
        let func;
        
        if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && (isValidObjectCallee(callee.node.name) || isValidIdentifierCallee(callee.node.name))) {
            func = global$1[callee.node.name];
        }
        
        if (callee.isMemberExpression()) {
            const object = callee.get('object');
            const property = callee.get('property');
            
            if (object.isIdentifier() && property.isIdentifier() && isValidObjectCallee(object.node.name) && !isInvalidMethod(property.node.name)) {
                context = global$1[object.node.name];
                const key = property.node.name;
                
                if (Object.hasOwn(context, key)) {
                    func = context[key];
                }
            }
            
            if (object.isLiteral() && property.isIdentifier()) {
                const type = typeof object.node.value;
                
                if (type === 'string' || type === 'number') {
                    context = object.node.value;
                    func = context[property.node.name];
                }
            }
        }
        
        if (func) {
            const args = path.get('arguments').map((arg) => evaluateCached(arg, state));
            
            if (!state.confident)
                return;
            
            return func.apply(context, args);
        }
    }
    
    deopt(path, state);
}

function evaluateQuasis(path, quasis, state, raw = false) {
    let str = '';
    let i = 0;
    const exprs = path.isTemplateLiteral() ? path.get('expressions') : path.get('quasi.expressions');
    
    for (const elem of quasis) {
        if (!state.confident)
            break;
        
        str += raw ? elem.value.raw : elem.value.cooked;
        const expr = exprs[i++];
        
        if (expr)
            str += String(evaluateCached(expr, state));
    }
    
    if (!state.confident)
        return;
    
    return str;
}

function evaluate() {
    const state = {
        confident: true,
        deoptPath: null,
        seen:         /* @__PURE__ */new Map(),
    };
    
    let value = evaluateCached(this, state);
    
    if (!state.confident)
        value = void 0;
    
    return {
        confident: state.confident,
        deopt: state.deoptPath,
        value,
    };
}

var {
    arrowFunctionExpression: arrowFunctionExpression2,
    assignmentExpression: assignmentExpression2,
    binaryExpression: binaryExpression2,
    blockStatement: blockStatement3,
    callExpression: callExpression2,
    conditionalExpression: conditionalExpression2,
    expressionStatement: expressionStatement3,
    identifier: identifier3,
    isIdentifier: isIdentifier$12,
    jsxIdentifier: jsxIdentifier2,
    logicalExpression: logicalExpression2,
    LOGICAL_OPERATORS: LOGICAL_OPERATORS2,
    memberExpression: memberExpression2,
    metaProperty: metaProperty2,
    numericLiteral: numericLiteral$1,
    objectExpression: objectExpression2,
    restElement: restElement2,
    returnStatement: returnStatement2,
    sequenceExpression: sequenceExpression2,
    spreadElement: spreadElement2,
    stringLiteral: stringLiteral3,
    super: _super2,
    thisExpression: thisExpression2,
    toExpression: toExpression2,
    unaryExpression: unaryExpression$1$1,
    toBindingIdentifierName: toBindingIdentifierName2,
    isFunction: isFunction4,
    isAssignmentPattern: isAssignmentPattern3,
    isRestElement: isRestElement2,
    getFunctionName: getFunctionName2,
    cloneNode: cloneNode3,
    variableDeclaration: variableDeclaration2,
    variableDeclarator: variableDeclarator2,
    exportNamedDeclaration: exportNamedDeclaration2,
    exportSpecifier: exportSpecifier2,
    inherits: inherits2,
} = lib_exports;

function toComputedKey2() {
    let key;
    
    if (this.isMemberExpression()) {
        key = this.node.property;
    } else if (this.isProperty() || this.isMethod()) {
        key = this.node.key;
    } else {
        throw new ReferenceError('todo');
    }
    
    if (!this.node.computed) {
        if (isIdentifier$12(key))
            key = stringLiteral3(key.name);
    }
    
    return key;
}

function ensureBlock2() {
    const body = this.get('body');
    const bodyNode = body.node;
    
    if (Array.isArray(body)) {
        throw new Error('Can\'t convert array path to a block statement');
    }
    
    if (!bodyNode) {
        throw new Error('Can\'t convert node without a body');
    }
    
    if (body.isBlockStatement()) {
        return bodyNode;
    }
    
    const statements2 = [];
    let stringPath = 'body';
    let key;
    let listKey;
    
    if (body.isStatement()) {
        listKey = 'body';
        key = 0;
        statements2.push(body.node);
    } else {
        stringPath += '.body.0';
        
        if (this.isFunction()) {
            key = 'argument';
            statements2.push(returnStatement2(body.node));
        } else {
            key = 'expression';
            statements2.push(expressionStatement3(body.node));
        }
    }
    
    this.node.body = blockStatement3(statements2);
    const parentPath = this.get(stringPath);
    setup.call(body, parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
    return this.node;
}

function unwrapFunctionEnvironment() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
        throw this.buildCodeFrameError('Can only unwrap the environment of a function.');
    }
    
    hoistFunctionEnvironment(this);
}

function setType(path, type) {
    path.node.type = type;
}

function arrowFunctionToExpression({allowInsertArrow = true, allowInsertArrowWithRest = allowInsertArrow, noNewArrows = true} = {}) {
    if (!this.isArrowFunctionExpression()) {
        throw this.buildCodeFrameError('Cannot convert non-arrow function to a function expression.');
    }
    
    let self = this;
    
    if (!noNewArrows) {
        self = self.ensureFunctionName(false) ?? self;
    }
    
    const {thisBinding, fnPath: fn} = hoistFunctionEnvironment(self, noNewArrows, allowInsertArrow, allowInsertArrowWithRest);
    
    fn.ensureBlock();
    setType(fn, 'FunctionExpression');
    
    if (!noNewArrows) {
        const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier('arrowCheckId');
        
        if (checkBinding) {
            fn.parentPath.scope.push({
                id: checkBinding,
                init: objectExpression2([]),
            });
        }
        
        fn.get('body').unshiftContainer('body', expressionStatement3(callExpression2(this.hub.addHelper('newArrowCheck'), [thisExpression2(), checkBinding ? identifier3(checkBinding.name) : identifier3(thisBinding)])));
        return fn
            .replaceWith(callExpression2(memberExpression2(fn.node, identifier3('bind')), [checkBinding ? identifier3(checkBinding.name) : thisExpression2()]))[0]
            .get('callee.object');
    }
    
    return fn;
}

var getSuperCallsVisitor = environmentVisitor({
    CallExpression(child, {allSuperCalls}) {
        if (!child.get('callee').isSuper())
            return;
        
        allSuperCalls.push(child);
    },
});

function hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true, allowInsertArrowWithRest = true) {
    let arrowParent;
    let thisEnvFn = fnPath.findParent((p) => {
        if (p.isArrowFunctionExpression()) {
            arrowParent ??= p;
            return false;
        }
        
        return p.isFunction()
            || p.isProgram()
            || p.isClassProperty({
            static: false,
        })
            || p.isClassPrivateProperty({
            static: false,
        });
    });
    
    const inConstructor = thisEnvFn.isClassMethod({
        kind: 'constructor',
    });
    
    if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {
        if (arrowParent) {
            thisEnvFn = arrowParent;
        } else if (allowInsertArrow) {
            thisEnvFn = fnPath
                .replaceWith(callExpression2(arrowFunctionExpression2([], toExpression2(fnPath.node)), []))[0]
                .get('callee');
            fnPath = thisEnvFn.get('body');
        } else {
            throw fnPath.buildCodeFrameError('Unable to transform arrow inside class property');
        }
    }
    
    const {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls,
    } = getScopeInformation(fnPath);
    
    if (inConstructor && superCalls.length > 0) {
        if (!allowInsertArrow) {
            throw superCalls[0].buildCodeFrameError('When using \'@babel/plugin-transform-arrow-functions\', it\'s not possible to compile `super()` in an arrow function without compiling classes.\nPlease add \'@babel/plugin-transform-classes\' to your Babel configuration.');
        }
        
        if (!allowInsertArrowWithRest) {
            throw superCalls[0].buildCodeFrameError('When using \'@babel/plugin-transform-parameters\', it\'s not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add \'@babel/plugin-transform-classes\' to your Babel configuration.');
        }
        
        const allSuperCalls = [];
        
        thisEnvFn.traverse(getSuperCallsVisitor, {
            allSuperCalls,
        });
        const superBinding = getSuperBinding(thisEnvFn);
        
        allSuperCalls.forEach((superCall) => {
            const callee = identifier3(superBinding);
            
            callee.loc = superCall.node.callee.loc;
            superCall.get('callee').replaceWith(callee);
        });
    }
    
    if (argumentsPaths.length > 0) {
        const argumentsBinding = getBinding$1(thisEnvFn, 'arguments', () => {
            const args = () => identifier3('arguments');
            
            if (thisEnvFn.scope.path.isProgram()) {
                return conditionalExpression2(binaryExpression2('===', unaryExpression$1$1('typeof', args()), stringLiteral3('undefined')), thisEnvFn.scope.buildUndefinedNode(), args());
            } else {
                return args();
            }
        });
        
        argumentsPaths.forEach((argumentsChild) => {
            const argsRef = identifier3(argumentsBinding);
            
            argsRef.loc = argumentsChild.node.loc;
            argumentsChild.replaceWith(argsRef);
        });
    }
    
    if (newTargetPaths.length > 0) {
        const newTargetBinding = getBinding$1(thisEnvFn, 'newtarget', () => metaProperty2(identifier3('new'), identifier3('target')));
        
        newTargetPaths.forEach((targetChild) => {
            const targetRef = identifier3(newTargetBinding);
            
            targetRef.loc = targetChild.node.loc;
            targetChild.replaceWith(targetRef);
        });
    }
    
    if (superProps.length > 0) {
        if (!allowInsertArrow) {
            throw superProps[0].buildCodeFrameError('When using \'@babel/plugin-transform-arrow-functions\', it\'s not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add \'@babel/plugin-transform-classes\' to your Babel configuration.');
        }
        
        const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);
        
        flatSuperProps.forEach((superProp) => {
            const key = superProp.node.computed ? '' : superProp.get('property').node.name;
            const superParentPath = superProp.parentPath;
            const isAssignment = superParentPath.isAssignmentExpression({
                left: superProp.node,
            });
            
            const isCall = superParentPath.isCallExpression({
                callee: superProp.node,
            });
            
            const isTaggedTemplate = superParentPath.isTaggedTemplateExpression({
                tag: superProp.node,
            });
            
            const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
            const args = [];
            
            if (superProp.node.computed) {
                args.push(superProp.get('property').node);
            }
            
            if (isAssignment) {
                const value = superParentPath.node.right;
                args.push(value);
            }
            
            const call2 = callExpression2(identifier3(superBinding), args);
            
            if (isCall) {
                superParentPath.unshiftContainer('arguments', thisExpression2());
                superProp.replaceWith(memberExpression2(call2, identifier3('call')));
                thisPaths.push(superParentPath.get('arguments.0'));
            } else if (isAssignment) {
                superParentPath.replaceWith(call2);
            } else if (isTaggedTemplate) {
                thisPaths.push(superProp
                    .replaceWith(callExpression2(memberExpression2(call2, identifier3('bind'), false), [thisExpression2()]))[0]
                    .get('arguments.0'));
            } else {
                superProp.replaceWith(call2);
            }

        });
    }
    
    let thisBinding;
    
    if (thisPaths.length > 0 || !noNewArrows) {
        thisBinding = getThisBinding(thisEnvFn, inConstructor);
        
        if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {
            thisPaths.forEach((thisChild) => {
                const thisRef = thisChild.isJSX() ? jsxIdentifier2(thisBinding) : identifier3(thisBinding);
                
                thisRef.loc = thisChild.node.loc;
                thisChild.replaceWith(thisRef);
            });
            
            if (!noNewArrows)
                thisBinding = null;
        }
    }
    
    return {
        thisBinding,
        fnPath,
    };
}

function isLogicalOp(op) {
    return LOGICAL_OPERATORS2.includes(op);
}

function standardizeSuperProperty(superProp) {
    if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== '=') {
        const assignmentPath = superProp.parentPath;
        const op = assignmentPath.node.operator.slice(0, -1);
        const value = assignmentPath.node.right;
        const isLogicalAssignment = isLogicalOp(op);
        
        if (superProp.node.computed) {
            const tmp = superProp.scope.generateDeclaredUidIdentifier('tmp');
            const {object, property} = superProp.node;
            
            assignmentPath.get('left').replaceWith(memberExpression2(object, assignmentExpression2('=', tmp, property), true));
            assignmentPath.get('right').replaceWith(rightExpression(isLogicalAssignment ? '=' : op, memberExpression2(object, identifier3(tmp.name), true), value));
        } else {
            const object = superProp.node.object;
            const property = superProp.node.property;
            assignmentPath.get('left').replaceWith(memberExpression2(object, property));
            assignmentPath.get('right').replaceWith(rightExpression(isLogicalAssignment ? '=' : op, memberExpression2(object, identifier3(property.name)), value));
        }
        
        if (isLogicalAssignment) {
            assignmentPath.replaceWith(logicalExpression2(op, assignmentPath.node.left, assignmentPath.node.right));
        } else {
            assignmentPath.node.operator = '=';
        }
        
        return [
            assignmentPath.get('left'),
            assignmentPath.get('right').get('left'),
        ];
    } else if (superProp.parentPath.isUpdateExpression()) {
        const updateExpr = superProp.parentPath;
        const tmp = superProp.scope.generateDeclaredUidIdentifier('tmp');
        const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier('prop') : null;
        const parts = [
            assignmentExpression2('=', tmp, memberExpression2(superProp.node.object, computedKey ? assignmentExpression2('=', computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)),
            assignmentExpression2('=', memberExpression2(superProp.node.object, computedKey ? identifier3(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression2(superProp.parentPath.node.operator[0], identifier3(tmp.name), numericLiteral$1(1))),
        ];
        
        if (!superProp.parentPath.node.prefix) {
            parts.push(identifier3(tmp.name));
        }
        
        const sequenceExpr = updateExpr.replaceWith(sequenceExpression2(parts))[0];
        const left = sequenceExpr.get('expressions.0.right');
        const right = sequenceExpr.get('expressions.1.left');
        
        return [left, right];
    }
    
    return [superProp];
    function rightExpression(op, left, right) {
        if (op === '=') {
            return assignmentExpression2('=', left, right);
        } else {
            return binaryExpression2(op, left, right);
        }
    }
}

function hasSuperClass(thisEnvFn) {
    return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
}

var assignSuperThisVisitor = environmentVisitor({
    CallExpression(child, {supers, thisBinding}) {
        if (!child.get('callee').isSuper())
            return;
        
        if (supers.has(child.node))
            return;
        
        supers.add(child.node);
        child.replaceWithMultiple([child.node, assignmentExpression2('=', identifier3(thisBinding), identifier3('this'))]);
    },
});

function getThisBinding(thisEnvFn, inConstructor) {
    return getBinding$1(thisEnvFn, 'this', (thisBinding) => {
        if (!inConstructor || !hasSuperClass(thisEnvFn))
            return thisExpression2();
        
        thisEnvFn.traverse(assignSuperThisVisitor, {
            supers:             /* @__PURE__ */new WeakSet(),
            thisBinding,
        });
    });
}

function getSuperBinding(thisEnvFn) {
    return getBinding$1(thisEnvFn, 'supercall', () => {
        const argsBinding = thisEnvFn.scope.generateUidIdentifier('args');
        return arrowFunctionExpression2([restElement2(argsBinding)], callExpression2(_super2(), [spreadElement2(identifier3(argsBinding.name))]));
    });
}

function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
    const op = isAssignment ? 'set' : 'get';
    
    return getBinding$1(thisEnvFn, `superprop_${op}:${propName || ''}`, () => {
        const argsList = [];
        let fnBody;
        
        if (propName) {
            fnBody = memberExpression2(_super2(), identifier3(propName));
        } else {
            const method = thisEnvFn.scope.generateUidIdentifier('prop');
            argsList.unshift(method);
            fnBody = memberExpression2(_super2(), identifier3(method.name), true);
        }
        
        if (isAssignment) {
            const valueIdent = thisEnvFn.scope.generateUidIdentifier('value');
            argsList.push(valueIdent);
            fnBody = assignmentExpression2('=', fnBody, identifier3(valueIdent.name));
        }
        
        return arrowFunctionExpression2(argsList, fnBody);
    });
}

function getBinding$1(thisEnvFn, key, init) {
    const cacheKey = 'binding:' + key;
    let data = thisEnvFn.getData(cacheKey);
    
    if (!data) {
        const id = thisEnvFn.scope.generateUidIdentifier(key);
        
        data = id.name;
        thisEnvFn.setData(cacheKey, data);
        thisEnvFn.scope.push({
            id,
            init: init(data),
        });
    }
    
    return data;
}

var getScopeInformationVisitor = environmentVisitor({
    ThisExpression(child, {thisPaths}) {
        thisPaths.push(child);
    },
    JSXIdentifier(child, {thisPaths}) {
        if (child.node.name !== 'this')
            return;
        
        if (!child.parentPath.isJSXMemberExpression({object: child.node}) && !child.parentPath.isJSXOpeningElement({name: child.node})) {
            return;
        }
        
        thisPaths.push(child);
    },
    CallExpression(child, {superCalls}) {
        if (child.get('callee').isSuper())
            superCalls.push(child);
    },
    MemberExpression(child, {superProps}) {
        if (child.get('object').isSuper())
            superProps.push(child);
    },
    Identifier(child, {argumentsPaths}) {
        if (!child.isReferencedIdentifier({name: 'arguments'}))
            return;
        
        let curr = child.scope;
        
        do {
            if (curr.hasOwnBinding('arguments')) {
                curr.rename('arguments');
                return;
            }
            
            if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {
                break;
            }
        } while (curr = curr.parent)
        argumentsPaths.push(child);
    },
    MetaProperty(child, {newTargetPaths}) {
        if (!child.get('meta').isIdentifier({name: 'new'}))
            return;
        
        if (!child.get('property').isIdentifier({name: 'target'}))
            return;
        
        newTargetPaths.push(child);
    },
});

function getScopeInformation(fnPath) {
    const thisPaths = [];
    const argumentsPaths = [];
    const newTargetPaths = [];
    const superProps = [];
    const superCalls = [];
    
    fnPath.traverse(getScopeInformationVisitor, {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls,
    });
    return {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls,
    };
}

function splitExportDeclaration() {
    if (!this.isExportDeclaration() || this.isExportAllDeclaration()) {
        throw new Error('Only default and named export declarations can be split.');
    }
    
    if (this.isExportNamedDeclaration() && this.get('specifiers').length > 0) {
        throw new Error('It doesn\'t make sense to split exported specifiers.');
    }
    
    const declaration = this.get('declaration');
    
    if (this.isExportDefaultDeclaration()) {
        const standaloneDeclaration = declaration.isFunctionDeclaration() || declaration.isClassDeclaration();
        const exportExpr = declaration.isFunctionExpression() || declaration.isClassExpression();
        const scope2 = declaration.isScope() ? declaration.scope.parent : declaration.scope;
        let id = declaration.node.id;
        let needBindingRegistration = false;
        
        if (!id) {
            needBindingRegistration = true;
            id = scope2.generateUidIdentifier('default');
            
            if (standaloneDeclaration || exportExpr) {
                declaration.node.id = cloneNode3(id);
            }
        } else if (exportExpr && scope2.hasBinding(id.name)) {
            needBindingRegistration = true;
            id = scope2.generateUidIdentifier(id.name);
        }
        
        const updatedDeclaration = standaloneDeclaration ? declaration.node : variableDeclaration2('var', [variableDeclarator2(cloneNode3(id), declaration.node)]);
        const updatedExportDeclaration = exportNamedDeclaration2(null, [exportSpecifier2(cloneNode3(id), identifier3('default'))]);
        
        this.insertAfter(updatedExportDeclaration);
        this.replaceWith(updatedDeclaration);
        
        if (needBindingRegistration) {
            scope2.registerDeclaration(this);
        }
        
        return this;
    } else if (this.get('specifiers').length > 0) {
        throw new Error('It doesn\'t make sense to split exported specifiers.');
    }
    
    const bindingIdentifiers = declaration.getOuterBindingIdentifiers();
    
    const specifiers = Object
        .keys(bindingIdentifiers)
        .map((name) => {
        return exportSpecifier2(identifier3(name), identifier3(name));
    });
    
    const aliasDeclar = exportNamedDeclaration2(null, specifiers);
    
    this.insertAfter(aliasDeclar);
    this.replaceWith(declaration.node);
    return this;
}

var refersOuterBindingVisitor = {
    'ReferencedIdentifier|BindingIdentifier'(path, state) {
        if (path.node.name !== state.name)
            return;
        
        state.needsRename = true;
        path.stop();
    },
    Scope(path, state) {
        if (path.scope.hasOwnBinding(state.name)) {
            path.skip();
        }
    },
};

function ensureFunctionName(supportUnicodeId) {
    if (this.node.id)
        return this;
    
    const res = getFunctionName2(this.node, this.parent);
    
    if (res == null)
        return this;
    
    let {name} = res;
    
    if (!supportUnicodeId && /[\uD800-\uDFFF]/.test(name)) {
        return null;
    }
    
    if (name.startsWith('get ') || name.startsWith('set ')) {
        return null;
    }
    
    name = toBindingIdentifierName2(name.replace(/[/ ]/g, '_'));
    const id = identifier3(name);
    inherits2(id, res.originalNode);
    const state = {
        needsRename: false,
        name,
    };
    
    const {scope: scope2} = this;
    
    const binding = scope2.getOwnBinding(name);
    
    if (binding) {
        if (binding.kind === 'param') {
            state.needsRename = true;
        }
    } else if (scope2.parent.hasBinding(name) || scope2.hasGlobal(name)) {
        this.traverse(refersOuterBindingVisitor, state);
    }
    
    if (!state.needsRename) {
        this.node.id = id;
        scope2
            .getProgramParent()
            .referencesSet
            .add(id.name);
        return this;
    }
    
    if (scope2.hasBinding(id.name) && !scope2.hasGlobal(id.name)) {
        scope2.rename(id.name);
        this.node.id = id;
        scope2
            .getProgramParent()
            .referencesSet
            .add(id.name);
        return this;
    }
    
    if (!isFunction4(this.node))
        return null;
    
    const key = scope2.generateUidIdentifier(id.name);
    const params = [];
    
    for (let i = 0, len = getFunctionArity(this.node); i < len; i++) {
        params.push(scope2.generateUidIdentifier('x'));
    }
    
    const call2 = index.expression.ast`
    (function (${key}) {
      function ${id}(${params}) {
        return ${cloneNode3(key)}.apply(this, arguments);
      }

      ${cloneNode3(id)}.toString = function () {
        return ${cloneNode3(key)}.toString();
      }

      return ${cloneNode3(id)};
    })(${toExpression2(this.node)})
  `;
    
    return this
        .replaceWith(call2)[0]
        .get('arguments.0');
}

function getFunctionArity(node) {
    const count = node.params.findIndex((param) => isAssignmentPattern3(param) || isRestElement2(param));
    return count === -1 ? node.params.length : count;
}

var {
    STATEMENT_OR_BLOCK_KEYS: STATEMENT_OR_BLOCK_KEYS2,
    VISITOR_KEYS: VISITOR_KEYS$3,
    isBlockStatement: isBlockStatement3,
    isExpression: isExpression3,
    isIdentifier: isIdentifier4,
    isLiteral: isLiteral3,
    isStringLiteral: isStringLiteral4,
    isType: isType3,
    matchesPattern: _matchesPattern,
} = lib_exports;

function matchesPattern2(pattern, allowPartial) {
    return _matchesPattern(this.node, pattern, allowPartial);
}

function isStatic() {
    return this.scope.isStatic(this.node);
}

function isNodeType(type) {
    return isType3(this.type, type);
}

function canHaveVariableDeclarationOrExpression() {
    return (this.key === 'init' || this.key === 'left') && this.parentPath.isFor();
}

function canSwapBetweenExpressionAndStatement(replacement) {
    if (this.key !== 'body' || !this.parentPath.isArrowFunctionExpression()) {
        return false;
    }
    
    if (this.isExpression()) {
        return isBlockStatement3(replacement);
    } else if (this.isBlockStatement()) {
        return isExpression3(replacement);
    }
    
    return false;
}

function isCompletionRecord(allowInsideFunction) {
    let path = this;
    let first = true;
    
    do {
        const {type, container} = path;
        
        if (!first && (path.isFunction() || type === 'StaticBlock')) {
            return !!allowInsideFunction;
        }
        
        first = false;
        
        if (Array.isArray(container) && path.key !== container.length - 1) {
            return false;
        }
    } while ((path = path.parentPath) && !path.isProgram() && !path.isDoExpression())
    
    return true;
}

function isStatementOrBlock() {
    if (this.parentPath.isLabeledStatement() || isBlockStatement3(this.container)) {
        return false;
    } else {
        return STATEMENT_OR_BLOCK_KEYS2.includes(this.key);
    }
}

function referencesImport(moduleSource, importName) {
    if (!this.isReferencedIdentifier()) {
        if (this.isJSXMemberExpression() && this.node.property.name === importName || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral4(this.node.property, {value: importName}) : this.node.property.name === importName)) {
            const object = this.get('object');
            return object.isReferencedIdentifier() && object.referencesImport(moduleSource, '*');
        }
        
        return false;
    }
    
    const binding = this.scope.getBinding(this.node.name);
    
    if (binding?.kind !== 'module')
        return false;
    
    const path = binding.path;
    const parent = path.parentPath;
    
    if (!parent.isImportDeclaration())
        return false;
    
    if (parent.node.source.value === moduleSource) {
        if (!importName)
            return true;
    } else {
        return false;
    }
    
    if (path.isImportDefaultSpecifier() && importName === 'default') {
        return true;
    }
    
    if (path.isImportNamespaceSpecifier() && importName === '*') {
        return true;
    }
    
    if (path.isImportSpecifier() && isIdentifier4(path.node.imported, {name: importName})) {
        return true;
    }
    
    return false;
}

function getSource() {
    const node = this.node;
    
    if (node.end) {
        const code2 = this.hub.getCode();
        
        if (code2)
            return code2.slice(node.start, node.end);
    }
    
    return '';
}

function willIMaybeExecuteBefore(target) {
    return this._guessExecutionStatusRelativeTo(target) !== 'after';
}

function getOuterFunction(path) {
    return path.isProgram() ? path : (path.parentPath.scope.getFunctionParent() || path.parentPath.scope.getProgramParent()).path;
}

function isExecutionUncertain(type, key) {
    switch(type) {
    case 'LogicalExpression':
        return key === 'right';
    
    case 'ConditionalExpression':    
    case 'IfStatement':
        return key === 'consequent' || key === 'alternate';
    
    case 'WhileStatement':    
    case 'DoWhileStatement':    
    case 'ForInStatement':    
    case 'ForOfStatement':
        return key === 'body';
    
    case 'ForStatement':
        return key === 'body' || key === 'update';
    
    case 'SwitchStatement':
        return key === 'cases';
    
    case 'TryStatement':
        return key === 'handler';
    
    case 'AssignmentPattern':
        return key === 'right';
    
    case 'OptionalMemberExpression':
        return key === 'property';
    
    case 'OptionalCallExpression':
        return key === 'arguments';
    
    default:
        return false;
    }
}

function isExecutionUncertainInList(paths, maxIndex) {
    for (let i = 0; i < maxIndex; i++) {
        const path = paths[i];
        
        if (isExecutionUncertain(path.parent.type, path.parentKey)) {
            return true;
        }
    }
    
    return false;
}

var SYMBOL_CHECKING = Symbol();

function _guessExecutionStatusRelativeTo(target) {
    return _guessExecutionStatusRelativeToCached(this, target,     /* @__PURE__ */new Map());
}

function _guessExecutionStatusRelativeToCached(base, target, cache2) {
    const funcParent = {
        this: getOuterFunction(base),
        target: getOuterFunction(target),
    };
    
    if (funcParent.target.node !== funcParent.this.node) {
        return _guessExecutionStatusRelativeToDifferentFunctionsCached(base, funcParent.target, cache2);
    }
    
    const paths = {
        target: target.getAncestry(),
        this: base.getAncestry(),
    };
    
    if (paths.target.includes(base))
        return 'after';
    
    if (paths.this.includes(target))
        return 'before';
    
    let commonPath;
    
    const commonIndex = {
        target: 0,
        this: 0,
    };
    
    while (!commonPath && commonIndex.this < paths.this.length) {
        const path = paths.this[commonIndex.this];
        
        commonIndex.target = paths.target.indexOf(path);
        
        if (commonIndex.target >= 0) {
            commonPath = path;
        } else {
            commonIndex.this++;
        }
    }
    
    if (!commonPath) {
        throw new Error('Internal Babel error - The two compared nodes don\'t appear to belong to the same program.');
    }
    
    if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {
        return 'unknown';
    }
    
    const divergence = {
        this: paths.this[commonIndex.this - 1],
        target: paths.target[commonIndex.target - 1],
    };
    
    if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {
        return divergence.target.key > divergence.this.key ? 'before' : 'after';
    }
    
    const keys2 = VISITOR_KEYS$3[commonPath.type];
    
    const keyPosition = {
        this: keys2.indexOf(divergence.this.parentKey),
        target: keys2.indexOf(divergence.target.parentKey),
    };
    
    return keyPosition.target > keyPosition.this ? 'before' : 'after';
}

function _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache2) {
    if (!target.isFunctionDeclaration()) {
        if (_guessExecutionStatusRelativeToCached(base, target, cache2) === 'before') {
            return 'before';
        }
        
        return 'unknown';
    } else if (target.parentPath.isExportDeclaration()) {
        return 'unknown';
    }
    
    const binding = target.scope.getBinding(target.node.id.name);
    
    if (!binding.references)
        return 'before';
    
    const referencePaths = binding.referencePaths;
    let allStatus;
    
    for (const path of referencePaths) {
        const childOfFunction = !!path.find((path2) => path2.node === target.node);
        
        if (childOfFunction)
            continue;
        
        if (path.key !== 'callee' || !path.parentPath.isCallExpression()) {
            return 'unknown';
        }
        
        const status = _guessExecutionStatusRelativeToCached(base, path, cache2);
        
        if (allStatus && allStatus !== status) {
            return 'unknown';
        } else {
            allStatus = status;
        }
    }
    
    return allStatus;
}

function _guessExecutionStatusRelativeToDifferentFunctionsCached(base, target, cache2) {
    let nodeMap = cache2.get(base.node);
    let cached;
    
    if (!nodeMap) {
        cache2.set(base.node, nodeMap =         /* @__PURE__ */new Map());
    } else if (cached = nodeMap.get(target.node)) {
        if (cached === SYMBOL_CHECKING) {
            return 'unknown';
        }
        
        return cached;
    }
    
    nodeMap.set(target.node, SYMBOL_CHECKING);
    const result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache2);
    nodeMap.set(target.node, result);
    return result;
}

function resolve2(dangerous, resolved) {
    return _resolve.call(this, dangerous, resolved) || this;
}

function _resolve(dangerous, resolved) {
    if (resolved?.includes(this))
        return;
    
    resolved = resolved || [];
    resolved.push(this);
    
    if (this.isVariableDeclarator()) {
        if (this.get('id').isIdentifier()) {
            return this
                .get('init')
                .resolve(dangerous, resolved);
        }
    } else if (this.isReferencedIdentifier()) {
        const binding = this.scope.getBinding(this.node.name);
        
        if (!binding)
            return;
        
        if (!binding.constant)
            return;
        
        if (binding.kind === 'module')
            return;
        
        if (binding.path !== this) {
            const ret = binding.path.resolve(dangerous, resolved);
            
            if (this.find((parent) => parent.node === ret.node))
                return;
            
            return ret;
        }
    } else if (this.isTypeCastExpression()) {
        return this
            .get('expression')
            .resolve(dangerous, resolved);
    } else if (dangerous && this.isMemberExpression()) {
        const targetKey = this.toComputedKey();
        
        if (!isLiteral3(targetKey))
            return;
        
        const targetName = targetKey.value;
        const target = this
            .get('object')
            .resolve(dangerous, resolved);
        
        if (target.isObjectExpression()) {
            const props = target.get('properties');
            
            for (const prop of props) {
                if (!prop.isProperty())
                    continue;
                
                const key = prop.get('key');
                let match = prop.isnt('computed') && key.isIdentifier({
                    name: targetName,
                });
                
                match = match || key.isLiteral({
                    value: targetName,
                });
                
                if (match)
                    return prop.get('value').resolve(dangerous, resolved);
            }
        } else if (target.isArrayExpression() && !isNaN(+targetName)) {
            const elems = target.get('elements');
            const elem = elems[targetName];
            
            if (elem)
                return elem.resolve(dangerous, resolved);
        }
    }


}

function isConstantExpression() {
    if (this.isIdentifier()) {
        const binding = this.scope.getBinding(this.node.name);
        
        if (!binding)
            return false;
        
        return binding.constant;
    }
    
    if (this.isLiteral()) {
        if (this.isRegExpLiteral()) {
            return false;
        }
        
        if (this.isTemplateLiteral()) {
            return this
                .get('expressions')
                .every((expression2) => expression2.isConstantExpression());
        }
        
        return true;
    }
    
    if (this.isUnaryExpression()) {
        if (this.node.operator !== 'void') {
            return false;
        }
        
        return this
            .get('argument')
            .isConstantExpression();
    }
    
    if (this.isBinaryExpression()) {
        const {operator} = this.node;
        
        return operator !== 'in'
            && operator !== 'instanceof'
            && this
            .get('left')
            .isConstantExpression()
            && this
            .get('right')
            .isConstantExpression();
    }
    
    if (this.isMemberExpression()) {
        return !this.node.computed && this
            .get('object')
            .isIdentifier({
                name: 'Symbol',
            }) && !this.scope.hasBinding('Symbol', {
            noGlobals: true,
        });
    }
    
    if (this.isCallExpression()) {
        return this.node.arguments.length === 1
            && this
            .get('callee')
            .matchesPattern('Symbol.for')
            && !this.scope.hasBinding('Symbol', {
            noGlobals: true,
        })
            && this
            .get('arguments')[0]
            .isStringLiteral();
    }
    
    return false;
}

function isInStrictMode() {
    const start = this.isProgram() ? this : this.parentPath;
    const strictParent = start.find((path) => {
        if (path.isProgram({sourceType: 'module'}))
            return true;
        
        if (path.isClass())
            return true;
        
        if (path.isArrowFunctionExpression() && !path.get('body').isBlockStatement()) {
            return false;
        }
        
        let body;
        
        if (path.isFunction()) {
            body = path.node.body;
        } else if (path.isProgram()) {
            body = path.node;
        } else {
            return false;
        }
        
        for (const directive2 of body.directives) {
            if (directive2.value.value === 'use strict') {
                return true;
            }
        }
        
        return false;
    });
    
    return !!strictParent;
}

var {
    getAssignmentIdentifiers: _getAssignmentIdentifiers,
    getBindingIdentifiers: _getBindingIdentifiers,
    getOuterBindingIdentifiers: _getOuterBindingIdentifiers,
    numericLiteral: numericLiteral2,
    unaryExpression: unaryExpression2,
} = lib_exports;

var NORMAL_COMPLETION = 0;
var BREAK_COMPLETION = 1;

function NormalCompletion(path) {
    return {
        type: NORMAL_COMPLETION,
        path,
    };
}

function BreakCompletion(path) {
    return {
        type: BREAK_COMPLETION,
        path,
    };
}

function getOpposite() {
    if (this.key === 'left') {
        return this.getSibling('right');
    } else if (this.key === 'right') {
        return this.getSibling('left');
    }
    
    return null;
}

function addCompletionRecords(path, records, context) {
    if (path) {
        records.push(..._getCompletionRecords(path, context));
    }
    
    return records;
}

function completionRecordForSwitch(cases, records, context) {
    let lastNormalCompletions = [];
    
    for (let i = 0; i < cases.length; i++) {
        const casePath = cases[i];
        const caseCompletions = _getCompletionRecords(casePath, context);
        const normalCompletions = [];
        const breakCompletions = [];
        
        for (const c of caseCompletions) {
            if (c.type === NORMAL_COMPLETION) {
                normalCompletions.push(c);
            }
            
            if (c.type === BREAK_COMPLETION) {
                breakCompletions.push(c);
            }
        }
        
        if (normalCompletions.length) {
            lastNormalCompletions = normalCompletions;
        }
        
        records.push(...breakCompletions);
    }
    
    records.push(...lastNormalCompletions);
    
    return records;
}

function normalCompletionToBreak(completions) {
    completions.forEach((c) => {
        c.type = BREAK_COMPLETION;
    });
}

function replaceBreakStatementInBreakCompletion(completions, reachable) {
    completions.forEach((c) => {
        if (c.path.isBreakStatement({label: null})) {
            if (reachable) {
                c.path.replaceWith(unaryExpression2('void', numericLiteral2(0)));
            } else {
                c.path.remove();
            }
        }
    });
}

function getStatementListCompletion(paths, context) {
    const completions = [];
    
    if (context.canHaveBreak) {
        let lastNormalCompletions = [];
        
        for (let i = 0; i < paths.length; i++) {
            const path = paths[i];
            const newContext = {
                ...context,
                inCaseClause: false,
            };
            
            if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {
                newContext.shouldPopulateBreak = true;
            } else {
                newContext.shouldPopulateBreak = false;
            }
            
            const statementCompletions = _getCompletionRecords(path, newContext);
            
            if (statementCompletions.length > 0 && statementCompletions.every((c) => c.type === BREAK_COMPLETION)) {
                if (lastNormalCompletions.length > 0 && statementCompletions.every((c) => c.path.isBreakStatement({label: null}))) {
                    normalCompletionToBreak(lastNormalCompletions);
                    completions.push(...lastNormalCompletions);
                    
                    if (lastNormalCompletions.some((c) => c.path.isDeclaration())) {
                        completions.push(...statementCompletions);
                        
                        if (!context.shouldPreserveBreak) {
                            replaceBreakStatementInBreakCompletion(statementCompletions, true);
                        }
                    }
                    
                    if (!context.shouldPreserveBreak) {
                        replaceBreakStatementInBreakCompletion(statementCompletions, false);
                    }
                } else {
                    completions.push(...statementCompletions);
                    
                    if (!context.shouldPopulateBreak && !context.shouldPreserveBreak) {
                        replaceBreakStatementInBreakCompletion(statementCompletions, true);
                    }
                }
                
                break;
            }
            
            if (i === paths.length - 1) {
                completions.push(...statementCompletions);
            } else {
                lastNormalCompletions = [];
                for (let i2 = 0; i2 < statementCompletions.length; i2++) {
                    const c = statementCompletions[i2];
                    
                    if (c.type === BREAK_COMPLETION) {
                        completions.push(c);
                    }
                    
                    if (c.type === NORMAL_COMPLETION) {
                        lastNormalCompletions.push(c);
                    }
                }
            }
        }
    } else if (paths.length) {
        for (let i = paths.length - 1; i >= 0; i--) {
            const pathCompletions = _getCompletionRecords(paths[i], context);
            
            if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration() && !pathCompletions[0].path.isEmptyStatement()) {
                completions.push(...pathCompletions);
                break;
            }
        }
    }
    
    return completions;
}

function _getCompletionRecords(path, context) {
    let records = [];
    
    if (path.isIfStatement()) {
        records = addCompletionRecords(path.get('consequent'), records, context);
        records = addCompletionRecords(path.get('alternate'), records, context);
    } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {
        return addCompletionRecords(path.get('body'), records, context);
    } else if (path.isProgram() || path.isBlockStatement()) {
        return getStatementListCompletion(path.get('body'), context);
    } else if (path.isFunction()) {
        return _getCompletionRecords(path.get('body'), context);
    } else if (path.isTryStatement()) {
        records = addCompletionRecords(path.get('block'), records, context);
        records = addCompletionRecords(path.get('handler'), records, context);
    } else if (path.isCatchClause()) {
        return addCompletionRecords(path.get('body'), records, context);
    } else if (path.isSwitchStatement()) {
        return completionRecordForSwitch(path.get('cases'), records, context);
    } else if (path.isSwitchCase()) {
        return getStatementListCompletion(path.get('consequent'), {
            canHaveBreak: true,
            shouldPopulateBreak: false,
            inCaseClause: true,
            shouldPreserveBreak: context.shouldPreserveBreak,
        });
    } else if (path.isBreakStatement()) {
        records.push(BreakCompletion(path));
    } else {
        records.push(NormalCompletion(path));
    }






    
    return records;
}

function getCompletionRecords(shouldPreserveBreak = false) {
    const records = _getCompletionRecords(this, {
        canHaveBreak: false,
        shouldPopulateBreak: false,
        inCaseClause: false,
        shouldPreserveBreak,
    });
    
    return records.map((r) => r.path);
}

function getSibling(key) {
    return NodePath_Final.get({
        parentPath: this.parentPath,
        parent: this.parent,
        container: this.container,
        listKey: this.listKey,
        key,
    }).setContext(this.context);
}

function getPrevSibling$1() {
    return this.getSibling(this.key - 1);
}

function getNextSibling$1() {
    return this.getSibling(this.key + 1);
}

function getAllNextSiblings() {
    let _key = this.key;
    let sibling = this.getSibling(++_key);
    const siblings = [];
    
    while (sibling.node) {
        siblings.push(sibling);
        sibling = this.getSibling(++_key);
    }
    
    return siblings;
}

function getAllPrevSiblings() {
    let _key = this.key;
    let sibling = this.getSibling(--_key);
    const siblings = [];
    
    while (sibling.node) {
        siblings.push(sibling);
        sibling = this.getSibling(--_key);
    }
    
    return siblings;
}

function get2(key, context = true) {
    if (context === true)
        context = this.context;
    
    const parts = key.split('.');
    
    if (parts.length === 1) {
        return _getKey.call(this, key, context);
    } else {
        return _getPattern.call(this, parts, context);
    }
}

function _getKey(key, context) {
    const node = this.node;
    const container = node[key];
    
    if (Array.isArray(container)) {
        return container.map((_, i) => {
            return NodePath_Final.get({
                listKey: key,
                parentPath: this,
                parent: node,
                container,
                key: i,
            }).setContext(context);
        });
    } else {
        return NodePath_Final.get({
            parentPath: this,
            parent: node,
            container: node,
            key,
        }).setContext(context);
    }
}

function _getPattern(parts, context) {
    let path = this;
    
    for (const part of parts) {
        if (part === '.') {
            path = path.parentPath;
        } else {
            if (Array.isArray(path)) {
                path = path[part];
            } else {
                path = path.get(part, context);
            }
        }
    }
    
    return path;
}

function getAssignmentIdentifiers2() {
    return _getAssignmentIdentifiers(this.node);
}

function getBindingIdentifiers2(duplicates) {
    return _getBindingIdentifiers(this.node, duplicates);
}

function getOuterBindingIdentifiers2(duplicates) {
    return _getOuterBindingIdentifiers(this.node, duplicates);
}

function getBindingIdentifierPaths(duplicates = false, outerOnly = false) {
    const path = this;
    const search = [path];
    const ids =     /* @__PURE__ */Object.create(null);
    
    while (search.length) {
        const id = search.shift();
        
        if (!id)
            continue;
        
        if (!id.node)
            continue;
        
        const keys2 = _getBindingIdentifiers.keys[id.node.type];
        
        if (id.isIdentifier()) {
            if (duplicates) {
                const _ids = ids[id.node.name] = ids[id.node.name] || [];
                _ids.push(id);
            } else {
                ids[id.node.name] = id;
            }
            
            continue;
        }
        
        if (id.isExportDeclaration()) {
            const declaration = id.get('declaration');
            
            if (declaration.isDeclaration()) {
                search.push(declaration);
            }
            
            continue;
        }
        
        if (outerOnly) {
            if (id.isFunctionDeclaration()) {
                search.push(id.get('id'));
                continue;
            }
            
            if (id.isFunctionExpression()) {
                continue;
            }
        }
        
        if (keys2) {
            for (let i = 0; i < keys2.length; i++) {
                const key = keys2[i];
                const child = id.get(key);
                
                if (Array.isArray(child)) {
                    search.push(...child);
                } else if (child.node) {
                    search.push(child);
                }
            }
        }
    }
    
    return ids;
}

function getOuterBindingIdentifierPaths(duplicates = false) {
    return this.getBindingIdentifierPaths(duplicates, true);
}

var {addComment: _addComment, addComments: _addComments} = lib_exports;

function shareCommentsWithSiblings() {
    if (typeof this.key === 'string')
        return;
    
    const node = this.node;
    
    if (!node)
        return;
    
    const trailing = node.trailingComments;
    const leading = node.leadingComments;
    
    if (!trailing && !leading)
        return;
    
    const prev = this.getSibling(this.key - 1);
    const next = this.getSibling(this.key + 1);
    const hasPrev = Boolean(prev.node);
    const hasNext = Boolean(next.node);
    
    if (hasPrev) {
        if (leading) {
            prev.addComments('trailing', removeIfExisting(leading, prev.node.trailingComments));
        }
        
        if (trailing && !hasNext)
            prev.addComments('trailing', trailing);
    }
    
    if (hasNext) {
        if (trailing) {
            next.addComments('leading', removeIfExisting(trailing, next.node.leadingComments));
        }
        
        if (leading && !hasPrev)
            next.addComments('leading', leading);
    }
}

function removeIfExisting(list, toRemove) {
    if (!toRemove?.length)
        return list;
    
    const set = new Set(toRemove);
    
    return list.filter((el) => {
        return !set.has(el);
    });
}

function addComment2(type, content, line) {
    _addComment(this.node, type, content, line);
}

function addComments2(type, comments) {
    _addComments(this.node, type, comments);
}

var {validate: validate3} = lib_exports;

createDebug2('babel');
var REMOVED = 1 << 0;
var SHOULD_STOP = 1 << 1;
var SHOULD_SKIP = 1 << 2;

var NodePath_Final = class NodePath {
    constructor(hub, parent) {
        this.parent = parent;
        this.hub = hub;
        this.data = null;
        this.context = null;
        this.scope = null;
    }
    
    contexts = [];
    state = null;
    _traverseFlags = 0;
    get removed() {
        return (this._traverseFlags & 1) > 0;
    }
    
    set removed(v) {
        if (v)
            this._traverseFlags |= 1;
        else
            this._traverseFlags &= -2;
    }
    
    get shouldStop() {
        return (this._traverseFlags & 2) > 0;
    }
    
    set shouldStop(v) {
        if (v)
            this._traverseFlags |= 2;
        else
            this._traverseFlags &= -3;
    }
    
    get shouldSkip() {
        return (this._traverseFlags & 4) > 0;
    }
    
    set shouldSkip(v) {
        if (v)
            this._traverseFlags |= 4;
        else
            this._traverseFlags &= -5;
    }
    
    skipKeys = null;
    parentPath = null;
    container = null;
    listKey = null;
    key = null;
    node = null;
    type = null;
    _store = null;
    static get({hub, parentPath, parent, container, listKey, key}) {
        if (!hub && parentPath) {
            hub = parentPath.hub;
        }
        
        if (!parent) {
            throw new Error('To get a node path the parent needs to exist');
        }
        
        const targetNode = container[key];
        const paths = getOrCreateCachedPaths(parent, parentPath);
        let path = paths.get(targetNode);
        
        if (!path) {
            path = new NodePath(hub, parent);
            
            if (targetNode)
                paths.set(targetNode, path);
        }
        
        setup.call(path, parentPath, container, listKey, key);
        return path;
    }
    
    getScope(scope2) {
        return this.isScope() ? new Scope2(this) : scope2;
    }
    
    setData(key, val) {
        if (this.data == null) {
            this.data =             /* @__PURE__ */Object.create(null);
        }
        
        return this.data[key] = val;
    }
    
    getData(key, def) {
        if (this.data == null) {
            this.data =             /* @__PURE__ */Object.create(null);
        }
        
        let val = this.data[key];
        
        if (val === void 0 && def !== void 0)
            val =
            this.data[key] = def;
        
        return val;
    }
    
    hasNode() {
        return this.node != null;
    }
    
    buildCodeFrameError(msg, Error2 = SyntaxError) {
        return this.hub.buildError(this.node, msg, Error2);
    }
    
    traverse(visitor, state) {
        traverse3(this.node, visitor, this.scope, state, this);
    }
    
    set(key, node) {
        validate3(this.node, key, node);
        this.node[key] = node;
    }
    
    getPathLocation() {
        const parts = [];
        let path = this;
        
        do {
            let key = path.key;
            
            if (path.inList)
                key = `${path.listKey}[${key}]`;
            
            parts.unshift(key);
        } while (path = path.parentPath)
        
        return parts.join('.');
    }
    
    debug(message) {
        return;
    }
    
    toString() {
        return generate$1(this.node).code;
    }
    
    get inList() {
        return !!this.listKey;
    }
    
    set inList(inList) {
        if (!inList) {
            this.listKey = null;
        }
    }
    
    get parentKey() {
        return this.listKey || this.key;
    }
};

var methods = {
    findParent: findParent$1,
    find,
    getFunctionParent,
    getStatementParent,
    getEarliestCommonAncestorFrom,
    getDeepestCommonAncestorFrom,
    getAncestry,
    isAncestor,
    isDescendant,
    inType,
    getTypeAnnotation,
    isBaseType,
    couldBeBaseType,
    baseTypeStrictlyMatches,
    isGenericType,
    replaceWithMultiple: replaceWithMultiple$1,
    replaceWithSourceString,
    replaceWith: replaceWith$3,
    replaceExpressionWithStatements,
    replaceInline,
    evaluateTruthy,
    evaluate,
    toComputedKey: toComputedKey2,
    ensureBlock: ensureBlock2,
    unwrapFunctionEnvironment,
    arrowFunctionToExpression,
    splitExportDeclaration,
    ensureFunctionName,
    matchesPattern: matchesPattern2,
    isStatic,
    isNodeType,
    canHaveVariableDeclarationOrExpression,
    canSwapBetweenExpressionAndStatement,
    isCompletionRecord,
    isStatementOrBlock,
    referencesImport,
    getSource,
    willIMaybeExecuteBefore,
    _guessExecutionStatusRelativeTo,
    resolve: resolve2,
    isConstantExpression,
    isInStrictMode,
    isDenylisted,
    visit,
    skip,
    skipKey,
    stop,
    setContext,
    requeue,
    requeueComputedKeyAndDecorators,
    remove: remove$1,
    insertBefore: insertBefore$1,
    insertAfter: insertAfter$1,
    unshiftContainer,
    pushContainer,
    getOpposite,
    getCompletionRecords,
    getSibling,
    getPrevSibling: getPrevSibling$1,
    getNextSibling: getNextSibling$1,
    getAllNextSiblings,
    getAllPrevSiblings,
    get: get2,
    getAssignmentIdentifiers: getAssignmentIdentifiers2,
    getBindingIdentifiers: getBindingIdentifiers2,
    getOuterBindingIdentifiers: getOuterBindingIdentifiers2,
    getBindingIdentifierPaths,
    getOuterBindingIdentifierPaths,
    shareCommentsWithSiblings,
    addComment: addComment2,
    addComments: addComments2,
};

Object.assign(NodePath_Final.prototype, methods);
for (const type of TYPES$4) {
    const typeKey = `is${type}`;
    const fn = lib_exports[typeKey];
    
    NodePath_Final.prototype[typeKey] = function(opts) {
        return fn(this.node, opts);
    };
    NodePath_Final.prototype[`assert${type}`] = function(opts) {
        if (!fn(this.node, opts)) {
            throw new TypeError(`Expected node path of type ${type}`);
        }
    };
}

Object.assign(NodePath_Final.prototype, NodePath_virtual_types_validator);
for (const type of Object.keys(virtualTypes)) {
    if (type.startsWith('_'))
        continue;
    
    if (!TYPES$4.includes(type))
        TYPES$4.push(type);
}

var {VISITOR_KEYS: VISITOR_KEYS$2} = lib_exports;

var TraversalContext = class {
    constructor(scope2, opts, state, parentPath) {
        this.parentPath = parentPath;
        this.scope = scope2;
        this.state = state;
        this.opts = opts;
    }
    
    queue = null;
    priorityQueue = null;
    shouldVisit(node) {
        const opts = this.opts;
        
        if (opts.enter || opts.exit)
            return true;
        
        if (opts[node.type])
            return true;
        
        const keys2 = VISITOR_KEYS$2[node.type];
        
        if (!keys2?.length)
            return false;
        
        for (const key of keys2) {
            if (node[key]) {
                return true;
            }
        }
        
        return false;
    }
    
    create(node, container, key, listKey) {
        return NodePath_Final.get({
            parentPath: this.parentPath,
            parent: node,
            container,
            key,
            listKey,
        });
    }
    
    maybeQueue(path, notPriority) {
        if (this.queue) {
            if (notPriority) {
                this.queue.push(path);
            } else {
                this.priorityQueue.push(path);
            }
        }
    }
    
    visitMultiple(container, parent, listKey) {
        if (container.length === 0)
            return false;
        
        const queue = [];
        
        for (let key = 0; key < container.length; key++) {
            const node = container[key];
            
            if (node && this.shouldVisit(node)) {
                queue.push(this.create(parent, container, key, listKey));
            }
        }
        
        return this.visitQueue(queue);
    }
    
    visitSingle(node, key) {
        if (this.shouldVisit(node[key])) {
            return this.visitQueue([this.create(node, node, key)]);
        } else {
            return false;
        }
    }
    
    visitQueue(queue) {
        this.queue = queue;
        this.priorityQueue = [];
        const visited =         /* @__PURE__ */new WeakSet();
        let stop2 = false;
        let visitIndex = 0;
        
        for (; visitIndex < queue.length;) {
            const path = queue[visitIndex];
            visitIndex++;
            resync.call(path);
            
            if (path.key === null)
                continue;
            
            if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {
                pushContext.call(path, this);
            }
            
            const {node} = path;
            
            if (visited.has(node))
                continue;
            
            if (node)
                visited.add(node);
            
            if (path.visit()) {
                stop2 = true;
                break;
            }
            
            if (this.priorityQueue.length) {
                stop2 = this.visitQueue(this.priorityQueue);
                this.priorityQueue = [];
                this.queue = queue;
                
                if (stop2)
                    break;
            }
        }
        
        for (let i = 0; i < visitIndex; i++) {
            if (queue[i].key === null)
                continue;
            
            popContext.call(queue[i]);
        }
        
        this.queue = null;
        
        return stop2;
    }
    
    visit(node, key) {
        const nodes2 = node[key];
        
        if (!nodes2)
            return false;
        
        if (Array.isArray(nodes2)) {
            return this.visitMultiple(nodes2, node, key);
        } else {
            return this.visitSingle(node, key);
        }
    }
};

var {VISITOR_KEYS: VISITOR_KEYS$12} = lib_exports;

function _visitPaths(ctx, paths) {
    ctx.queue = paths;
    ctx.priorityQueue = [];
    const visited =     /* @__PURE__ */new Set();
    let stop2 = false;
    let visitIndex = 0;
    
    for (; visitIndex < paths.length;) {
        const path = paths[visitIndex];
        visitIndex++;
        resync.call(path);
        
        if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== ctx) {
            pushContext.call(path, ctx);
        }
        
        if (path.key === null)
            continue;
        
        const {node} = path;
        
        if (visited.has(node))
            continue;
        
        if (node)
            visited.add(node);
        
        if (_visit(ctx, path)) {
            stop2 = true;
            break;
        }
        
        if (ctx.priorityQueue.length) {
            stop2 = _visitPaths(ctx, ctx.priorityQueue);
            ctx.priorityQueue = [];
            ctx.queue = paths;
            
            if (stop2)
                break;
        }
    }
    
    for (let i = 0; i < visitIndex; i++) {
        popContext.call(paths[i]);
    }
    
    ctx.queue = null;
    
    return stop2;
}

function _visit(ctx, path) {
    const node = path.node;
    
    if (!node) {
        return false;
    }
    
    const opts = ctx.opts;
    const denylist = opts.denylist;
    
    if (denylist?.includes(node.type)) {
        return false;
    }
    
    if (opts.shouldSkip?.(path)) {
        return false;
    }
    
    if (path.shouldSkip)
        return path.shouldStop;
    
    if (_call.call(path, opts.enter))
        return path.shouldStop;
    
    if (path.node) {
        if (_call.call(path, opts[node.type]?.enter))
            return path.shouldStop;
    }
    
    path.shouldStop = traverseNode(path.node, opts, path.scope, ctx.state, path, path.skipKeys);
    
    if (path.node) {
        if (_call.call(path, opts.exit))
            return true;
    }
    
    if (path.node) {
        _call.call(path, opts[node.type]?.exit);
    }
    
    return path.shouldStop;
}

function traverseNode(node, opts, scope2, state, path, skipKeys, visitSelf) {
    const keys2 = VISITOR_KEYS$12[node.type];
    
    if (!keys2?.length)
        return false;
    
    const ctx = new TraversalContext(scope2, opts, state, path);
    
    if (visitSelf) {
        if (skipKeys?.[path.parentKey])
            return false;
        
        return _visitPaths(ctx, [path]);
    }
    
    const hub = path == null ? node.type === 'Program' || node.type === 'File' ? new Hub() : void 0 : path.hub;
    
    for (const key of keys2) {
        if (skipKeys?.[key])
            continue;
        
        const prop = node[key];
        
        if (!prop)
            continue;
        
        if (Array.isArray(prop)) {
            if (!prop.length)
                continue;
            
            const paths = [];
            
            for (let i = 0; i < prop.length; i++) {
                const childPath = NodePath_Final.get({
                    parentPath: path,
                    parent: node,
                    container: prop,
                    key: i,
                    listKey: key,
                    hub,
                });
                
                paths.push(childPath);
            }
            
            if (_visitPaths(ctx, paths))
                return true;
        } else {
            if (_visitPaths(ctx, [
                NodePath_Final.get({parentPath: path, parent: node, container: node, key, listKey: null, hub}),
            ])) {
                return true;
            }
        }
    }
    
    return false;
}

function call(key) {
    const opts = this.opts;
    this.debug(key);
    
    if (this.node) {
        if (_call.call(this, opts[key]))
            return true;
    }
    
    if (this.node) {
        return _call.call(this, opts[this.node.type]?.[key]);
    }
    
    return false;
}

function _call(fns) {
    if (!fns)
        return false;
    
    for (const fn of fns) {
        if (!fn)
            continue;
        
        const node = this.node;
        
        if (!node)
            return true;
        
        const ret = fn.call(this.state, this, this.state);
        
        if (ret && typeof ret === 'object' && typeof ret.then === 'function') {
            throw new Error(`You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.`);
        }
        
        if (ret) {
            throw new Error(`Unexpected return value from visitor method ${fn}`);
        }
        
        if (this.node !== node)
            return true;
        
        if (this._traverseFlags > 0)
            return true;
    }
    
    return false;
}

function isDenylisted() {
    return !!this.opts.denylist?.includes(this.node.type);
}

function restoreContext(path, context) {
    if (path.context !== context) {
        path.context = context;
        path.state = context.state;
        path.opts = context.opts;
    }
}

function visit() {
    if (!this.node) {
        return false;
    }
    
    if (this.isDenylisted()) {
        return false;
    }
    
    if (this.opts.shouldSkip?.(this)) {
        return false;
    }
    
    const currentContext = this.context;
    
    if (this.shouldSkip || call.call(this, 'enter')) {
        this.debug('Skip...');
        return this.shouldStop;
    }
    
    restoreContext(this, currentContext);
    this.debug('Recursing into...');
    this.shouldStop = traverseNode(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
    restoreContext(this, currentContext);
    call.call(this, 'exit');
    return this.shouldStop;
}

function skip() {
    this.shouldSkip = true;
}

function skipKey(key) {
    if (this.skipKeys == null) {
        this.skipKeys = {};
    }
    
    this.skipKeys[key] = true;
}

function stop() {
    this._traverseFlags |= SHOULD_SKIP | SHOULD_STOP;
}

function _forceSetScope() {
    let path = this.parentPath;
    
    if ((this.key === 'key' || this.listKey === 'decorators') && path.isMethod() || this.key === 'discriminant' && path.isSwitchStatement()) {
        path = path.parentPath;
    }
    
    let target;
    
    while (path && !target) {
        target = path.scope;
        path = path.parentPath;
    }
    
    this.scope = this.getScope(target);
    this.scope?.init();
}

function setScope() {
    if (this.opts?.noScope)
        return;
    
    let path = this.parentPath;
    
    if ((this.key === 'key' || this.listKey === 'decorators') && path.isMethod() || this.key === 'discriminant' && path.isSwitchStatement()) {
        path = path.parentPath;
    }
    
    let target;
    
    while (path && !target) {
        if (path.opts?.noScope)
            return;
        
        target = path.scope;
        path = path.parentPath;
    }
    
    this.scope = this.getScope(target);
    this.scope?.init();
}

function setContext(context) {
    if (this.skipKeys != null) {
        this.skipKeys = {};
    }
    
    this._traverseFlags = 0;
    
    if (context) {
        this.context = context;
        this.state = context.state;
        this.opts = context.opts;
    }
    
    setScope.call(this);
    return this;
}

function resync() {
    if (this.removed)
        return;
    
    _resyncParent.call(this);
    _resyncList.call(this);
    _resyncKey.call(this);
}

function _resyncParent() {
    if (this.parentPath) {
        this.parent = this.parentPath.node;
    }
}

function _resyncKey() {
    if (!this.container)
        return;
    
    if (this.node === this.container[this.key]) {
        return;
    }
    
    if (Array.isArray(this.container)) {
        for (let i = 0; i < this.container.length; i++) {
            if (this.container[i] === this.node) {
                setKey.call(this, i);
                return;
            }
        }
    } else {
        for (const key of Object.keys(this.container)) {
            if (this.container[key] === this.node) {
                setKey.call(this, key);
                return;
            }
        }
    }
    
    this.key = null;
}

function _resyncList() {
    if (!this.parent || !this.inList)
        return;
    
    const newContainer = this.parent[this.listKey];
    
    if (this.container === newContainer)
        return;
    
    this.container = newContainer || null;
}

function popContext() {
    this.contexts.pop();
    
    if (this.contexts.length > 0) {
        this.setContext(this.contexts[this.contexts.length - 1]);
    } else {
        this.setContext(void 0);
    }
}

function pushContext(context) {
    this.contexts.push(context);
    this.setContext(context);
}

function setup(parentPath, container, listKey, key) {
    this.listKey = listKey;
    this.container = container;
    this.parentPath = parentPath || this.parentPath;
    setKey.call(this, key);
}

function setKey(key) {
    this.key = key;
    this.node = this.container[this.key];
    this.type = this.node?.type;
}

function requeue(pathToQueue = this) {
    if (pathToQueue.removed)
        return;
    
    pathToQueue.shouldSkip = false;
    const contexts = this.contexts;
    
    for (const context of contexts) {
        context.maybeQueue(pathToQueue);
    }
}

function requeueComputedKeyAndDecorators() {
    const {context, node} = this;
    
    if (!isPrivate(node) && node.computed) {
        context.maybeQueue(this.get('key'));
    }
    
    if (node.decorators) {
        for (const decorator2 of this.get('decorators')) {
            context.maybeQueue(decorator2);
        }
    }
}

function _getQueueContexts() {
    let path = this;
    let contexts = this.contexts;
    
    while (!contexts.length) {
        path = path.parentPath;
        
        if (!path)
            break;
        
        contexts = path.contexts;
    }
    
    return contexts;
}

var Hub = class {
    getCode() {}
    
    getScope() {}
    
    addHelper() {
        throw new Error('Helpers are not supported by the default hub.');
    }
    
    buildError(node, msg, Error2 = TypeError) {
        return new Error2(msg);
    }
};

var {
    VISITOR_KEYS: VISITOR_KEYS3,
    removeProperties: removeProperties2,
    traverseFast: traverseFast3,
} = lib_exports;

function traverse3(parent, opts = {}, scope2, state, parentPath, visitSelf) {
    if (!parent)
        return;
    
    if (!opts.noScope && !scope2) {
        if (parent.type !== 'Program' && parent.type !== 'File') {
            throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${parent.type} node without passing scope and parentPath.`);
        }
    }
    
    if (!parentPath && visitSelf) {
        throw new Error('visitSelf can only be used when providing a NodePath.');
    }
    
    if (!VISITOR_KEYS3[parent.type]) {
        return;
    }
    
    explode$1(opts);
    traverseNode(parent, opts, scope2, state, parentPath, void 0, visitSelf);
}

traverse3.visitors = visitors;
traverse3.verify = verify$1;
traverse3.explode = explode$1;
traverse3.cheap = function(node, enter) {
    traverseFast3(node, enter);
    return;
};
traverse3.node = function(node, opts, scope2, state, path, skipKeys) {
    traverseNode(node, opts, scope2, state, path, skipKeys);
};
traverse3.clearNode = function(node, opts) {
    removeProperties2(node, opts);
};
traverse3.removeProperties = function(tree, opts) {
    traverseFast3(tree, traverse3.clearNode, opts);
    return tree;
};
traverse3.hasType = function(tree, type, denylistTypes) {
    if (denylistTypes?.includes(tree.type))
        return false;
    
    if (tree.type === type)
        return true;
    
    return traverseFast3(tree, function(node) {
        if (denylistTypes?.includes(node.type)) {
            return traverseFast3.skip;
        }
        
        if (node.type === type) {
            return traverseFast3.stop;
        }
    });
};
traverse3.cache = cache;

var bundle = /*#__PURE__*/Object.freeze({
	__proto__: null,
	codeFrameColumns: codeFrameColumns,
	generate: generate$1,
	parse: parse$9,
	parseExpression: parseExpression$1,
	template: index,
	tokTypes: tokTypes,
	traverse: traverse3,
	types: lib_exports
});

const TYPES$3 = {
    TOKEN: 'Token',
    NEWLINE: 'Newline',
    SPLITTER: 'Splitter',
    INDENT: 'Indent',
    DEBUG: 'Debug',
    SPACE: 'Space',
    QUOTE: 'Quote',
    END_OF_FILE: 'EndOfFile',
};

const {
    isStringLiteral: isStringLiteral$9,
    isIdentifier: isIdentifier$g,
    isIfStatement: isIfStatement$2,
    isStatement: isStatement$6,
    isForOfStatement: isForOfStatement$1,
    isVariableDeclaration: isVariableDeclaration$4,
    isMemberExpression: isMemberExpression$8,
    isArrayExpression: isArrayExpression$9,
    isObjectExpression: isObjectExpression$9,
    isLabeledStatement: isLabeledStatement$1,
} = lib_exports;

const isParentProgram = (path) => path.parentPath?.isProgram();
const isParentBlock$1 = (path) => path.parentPath.isBlockStatement();

const isNext = (path) => {
    const next = path.getNextSibling();
    
    if (!next.node)
        return false;
    
    return !next.isEmptyStatement();
};

const isPrev = (path) => {
    const next = path.getPrevSibling();
    return next.node;
};

const isNextParent = (path) => isNext(path.parentPath);
const isLast$2 = (path) => isParentProgram(path) && !isNext(path);

const isNextObject = (a) => a
    .getNextSibling()
    .isObjectExpression();

const isPrevObject = (a) => a
    .getPrevSibling()
    .isObjectExpression();

const isFirst$2 = (path) => path.node === path.parentPath.node.body?.[0];
const isPrevBody = (path) => path
    .getPrevSibling()
    .isBlockStatement();

const isParentLast = (path) => isLast$2(path.parentPath);

const isIndented = (path = {}) => {
    const {parentPath, node} = path;
    
    if (!parentPath.node.loc)
        return true;
    
    return node.loc?.start.column !== parentPath.node.loc.start.column;
};

function isCoupleLines(path) {
    const start = path.node?.loc?.start?.line;
    const end = path.node?.loc?.end?.line;
    
    return end !== start;
}

const exists = (a) => a.node;

function isStringAndIdentifier([a, b]) {
    return isStringLiteral$9(a) && isIdentifier$g(b);
}

const checkObject = (elements) => {
    let a = elements.at(-1);
    
    if (!isObjectExpression$9(a))
        a = elements.at(-2);
    
    if (!isObjectExpression$9(a))
        return false;
    
    return a.node.properties.length;
};

const isSimpleAndNotEmptyObject = (elements) => {
    const [a] = elements;
    
    const simpleTypes = [
        'Identifier',
        'SpreadElement',
        'ArrayExpression',
        'CallExpression',
        'NewExpression',
    ];
    
    if (a && !simpleTypes.includes(a.type))
        return false;
    
    return checkObject(elements);
};

const isIdentifierAndIdentifier = ([a, b]) => {
    return isIdentifier$g(a) && isIdentifier$g(b);
};

const isStringAndMember = ([a, b]) => isStringLiteral$9(a) && isMemberExpression$8(b);
const isIdentifierAndString = ([a, b]) => isIdentifier$g(a) && isStringLiteral$9(b);
const isStringAndArray = ([a, b]) => {
    if (!isStringLiteral$9(a))
        return false;
    
    if (!isArrayExpression$9(b))
        return false;
    
    return !isStringAndIdentifier(b.node.elements);
};

const isIfOrStatement = (a) => isIfStatement$2(a) || isStatement$6(a);
const isForOfOrStatement = (a) => isForOfStatement$1(a) || isStatement$6(a);

const isIf = (path) => isIfStatement$2(path.find(isIfOrStatement));

const isForOf$2 = (path) => {
    const current = path.find(isForOfOrStatement);
    
    if (isForOfStatement$1(current))
        return true;
    
    if (isVariableDeclaration$4(current))
        return isForOfStatement$1(current.parentPath);
    
    return false;
};

const isInsideIf = (path) => path.parentPath?.isIfStatement();

const isNewlineBetweenSiblings = (path) => {
    const endCurrent = path.node?.loc?.end?.line;
    const startNext = path.getNextSibling().node?.loc?.start?.line;
    
    if (!startNext)
        return false;
    
    return startNext - endCurrent > 1;
};

const isInsideLabel = ({parentPath}) => isLabeledStatement$1(parentPath);

const satisfy = (conditions) => (path) => {
    for (const condition of conditions)
        if (condition(path))
            return true;
    
    return false;
};

const parseNode$3 = (path) => path.node || path;

const hasCoupleTrailingComments = (path) => {
    const node = parseNode$3(path);
    return node?.trailingComments?.length > 1;
};

const hasTrailingComment = (path) => {
    const node = parseNode$3(path);
    return node.trailingComments?.length;
};

const hasLeadingComment = (path) => path.node?.leadingComments?.length;

const noTrailingComment = (path) => !path.node.trailingComments?.length;
const noLeadingComment = (path) => !path.node.leadingComments?.length;

const WATER_MARK_BEFORE = '__putout_newline_before';
const WATER_MARK_AFTER = '__putout_newline_after';

const maybeMarkAfter = (a, path) => a && markAfter(path);

function markBefore(path) {
    path[WATER_MARK_BEFORE] = true;
}

function markAfter(path) {
    path[WATER_MARK_AFTER] = true;
}

function isMarkedAfter(path) {
    return path[WATER_MARK_AFTER];
}

const hasPrevNewline = (path) => {
    return isMarkedAfter(path.getPrevSibling());
};

const maybeInsideFn = (insideFn, {print, indent}) => {
    if (!insideFn)
        return;
    
    indent.inc();
    indent.inc();
    print.breakline();
    indent.dec();
    indent.dec();
};

const createPrintCommentLine$1 = (fn, value) => () => fn(`//${value}`);
const createPrintCommentBlock$1 = (fn, value) => () => fn(`/*${value}*/\n`);

const hasTrailingCommentsPrinter = (currentTraverse) => {
    const {
        printTrailingCommentBlock,
        printTrailingCommentLine,
    } = currentTraverse;
    
    if (printTrailingCommentBlock)
        return true;
    
    return Boolean(printTrailingCommentLine);
};

const hasLeadingCommentsPrinter = (currentTraverse) => {
    const {
        printLeadingCommentLine,
        printLeadingCommentBlock,
    } = currentTraverse;
    
    if (printLeadingCommentLine)
        return true;
    
    return Boolean(printLeadingCommentBlock);
};

const printLeadingComments$1 = (path, printer, semantics, {currentTraverse}) => {
    const {print} = printer;
    const {
        leadingComments = [],
    } = path.node;
    
    const {
        printLeadingCommentLine,
        printLeadingCommentBlock,
    } = currentTraverse;
    
    const n = leadingComments.length - 1;
    
    for (const [index, {type, value}] of leadingComments.entries()) {
        if (type === 'CommentLine') {
            printLeadingCommentLine?.(path, printer, semantics, {
                index,
                printComment: createPrintCommentLine$1(print, value),
                isLast: index === n,
            });
            continue;
        }
        
        if (type === 'CommentBlock')
            printLeadingCommentBlock?.(path, printer, semantics, {
                index,
                printComment: createPrintCommentBlock$1(print, value),
            });
    }
};

const printTrailingComments = (path, printer, semantics, {currentTraverse}) => {
    const {print} = printer;
    const {
        trailingComments = []} = path.node;
    
    const {
        printTrailingCommentLine,
        printTrailingCommentBlock,
    } = currentTraverse;
    
    const n = trailingComments.length - 1;
    
    for (const [index, {type, value}] of trailingComments.entries()) {
        if (type === 'CommentLine') {
            printTrailingCommentLine?.(path, printer, semantics, {
                index,
                printComment: createPrintCommentLine$1(print, value),
                isLast: index === n,
            });
            continue;
        }
        
        if (type === 'CommentBlock')
            printTrailingCommentBlock?.(path, printer, semantics, {
                index,
                printComment: createPrintCommentBlock$1(print, value),
            });
    }
};

const {
    isArrowFunctionExpression: isArrowFunctionExpression$2,
    isObjectProperty: isObjectProperty$2,
    isVariableDeclarator: isVariableDeclarator$3,
    isClassProperty,
    isTSPropertySignature,
    isSpreadElement: isSpreadElement$2,
    isClassBody: isClassBody$1,
    isBinaryExpression: isBinaryExpression$1,
    isClassMethod: isClassMethod$1,
    isDecorator: isDecorator$1,
} = lib_exports;

const isProperty = satisfy([
    isObjectProperty$2,
    isVariableDeclarator$3,
    isClassProperty,
    isTSPropertySignature,
    isSpreadElement$2,
]);

const isInsideVar = (path) => {
    const {parentPath} = path;
    
    if (isVariableDeclarator$3(parentPath) && path === parentPath.get('init'))
        return true;
    
    if (!isArrowFunctionExpression$2(parentPath))
        return false;
    
    return isVariableDeclarator$3(parentPath.parentPath);
};

const hasDecoratorsWithComments = (path) => path?.parentPath.node?.decorators;

function isCommentOfPrevious(path) {
    const [comment] = path.node.leadingComments;
    const {line} = comment.loc.start;
    
    return path.getPrevSibling().node?.loc.start.line === line;
}

function isCommentOnPreviousLine(path) {
    const {
        loc,
        leadingComments,
    } = path.node;
    
    if (!isProperty(path))
        return false;
    
    const [comment] = leadingComments;
    const {line} = comment.loc.start;
    
    if (isCommentOfPrevious(path))
        return false;
    
    return line <= loc.start.line - 1;
}

const isFirst$1 = (path) => {
    const {parentPath} = path;
    
    if (path === parentPath.get('properties')[0])
        return true;
    
    if (isClassBody$1(parentPath) && isClassProperty(path))
        return path === parentPath.get('body')[0];
    
    return false;
};

const parseLeadingComments = (path, printer, semantics, {currentTraverse = {}} = {}) => {
    const {
        print,
        maybe,
        indent,
    } = printer;
    
    if (!semantics.comments)
        return;
    
    const {leadingComments} = path.node;
    
    if (!leadingComments?.length)
        return;
    
    if (hasLeadingCommentsPrinter(currentTraverse))
        return printLeadingComments$1(path, printer, semantics, {
            currentTraverse,
        });
    
    if (hasDecoratorsWithComments(path))
        return;
    
    const looksLikeSwitchCase = path.isSwitchCase();
    
    if (!looksLikeSwitchCase && hasTrailingComment(path.getPrevSibling()))
        return;
    
    const insideFn = (path.parentPath.isFunction() || path.parentPath.isTSDeclareMethod()) && !path.isTSTypeParameterDeclaration();
    
    const propIs = isProperty(path);
    const isIndent = isFirst$1(path)
        || !looksLikeSwitchCase
        && !path.isClassMethod()
        && !insideFn
        && !propIs;
    
    const count = leadingComments.length - 1;
    
    for (const [index, {type, value}] of leadingComments.entries()) {
        if (type === 'CommentLine') {
            if (index || !path.isClassProperty() && !path.isBinaryExpression())
                maybe.indent(isIndent);
            
            maybeInsideFn(insideFn, {
                print,
                indent,
            });
            
            if (isCommentOnPreviousLine(path))
                maybe.print.breakline(!isFirst$1(path));
            else
                maybe.print.space(propIs && !path.isClassProperty());
            
            print(`//${value}`);
            
            if (index === count) {
                maybe.print.breakline(propIs);
                maybe.print.newline(!propIs);
                
                if (isClassMethod$1(path)) {
                    indent();
                } else if (isBinaryExpression$1(path) || isDecorator$1(path)) {
                    indent.inc();
                    indent();
                    indent.dec();
                }
            } else {
                print.newline();
            }
            
            if (isInsideVar(path)) {
                indent.inc();
                indent();
                indent.dec();
            }
            
            continue;
        }
        
        if (type === 'CommentBlock') {
            maybe.indent(isIndent);
            
            const looksLikeMethod = path.isClassMethod();
            const looksLikeDirective = path.isDirective();
            const looksLikeProp = path.isObjectProperty();
            
            if (looksLikeProp)
                print.breakline();
            
            print(`/*${value}*/`);
            
            if (path.isStatement() || path.isTSEnumMember() || looksLikeDirective || looksLikeMethod || looksLikeProp || looksLikeSwitchCase) {
                print.newline();
                markBefore(path);
                maybe.indent(looksLikeMethod || looksLikeProp || looksLikeSwitchCase);
            }
            
            continue;
        }
    }
};

const {assign: assign$b} = Object;

const chain$1 = (path) => {
    const all = [
        ...down$1(path),
        ...up$1(path),
    ];
    
    const properties = all.slice(0, -1);
    const root = all.at(-1);
    
    return [root, properties];
};

function down$1(path) {
    const properties = [];
    
    let current = path.get('object');
    
    while (!current.isIdentifier()) {
        const isFn = current.isCallExpression();
        const prop = build(current);
        
        if (isFn)
            current = current.get('callee');
        
        properties.unshift(prop);
        
        if (!current.isMemberExpression())
            break;
        
        current = current.get('object');
    }
    
    return properties;
}

function up$1(current) {
    const properties = [];
    
    while (current.isMemberExpression()) {
        if (hasTrailingComment(current.get('object')))
            properties.push({
                type: 'CommentLine',
            });
        
        current = current.parentPath;
        
        if (current.isCallExpression()) {
            properties.push(build(current));
            current = current.parentPath;
        }
        
        if (!current.isMemberExpression())
            break;
    }
    
    properties.push({
        type: current.type,
    });
    
    return properties;
}

function build(path) {
    const prop = {
        type: path.type,
    };
    
    if (path.isCallExpression())
        assign$b(prop, {
            args: path.node.arguments.length,
            name: path.node.callee.property?.name || '',
        });
    
    return prop;
}

const {
    isUnaryExpression,
    isIfStatement: isIfStatement$1,
    isCallExpression: isCallExpression$9,
    isIdentifier: isIdentifier$f,
} = lib_exports;

const isArgOfCall = (path) => path.parentPath?.isCallExpression() && path.parentPath.get('arguments.0') === path;
const isCall$1 = (a) => a.type === 'CallExpression';

const isExcludedFromChain = satisfy([isUnaryExpression, isIfStatement$1]);
const hasComment = ({type}) => type === 'CommentLine';

const isInsideMemberCall = (path) => {
    if (!isIdentifier$f(path.node.object))
        return false;
    
    if (!isIdentifier$f(path.node.property))
        return false;
    
    if (isLastArgInCall(path))
        return true;
    
    return isCallExpression$9(path.parentPath.parentPath);
};

function isLastArgInCall(path) {
    const {parentPath} = path;
    
    if (!isCallExpression$9(parentPath))
        return false;
    
    return path === parentPath.get('arguments').at(-1);
}

const isLooksLikeChain = (path) => {
    const [root, properties] = chain$1(path);
    
    if (isInsideMemberCall(path))
        return false;
    
    if (isExcludedFromChain(root))
        return false;
    
    if (isPathGet(properties))
        return false;
    
    if (properties.find(hasComment))
        return true;
    
    if (path.find(isIfUp))
        return false;
    
    const calls = properties.filter(isCall$1);
    const [firstCall] = calls;
    
    if (calls.length === 2 && !firstCall.name)
        return false;
    
    if (isArgOfCall(path))
        return false;
    
    return calls.length > 1;
};

const isPathGet = ([property]) => {
    return isCallExpression$9(property, {
        name: 'get',
    });
};

const isIfUp = (path) => {
    const ifPath = path.find(isIfStatement$1);
    let is = false;
    
    if (!ifPath)
        return is;
    
    ifPath.get('test').traverse({
        MemberExpression(currentPath) {
            if (path === currentPath) {
                is = true;
                path.stop();
            }
        },
    });
    
    return is;
};

const {
    isDecorator,
    isMemberExpression: isMemberExpression$7,
    isExpressionStatement: isExpressionStatement$9,
    isCallExpression: isCallExpression$8,
} = lib_exports;

const hasBody$1 = (path) => {
    if (path.isTSModuleDeclaration())
        return true;
    
    return path.node.body?.length;
};

const isFnParam = (path) => {
    const {parentPath} = path;
    
    if (!parentPath.isFunction())
        return false;
    
    return parentPath.get('params').includes(path);
};

function isSameLine(path, loc) {
    return path.node.loc?.start.line === loc.start.line || path.node.loc?.end.line === loc.end.line;
}

const isTrailingIsLeading = (path) => path.node.trailingComments === path.getNextSibling().node?.leadingComments;

const isNewlineAfter = (path) => {
    const {parentPath} = path;
    
    if (isDecorator(path)) {
        const {loc} = path.node.trailingComments[0];
        return !isSameLine(path, loc);
    }
    
    if (isMemberExpression$7(parentPath))
        return false;
    
    return !isLast$2(path);
};

function isCommentOnNextLine(path) {
    const {node} = path;
    const {
        loc,
        trailingComments,
    } = node;
    
    if (path.isClassMethod())
        return false;
    
    if (isTrailingIsLeading(path))
        return false;
    
    if (path.isThrowStatement())
        return false;
    
    const [comment] = trailingComments;
    const {line} = comment.loc.start;
    
    const next = path.getNextSibling();
    
    if (next.node && line < next.node.loc?.start.line)
        return false;
    
    if (!loc)
        return true;
    
    const startLine = loc.start.line;
    const endLine = loc.end.line;
    const isNextLine = line === startLine + 1 && line === endLine + 1;
    const isNextLineAfterNewline = line === startLine + 2 && line === endLine + 2;
    
    return isNextLine || isNextLineAfterNewline;
}

const parseTrailingComments = (path, printer, semantics, {currentTraverse} = {}) => {
    const {parentPath} = path;
    const {
        write,
        maybe,
        indent,
    } = printer;
    
    if (!semantics.comments)
        return;
    
    const {trailingComments} = path.node;
    
    if (!trailingComments?.length)
        return;
    
    if (hasTrailingCommentsPrinter(currentTraverse))
        return printTrailingComments(path, printer, semantics, {
            currentTraverse,
        });
    
    if (path.isDirective())
        return;
    
    const n = trailingComments.length - 1;
    const likeChain = isLooksLikeChain(parentPath);
    
    for (const {type, value, loc} of trailingComments) {
        const sameLine = isSameLine(path, loc);
        const commentOnNextLine = isCommentOnNextLine(path);
        
        if (type === 'CommentLine') {
            const nextLineInChain = commentOnNextLine && likeChain;
            const shouldIndent = !sameLine && !commentOnNextLine;
            
            maybe.write.breakline(commentOnNextLine);
            maybe.write.space(sameLine);
            
            if (shouldIndent || nextLineInChain) {
                maybe.indent.inc(nextLineInChain);
                indent();
                maybe.indent.dec(nextLineInChain);
            }
            
            if (hasBody$1(path)) {
                maybe.write.breakline(!isNext(path));
                maybe.write.breakline(!n);
            }
            
            write(`//${value}`);
            maybe.write.newline(isNewlineAfter(path));
            
            continue;
        }
        
        if (type === 'CommentBlock') {
            maybe.write.space(sameLine);
            maybe.indent(!sameLine);
            maybe.print.breakline(isPrevCall(path));
            write(`/*${value}*/`);
            maybe.write.newline(!sameLine || !isFnParam(path) && isCoupleLines(path.parentPath));
        }
    }
};

function isPrevCall(path) {
    const prev = path.getPrevSibling();
    
    if (isExpressionStatement$9(prev))
        return false;
    
    const {expression} = path.node;
    
    if (!isCallExpression$8(expression))
        return false;
    
    return !isCallExpression$8(expression.arguments[0]);
}

const parseComments = (path, {write, maybe}, semantics) => {
    if (!semantics.comments)
        return;
    
    const comments = path.node.comments || path.node.innerComments;
    
    if (!comments)
        return;
    
    const n = comments.length - 1;
    const program = path.isProgram();
    
    for (const [i, {type, value}] of comments.entries()) {
        if (type === 'CommentLine') {
            maybe.write.breakline(isNext(path) || !program);
            write('//');
            write(value);
            
            if (program) {
                maybe.write.newline(i < n);
                continue;
            }
            
            write.newline();
            continue;
        }
        
        if (type === 'CommentBlock') {
            write('/*');
            write(value);
            write('*/');
        }
    }
};

const noop$6 = () => {};
const parseParams = (path) => path.get('params');

const printParams = (path, printer, semantics, customization = {}) => {
    const {extra, typeParameters} = path.node;
    const {
        print,
        maybe,
        traverse,
    } = printer;
    
    const {
        params = parseParams(path),
        braceOpen = '(',
        braceClose = ')',
        printSpace = print.space,
        printAfterOpen = noop$6,
        printBeforeClose = noop$6,
        printAfterClose = noop$6,
    } = customization;
    
    if (typeParameters)
        traverse(path.get('typeParameters'));
    
    printBraceOpen(path, {
        print,
        braceOpen,
    }, semantics);
    
    parseComments(path, printer, semantics);
    printAfterOpen();
    
    const n = params.length - 1;
    
    for (let i = 0; i <= n; i++) {
        const isLast = i === n;
        const current = params[i];
        
        traverse(current);
        
        if (!isLast) {
            print(',');
            printSpace();
        }
    }
    
    maybe.print(extra?.trailingComma, ',');
    
    printBeforeClose();
    printBraceClose(path, {
        print,
        braceClose,
    }, semantics);
    printAfterClose();
};

function printBraceOpen(path, {print, braceOpen}, semantics) {
    if (isOneArgArrow(path) && !semantics.roundBraces.arrow)
        return;
    
    return print(braceOpen);
}

function printBraceClose(path, {print, braceClose}, semantics) {
    if (isOneArgArrow(path) && !semantics.roundBraces.arrow)
        return;
    
    print(braceClose);
}

function isOneArgArrow(path) {
    if (path.type !== 'ArrowFunctionExpression')
        return false;
    
    const {params} = path.node;
    const [param] = params;
    
    if (params.length !== 1)
        return false;
    
    return param.type === 'Identifier';
}

const isFn$7 = (a) => typeof a === 'function';

const isParens$2 = (path) => path.node.extra?.parenthesized;

const maybeParens = (print) => {
    if (isFn$7(print))
        return maybeParensPrint(print);
    
    return maybeParensCondition(print);
};

const maybeParensPrint = (print) => ({
    condition: isParens$2,
    before(path, {write}) {
        write('(');
    },
    print,
    after(path, {write}) {
        write(')');
    },
});

const maybeParensCondition = ({print, condition, checkParens = true}) => ({
    ...maybeParensPrint(print),
    condition: (path, print, semantics) => {
        const is = condition?.(path, print, semantics);
        
        if (!checkParens)
            return is;
        
        return is || isParens$2(path);
    },
});

const ArrowFunctionExpression = maybeParens((path, printer, semantics) => {
    const {
        print,
        maybe,
        write,
        traverse,
    } = printer;
    
    const {async} = path.node;
    
    maybe.print(async, 'async ');
    printParams(path, printer, semantics);
    
    const returnType = path.get('returnType');
    
    if (exists(returnType)) {
        write(':');
        write.space();
        traverse(returnType);
    }
    
    print.space();
    print('=>');
    
    const body = path.get('body');
    
    const isJSX = body.isJSXElement();
    
    maybe.print.space(!isJSX);
    
    print('__body');
});

const not$1 = (fn) => (...a) => !fn(...a);
const notInsideExportDefaultWithBody = not$1(isInsideExportDefaultWithBody);

const {
    isAssignmentExpression: isAssignmentExpression$3,
    isTSModuleBlock: isTSModuleBlock$3,
    isBlockStatement: isBlockStatement$6,
    isExportNamedDeclaration: isExportNamedDeclaration$2,
    isExpressionStatement: isExpressionStatement$8,
    isFunctionDeclaration: isFunctionDeclaration$2,
    isExportDefaultDeclaration,
} = lib_exports;

const isInsideNamedExport$1 = ({parentPath}) => isExportNamedDeclaration$2(parentPath);

const FunctionDeclaration = {
    print(path, printer, semantics) {
        const {print, maybe} = printer;
        
        const {
            async,
            generator,
            returnType,
        } = path.node;
        
        maybe.indent(!isInsideNamedExport$1(path));
        maybe.print(async, 'async ');
        
        print('function');
        
        if (!generator) {
            print(' ');
        } else {
            print('*');
            print.space();
        }
        
        print('__id');
        printParams(path, printer, semantics);
        
        if (returnType) {
            print(': ');
            print('__returnType');
        }
        
        print.space();
        print('__body');
    },
    afterSatisfy: () => [isNext, isNextParent, isInsideBlockStatement],
    after(path, {indent, maybe}) {
        if (isNextAssign$1(path) || isNextFunction(path) || isNext(path))
            indent();
        
        maybe.write.newline(notInsideExportDefaultWithBody(path));
        markAfter(path);
    },
};

const isNextFunction = (path) => {
    const next = path.getNextSibling();
    return isFunctionDeclaration$2(next);
};

const isNextAssign$1 = (path) => {
    const next = path.getNextSibling();
    
    if (!isExpressionStatement$8(next))
        return false;
    
    return isAssignmentExpression$3(next.node.expression);
};

function isInsideBlockStatement(path) {
    const {parentPath} = path;
    
    if (isTSModuleBlock$3(parentPath.parentPath))
        return true;
    
    if (!isBlockStatement$6(parentPath))
        return false;
    
    return !path.node.body.body.length;
}

function isInsideExportDefaultWithBody(path) {
    if (!isExportDefaultDeclaration(path.parentPath))
        return false;
    
    return path.node.body.body.length;
}

const isPrevClassProperty = (path) => {
    const prev = path.getPrevSibling();
    
    if (!prev.node)
        return false;
    
    return prev.isClassProperty() || prev.isClassAccessorProperty();
};

const maybeDecorators$1 = (visitor) => (path, printer, semantics, options) => {
    const {
        write,
        traverse,
        maybe,
    } = printer;
    
    const {decorators} = path.node;
    
    if (decorators)
        for (const decorator of path.get('decorators')) {
            maybe.write.breakline(isPrevClassProperty(path));
            traverse(decorator);
            write.breakline();
        }
    
    visitor(path, printer, semantics, options);
};

const maybePrintComputed = (path, key, {maybe, traverse}) => {
    const {computed} = path.node;
    
    maybe.write(computed, '[');
    traverse(key);
    maybe.write(computed, ']');
};

const printKey = (path, printer) => {
    const key = path.get('key');
    
    maybePrintComputed(path, key, printer);
};

const printKind = (path, {write}) => {
    const {kind, generator} = path.node;
    
    const isGetter = kind === 'get' || kind === 'set';
    
    if (isGetter)
        write(`${kind} `);
    else if (generator)
        write('*');
};

const isAllParamsHasLeadingComments = (path) => {
    const params = path.get('params');
    let commentsCount = 0;
    let decoratorsCount = 0;
    
    for (const param of params) {
        const decorators = param.get('decorators');
        
        if (!decorators.length)
            continue;
        
        const [firstDecorator] = decorators;
        ++decoratorsCount;
        
        if (hasLeadingComment(firstDecorator))
            ++commentsCount;
    }
    
    return commentsCount === decoratorsCount;
};

const hasDecorators = ({decorators}) => decorators?.length;

const printFunctionParams = (path, printer, semantics) => {
    const {params} = path.node;
    const isNewline = params.filter(hasDecorators).length;
    const isAllHasComments = isAllParamsHasLeadingComments(path);
    
    const printSpace = createPrintSpace({
        isNewline,
        printer,
    });
    
    const printAfterOpen = createPrintAfterOpen({
        type: 'inc',
        printer,
        isNewline,
        isAllHasComments,
    });
    
    const printBeforeClose = createPrintBeforeClose({
        type: 'dec',
        printer,
        isNewline,
        isAllHasComments,
    });
    
    printParams(path, printer, semantics, {
        printAfterOpen,
        printSpace,
        printBeforeClose,
    });
};

const createPrintAfterOpen = ({isNewline, isAllHasComments, printer, type}) => () => {
    if (!isNewline)
        return;
    
    const {indent, print} = printer;
    
    if (!isAllHasComments)
        indent[type]();
    
    print.breakline();
};

const createPrintBeforeClose = ({isNewline, printer, isAllHasComments, type}) => () => {
    if (!isNewline)
        return;
    
    const {indent, print} = printer;
    
    if (!isAllHasComments)
        indent[type]();
    
    print.breakline();
};

const createPrintSpace = ({isNewline, printer}) => () => {
    const {print} = printer;
    
    if (!isNewline)
        return print.space();
    
    print.breakline();
};

const noTrailingCommentAndNext = (path) => {
    if (hasTrailingComment(path))
        return false;
    
    return isNext(path);
};

const ClassMethod = {
    print: maybeDecorators$1((path, printer, semantics) => {
        const {print} = printer;
        const {node} = path;
        const {accessibility, returnType} = node;
        
        if (accessibility) {
            print(accessibility);
            print(' ');
        }
        
        if (node.static) {
            print('static');
            print(' ');
        }
        
        if (node.override) {
            print('override');
            print(' ');
        }
        
        if (node.async) {
            print('async');
            print(' ');
        }
        
        printKind(path, printer);
        printKey(path, printer);
        printFunctionParams(path, printer, semantics);
        
        if (returnType) {
            print(':');
            print.space();
            print('__returnType');
        }
        
        print.space();
        print('__body');
    }),
    afterSatisfy: () => [noTrailingCommentAndNext],
    after(path, {print}) {
        print.linebreak();
    },
};

const ClassPrivateMethod = ClassMethod;

const ObjectMethod = {
    beforeIf(path) {
        return path.node.async;
    },
    before(path, {write}) {
        write('async ');
    },
    print(path, printer, semantics) {
        const {print} = printer;
        
        printKind(path, printer);
        printKey(path, printer);
        printParams(path, printer, semantics);
        
        print.space();
        print('__body');
    },
    afterIf(path) {
        return isNewlineBetweenSiblings(path);
    },
    after(path, {print}) {
        print.linebreak();
    },
};

const FunctionExpression = maybeParens((path, printer, semantics) => {
    const {
        print,
        maybe,
        write,
        traverse,
    } = printer;
    
    const {node} = path;
    const {generator, async} = node;
    
    maybe.write(async, 'async ');
    write('function');
    maybe.write(generator, '*');
    
    const id = path.get('id');
    
    if (exists(id)) {
        write(' ');
        traverse(id);
    }
    
    printParams(path, printer, semantics);
    
    print.space();
    print('__body');
});

const isWord = (a) => /^(delete|typeof|void|throw)$/.test(a);

const unaryExpression = maybeParens((path, printer) => {
    const {maybe, traverse} = printer;
    const {prefix, operator} = path.node;
    const argPath = path.get('argument');
    
    maybe.print(prefix, operator);
    maybe.print(isWord(operator), ' ');
    traverse(argPath);
    maybe.print(!prefix, operator);
});

const UnaryExpression = unaryExpression;
const UpdateExpression = unaryExpression;

const AwaitExpression = maybeParens((path, {print}) => {
    printUnary('await', {
        print,
    });
});

const YieldExpression = maybeParens((path, {print, maybe}) => {
    const {delegate} = path.node;
    
    print(`yield`);
    maybe.print(delegate, '*');
    print(' ');
    print('__argument');
});

const ThrowStatement = (path, {print, indent, maybe}) => {
    indent();
    
    printUnary('throw', {
        print,
    });
    
    print(';');
    maybe.print.newline(!isLast$2(path));
    maybe.print.breakline(isNext(path));
};

function printUnary(name, {print}) {
    print(`${name} `);
    print('__argument');
}

const {
    isObjectExpression: isObjectExpression$8,
    isArrowFunctionExpression: isArrowFunctionExpression$1,
} = lib_exports;

const MemberExpression = maybeParens({
    checkParens: false,
    condition: (path) => isObjectInsideArrow(path),
    print: (path, printer) => {
        const {
            print,
            maybe,
            traverse,
        } = printer;
        
        const object = path.get('object');
        const property = path.get('property');
        
        const {computed} = path.node;
        
        const isChain = isLooksLikeChain(path);
        
        traverse(object);
        
        if (computed)
            return maybePrintComputed(path, property, printer);
        
        maybe.indent.inc(isChain);
        maybe.print.breakline(isChain);
        
        print('.');
        print('__property');
        maybe.indent.dec(isChain);
    },
});

const OptionalMemberExpression = maybeParens((path, {print, maybe}) => {
    const {computed, optional} = path.node;
    
    print('__object');
    
    maybe.print(optional, '?.');
    maybe.print(!optional && !computed, '.');
    
    if (computed) {
        print('[');
        print('__property');
        print(']');
        
        return;
    }
    
    print('__property');
});

const isObjectInsideArrow = ({node, parentPath}) => {
    if (!isObjectExpression$8(node.object))
        return false;
    
    return isArrowFunctionExpression$1(parentPath);
};

const maybeDeclare = (visit) => (path, printer, semantics) => {
    const {maybe} = printer;
    const {declare} = path.node;
    
    maybe.print(declare, 'declare ');
    visit(path, printer, semantics);
};

const isInsideTSModuleBlock = (path) => {
    return isTSModuleBlock$2(path.parentPath.parentPath);
};

const {
    isFunction: isFunction$7,
    isTSModuleBlock: isTSModuleBlock$2,
} = lib_exports;

const isInsideExport = ({parentPath}) => parentPath.isExportDeclaration();
const isFunctionLike = (path) => isFunction$7(path.parentPath.parentPath);
const hasBody = ({node}) => node.body.body.length;

const classVisitor = maybeDecorators$1((path, printer, semantics) => {
    const {
        id,
        abstract,
        superClass,
    } = path.node;
    
    const {
        print,
        indent,
        maybe,
        traverse,
    } = printer;
    
    maybe.print(abstract, 'abstract ');
    print('class');
    maybe.print(id || superClass, ' ');
    print('__id');
    print('__typeParameters');
    
    const {node} = path;
    
    if (node.superClass) {
        maybe.print(id, ' ');
        print('extends ');
        print('__superClass');
        print('__superTypeArguments');
    }
    
    if (node.implements) {
        const {typeParameters} = node;
        
        if (!typeParameters || typeParameters.params.length < 2)
            print(' ');
        
        print('implements ');
        
        const implementsPaths = path.get('implements');
        const n = implementsPaths.length - 1;
        
        for (const [i, implement] of implementsPaths.entries()) {
            print(implement);
            maybe.print(i < n, ', ');
        }
    }
    
    print.space();
    print('{');
    maybe.print.newline(path.node.body.body.length);
    indent.inc();
    
    const classBody = path.get('body');
    const body = classBody.get('body');
    
    for (const item of body) {
        indent();
        traverse(item);
    }
    
    if (!body.length)
        parseComments(classBody, printer, semantics);
    
    indent.dec();
    maybe.indent(body.length);
    print('}');
});

const ClassExpression = classVisitor;

const ClassDeclaration = {
    print: maybeDeclare((path, printer, semantics) => {
        const {maybe} = printer;
        maybe.indent(!isInsideExport(path));
        classVisitor(path, printer, semantics);
    }),
    afterIf(path) {
        if (isFunctionLike(path))
            return true;
        
        if (isNext(path))
            return true;
        
        return isInsideTSModuleBlock(path);
    },
    after(path, {write}) {
        write.newline();
        
        if (!isFunctionLike(path) && hasBody(path)) {
            write.newline();
            markAfter(path);
        }
    },
};

const {isArray: isArray$c} = Array;

const parseArgs = (path) => {
    const argsPath = path.get('arguments');
    
    if (!isArray$c(argsPath))
        return [];
    
    return argsPath;
};

const CallExpression = maybeParens((path, {indent, print, maybe, traverse}) => {
    const args = parseArgs(path);
    const isParentCall = tooLong$1(args) && path.parentPath.isCallExpression();
    
    const callee = path.get('callee');
    const typeParameters = path.get('typeArguments');
    
    traverse(callee);
    
    if (exists(typeParameters))
        traverse(typeParameters);
    
    if (path.node.optional)
        print('?.');
    
    print('(');
    
    const n = args.length - 1;
    
    maybe.indent.inc(isParentCall);
    
    for (const [i, arg] of args.entries()) {
        const isObject = arg.isObjectExpression();
        
        if (isParentCall && !isObject && n)
            print.breakline();
        
        print(arg);
        
        if (isParentCall && n) {
            print(',');
            continue;
        }
        
        if (i < n) {
            print(',');
            print.space();
        }
    }
    
    if (isParentCall) {
        indent.dec();
        maybe.print.breakline(n);
    }
    
    print(')');
});

const OptionalCallExpression = CallExpression;

function tooLong$1(args) {
    for (const arg of args) {
        if (arg.isIdentifier() && arg.node.name.length > 10)
            return true;
    }
    
    return false;
}

const {
    isExpressionStatement: isExpressionStatement$7,
    isMemberExpression: isMemberExpression$6,
} = lib_exports;

const isInsideExpressionStatement = ({parentPath}) => isExpressionStatement$7(parentPath);
const notFirst = ({parentPath}) => exists(parentPath.getPrevSibling());
const isInsideMember = ({parentPath}) => isMemberExpression$6(parentPath);

const getPrev = ({parentPath}) => {
    const prev = parentPath.getPrevSibling();
    
    return [
        prev.node,
        prev,
    ];
};

const NewExpression = {
    beforeIf(path) {
        if (!isInsideExpressionStatement(path))
            return false;
        
        const [exists, prev] = getPrev(path);
        
        if (!exists)
            return false;
        
        if (isMarkedAfter(prev))
            return false;
        
        if (prev.isExpressionStatement())
            return false;
        
        return notFirst(path);
    },
    before(path, {print}) {
        print.breakline();
    },
    print(path, printer, semantics) {
        const {print, maybe} = printer;
        print('new ');
        print('__callee');
        print('__typeArguments');
        
        const args = path.get('arguments');
        maybePrintOpenBrace(path, printer, semantics);
        
        const n = args.length - 1;
        
        for (const [i, arg] of args.entries()) {
            print(arg);
            maybe.print(i < n, ', ');
        }
        
        maybePrintCloseBrace(path, printer, semantics);
    },
};

function maybePrintOpenBrace(path, printer, semantics) {
    maybePrintBrace('(', path, printer, semantics);
}

function maybePrintCloseBrace(path, printer, semantics) {
    maybePrintBrace(')', path, printer, semantics);
}

function maybePrintBrace(brace, path, printer, semantics) {
    const {maybe, print} = printer;
    const {roundBraces} = semantics;
    const {length} = path.node.arguments;
    
    if (length || isInsideMember(path))
        return print(brace);
    
    maybe.print(roundBraces.new, brace);
}

const {isArrayExpression: isArrayExpression$8} = lib_exports;

const TYPES$2 = [
    'NullLiteral',
    'NumericLiteral',
    'BigIntLiteral',
];

const isInsideTuple = (path) => {
    const {parentPath} = path;
    
    if (!isArrayExpression$8(parentPath))
        return false;
    
    const [first, second] = parentPath.node.elements;
    
    if (second !== path.node)
        return false;
    
    return TYPES$2.includes(first.type);
};

const {
    isArrayExpression: isArrayExpression$7,
    isCallExpression: isCallExpression$7,
    isIdentifier: isIdentifier$e,
} = lib_exports;

const isThirdObjectInsideArray = ({parentPath}) => {
    if (!isArrayExpression$7(parentPath))
        return false;
    
    const [, second] = parentPath.node.elements;
    
    return isCallExpression$7(second) && !!isIdentifier$e(second);
};

const {
    isStringLiteral: isStringLiteral$8,
    isArrayExpression: isArrayExpression$6,
} = lib_exports;

const isBodyOfArrow = (path) => path.parentPath.node.body === path.node;
const isLogical = (path) => path.get('argument').isLogicalExpression();
const isValue = (path) => path.get('properties.0.value').node;
const isParentExpression = (path) => path.parentPath.isExpressionStatement();

const isMemberExpressionCallee = ({parentPath}) => {
    if (!parentPath.isCallExpression())
        return false;
    
    const callee = parentPath.get('callee');
    
    if (!callee.isMemberExpression())
        return false;
    
    return isLooksLikeChain(callee);
};

const isInsideCall = ({parentPath}) => parentPath.isCallExpression();

function isInsideNestedArrayCall({parentPath}) {
    if (!isArrayExpression$6(parentPath))
        return false;
    
    if (!isArrayExpression$6(parentPath.parentPath))
        return false;
    
    return isInsideCall(parentPath.parentPath);
}

function isInsideNestedTuple({parentPath}) {
    const {elements} = parentPath.parentPath.node;
    const [first] = elements;
    
    return isStringLiteral$8(first);
}

const ObjectExpression = (path, printer, semantics) => {
    const {trailingComma} = semantics;
    const {
        print,
        maybe,
        indent,
    } = printer;
    
    const insideNestedArrayCall = isInsideTuple(path) || isInsideNestedArrayCall(path) || isThirdObjectInsideArray(path);
    
    maybe.indent.inc(!insideNestedArrayCall);
    
    const properties = path.get('properties');
    const {length} = properties;
    const parens = isParens$1(path);
    const manyLines = !isOneLine(path);
    
    maybe.print(parens, '(');
    print('{');
    parseComments(path, printer, semantics);
    maybe.print.newline(manyLines);
    
    const n = properties.length - 1;
    
    const memberCallee = isMemberExpressionCallee(path);
    maybe.indent.inc(memberCallee);
    
    for (const [index, property] of properties.entries()) {
        if (property.isSpreadElement()) {
            const logical = isLogical(property);
            
            if (noLeadingComment(property))
                maybe.indent(length > 1 || logical || manyLines);
            
            print(property);
            
            if (noTrailingComment(property) && (length > 1 || manyLines)) {
                maybe.print(index !== n || trailingComma, ',');
                print.newline();
            }
            
            continue;
        }
        
        maybe.indent(manyLines && noLeadingComment(property));
        print(property);
        
        if (property.isObjectMethod())
            continue;
        
        if (noTrailingComment(property) && !hasNextLeadingComment(property)) {
            maybe.print.newline(manyLines);
            maybe.print.linebreak(isNewlineBetweenSiblings(property));
        }
    }
    
    if (!insideNestedArrayCall) {
        indent.dec();
        maybe.indent(manyLines);
    } else if (isInsideTuple(path) || isInsideNestedTuple(path)) {
        indent.dec();
        indent();
        indent.inc();
    }
    
    print('}');
    maybe.print(parens, ')');
    
    maybe.indent.dec(memberCallee);
};

const hasNextLeadingComment = (path) => {
    const next = path.getNextSibling();
    
    if (!exists(next))
        return false;
    
    return hasLeadingComment(next);
};

const notLastArgInsideCall = (path) => {
    const {parentPath} = path;
    
    if (!parentPath.isCallExpression())
        return false;
    
    if (isCoupleLines(path))
        return false;
    
    return path !== parentPath.get('arguments').at(-1);
};

const ONE_LINE$2 = true;
const MANY_LINES = false;

function isOneLine(path) {
    const {length} = path.get('properties');
    
    if (!length)
        return ONE_LINE$2;
    
    if (notLastArgInsideCall(path))
        return ONE_LINE$2;
    
    if (isForOf$2(path))
        return ONE_LINE$2;
    
    if (isIf(path))
        return ONE_LINE$2;
    
    if (isCoupleLines(path))
        return MANY_LINES;
    
    return !isValue(path);
}

function isParens$1(path) {
    if (isBodyOfArrow(path))
        return true;
    
    return isParentExpression(path);
}

const {
    isStringLiteral: isStringLiteral$7,
    isTemplateLiteral: isTemplateLiteral$3,
    isBinaryExpression,
} = lib_exports;

const isStringLike = (a) => {
    if (isStringLiteral$7(a))
        return true;
    
    return isTemplateLiteral$3(a);
};

const isConcatenation = (path) => {
    const {parentPath} = path;
    const {operator} = path.node;
    
    if (operator !== '+')
        return false;
    
    const startLine = path.node.loc?.start.line;
    const endLine = path.node.loc?.end.line;
    
    if (startLine === endLine)
        return false;
    
    const left = path.get('left');
    const right = path.get('right');
    
    if (isStringLike(left) && isStringLike(right) && isBinaryExpression(parentPath))
        return true;
    
    return isBinaryExpression(left) && isStringLike(right);
};

const concatenate = (path, {print, indent}) => {
    if (!path.parentPath.isBinaryExpression()) {
        indent.inc();
        print.breakline();
    }
    
    print('__left');
    print.space();
    print('+');
    print.breakline();
    print('__right');
    
    if (!path.parentPath.isBinaryExpression())
        indent.dec();
};

const ObjectProperty = (path, printer, semantics) => {
    const {trailingComma} = semantics;
    const {shorthand} = path.node;
    const {
        maybe,
        traverse,
        write,
    } = printer;
    
    const value = path.get('value');
    const properties = path.parentPath.get('properties');
    const isLast = path === properties.at(-1);
    const manyLines = !isOneLine(path.parentPath);
    
    printKey(path, printer);
    
    if (!shorthand) {
        write(':');
        maybe.write.space(!isConcatenation(value));
        traverse(value);
    }
    
    if (manyLines)
        maybe.write(!isLast || trailingComma, ',');
    else if (!isLast && properties.length)
        write(', ');
};

const wrongShorthand = ({computed, isAssign, keyPath, valuePath}) => {
    return !computed && !isAssign && keyPath.node.name !== valuePath.node.name;
};

const moreThenMaxPropertiesInOneLine = (path, {maxPropertiesInOneLine}) => {
    const {parentPath} = path;
    
    if (parentPath.isObjectProperty())
        return false;
    
    const n = path.node.properties.length;
    
    return maxPropertiesInOneLine >= n;
};

const {
    isMemberExpression: isMemberExpression$5,
    isSequenceExpression: isSequenceExpression$1,
} = lib_exports;

const maybeTypeAnnotation = (visit) => (path, printer, semantics) => {
    visit(path, printer, semantics);
    
    maybePrintTypeAnnotation(path, printer);
};

function maybePrintTypeAnnotation(path, printer) {
    const {parentPath, node} = path;
    
    const {typeAnnotation} = node;
    const {write, traverse} = printer;
    
    if (isSequenceExpression$1(parentPath))
        return;
    
    if (isMemberExpression$5(parentPath))
        return;
    
    if (typeAnnotation) {
        write(':');
        write.space();
        traverse(path.get('typeAnnotation'));
    }
}

const {
    isAssignmentPattern: isAssignmentPattern$2,
    isIdentifier: isIdentifier$d,
} = lib_exports;

function getLength(left, right) {
    if (isIdentifier$d(left) && isIdentifier$d(right))
        return left.name.length + right.name.length;
    
    if (isIdentifier$d(left))
        return left.name.length;
    
    return 0;
}

const moreThenMaxPropertiesLengthInOneLine = (path, {maxPropertiesLengthInOneLine}) => {
    const {properties} = path.node;
    
    for (const {key, value} of properties) {
        if (isAssignmentPattern$2(value)) {
            const {left, right} = value;
            
            const length = getLength(left, right);
            
            if (length >= maxPropertiesLengthInOneLine)
                return true;
        }
        
        if (!isIdentifier$d(key))
            continue;
        
        const {name} = key;
        
        if (name.length >= maxPropertiesLengthInOneLine)
            return true;
    }
    
    return false;
};

const {
    isAssignmentPattern: isAssignmentPattern$1,
    isArrayExpression: isArrayExpression$5,
    isObjectExpression: isObjectExpression$7,
    isIdentifier: isIdentifier$c,
} = lib_exports;

const calculateAssigns = (property, semantics) => {
    const currentAssign = isLongAssignPattern(property, semantics);
    
    const {right} = property.node.value;
    const isArrayOrObjectRight = isArrayExpression$5(right) || isComplexObject(right);
    const complexAssign = currentAssign && isArrayOrObjectRight;
    
    return {
        complexAssign,
    };
};

function isLongAssignPattern(path, semantics) {
    const {key, value} = path.node;
    
    if (!isAssignmentPattern$1(value))
        return false;
    
    if (!isIdentifier$c(key))
        return true;
    
    const {maxPropertiesLengthInOneLine} = semantics;
    
    return key.name.length > maxPropertiesLengthInOneLine;
}

function isComplexObject(node) {
    if (!isObjectExpression$7(node))
        return false;
    
    return node.properties.length;
}

const createPrintCommentLine = (fn) => (value) => fn(`//${value}`);
const createPrintCommentBlock = (fn) => (value) => fn(`/*${value}*/`);

const printLeadingComments = (path, {print}) => {
    const printCommentLine = createPrintCommentLine(print);
    const printCommentBlock = createPrintCommentBlock(print);
    const {leadingComments} = path.node;
    
    if (!leadingComments)
        return;
    
    for (const {type, value} of leadingComments) {
        if (type === 'CommentLine')
            printCommentLine(value);
        else
            printCommentBlock(value);
        
        print.breakline();
    }
};

const {
    isObjectExpression: isObjectExpression$6,
    isIdentifier: isIdentifier$b,
    isAssignmentPattern,
    isVariableDeclarator: isVariableDeclarator$2,
    isFunction: isFunction$6,
    isObjectPattern: isObjectPattern$2,
    isForOfStatement,
    isVariableDeclaration: isVariableDeclaration$3,
} = lib_exports;

const isInsideFn = (path) => {
    if (isFunction$6(path.parentPath))
        return true;
    
    return isFunction$6(path.parentPath.parentPath);
};

function isIndent(path) {
    return !path.parentPath.isArrayPattern();
}

const isCoupleProperties = ({path, valuePath, property}) => {
    if (!isCoupleLines(valuePath))
        return false;
    
    if (exists(property.getPrevSibling()))
        return false;
    
    const properties = path.get('properties');
    
    if (path.parentPath.isVariableDeclarator() && !hasAssign(properties))
        return false;
    
    return !path.parentPath.isObjectProperty();
};

function isInsideForOf({parentPath}) {
    return isForOfStatement(parentPath.parentPath.parentPath);
}

function isPrevAssign(path) {
    const prev = path.getPrevSibling();
    
    return isAssignmentPattern(prev.node.value);
}

function isPrevAssignObject(path) {
    const prev = path.getPrevSibling();
    
    if (!isAssignmentPattern(prev.node.value))
        return false;
    
    const {right} = prev.node.value;
    
    return isObjectExpression$6(right);
}

function isNextAssignObject(path) {
    const next = path.getNextSibling();
    
    if (!next.node)
        return false;
    
    if (!isAssignmentPattern(next.node.value))
        return false;
    
    const {right} = next.node.value;
    
    return isObjectExpression$6(right);
}

const ObjectPattern = {
    print: maybeTypeAnnotation((path, printer, semantics) => {
        const shouldIndent = isIndent(path);
        const {
            maxPropertiesInOneLine,
            maxPropertiesLengthInOneLine,
        } = semantics;
        
        const {
            print,
            maybe,
            indent,
        } = printer;
        
        maybe.indent.inc(shouldIndent);
        print('{');
        
        const properties = path.get('properties');
        const n = properties.length - 1;
        
        const is = shouldAddNewline(path, {
            maxPropertiesInOneLine,
            maxPropertiesLengthInOneLine,
        });
        
        const hasObject = n && hasObjectPattern(properties);
        const notInsideFn = !isInsideFn(path);
        
        maybe.print.newline(is && notInsideFn);
        
        for (const [i, property] of properties.entries()) {
            if (property.isRestElement()) {
                const couple = is || hasObject;
                
                maybe.indent(couple);
                print(property);
                maybe.print.newline(couple);
                continue;
            }
            
            const prevAssignObject = i && isPrevAssignObject(property);
            const nextAssignObject = isNextAssignObject(property);
            
            const valuePath = property.get('value');
            const keyPath = property.get('key');
            const isAssign = valuePath.isAssignmentPattern();
            
            const {shorthand, computed} = property.node;
            const couple = isCoupleProperties({
                path,
                property,
                valuePath,
            });
            
            maybe.indent((prevAssignObject || is) && notInsideFn);
            maybe.print.breakline(couple && !isLongAssignPattern(property, semantics));
            
            if (!isAssign && nextAssignObject)
                print.breakline();
            
            printLeadingComments(property, {
                print,
            });
            printKey(property, printer);
            
            if (!shorthand || wrongShorthand({computed, isAssign, keyPath, valuePath})) {
                print(':');
                print.space();
                print(valuePath);
            } else if (isAssign) {
                print(valuePath);
                
                maybe.print(couple, ',');
                maybe.print.newline(couple);
                
                const {right} = valuePath.node;
                
                if (i && !isPrevAssign(property) && !isInsideForOf(path) && isObjectExpression$6(right)) {
                    print(',');
                    print.newline();
                    continue;
                }
            }
            
            if (!isAssign && nextAssignObject && notInsideFn) {
                print(',');
                print.breakline();
                continue;
            }
            
            const {complexAssign} = calculateAssigns(property, semantics);
            
            if (!complexAssign && (is || hasObject || prevAssignObject && notInsideFn)) {
                print(',');
                print.newline();
                
                continue;
            }
            
            if (i < n && !(isAssign && couple)) {
                print(',');
                print.space();
            }
        }
        
        indent.dec();
        
        maybe.indent(is || hasAssignObject(path, maxPropertiesLengthInOneLine));
        maybe.indent.inc(!shouldIndent);
        print('}');
    }),
};

function checkLength(properties) {
    for (const prop of properties) {
        const {value} = prop.node;
        
        if (!isIdentifier$b(value))
            continue;
        
        if (value.name.length > 4)
            return true;
    }
    
    return false;
}

function hasAssign(properties) {
    for (const prop of properties) {
        const {value} = prop.node;
        
        if (isAssignmentPattern(value))
            return true;
    }
    
    return false;
}

function hasComputed(properties) {
    for (const prop of properties) {
        const {computed} = prop.node;
        
        if (computed)
            return true;
    }
    
    return false;
}

function hasAssignObject(path, maxPropertiesLengthInOneLine) {
    const {parentPath} = path;
    
    if (isVariableDeclaration$3(parentPath.parentPath)) {
        const {declarations} = parentPath.parentPath.node;
        
        if (declarations.length > 1)
            return false;
    }
    
    const properties = path.get('properties');
    const n = properties.length;
    
    for (const prop of properties) {
        const {value} = prop.node;
        
        if (isAssignmentPattern(value) && isObjectExpression$6(value.right))
            return n > 1 || maxPropertiesLengthInOneLine <= value.left;
    }
    
    return false;
}

function hasObjectPattern(properties) {
    for (const property of properties) {
        if (isObjectPattern$2(property.node.value))
            return true;
    }
    
    return false;
}

const ONE_LINE$1 = false;
const COUPLE_LINES = true;

function hasPropertyLeadingComment(properties) {
    for (const property of properties) {
        if (property.node.leadingComments)
            return true;
    }
    
    return false;
}

function shouldAddNewline(path, semantics) {
    const {parentPath} = path;
    const properties = path.get('properties');
    const n = properties.length - 1;
    
    if (hasPropertyLeadingComment(properties))
        return true;
    
    const {
        maxPropertiesInOneLine,
        maxPropertiesLengthInOneLine,
    } = semantics;
    
    const moreLength = moreThenMaxPropertiesLengthInOneLine(path, {
        maxPropertiesLengthInOneLine,
    });
    
    const moreCount = moreThenMaxPropertiesInOneLine(path, {
        maxPropertiesInOneLine,
    });
    
    if (hasComputed(properties))
        return COUPLE_LINES;
    
    const fnParam = isFunctionParam(path);
    
    if (hasObjectPattern(properties))
        return COUPLE_LINES;
    
    if (moreCount && !moreLength && isVariableDeclarator$2(path.parentPath))
        return ONE_LINE$1;
    
    if (!fnParam && n && !isForOf$2(path) && checkLength(properties))
        return COUPLE_LINES;
    
    if (!fnParam && hasAssign(properties))
        return COUPLE_LINES;
    
    return parentPath.isObjectProperty();
}

function isFunctionParam({parentPath}) {
    if (parentPath.isFunction())
        return true;
    
    if (!parentPath.isAssignmentPattern())
        return false;
    
    return parentPath.parentPath.isFunction();
}

const condition$4 = (path, printer, semantics) => {
    const {parentPath} = path;
    const {type} = parentPath;
    const {roundBraces} = semantics;
    
    if (path.node.left.type === 'ObjectPattern')
        return true;
    
    if (parentPath.type === 'MemberExpression')
        return true;
    
    if (type === 'LogicalExpression')
        return true;
    
    if (type === 'BinaryExpression')
        return true;
    
    if (type === 'UnaryExpression')
        return true;
    
    if (!roundBraces.assign && !hasLeadingComment(path))
        return false;
    
    return isParens$2(path);
};

const {isReturnStatement: isReturnStatement$3} = lib_exports;

const printLeadingCommentLine$3 = (path, printer, semantics, {printComment, isLast}) => {
    const {parentPath} = path;
    const {print, maybe} = printer;
    
    if (isReturnStatement$3(parentPath))
        return;
    
    maybe.print.breakline(!isLast);
    printComment();
    print.breakline();
};

const printLeadingCommentBlock$3 = (path, printer, semantics, {printComment}) => {
    const {parentPath} = path;
    const {print} = printer;
    
    if (isReturnStatement$3(parentPath))
        return;
    
    printComment();
    print.indent();
};

const maybeInsideReturnWithCommentStart = (path, {print, indent}) => {
    const {parentPath} = path;
    const is = isReturnStatement$3(parentPath);
    
    if (is && hasLeadingComment(path)) {
        indent.inc();
        const {leadingComments} = path.node;
        
        print.breakline();
        for (const {type, value} of leadingComments) {
            if (type === 'CommentLine')
                print(`//${value}`);
            else
                print(`/*${value}*/`);
            
            print.breakline();
        }
    }
};

const maybeInsideReturnWithCommentEnd = (path, {print, indent}) => {
    const {parentPath} = path;
    const is = isReturnStatement$3(parentPath);
    
    if (!is || !hasLeadingComment(path))
        return;
    
    indent.dec();
    print.breakline();
};

const {
    isAssignmentExpression: isAssignmentExpression$2,
    isExpressionStatement: isExpressionStatement$6,
} = lib_exports;

const printSeparator = (path, {print}) => {
    if (isMultiline(path))
        print.breakline();
    else
        print.space();
};

function isMultiline(path) {
    const {right} = path.node;
    
    if (!path.parentPath.find(isExpressionStatement$6))
        return false;
    
    return isAssignmentExpression$2(right);
}

const isInsideBlock$4 = ({parentPath}) => /BlockStatement|Program/.test(parentPath.type);

const AssignmentExpression = maybeParens({
    checkParens: false,
    condition: condition$4,
    print(path, printer) {
        const {print} = printer;
        const {operator} = path.node;
        
        maybeInsideReturnWithCommentStart(path, printer);
        
        print('__left');
        print.space();
        print(operator);
        printSeparator(path, printer);
        print('__right');
        
        if (isInsideBlock$4(path)) {
            print(';');
            print.breakline();
        }
        
        maybeInsideReturnWithCommentEnd(path, printer);
    },
});

AssignmentExpression.printLeadingCommentLine = printLeadingCommentLine$3;
AssignmentExpression.printLeadingCommentBlock = printLeadingCommentBlock$3;

const {
    isIdentifier: isIdentifier$a,
    isMemberExpression: isMemberExpression$4,
} = lib_exports;

const isString$e = (a) => typeof a === 'string';

function getBinding(path, node) {
    const name = parseName$1(node);
    return path.scope.getAllBindings()[name];
}

const getBindingPath = (path, name) => getBinding(path, name)?.path;

const parseName$1 = (node) => {
    if (isString$e(node))
        return node;
    
    if (isIdentifier$a(node))
        return node.name;
    
    if (isMemberExpression$4(node))
        return parseName$1(node.object);
    
    return '';
};

const {
    isOptionalMemberExpression,
    isMemberExpression: isMemberExpression$3,
    isIdentifier: isIdentifier$9,
    isLiteral: isLiteral$3,
} = lib_exports;

const isSimple = (a) => {
    if (isLiteral$3(a))
        return true;
    
    if (isIdentifier$9(a))
        return true;
    
    if (isMemberExpression$3(a))
        return true;
    
    return isOptionalMemberExpression(a);
};

const {
    isArrayExpression: isArrayExpression$4,
    isLiteral: isLiteral$2,
    isIdentifier: isIdentifier$8,
    isMemberExpression: isMemberExpression$2,
    isTemplateElement: isTemplateElement$3,
    isRegExpLiteral: isRegExpLiteral$1,
    isClassMethod,
    isTemplateLiteral: isTemplateLiteral$2,
    isJSXText: isJSXText$3,
    isJSXAttribute: isJSXAttribute$2,
    isJSXIdentifier: isJSXIdentifier$2,
    isTSTypeReference: isTSTypeReference$2,
    isTSTypeParameter,
    isTSAsExpression,
} = lib_exports;

function extract(node) {
    node = node.node || node;
    
    if (isIdentifier$8(node))
        return node.name;
    
    if (isJSXIdentifier$2(node))
        return node.name;
    
    if (isRegExpLiteral$1(node))
        return node.pattern;
    
    if (isTemplateLiteral$2(node))
        return extract(node.quasis[0]);
    
    if (isLiteral$2(node))
        return node.value;
    
    if (isTemplateElement$3(node))
        return node.value.raw;
    
    if (isMemberExpression$2(node))
        return `${extract(node.object)}.${extract(node.property)}`;
    
    if (isArrayExpression$4(node))
        return extractArrayExpression(node);
    
    if (isJSXText$3(node))
        return node.value;
    
    if (isJSXAttribute$2(node))
        return node.name.name;
    
    if (isClassMethod(node))
        return extract(node.key);
    
    if (isTSTypeReference$2(node))
        return extract(node.typeName);
    
    if (isTSTypeParameter(node))
        return extract(node.name);
    
    if (isTSAsExpression(node))
        return extract(node.expression);
    
    const nodeTypes = [
        'Literals',
        'Identifiers',
        'TemplateLiteral',
        'TemplateElement',
        'RegExpLiteral',
        'ArrayExpression',
        'MemberExpression',
        'JSXIdentifier',
        'JSXAttribute',
        'JSXText',
        'TSTypeParameter',
        'TSAsExpression',
    ].join(', ');
    
    throw Error(`'operator.extract(node)' understands only ${nodeTypes} and TSTypeReference, found: ${node.type}`);
}

function extractArrayExpression(node, collector = []) {
    for (const el of node.elements) {
        if (isArrayExpression$4(el)) {
            extractArrayExpression(el, collector);
            continue;
        }
        
        collector.push(extract(el));
    }
    
    return collector.join(',');
}

const NOT_COMPUTED = false;
const COMPUTED = true;

function compute(path) {
    const {node} = path;
    
    if (!path.evaluate)
        throw Error(` Looks like argument of 'compute' is not 'path'`);
    
    const {confident, value} = path.evaluate();
    
    if (confident)
        return [COMPUTED, value];
    
    if (path.isBinaryExpression())
        return parseBinaryExpression(path);
    
    if (isExtractable(path))
        return [COMPUTED, extract(node)];
    
    const bindingPath = parseBindingPath(path);
    
    if (!bindingPath)
        return [NOT_COMPUTED];
    
    const initPath = bindingPath.get('init');
    
    if (initPath.isObjectExpression() && path.isMemberExpression())
        return parseObjectExpression(path, initPath);
    
    return [NOT_COMPUTED];
}

function parseBindingPath(path) {
    const {node} = path;
    
    if (path.isIdentifier())
        return getBindingPath(path, extract(node));
    
    if (isSimpleMemberExpression(path))
        return getBindingPath(path, extract(node.object));
    
    return null;
}

function parseObjectExpression(path, initPath) {
    const keyPropertyValue = extract(path.node.property);
    
    for (const propertyPath of initPath.get('properties')) {
        const keyPath = propertyPath.get('key');
        
        if (!isExtractable(keyPath))
            return [NOT_COMPUTED];
        
        const keyValue = extract(keyPath);
        
        if (keyValue !== keyPropertyValue)
            continue;
        
        const [is, value] = compute(propertyPath.get('value'));
        
        if (!is)
            break;
        
        return [COMPUTED, value];
    }
    
    return [NOT_COMPUTED];
}

function isExtractable(path) {
    const computed = false;
    const {parentPath} = path;
    
    if (!path.isIdentifier() && !path.isLiteral())
        return false;
    
    if (parentPath.isObjectProperty({computed}))
        return !usedInAssignment(path);
    
    return false;
}

function isSimpleMemberExpression(path) {
    const objectPath = path.get('object');
    
    if (!path.isMemberExpression())
        return false;
    
    if (path.node.computed)
        return false;
    
    return objectPath.isIdentifier();
}

const binary = {
    init: (op, fn) => binary[op] = fn,
};

function parseBinaryExpression(path) {
    const {operator} = path.node;
    const leftPath = path.get('left');
    const rightPath = path.get('right');
    const [computedLeft, left] = compute(leftPath);
    
    if (!computedLeft)
        return [NOT_COMPUTED];
    
    const [computedRight, right] = compute(rightPath);
    
    if (!computedRight)
        return [NOT_COMPUTED];
    
    const line = `return a ${operator} b`;
    const fn = binary[operator] || binary.init(operator, Function('a', 'op', 'b', line));
    
    return [COMPUTED, fn(left, operator, right)];
}

function getReferences(path) {
    const {referencesSet} = path.scope;
    
    if (!referencesSet)
        return {};
    
    const entries = referencesSet.entries();
    
    return Object.fromEntries(entries);
}

function usedInAssignment(path) {
    const references = getReferences(path);
    
    const [name] = Object.keys(references);
    const binding = path.scope.bindings[name];
    
    if (!binding)
        return false;
    
    const {referencePaths} = binding;
    
    for (const ref of referencePaths) {
        if (ref.parentPath.parentPath?.isAssignmentExpression())
            return true;
    }
    
    return false;
}

const {entries: entries$a} = Object;
const isOneDeclaration = ({node}) => node.declarations.length === 1;

const remove = (path) => {
    if (!path.node)
        return;
    
    const {scope} = path;
    const prev = getPrevSibling(path);
    const next = getNextSibling(path);
    
    if (scope && !next.node) {
        const programBlock = scope.getProgramParent().block;
        
        if (scope.block === programBlock && !prev.node)
            programBlock.comments = getComments(path);
    }
    
    if (!path.parentPath.isArrayPattern()) {
        path.remove();
        return;
    }
    
    const elements = path.parentPath.get('elements');
    const n = elements.length - 1;
    
    for (const [i, el] of entries$a(elements)) {
        if (el !== path)
            continue;
        
        if (!Number(i) && n) {
            path.parentPath.node.elements[i] = null;
            break;
        }
        
        path.remove();
        break;
    }
};

const getComments = (path) => {
    const {leadingComments} = path.node;
    
    if (leadingComments?.length)
        return leadingComments;
    
    const {parentPath} = path;
    
    if (path.isVariableDeclarator() && isOneDeclaration(parentPath))
        return parentPath.node.leadingComments;
    
    return [];
};

const getPrevSibling = (path) => {
    if (!path.isVariableDeclarator())
        return path.getPrevSibling();
    
    return path.parentPath.getPrevSibling();
};

const getNextSibling = (path) => {
    if (!path.isVariableDeclarator())
        return path.getNextSibling();
    
    return path.parentPath.getNextSibling();
};

const getExportDefault = (path) => {
    const programParent = path.scope.getProgramParent();
    const programPath = programParent.path;
    
    for (const current of programPath.get('body')) {
        if (current.isExportDefaultDeclaration())
            return current;
    }
    
    return null;
};

const renameProperty = (path, from, to) => {
    path.traverse({
        ObjectProperty(path) {
            const {node} = path;
            const {key, value} = node;
            const equal = key.name === value.name;
            
            if (!equal)
                return;
            
            if (key.name !== from)
                return;
            
            key.name = to;
            value.name = to;
            node.shorthand = true;
            
            path.stop();
        },
    });
};

const rename = (path, from, to) => {
    const bindings = path.scope.getAllBindings();
    const bindingCurrent = bindings[from];
    
    if (!bindingCurrent)
        return;
    
    const bindingPath = bindingCurrent.path;
    
    renameProperty(bindingPath, from, to);
    bindingPath.scope.rename(from, to);
};

const setLiteralValue = (path, newValue) => {
    const node = path.node || path;
    const {
        raw,
        extra,
        value,
    } = node;
    
    node.value = value.replace(value, newValue);
    
    if (raw === '""') {
        node.raw = raw.replace(raw, `"${newValue}"`);
        return;
    }
    
    if (raw || !value) {
        node.raw = `'` + String.raw`${newValue}` + `'`;
        return;
    }
    
    if (extra) {
        node.raw = extra.raw.replace(value, newValue);
        node.extra.rawValue = value;
    }
};

const getPathAfterRequires = (body) => {
    let path;
    
    for (path of body) {
        if (!isRequire$1(path))
            break;
    }
    
    return path;
};

function isRequire$1(path) {
    if (!path.isVariableDeclaration())
        return false;
    
    const initPath = path.get('declarations.0.init');
    
    if (!initPath.isCallExpression())
        return false;
    
    const calleePath = initPath.get('callee');
    
    return calleePath.isIdentifier({
        name: 'require',
    });
}

const {
    isCallExpression: isCallExpression$6,
    isObjectExpression: isObjectExpression$5,
} = lib_exports;

const nodeOrPath = (path) => path.node || path;

function getNode$1(path) {
    if (!isObjectExpression$5(path))
        return nodeOrPath(path);
    
    if (isCallExpression$6(path.parentPath))
        return path.parentPath.node;
    
    return {
        type: 'ExpressionStatement',
        expression: nodeOrPath(path),
    };
}

const traverseProperties = (path, name, {firstLevel = false} = {}) => {
    const collector = [];
    const node = getNode$1(path);
    
    const fn = collect({
        name,
        collector,
    });
    
    if (firstLevel) {
        fn(path);
        return collector;
    }
    
    traverse3(node, {
        noScope: true,
        ObjectExpression: fn,
    });
    
    return collector;
};

const collect = ({name, collector}) => (path) => {
    for (const propertyPath of path.get('properties')) {
        if (propertyPath.isSpreadElement())
            continue;
        
        if (propertyPath.isRestElement())
            continue;
        
        const keyPath = propertyPath.get('key');
        
        if (keyPath.isConditionalExpression())
            continue;
        
        const currentName = extract(keyPath);
        
        if (name === currentName)
            collector.push(propertyPath);
    }
};

const {
    isObjectExpression: isObjectExpression$4,
    isObjectPattern: isObjectPattern$1,
} = lib_exports;

const getProperties = (path, names) => {
    const result = {};
    
    for (const propertyPath of path.get('properties')) {
        if (propertyPath.isSpreadElement())
            continue;
        
        const keyPath = propertyPath.get('key');
        const currentName = extract(keyPath);
        
        if (names.includes(currentName)) {
            const name = `${currentName}Path`;
            
            result[name] = propertyPath;
            continue;
        }
    }
    
    return result;
};

const getProperty$2 = (path, name) => {
    if (!isObjectExpression$4(path) && !isObjectPattern$1(path))
        throw Error(`Looks like path is not 'ObjectExpression | ObjectPattern', but: '${path.type}' for path: ${path}`);
    
    const propertyPaths = path.get(`properties`);
    
    for (const propertyPath of propertyPaths) {
        const keyPath = propertyPath.get('key');
        const currentName = extract(keyPath);
        
        if (currentName === name)
            return propertyPath;
    }
    
    return null;
};

const isString$d = (a) => typeof a === 'string';

const getLiteralRaw = (path) => {
    const {
        raw,
        extra,
        value,
    } = path.node || path;
    
    if (isString$d(raw))
        return raw;
    
    if (extra && isString$d(extra.raw))
        return extra.raw;
    
    return `'${maybeEncode(value)}'`;
};

function maybeEncode(a) {
    if (a.includes(`\\'`))
        return a;
    
    return a.replaceAll(`'`, `\\'`);
}

const {
    isStatement: isStatement$5,
    isBlockStatement: isBlockStatement$5,
    blockStatement,
    expressionStatement: expressionStatement$3,
} = lib_exports;

const maybeBody = (path, node) => {
    const {parentPath} = path;
    
    if (node && !isStatement$5(node) || isBlockStatement$5(node) || !parentPath?.isArrowFunctionExpression?.())
        return {
            currentPath: path,
        };
    
    parentPath.node.body = blockStatement([
        expressionStatement$3(path.node),
    ]);
    
    return {
        currentPath: parentPath.get('body.body.0'),
    };
};

const {
    isExpression: isExpression$1,
    toStatement,
    expressionStatement: expressionStatement$2,
} = lib_exports;

const toExpression = (el) => {
    const {type} = el;
    
    const ignore = [
        'ObjectProperty',
    ];
    
    if (ignore.includes(type))
        return el;
    
    if (isExpression$1(el))
        return expressionStatement$2(el);
    
    return toStatement(el);
};

const {isSequenceExpression} = lib_exports;

const replaceWithMultiple = (path, nodes) => {
    const {node} = path;
    const {
        trailingComments,
        comments,
        leadingComments,
    } = node;
    
    delete path.node.trailingComments;
    
    const parentComments = path.parentPath.node.comments;
    
    const newNodes = nodes
        .filter(Boolean)
        .map(toExpression);
    
    removeDuplicateLeadingComments(newNodes);
    
    const {currentPath} = maybeBody(path);
    const newPath = currentPath.replaceWithMultiple(newNodes);
    
    if (!newPath.length)
        return newPath;
    
    if (!leadingComments && !isSequenceExpression(path))
        delete newPath[0].node.leadingComments;
    
    newPath[0].node.comments = comments || parentComments;
    newPath.at(-1).node.trailingComments = trailingComments;
    
    return newPath;
};

function removeDuplicateLeadingComments(nodes) {
    for (const node1 of nodes) {
        for (const node2 of nodes) {
            if (node1 === node2)
                continue;
            
            if (node1.leadingComments === node2.leadingComments)
                delete node2.leadingComments;
        }
    }
}

const {assign: assign$a} = Object;

const parseNode$2 = (a) => {
    a = extractMark(a);
    
    if (a.node)
        return a.node;
    
    return a;
};

const replaceWith$2 = (path, node) => {
    node = parseNode$2(node);
    
    if (path?.parentPath?.isExpressionStatement() && !path.parentPath.isProgram()) {
        addMark(path, node);
        path = path.parentPath;
    }
    
    const {comments, loc} = path.node;
    const {currentPath} = maybeBody(path, node);
    
    currentPath.replaceWith(node);
    
    assign$a(currentPath.node, {
        comments,
        loc,
    });
    
    return currentPath;
};

function addMark(path, node) {
    path.__putout_replaced_with = node;
}

function extractMark(node) {
    if (node.__putout_replaced_with)
        return node.__putout_replaced_with;
    
    return node;
}

const {
    matchesPattern,
    isImportDeclaration: isImportDeclaration$1,
    isExportDeclaration: isExportDeclaration$4,
    isStatement: isStatement$4,
    expressionStatement: expressionStatement$1,
} = lib_exports;

const insertBefore = (path, node) => {
    path.insertBefore(node);
};

const insertAfter = (path, node) => {
    const {comments} = path.node;
    
    if (path.node.trailingComments?.length && path.getNextSibling()?.node?.leadingComments)
        delete path.node.trailingComments;
    
    if (node.trailingComments)
        delete node.trailingComments;
    
    if (isStatement$4(path) && !isStatement$4(node))
        path.insertAfter(expressionStatement$1(node));
    else
        path.insertAfter(node);
    
    path.node.comments = comments;
};

const isModuleExports = (path) => {
    return matchesPattern(path.node || path, 'module.exports');
};

const isBinding = (name) => (path) => path.scope.bindings[name];

const findBinding = (path, name) => {
    const referencePath = path.findParent(isBinding(name));
    
    if (!referencePath)
        return null;
    
    return referencePath.scope.bindings[name];
};

const getPathAfterImports = (body) => {
    const n = body.length;
    let i = 0;
    
    while (i < n - 1 && isImportDeclaration$1(body[i]))
        ++i;
    
    return body[i];
};

const isESM = (path) => {
    const scope = path.scope.getProgramParent();
    const programPath = scope.path;
    
    for (const node of programPath.node.body) {
        if (isImportDeclaration$1(node))
            return true;
        
        if (isExportDeclaration$4(node))
            return true;
    }
    
    return false;
};

var operate = /*#__PURE__*/Object.freeze({
	__proto__: null,
	compute: compute,
	extract: extract,
	findBinding: findBinding,
	getBinding: getBinding,
	getBindingPath: getBindingPath,
	getExportDefault: getExportDefault,
	getLiteralRaw: getLiteralRaw,
	getPathAfterImports: getPathAfterImports,
	getPathAfterRequires: getPathAfterRequires,
	getProperties: getProperties,
	getProperty: getProperty$2,
	insertAfter: insertAfter,
	insertBefore: insertBefore,
	isESM: isESM,
	isModuleExports: isModuleExports,
	isSimple: isSimple,
	remove: remove,
	rename: rename,
	renameProperty: renameProperty,
	replaceWith: replaceWith$2,
	replaceWithMultiple: replaceWithMultiple,
	setLiteralValue: setLiteralValue,
	toExpression: toExpression,
	traverseProperties: traverseProperties
});

const {
    isObjectExpression: isObjectExpression$3,
    isArrayExpression: isArrayExpression$3,
    isObjectProperty: isObjectProperty$1,
    isCallExpression: isCallExpression$5,
    isAwaitExpression,
    isBooleanLiteral: isBooleanLiteral$1,
    isNullLiteral,
    isStringLiteral: isStringLiteral$6,
    isSpreadElement: isSpreadElement$1,
    isIdentifier: isIdentifier$7,
} = lib_exports;

const {round: round$1} = Math;

const isOneSpread = (elements) => {
    if (elements.length > 1)
        return false;
    
    const [first] = elements;
    
    return isSpreadElement$1(first);
};

const isSimpleAndCall = ([a, b]) => {
    if (!isSimple(a))
        return;
    
    return isCallExpression$5(b) || isAwaitExpression(b);
};

const isBooleanAndSimple = ([a, b]) => isBooleanLiteral$1(a) && isSimple(b);
const isBooleanAndObject = ([a, b]) => isBooleanLiteral$1(a) && isObjectExpression$3(b);
const isNullAndSimple = ([a, b]) => isNullLiteral(a) && isSimple(b);
const isSimpleAndObject = ([a, b]) => isSimple(a) && isObjectExpression$3(b);
const ONE_LINE = false;
const MULTI_LINE = true;

const isSiblingIsArray = (path) => {
    if (path.getNextSibling().isArrayExpression())
        return true;
    
    return path
        .getPrevSibling()
        .isArrayExpression();
};

function isMaxElementLengthInOneLine(elements, maxElementLengthInOneLine) {
    if (elements.length > 1)
        return false;
    
    const [first] = elements;
    
    if (!isIdentifier$7(first))
        return false;
    
    return first.node.name.length < maxElementLengthInOneLine;
}

const isMultiLine = (path, {elements, maxElementsInOneLine, maxElementLengthInOneLine}) => {
    const [first] = elements;
    
    if (isMaxElementLengthInOneLine(elements, maxElementLengthInOneLine))
        return ONE_LINE;
    
    if (elements.length > maxElementsInOneLine && isStringLiteral$6(first))
        return MULTI_LINE;
    
    if (elements.length > 3 && !isObjectExpression$3(first))
        return MULTI_LINE;
    
    if (isSimpleAndNotEmptyObject(elements))
        return MULTI_LINE;
    
    if (isOneSimple(path))
        return ONE_LINE;
    
    if (isOneSpread(elements))
        return ONE_LINE;
    
    if (elements.length === 2 && isIdentifierAndIdentifier(elements))
        return ONE_LINE;
    
    if (isCallInsideArrow(path))
        return ONE_LINE;
    
    if (isIncreaseIndent(path))
        return ONE_LINE;
    
    if (isInsideLoop(path))
        return ONE_LINE;
    
    if (isBooleanAndSimple(elements))
        return ONE_LINE;
    
    if (isNullAndSimple(elements))
        return ONE_LINE;
    
    if (isSimpleAndCall(elements))
        return ONE_LINE;
    
    if (isShortTwoSimplesInsideCall(path, maxElementsInOneLine))
        return ONE_LINE;
    
    if (isTwoStringsDifferentLength(elements))
        return ONE_LINE;
    
    if (isTwoSimplesInsideObjectProperty(path))
        return ONE_LINE;
    
    if (isStringAndArray(elements) && elements.length < 3)
        return ONE_LINE;
    
    if (isStringAndMember(elements))
        return ONE_LINE;
    
    if (isStringAndIdentifier(elements))
        return ONE_LINE;
    
    if (isIdentifierAndString(elements))
        return ONE_LINE;
    
    if (isSimpleAndObject(elements))
        return ONE_LINE;
    
    if (isStringAndString(elements) && path.parentPath.isArrayExpression() && isArrayExpression$3(path.parentPath.node.elements[0]))
        return ONE_LINE;
    
    if (isSiblingIsArray(path))
        return ONE_LINE;
    
    if (tooLong(path) || isCoupleLines(path) || !isNumbers(elements) && !isForOf$1(path) && isLastArg(path) && !isParentProperty(path))
        return MULTI_LINE;
    
    return ONE_LINE;
};

const isForOf$1 = ({parentPath}) => parentPath.isForOfStatement();

const isStringAndString = ([a, b]) => isStringLiteral$6(a) && isStringLiteral$6(b);

const isShortTwoSimplesInsideCall = (path, maxElementsInOneLine) => {
    const {node, parentPath} = path;
    
    const {elements} = node;
    const {length} = elements;
    const [a, b] = elements;
    
    if (!parentPath.isCallExpression())
        return false;
    
    if (!isStringLiteral$6(a) || !isStringLiteral$6(b))
        return false;
    
    return length < maxElementsInOneLine;
};

const isTwoSimplesInsideObjectProperty = (path) => {
    const {node, parentPath} = path;
    
    const {elements} = node;
    const {length} = elements;
    const [a, b] = elements;
    
    if (length > 2)
        return false;
    
    if (!parentPath.isObjectProperty())
        return false;
    
    if (!isStringLiteral$6(a) || !isStringLiteral$6(b))
        return false;
    
    return !isCoupleLines(path);
};

function isOneSimple(path) {
    const elements = path.get('elements');
    
    if (elements.length !== 1)
        return false;
    
    const [first] = elements;
    
    if (first.isIdentifier() && first.node.name.length < 15)
        return true;
    
    if (first.isStringLiteral() && first.node.value.length > 10)
        return false;
    
    if (!first.isIdentifier() && isSimple(first))
        return true;
    
    if (first.isCallExpression())
        return false;
    
    return first.isMemberExpression();
}

function isTwoStringsDifferentLength(strings) {
    const [a, b] = strings;
    
    if (strings.length > 2)
        return false;
    
    if (!a?.isStringLiteral() || !b?.isStringLiteral())
        return false;
    
    const aLength = a.node.value.length;
    const bLength = b.node.value.length;
    
    return round$1(bLength / aLength) > 2;
}

function isInsideLoop(path) {
    return path.parentPath.isForOfStatement();
}

function tooLong(path) {
    const elements = path.get('elements');
    
    if (elements.length < 2)
        return false;
    
    for (const el of path.get('elements')) {
        if (el.isStringLiteral() && el.node.value.length > 4)
            return true;
    }
    
    return false;
}

function isCallInsideArrow(path) {
    const {parentPath} = path;
    
    if (!parentPath.isCallExpression())
        return false;
    
    if (!parentPath.parentPath.isFunction())
        return false;
    
    return path.node.elements.length < 4;
}

function isNumbers(elements) {
    for (const element of elements) {
        if (element.isNumericLiteral())
            return true;
    }
    
    return false;
}

const isLastArg = ({parentPath}) => !parentPath.isCallExpression();

const isParentProperty = (path) => path.find(isObjectProperty$1);

function isIncreaseIndent(path) {
    const elements = path.get('elements');
    
    if (!elements.length)
        return false;
    
    if (isBooleanAndObject(elements))
        return true;
    
    if (isInsideCallLoop(path))
        return false;
    
    if (elements[0].isObjectExpression())
        return true;
    
    if (isSpreadElement$1(elements[1]))
        return false;
    
    return isStringAndObject(elements);
}

function isInsideCallLoop(path) {
    if (!path.parentPath.isCallExpression())
        return false;
    
    return path.parentPath.parentPath.isForOfStatement();
}

const isStringAndObject = (elements) => {
    const first = elements.at(0);
    const last = elements.at(-1);
    
    return isStringLiteral$6(first) && isObjectExpression$3(last);
};

const isCurrentNewLine = (path) => {
    if (path.isSpreadElement())
        return true;
    
    return !path.isObjectExpression();
};

const {
    isStringLiteral: isStringLiteral$5,
    isArrayExpression: isArrayExpression$2,
} = lib_exports;

const isInsideArray = (path) => path.parentPath.isArrayExpression();

const isArrayIndented = (path) => {
    const elements = path.get('elements');
    
    if (isArrayInsideArray(path))
        return false;
    
    const [first] = elements;
    
    return !isTwoLongStrings(elements) || !isInsideArray(path) && isIndented(first);
};

function isArrayInsideArray(path) {
    if (!path.isArrayExpression() || !path.parentPath.isArrayExpression())
        return false;
    
    const parentElements = path.parentPath.node.elements;
    const parentHasArrays = parentElements.filter(isArrayExpression$2).length;
    const lastNotArray = !isArrayExpression$2(parentElements.at(-1));
    
    if (parentHasArrays && lastNotArray)
        return false;
    
    const {length} = parentElements;
    
    return length <= 3 && length !== 1;
}

const isTwoLongStrings = ([a, b]) => {
    const LONG_STRING = 20;
    
    if (!isStringLiteral$5(a) || !isStringLiteral$5(b))
        return false;
    
    return a.node.value.length > LONG_STRING;
};

const SIMPLE_TYPES = [
    'ArrayExpression',
    'ObjectExpression',
    'SpreadElement',
    'CallExpression',
    'Identifier',
    'NewExpression',
];

const isObjectAfterSimple = (a) => {
    const {type} = a;
    
    if (!isNextObject(a) || isPrevObject(a))
        return false;
    
    return SIMPLE_TYPES.includes(type);
};

const isNextSimple = (a) => {
    const {type} = a.getNextSibling();
    
    return SIMPLE_TYPES.includes(type);
};

const {
    isObjectExpression: isObjectExpression$2,
    isSpreadElement,
    isStringLiteral: isStringLiteral$4,
    isIdentifier: isIdentifier$6,
    isFunction: isFunction$5,
    isCallExpression: isCallExpression$4,
    isObjectProperty,
} = lib_exports;

const isNextString = (path) => isStringLiteral$4(path.getNextSibling());
const isPrevString = (path) => isStringLiteral$4(path.getPrevSibling());
const isAroundStrings = (path) => isNextString(path) || isPrevString(path);

const isSpreadBeforeObject = (a) => {
    if (!a.isObjectExpression())
        return false;
    
    const prev = a.getPrevSibling();
    
    if (!prev.isSpreadElement())
        return false;
    
    const argCall = prev.get('argument');
    
    if (argCall.isCallExpression()) {
        const [first] = argCall.get('arguments');
        
        if (isFunction$5(first))
            return false;
    }
    
    if (prev.getPrevSibling().isObjectExpression())
        return false;
    
    return prev.get('argument').isCallExpression();
};

const isNextSimpleBetweenObjects = (a) => {
    const next = a.getNextSibling();
    const is = next.isSpreadElement() || next.isIdentifier() || next.isCallExpression();
    
    if (!is)
        return true;
    
    return next
        .getNextSibling()
        .isObjectExpression();
};

const isInsideOneElementArray = ({parentPath}) => parentPath.node.elements.length === 1;

const ArrayExpression = {
    beforeIf(path) {
        const {parentPath} = path;
        const {elements} = path.node;
        
        if (!parentPath.isArrayExpression())
            return false;
        
        if (isCoupleLines(parentPath))
            return false;
        
        if (isStringAndIdentifier(elements) && isInsideOneElementArray(path))
            return true;
        
        return isIdentifierAndIdentifier(elements);
    },
    before(path, {print}) {
        print.breakline();
    },
    print(path, {print, maybe}, semantics) {
        const {
            maxElementsInOneLine,
            trailingComma,
            maxElementLengthInOneLine,
        } = semantics;
        
        const elements = path.get('elements');
        const shouldIncreaseIndent = !isIncreaseIndent(path);
        
        print('[');
        
        const indented = isArrayIndented(path);
        
        maybe.indent.inc(indented && shouldIncreaseIndent);
        
        const isNewLine = isMultiLine(path, {
            elements,
            maxElementsInOneLine,
            maxElementLengthInOneLine,
        });
        
        const n = elements.length - 1;
        
        maybe.print.newline(isNewLine && elements.length);
        
        for (const [index, element] of elements.entries()) {
            const is = isNewLine && isCurrentNewLine(element);
            
            if (isSimpleAfterObject(element))
                print.newline();
            
            maybe.indent(is);
            print(element);
            
            if (index < n || trailingComma)
                maybe.print(is, ',');
            
            if (!(isObjectExpression$2(element) && isObjectProperty(path.parentPath)))
                maybe.print.newline((is || isSpreadBeforeObject(element)) && !isNextObject(element) && !isObjectExpression$2(element));
            
            maybe.print.space(is && isObjectAfterSimple(element));
            
            if (!is && index < n) {
                print(',');
                
                if (isNextSimpleBetweenObjects(element) || !(element.isObjectExpression() && isNextSimple(element)))
                    print.space();
            }
        }
        
        maybe.indent.dec(indented && shouldIncreaseIndent);
        
        const parentElements = path.parentPath.get('elements');
        
        if (isInsideArray(path) && isStringAndArray(parentElements)) {
            const parentCountTwo = parentElements.length === 2;
            const isHideIdent = !isAroundStrings(path) || parentCountTwo;
            
            maybe.indent.dec(isHideIdent);
            maybe.indent(elements.length && isNewLine);
            maybe.indent.inc(isHideIdent);
        } else if (!isArrayInsideArray(path) && !isObjectExpression$2(elements.at(-1))) {
            maybe.indent(elements.length && isNewLine);
        }
        
        if (isSimpleAndNotEmptyObject(elements) && !isSpreadElement(elements.at(-1)) && !isCallExpression$4(elements.at(-1))) {
            print(',');
            print.breakline();
        }
        
        print(']');
    },
    afterIf(path) {
        const {parentPath} = path;
        const {elements} = path.node;
        
        if (!parentPath.isArrayExpression())
            return false;
        
        if (isCoupleLines(parentPath))
            return false;
        
        if (isStringAndIdentifier(elements) && isInsideOneElementArray(path))
            return true;
        
        return isIdentifierAndIdentifier(elements);
    },
    after(path, {print, indent}) {
        indent.dec();
        print.breakline();
        indent.inc();
    },
};

function isSimpleAfterObject(path) {
    if (!isSpreadElement(path) && !isIdentifier$6(path) && !isCallExpression$4(path))
        return;
    
    const prev = path.getPrevSibling();
    const next = path.getNextSibling();
    
    if (next.isObjectExpression())
        return false;
    
    return prev.isObjectExpression();
}

const isForOf = ({parentPath}) => parentPath.parentPath.parentPath?.isForOfStatement();

const ArrayPattern = maybeTypeAnnotation((path, {indent, maybe, print}, semantics) => {
    const {maxElementsInOneLine} = semantics;
    
    print('[');
    
    const elements = path.get('elements');
    indent.inc();
    
    const isNewLine = !isForOf(path) && elements.length > maxElementsInOneLine;
    const n = elements.length - 1;
    
    maybe.print(isNewLine && elements.length, '\n');
    
    for (const [index, element] of elements.entries()) {
        maybe.indent(isNewLine);
        print(element);
        
        if (isNewLine) {
            print(',\n');
        } else if (index < n) {
            print(',');
            print.space();
        }
    }
    
    indent.dec();
    maybe.indent(elements.length && isNewLine);
    print(']');
});

const isArg = (path) => path.parentPath.isFunction();

const AssignmentPattern = {
    print(path, {print, maybe}) {
        maybe.print(shouldPrint(path), '__left');
        print.space();
        print('=');
        print.space();
        print('__right');
    },
};

function shouldPrint(path) {
    const {parentPath} = path;
    
    if (parentPath.isObjectProperty() && !parentPath.node.shorthand)
        return true;
    
    if (isArg(path))
        return true;
    
    if (parentPath.isTSParameterProperty())
        return true;
    
    return parentPath.isArrayPattern();
}

const RestElement = maybeTypeAnnotation((path, {print}) => {
    print('...');
    print('__argument');
});

const SpreadElement = (path, printer) => {
    const {print} = printer;
    print('...');
    print('__argument');
    
    if (hasTrailingComment(path))
        print(',');
};

const condition$3 = (path, printer, semantics) => {
    const {parentPath} = path;
    const {type} = parentPath;
    const {roundBraces} = semantics;
    
    if (type === 'ArrowFunctionExpression')
        return true;
    
    if (type === 'ConditionalExpression' && path !== parentPath.get('test'))
        return true;
    
    if (type === 'LogicalExpression')
        return true;
    
    return roundBraces.sequence;
};

const noop$5 = () => {};

const printLeadingCommentLine$2 = noop$5;
const printLeadingCommentBlock$2 = noop$5;

const maybePrintComments = (path, {print}) => {
    if (hasLeadingComment(path)) {
        const {leadingComments} = path.node;
        
        for (const {type, value} of leadingComments) {
            if (type === 'CommentLine')
                print(`//${value}`);
            else
                print(`/*${value}*/`);
            
            print.breakline();
        }
    }
};

const SequenceExpression = maybeParens({
    checkParens: false,
    condition: condition$3,
    print(path, printer) {
        const {
            write,
            traverse,
            indent,
            maybe,
        } = printer;
        
        const expressions = path.get('expressions');
        const n = expressions.length - 1;
        
        const withComment = hasLeadingComment(path);
        
        if (withComment) {
            indent.inc();
            write.breakline();
            maybePrintComments(path, printer);
        }
        
        for (const [index, expression] of expressions.entries()) {
            traverse(expression);
            
            if (index < n) {
                write(',');
                maybe.write.space(!withComment);
                maybe.print.breakline(withComment);
            }
        }
        
        if (withComment) {
            indent.dec();
            write.breakline();
        }
    },
});

SequenceExpression.printLeadingCommentLine = printLeadingCommentLine$2;
SequenceExpression.printLeadingCommentBlock = printLeadingCommentBlock$2;

const TaggedTemplateExpression = (path, {print}) => {
    print('__tag');
    print('__quasi');
};

const maybeSpace = (path, {print}) => {
    const {right} = path.node;
    
    if (right.type === 'UnaryExpression' && right.operator === '+')
        return print(' ');
    
    return print.space();
};

const BinaryExpression = maybeParens((path, {print, indent, maybe}) => {
    const {operator} = path.node;
    
    if (operator === 'in' || operator === 'instanceof') {
        print('__left');
        print(' ');
        print(operator);
        print(' ');
        print('__right');
        
        return;
    }
    
    if (isConcatenation(path))
        return concatenate(path, {
            print,
            indent});
    
    print('__left');
    print.space();
    print(path.node.operator);
    maybeSpace(path, {
        print,
    });
    print('__right');
});

const {
    isLogicalExpression,
    isReturnStatement: isReturnStatement$2,
    isVariableDeclarator: isVariableDeclarator$1,
} = lib_exports;

const isRootOk = (path) => {
    return isReturnStatement$2(path) || isVariableDeclarator$1(path);
};

const chain = (path) => {
    const [downCount] = down(path);
    const [upCount, root] = up(path);
    
    return [
        root,
        downCount + upCount,
        downCount,
        upCount,
    ];
};

function down(current) {
    let count = 0;
    
    do {
        ++count;
        const right = current.get('right');
        
        if (isLogicalExpression(right))
            count += down(right)[0];
        
        current = current.get('left');
        
        const {operator} = current.node;
        
        if (operator !== '||' && operator !== '&&')
            break;
    } while (current.isLogicalExpression());
    
    return [count];
}

function up(current) {
    let count = 0;
    
    do {
        ++count;
        current = current.parentPath;
    } while (current.isLogicalExpression());
    
    return [
        count, {
            type: current.type,
        },
    ];
}

const LogicalExpression = maybeParens({
    condition(path) {
        if (path.parentPath.isUnaryExpression())
            return true;
        
        return path.parentPath.isAwaitExpression();
    },
    print(path, {print, maybe}, semantics) {
        print('__left');
        
        const needNewLine = isNewLine(path, semantics);
        
        maybe.indent.inc(needNewLine);
        needNewLine ? print.breakline() : print.space();
        maybe.indent.dec(needNewLine);
        
        print(path.node.operator);
        print.space();
        print('__right');
    },
});

function isNewLine(path, semantics) {
    const [root, count] = chain(path);
    
    if (!isRootOk(root))
        return false;
    
    if (count <= semantics.maxLogicalsInOneLine)
        return false;
    
    const {operator} = path.node;
    
    return operator === '||' || operator === '&&';
}

const ConditionalExpression = maybeParens((path, {print}) => {
    print('__test');
    print.space();
    print('?');
    print.space();
    print('__consequent');
    print.space();
    print(':');
    print.space();
    print('__alternate');
});

const StaticBlock = (path, {print, traverse}) => {
    print('static ');
    print('{');
    print.breakline();
    
    for (const child of path.get('body')) {
        traverse(child);
    }
    
    print.indent();
    print('}');
    print.newline();
};

const ImportExpression = createImportExpression;

function createImportExpression(path, printer) {
    const {print, maybe} = printer;
    const {options} = path.node;
    
    print('import(');
    print('__source');
    
    maybe.print(options, ',');
    maybe.print.space(options);
    
    print('__options');
    print(')');
}

const {isJSXElement: isJSXElement$4} = lib_exports;

const condition$2 = (path) => {
    const {expression} = path.node;
    return !isJSXElement$4(expression);
};

const ParenthesizedExpression = {
    before(path, {print}) {
        print('(');
    },
    condition: condition$2,
    print(path, {print}) {
        print('__expression');
    },
    after(path, {print}) {
        print(')');
    },
};

const processClassProperty = maybeDecorators$1((path, printer, semantics, {accessor} = {}) => {
    const {node} = path;
    const {
        accessibility,
        declare,
        optional,
    } = node;
    
    const {print, maybe} = printer;
    
    maybe.print(accessor, 'accessor ');
    
    const value = path.get('value');
    
    maybe.print(declare, 'declare ');
    maybe.print(accessibility, `${accessibility} `);
    maybe.print(node.static, 'static ');
    maybe.print(node.readonly, 'readonly ');
    
    printKind(path, printer);
    printKey(path, printer);
    
    maybe.print(optional, '?');
    
    maybePrintTypeAnnotation(path, printer);
    
    if (exists(value)) {
        print.space();
        print('=');
        print.space();
        print('__value');
    }
    
    print(';');
    print.newline();
});

const ClassProperty = processClassProperty;
const ClassPrivateProperty = processClassProperty;

const PrivateName = (path, {print}) => {
    print('#');
    print('__id');
};

const ClassAccessorProperty = (path, printer, semantics) => {
    processClassProperty(path, printer, semantics, {
        accessor: true,
    });
};

const ThisExpression = (path, {write}) => {
    write('this');
};

const WithStatement = {
    print(path, {print, indent}) {
        indent();
        print('with');
        print.space();
        print('(');
        print('__object');
        print(')');
        
        if (path.node.body.body) {
            print.space();
            print('__body');
        } else {
            indent.inc();
            print.newline();
            print('__body');
            indent.dec();
        }
    },
    afterIf(path) {
        return isNext(path);
    },
    after(path, {print}) {
        print.linebreak();
        markAfter(path);
    },
};

const EmptyStatement = (path, {write, maybe}) => {
    const {parentPath} = path;
    write(';');
    maybe.write.newline(!isLast$2(path) && !isLast$2(parentPath));
};

const LabeledStatement = (path, {print, maybe}) => {
    maybe.indent(!isInsideLabel(path));
    print('__label');
    print(':');
    print.space();
    print('__body');
};

const ContinueStatement = (path, {print, maybe, write}) => {
    const {label} = path.node;
    
    maybe.indent(!isInsideLabel(path));
    print('continue');
    
    maybe.print.space(label);
    print('__label');
    
    write(';');
    print.newline();
};

const getDirectives = (path) => !path.node.directives ? [] : path.get('directives');

const Program = (path, printer, semantics) => {
    const {body} = path.node;
    const {
        traverse,
        maybe,
        write,
    } = printer;
    
    traverse(path.get('interpreter'));
    parseComments(path, printer, semantics);
    
    const directives = getDirectives(path);
    
    for (const directive of directives) {
        traverse(directive);
        maybe.write.newline(body.length);
    }
    
    path.get('body').forEach(traverse);
    
    if (directives.length && !body.length)
        return;
    
    if (body.length && hasCoupleTrailingComments(body.at(-1)))
        return;
    
    write.endOfFile();
};

const notLast = (path) => !isLast$2(path);

const DoWhileStatement = {
    print(path, {print, indent}) {
        indent();
        print('do');
        print.space();
        print('__body');
        print.space();
        print('while');
        print.space();
        print('(');
        print('__test');
        print(')');
    },
    afterSatisfy: () => [notLast],
    after(path, {print}) {
        print.newline();
    },
};

const isInsideCase = (path) => path.parentPath.isSwitchCase();

const BreakStatement = {
    split(path, {print}) {
        print.newline();
    },
    print(path, {print, maybe}) {
        const {label} = path.node;
        
        maybe.indent(!isInsideLabel(path));
        print('break');
        maybe.print.space(label);
        print('__label');
        print(';');
    },
    afterSatisfy: () => [
        isParentBlock$1,
        isNextParent,
        isInsideCase,
        isInsideIf,
    ],
};

const {
    isVariableDeclaration: isVariableDeclaration$2,
    isFunction: isFunction$4,
} = lib_exports;

function shouldAddSemicolon(path) {
    if (path.isClassDeclaration())
        return false;
    
    return !path.isFunctionDeclaration();
}

const ExportDefaultDeclaration = {
    print(path, {print, traverse, maybe}) {
        const declaration = path.get('declaration');
        print('export default ');
        traverse(declaration);
        maybe.print(shouldAddSemicolon(declaration), ';');
    },
    afterSatisfy: () => [isNext],
    after(path, {print, maybe}) {
        print.newline();
        maybe.print.newline(!isVarAfterFn(path));
    },
};

function isVarAfterFn(path) {
    const next = path.getNextSibling();
    
    if (!isVariableDeclaration$2(next))
        return false;
    
    const {declaration} = path.node;
    
    return isFunction$4(declaration);
}

const ForInStatement = (path, {print, indent}) => {
    indent();
    print('for');
    print.space();
    print('(');
    print('__left');
    print(' in ');
    print('__right');
    print(')');
    
    if (path.get('body').isBlockStatement())
        print.space();
    
    print('__body');
};

const maybeSpaceAfterKeyword$1 = (path, {print}, semantics) => {
    const {roundBraces} = semantics;
    const {node} = path;
    
    if (!node)
        return;
    
    const {type} = node;
    
    if (type === 'SequenceExpression' && roundBraces.sequence)
        return print.space();
    
    if (type === 'StringLiteral' || type === 'TemplateLiteral')
        return print.space();
    
    if (type === 'ArrayExpression' || type === 'ObjectExpression')
        return print.space();
    
    if (type === 'UnaryExpression' && node.operator === '!')
        return print.space();
    
    if (type === 'ArrowFunctionExpression' && roundBraces.arrow)
        return print.space();
    
    print(' ');
};

const SwitchStatement = {
    print(path, printer, semantics) {
        const {
            print,
            maybe,
            indent,
            write,
            traverse,
        } = printer;
        
        indent();
        print('switch');
        print('(');
        print('__discriminant');
        print(') {');
        print.newline();
        
        const cases = path.get('cases');
        const n = cases.length - 1;
        
        for (const [index, switchCase] of cases.entries()) {
            const test = switchCase.get('test');
            
            indent();
            
            parseLeadingComments(switchCase, printer, semantics);
            
            if (exists(test)) {
                write('case');
                maybeSpaceAfterKeyword$1(test, printer, semantics);
                traverse(test);
            } else {
                write('default');
            }
            
            print(':');
            
            const consequents = switchCase.get('consequent');
            const isBlock = switchCase.get('consequent.0')?.isBlockStatement();
            
            maybe.indent.inc(!isBlock);
            maybe.print.newline(!isBlock && consequents.length);
            
            for (const consequent of consequents) {
                if (!consequent.isBlockStatement()) {
                    print(consequent);
                    continue;
                }
                
                print.space();
                print(consequent);
            }
            
            maybe.indent.dec(!isBlock);
            maybe.write.linebreak(index < n);
        }
        
        print.indent();
        print('}');
        
        if (!isNext(path) && !isLast$2(path))
            print.newline();
    },
    afterSatisfy: () => [isNext],
    after(path, {print}) {
        print.breakline();
        print.newline();
    },
};

const WhileStatement = {
    print(path, {print, indent}) {
        indent();
        print('while');
        print.space();
        print('(');
        print('__test');
        print(')');
        
        if (path.node.body.body) {
            print.space();
            print('__body');
        } else {
            indent.inc();
            print.newline();
            print('__body');
            indent.dec();
        }
    },
    afterIf(path) {
        return isNext(path);
    },
    after(path, {print}) {
        print.linebreak();
        markAfter(path);
    },
};

const ExportAllDeclaration = (path, {print}) => {
    const {exportKind} = path.node;
    print('export ');
    
    if (exportKind === 'type')
        print('type ');
    
    print('* from ');
    print('__source');
    print(';');
    print.newline();
};

const {
    isExportNamespaceSpecifier,
    isVariableDeclaration: isVariableDeclaration$1,
    isExportNamedDeclaration: isExportNamedDeclaration$1,
    isExportDefaultSpecifier,
} = lib_exports;

const isDeclarationNewline = (path) => isMarkedAfter(path.get('declaration'));
const isInsideNamespace$1 = (path) => path.parentPath.isTSModuleBlock();

const options$1 = {
    exports: {
        maxOneLineSpecifiers: 2,
    },
};

const ExportSpecifier = (path, {print}) => {
    const {local, exported} = path.node;
    
    print('__local');
    
    if (exported.name !== local.name) {
        print(' as ');
        print('__exported');
    }
};

const ExportNamespaceSpecifier = (path, {print}) => {
    print('* as ');
    print('__exported');
};

const ExportDefaultSpecifier = (path, {print}) => {
    print('__exported');
};

const ExportNamedDeclaration = {
    beforeIf(path) {
        const prev = path.getPrevSibling();
        
        if (hasPrevNewline(path))
            return false;
        
        return isVariableDeclaration$1(prev);
    },
    before(path, {print}) {
        print.linebreak();
    },
    print(path, {print, traverse, indent, maybe}, semantics) {
        const {trailingComma} = semantics;
        const {exportKind} = path.node;
        const specifiers = path.get('specifiers');
        const {maxOneLineSpecifiers} = options$1.exports;
        const source = path.get('source');
        
        indent();
        print('export');
        
        if (exportKind === 'type' && specifiers.length)
            print(' type');
        
        if (isExportNamespaceSpecifier(specifiers[0])) {
            print(' ');
            print(specifiers[0]);
            print(' from ');
            print('__source');
            print(';');
            maybe.print.newline(!isLast$2(path));
            
            return;
        }
        
        const n = specifiers.length;
        const isNewline = !exists(source) || n > maxOneLineSpecifiers;
        
        if (specifiers && !path.node.declaration) {
            print.space();
            
            const [first, ...rest] = specifiers;
            
            if (!specifiers.length) {
                print('{}');
            } else if (isExportDefaultSpecifier(first) && !rest.length) {
                traverse(first);
            } else {
                if (isExportDefaultSpecifier(first)) {
                    traverse(first);
                    print(',');
                    print.space();
                } else {
                    rest.unshift(first);
                }
                
                print('{');
                
                indent.inc();
                maybe.print.newline(isNewline);
                
                const lastIndex = n - 1;
                
                for (const [i, spec] of rest.entries()) {
                    const isType = spec.node.exportKind === 'type';
                    const isLast = i < lastIndex;
                    
                    maybe.indent(isNewline);
                    maybe.print(isType, 'type ');
                    traverse(spec);
                    
                    if (isLast && !isNewline)
                        print(', ');
                    else if (isNewline)
                        maybe.print(isLast || trailingComma, ',');
                    
                    maybe.print.newline(isNewline);
                }
                
                indent.dec();
                indent();
                print('}');
            }
            
            const source = path.get('source');
            
            if (exists(source)) {
                print(' from ');
                traverse(source);
            }
            
            print(';');
            maybe.print.newline(isNext(path) || isInsideNamespace$1(path));
            
            return;
        }
        
        print(' ');
        print('__declaration');
    },
    afterIf(path) {
        if (isLast$2(path))
            return false;
        
        if (isDeclarationNewline(path))
            return false;
        
        if (isNewlineBetweenSiblings(path))
            return true;
        
        return isParentBlock$1(path);
    },
    after(path, {print, indent}) {
        const next = path.getNextSibling();
        
        if (isExportNamedDeclaration$1(next))
            indent();
        
        print.newline();
        
        markAfter(path);
    },
};

var parseImportSpecifiers_1 = (specifiers) => {
    const defaults = [];
    const namespaces = [];
    const imports = [];
    
    for (const spec of specifiers) {
        if (spec.type === 'ImportDefaultSpecifier') {
            defaults.push(spec);
            continue;
        }
        
        if (spec.type === 'ImportNamespaceSpecifier') {
            namespaces.push(spec);
            continue;
        }
        
        if (spec.type === 'ImportSpecifier') {
            imports.push(spec);
            continue;
        }
    }
    
    return {
        defaults,
        namespaces,
        imports,
    };
};

const ImportAttribute = (path, {print}) => {
    print('__key');
    print(':');
    print.space();
    print('__value');
    print(',');
};

const printAttributes = (path, keyword, {write, traverse, indent}) => {
    const attributes = path.get('attributes');
    
    if (!attributes.length)
        return;
    
    write(` ${keyword}`);
    write.space();
    
    write('{');
    write.breakline();
    indent.inc();
    
    for (const attr of attributes) {
        indent();
        traverse(attr);
        write.newline();
    }
    
    indent.dec();
    write('}');
};

const {isExportDeclaration: isExportDeclaration$3} = lib_exports;

const printTrailingCommentLine = (path, printer, semantics, {printComment}) => {
    const {print} = printer;
    printComment();
    print.breakline();
};

const printTrailingCommentBlock$1 = (path, printer, semantics, {printComment}) => {
    const {maybe} = printer;
    const next = path.getNextSibling();
    
    maybe.print.breakline(!isExportDeclaration$3(next));
    printComment();
};

const ImportDeclaration = {
    print(path, printer, semantics) {
        const {
            print,
            maybe,
            write,
            traverse,
            indent,
        } = printer;
        
        const {phase} = path.node;
        const isType = path.node.importKind === 'type';
        const specifiers = path.get('specifiers');
        
        indent();
        write('import');
        maybe.write(isType, ' type');
        maybe.write(phase, ` ${phase}`);
        
        let wasSpecifier = false;
        const n = specifiers.length - 1;
        
        const {
            defaults,
            namespaces,
            imports,
        } = parseImportSpecifiers_1(specifiers);
        
        maybe.write(specifiers.length, ' ');
        
        for (const spec of defaults) {
            traverse(spec.get('local'));
            maybe.write(n, ',');
            maybe.write.space(n);
        }
        
        for (const spec of namespaces) {
            write('* as ');
            traverse(spec.get('local'));
        }
        
        const maxSpecifiersInOneLine = parseMaxSpecifiers(imports, semantics);
        const importsCount = imports.length - 1;
        
        for (const [index, spec] of imports.entries()) {
            const last = index === importsCount;
            const notLast = !last;
            
            const {imported, local} = spec.node;
            
            indent.inc();
            
            maybe.write(!wasSpecifier, '{');
            maybe.write.breakline(importsCount >= maxSpecifiersInOneLine);
            
            wasSpecifier = true;
            traverse(spec.get('imported'));
            
            if (imported.name !== local.name) {
                write(' as ');
                write(local.name);
            }
            
            if (importsCount < maxSpecifiersInOneLine && notLast) {
                maybe.write(n, ',');
                maybe.write.space(n);
            }
            
            if (importsCount >= maxSpecifiersInOneLine) {
                maybe.write(n, ',');
                
                const last = index === n;
                const penalty = index === n - 1;
                
                maybe.write.newline(penalty && defaults.length);
                maybe.write.newline(last);
            }
            
            indent.dec();
            maybe.write(last, '}');
        }
        
        maybe.write(specifiers.length, ' from');
        print.space();
        
        print('__source');
        printAttributes(path, 'with', printer);
        
        print(';');
        
        if (isNext(path))
            print.newline();
    },
    afterIf(path) {
        if (isLast$2(path))
            return false;
        
        return !path.getNextSibling().isImportDeclaration();
    },
    after(path, {print}) {
        print.newline();
        markAfter(path);
    },
};

function parseMaxSpecifiers(imports, semantics) {
    const {
        maxSpecifiersInOneLine,
        maxPropertiesLengthInOneLine,
    } = semantics;
    
    for (const {node} of imports) {
        if (node.imported.name !== node.local.name)
            return 1;
        
        if (node.imported.name.length >= maxPropertiesLengthInOneLine)
            return 1;
    }
    
    return maxSpecifiersInOneLine;
}

ImportDeclaration.printTrailingCommentBlock = printTrailingCommentBlock$1;
ImportDeclaration.printTrailingCommentLine = printTrailingCommentLine;

const ForStatement = {
    print(path, {print, maybe}) {
        const {
            test,
            update,
            body,
        } = path.node;
        
        maybe.indent(!isInsideLabel(path));
        print('for');
        print.space();
        print('(');
        print('__init');
        print(';');
        maybe.print.space(test);
        print('__test');
        
        print(';');
        maybe.print.space(update);
        print('__update');
        print(')');
        
        if (body.body) {
            print.space();
            print('__body');
        } else {
            const is = !path.get('body').isEmptyStatement();
            maybe.print.newline(is);
            maybe.indent.inc(is);
            print('__body');
            maybe.indent.dec(is);
        }
    },
    afterIf(path) {
        return exists(path.getNextSibling());
    },
    after(path, {print}) {
        print.linebreak();
        markAfter(path);
    },
};

const isInsideBlock$3 = (path) => path.parentPath.isBlockStatement();

const DebuggerStatement = {
    print(path, {print, indent}) {
        indent();
        print('debugger;');
    },
    afterSatisfy: () => [
        isNext,
        isInsideBlock$3,
        isInsideIf,
    ],
    after(path, {print}) {
        print.newline();
    },
};

const TryStatement = {
    print(path, {print}) {
        const finalizer = path.get('finalizer');
        print.indent();
        print('try');
        print.space();
        print('__block');
        print('__handler');
        
        if (finalizer.node) {
            print.space();
            print('finally');
            print.space();
            print(finalizer);
            print.newline();
        }
    },
    afterSatisfy: () => [isNext],
    after(path, {maybe, print}) {
        maybe.print.newline(!path.node.finalizer);
        print.breakline();
    },
};

const CatchClause = (path, {print, maybe}) => {
    const param = path.get('param');
    const body = path.get('body');
    
    print.space();
    print('catch');
    
    if (!param.node) {
        print.space();
    } else {
        print('(');
        print(param);
        print(')');
        print.space();
    }
    
    print(body);
    maybe.print.newline(isInsideBlock$2(path));
};

function isInsideBlock$2(path) {
    return path.parentPath.parentPath.isBlockStatement();
}

const {isJSXElement: isJSXElement$3} = lib_exports;
const isBodyLength = ({parentPath}) => parentPath.node?.body?.length > 2;

const isInsideIfWithElse = ({parentPath}) => parentPath.isIfStatement() && parentPath.node.alternate;

const ReturnStatement = {
    beforeIf(path) {
        return !hasPrevNewline(path) && isBodyLength(path) || isPrevBody(path);
    },
    before(path, {print}) {
        print.linebreak();
    },
    print(path, printer, semantics) {
        const {maybe, print} = printer;
        
        maybe.indent(!isInsideLabel(path));
        print('return');
        
        const arg = path.get('argument');
        
        maybeSpaceAfterKeyword$1(arg, printer, semantics);
        
        if (isJSXWithComment(path)) {
            print('(');
            print.breakline();
            print('__argument');
            print(');');
            
            return;
        }
        
        print('__argument');
        print(';');
    },
    afterIf: (path) => {
        if (isInsideIfWithElse(path))
            return true;
        
        if (isLast$2(path))
            return false;
        
        if (isLast$2(path.parentPath))
            return false;
        
        return noTrailingComment(path);
    },
    after(path, {print}) {
        print.newline();
    },
};

function isJSXWithComment(path) {
    const arg = path.node.argument;
    
    if (!arg)
        return;
    
    const {leadingComments} = arg;
    
    return isJSXElement$3(arg) && leadingComments?.length;
}

const insideIfWithNoBody = (path) => {
    if (!path.parentPath.isIfStatement())
        return false;
    
    if (!path.parentPath.parentPath.isIfStatement())
        return false;
    
    const next = path.parentPath?.parentPath.getNextSibling();
    
    return !exists(next);
};

const {
    isReturnStatement: isReturnStatement$1,
    isExpressionStatement: isExpressionStatement$5,
    isMemberExpression: isMemberExpression$1,
    isCallExpression: isCallExpression$3,
} = lib_exports;

const isCallInsideChain = (path) => {
    if (!isCallExpression$3(path.parentPath.parentPath))
        return false;
    
    const member = path.find(isTopMemberInsideCall);
    
    if (member)
        return isLooksLikeChain(member);
    
    const callPath = path.find(isTopCall);
    
    if (!callPath)
        return false;
    
    const calleeMember = callPath.get('callee');
    
    return isLooksLikeChain(calleeMember);
};

function isTopMemberInsideCall(path) {
    if (!isMemberExpression$1(path))
        return false;
    
    return isExpressionStatement$5(path.parentPath.parentPath);
}

function isTopCall(path) {
    if (!isCallExpression$3(path))
        return false;
    
    const {parentPath} = path;
    
    if (isReturnStatement$1(parentPath))
        return true;
    
    return isExpressionStatement$5(parentPath);
}

const {
    isArrowFunctionExpression,
    isObjectMethod,
    isFunctionDeclaration: isFunctionDeclaration$1,
    isExportDeclaration: isExportDeclaration$2,
    isDoWhileStatement,
    isBlockStatement: isBlockStatement$4,
    isArrayExpression: isArrayExpression$1,
} = lib_exports;

const isFirstStatement = (path) => path.node.body[0];
const isFirstDirective = (path) => path.node.directives?.[0];
const isMethodOrArrow = (path) => isArrowFunctionExpression(path) || isObjectMethod(path);

const isInsideArrayTupleOfThree = (path) => {
    const {parentPath} = path.parentPath;
    
    if (!isArrayExpression$1(parentPath))
        return false;
    
    const {length} = parentPath.node.elements;
    
    return length === 3;
};

const parentIfWithoutElse = ({parentPath}) => {
    if (!parentPath.isIfStatement())
        return false;
    
    return !parentPath.node.alternate;
};

const BlockStatement = {
    print(path, printer, semantics) {
        const {trailingComma} = semantics;
        const {
            indent,
            maybe,
            write,
            traverse,
        } = printer;
        
        const body = path.get('body');
        const directives = getDirectives(path);
        
        if (path.parentPath.isBlockStatement())
            indent();
        
        const insideArray = isInsideArrayTupleOfThree(path);
        maybe.indent.inc(!insideArray);
        write('{');
        
        if (isFirstStatement(path) || isFirstDirective(path))
            write.newline();
        
        for (const directive of directives) {
            traverse(directive);
        }
        
        maybe.write.linebreak(directives.length && body.length);
        const callInsideChain = isCallInsideChain(path);
        
        maybe.indent.inc(callInsideChain);
        
        for (const element of body) {
            traverse(element);
        }
        
        parseComments(path, printer, semantics);
        
        maybe.indent.dec(!insideArray);
        
        maybe.indent.dec(insideArray);
        maybe.indent(body.length);
        maybe.indent.inc(insideArray);
        write('}');
        
        maybe.indent.dec(callInsideChain);
        
        const {parentPath} = path;
        
        if (isObjectMethod(parentPath))
            maybe.write(isNext(parentPath) || trailingComma, ',');
    },
    afterIf: shouldAddNewlineAfter,
    after(path, {write}) {
        write.newline();
        markAfter(path.parentPath);
    },
};

const isTopLevelWithNoNext = (path) => {
    if (isNext(path))
        return false;
    
    return !isNext(path.parentPath) && isParentProgram(path.parentPath);
};

const isInsideIfWithoutElseInsideFn = (path) => {
    return parentIfWithoutElse(path) && path.find(isMethodOrArrow);
};

const isEmptyBodyNoNext = (path) => {
    const {parentPath} = path;
    return parentPath.isStatement() && !path.node.body.length && !isNext(parentPath);
};

const isLooksLikeInsideFn = ({parentPath}) => {
    return /FunctionExpression/.test(parentPath.type);
};

const NEWLINE = true;
const NO_NEWLINE = false;

const isInsideDoWhile = ({parentPath}) => isDoWhileStatement(parentPath);
const isInsideBlock$1 = ({parentPath}) => isBlockStatement$4(parentPath);

const isNoNewline = satisfy([
    isInsideDoWhile,
    isTopLevelWithNoNext,
    insideIfWithNoBody,
]);

function shouldAddNewlineAfter(path) {
    if (isInsideBlock$1(path))
        return NEWLINE;
    
    if (isNoNewline(path))
        return NO_NEWLINE;
    
    if (isInsideIfWithoutElseInsideFn(path))
        return NEWLINE;
    
    if (isEmptyBodyNoNext(path))
        return NO_NEWLINE;
    
    if (isTry(path))
        return NO_NEWLINE;
    
    if (isLooksLikeInsideFn(path))
        return NO_NEWLINE;
    
    if (isLast$2(path))
        return NO_NEWLINE;
    
    if (isExportFunction(path))
        return NO_NEWLINE;
    
    return !isNextIfAlternate(path);
}

function isExportFunction(path) {
    if (!isFunctionDeclaration$1(path.parentPath))
        return false;
    
    if (!isExportDeclaration$2(path.parentPath?.parentPath))
        return false;
    
    return !isNext(path.parentPath?.parentPath);
}

function isNextIfAlternate(path) {
    const {parentPath} = path;
    
    if (!parentPath.isIfStatement())
        return false;
    
    const alternate = parentPath.get('alternate');
    
    if (path === alternate)
        return false;
    
    return exists(alternate);
}

function isTry({parentPath}) {
    if (parentPath.isTryStatement())
        return true;
    
    return parentPath.parentPath?.isTryStatement();
}

const ForOfStatement = {
    beforeIf(path) {
        const {parentPath} = path;
        
        if (!parentPath.isBlockStatement() && parentPath.isStatement())
            return false;
        
        return !isFirst$2(path) && !hasPrevNewline(path);
    },
    before(path, {print}) {
        print.linebreak();
        markBefore(path);
    },
    print(path, {indent, print, maybe, traverse}) {
        const {node} = path;
        
        indent();
        print('for');
        maybe.print(node.await, ' await');
        print.space();
        print('(');
        print('__left');
        print(' of ');
        print('__right');
        print(')');
        
        const bodyPath = path.get('body');
        
        if (bodyPath.isBlockStatement()) {
            print.space();
            print('__body');
            
            const {length} = bodyPath.node.body;
            maybe.print.newline(!length && !isLast$2(path) && !isNext(path));
            
            return;
        }
        
        indent.inc();
        print.newline();
        traverse(bodyPath);
        indent.dec();
        
        maybe.markAfter(isMarkedAfter(bodyPath), path);
    },
    afterIf: isNext,
    after(path, {print}) {
        print.linebreak();
        markAfter(path);
    },
};

const {
    isBlockStatement: isBlockStatement$3,
    isFunctionDeclaration,
    isStatement: isStatement$3,
    isExpressionStatement: isExpressionStatement$4,
    isReturnStatement,
    isContinueStatement,
} = lib_exports;

const isStatementNotExpression = (path) => {
    if (isBlockStatement$3(path))
        return false;
    
    if (isReturnStatement(path))
        return false;
    
    if (isContinueStatement(path))
        return false;
    
    return !isExpressionStatement$4(path);
};

const isTopLevel = ({parentPath}) => parentPath.parentPath.isProgram();
const isEmptyConsequent = (path) => path.get('consequent').isEmptyStatement();

const isInsideNestedBody = ({parentPath}) => {
    if (parentPath.type !== 'BlockStatement')
        return false;
    
    return parentPath.parentPath.type === 'BlockStatement';
};

const isEmptyBody = (path) => !path.node.body.length;

const isLastEmptyInsideBody = (path) => {
    const {parentPath} = path;
    
    if (!isBlockStatement$3(parentPath))
        return false;
    
    if (!isBlockStatement$3(path.node.consequent))
        return false;
    
    if (path.node.consequent.body.length)
        return false;
    
    return isFunctionDeclaration(path.parentPath.parentPath);
};

const IfStatement = {
    print: (path, {indent, print, maybe, write, traverse}) => {
        const {parentPath} = path;
        const partOfAlternate = parentPath.get('alternate');
        
        if (path !== partOfAlternate)
            indent();
        
        print('if');
        print.space();
        print('(');
        print('__test');
        print(')');
        
        const consequent = path.get('consequent');
        const alternate = path.get('alternate');
        const isConsequentBlock = consequent.isBlockStatement();
        const isVar = consequent.isVariableDeclaration();
        
        if (isConsequentBlock) {
            print.space();
            print(consequent);
            
            if (isInsideIf(path.parentPath) || isInsideNestedBody(path))
                maybe.print.newline(isEmptyBody(consequent));
        } else {
            const is = !isEmptyConsequent(path);
            
            maybe.print.newline(is);
            maybe.indent.inc(is);
            maybe.indent(isVar);
            print(consequent);
            maybe.indent.dec(is);
        }
        
        if (alternate.isBlockStatement()) {
            write.space();
            write('else');
            write.space();
            traverse(alternate);
        } else if (alternate.isIfStatement()) {
            if (alternate.get('consequent').isBlockStatement()) {
                write.space();
            } else {
                maybe.write.newline(isStatementNotExpression(consequent));
                indent();
            }
            
            write('else ');
            traverse(alternate);
        } else if (exists(alternate)) {
            maybe.write.newline(isVar || isStatementNotExpression(consequent));
            maybe.indent(!isConsequentBlock);
            maybe.write.space(isConsequentBlock);
            write('else');
            write.splitter();
            indent.inc();
            traverse(alternate);
            indent.dec();
        }
        
        if (!isNext(path) && !consequent.isBlockStatement())
            return;
        
        const nextPath = path.parentPath.getNextSibling();
        
        if (path === partOfAlternate && !isTopLevel(path) && !isStatement$3(nextPath))
            print.newline();
        
        if (isLastEmptyInsideBody(path))
            print.newline();
    },
    afterSatisfy: () => [isNext],
    after: (path, {print}) => {
        print.linebreak();
        markAfter(path);
    },
};

const maybeSpaceAfterKeyword = (path, {write}) => {
    const {declarations} = path.node;
    
    if (!declarations.length)
        return;
    
    const {id} = declarations[0];
    
    if (id.type === 'ArrayPattern' || id.type === 'ObjectPattern')
        return write.space();
    
    write(' ');
};

const {isExportDeclaration: isExportDeclaration$1} = lib_exports;

const isParentTSModuleBlock = (path) => path.parentPath.isTSModuleBlock();
const isParentBlock = (path) => /Program|BlockStatement|Export|LabeledStatement/.test(path.parentPath.type);
const isInsideBlock = (path) => /^(Program|BlockStatement|TSModuleBlock|SwitchCase)$/.test(path.parentPath.type);
const isParentSwitchCase = (path) => path.parentPath.isSwitchCase();
const isFirstInSwitch = (path) => path.parentPath.get('consequent.0') === path;
const isParentIf = (path) => path.parentPath.isIfStatement();

const VariableDeclaration = {
    beforeIf: shouldAddNewlineBefore,
    before(path, {print}) {
        print.breakline();
    },
    print: maybeDeclare((path, {maybe, store, write, traverse, print, indent}, semantics) => {
        const {maxVariablesInOneLine} = semantics;
        
        maybe.indent(isInsideBlock(path));
        
        write(path.node.kind);
        maybeSpaceAfterKeyword(path, {
            write,
        });
        
        const declarations = path.get('declarations');
        const n = declarations.length - 1;
        
        maybe.indent.inc(n);
        
        for (const [index, declaration] of declarations.entries()) {
            const id = declaration.get('id');
            const init = declaration.get('init');
            const isLast = index === n;
            
            traverse(id);
            
            if (exists(init)) {
                write.space();
                write('=');
                maybe.write.space(!isConcatenation(init));
                traverse(init);
            }
            
            if (!isLast) {
                const next = declarations[index + 1];
                
                write(',');
                
                if (!next.node.leadingComments) {
                    maybe.write.breakline(n > maxVariablesInOneLine);
                    maybe.write.space(n <= maxVariablesInOneLine);
                    continue;
                }
                
                parseLeadingComments(next, {print, maybe, indent}, semantics);
            }
        }
        
        maybe.indent.dec(n);
        
        if (isParentBlock(path) || isParentSwitchCase(path) || isParentTSModuleBlock(path) || isParentIf(path))
            write(';');
        
        let wasNewline = false;
        
        if (isParentSwitchCase(path)) {
            write.newline();
            
            if (!isFirstInSwitch(path))
                wasNewline = true;
        }
        
        if (isParentBlock(path) && isNext(path) && (noTrailingComment(path) || isNewlineBetweenSiblings(path))) {
            write.newline();
            wasNewline = true;
        }
        
        store(wasNewline);
    }),
    afterSatisfy: () => [
        isNextIf$1,
        isNextFn,
        noNextParentBlock,
        notLastCoupleLines,
        isNextAssign,
        isNextCoupleLines,
        notLastPrevVarNotNextVar,
        isNewlineBetweenSiblings,
        notLastParentExport,
        isParentTSModuleBlock,
    ],
    after(path, {maybe, store}) {
        const wasNewline = store();
        
        if (isLast$1(path.parentPath) && !path.parentPath.isBlockStatement() || !isParentBlock(path) && !isParentTSModuleBlock(path))
            return false;
        
        maybe.print.linebreak(wasNewline);
        maybe.print.newline(!wasNewline);
        maybe.markAfter(wasNewline, path);
    },
};

function noNextParentBlock(path) {
    if (isNext(path))
        return false;
    
    return path.parentPath.isBlockStatement();
}

function notLastParentExport(path) {
    if (isLast$1(path.parentPath))
        return false;
    
    return path.parentPath.isExportDeclaration();
}

function notLastCoupleLines(path) {
    if (isLast$1(path))
        return false;
    
    return isCoupleLines(path);
}

function notLastPrevVarNotNextVar(path) {
    const prev = path.getPrevSibling();
    const next = path.getNextSibling();
    
    if (!exists(prev.getPrevSibling()))
        return false;
    
    if (path.node.loc?.start.line === prev.node?.loc?.start.line + 2)
        return false;
    
    return !isLast$1(path) && prev.isVariableDeclaration() && !next.isVariableDeclaration();
}

function isNextCoupleLines(path) {
    const next = path.getNextSibling();
    const prev = path.getPrevSibling();
    
    if (!exists(prev.getPrevSibling()) && next.isVariableDeclaration())
        return false;
    
    if (path.node.loc?.start.line === prev.node?.loc?.start?.line + 2)
        return false;
    
    return isCoupleLines(next);
}

const isLast$1 = (path) => path.parentPath?.isProgram() && !isNext(path);

function shouldAddNewlineBefore(path) {
    if (isFirst(path))
        return false;
    
    if (hasPrevNewline(path))
        return false;
    
    if (hasPrevNewline(path.parentPath))
        return false;
    
    const prevPath = path.getPrevSibling();
    
    if (prevPath.isStatement() && !prevPath.isExpressionStatement() && !prevPath.isBlockStatement())
        return false;
    
    return !isExportDeclaration$1(path.parentPath) && isCoupleLines(path);
}

function isFirst(path) {
    return path.node === path.parentPath.node.body?.[0];
}

const isNextIf$1 = (path) => {
    const nextPath = path.getNextSibling();
    return nextPath.isIfStatement();
};

const isNextFn = (path) => {
    const nextPath = path.getNextSibling();
    return nextPath.isFunctionDeclaration();
};

const isNextAssign = (path) => {
    const nextPath = path.getNextSibling();
    
    if (!nextPath.isExpressionStatement())
        return false;
    
    const {parentPath} = path;
    
    if (parentPath.isBlockStatement() && parentPath.node.body.length < 3)
        return false;
    
    return nextPath.get('expression').isAssignmentExpression();
};

const {
    isExpressionStatement: isExpressionStatement$3,
    isFunction: isFunction$3,
    isAssignmentExpression: isAssignmentExpression$1,
} = lib_exports;

const isInsideAssignNextAssignFunction = (path) => {
    const {expression} = path.node;
    
    if (!isAssignmentExpression$1(expression))
        return false;
    
    const next = path.getNextSibling();
    
    if (isFunction$3(next) && next.node.leadingComments)
        return true;
    
    if (!isExpressionStatement$3(next))
        return false;
    
    const {leadingComments} = next.node;
    
    if (!leadingComments)
        return false;
    
    if (!isAssignmentExpression$1(next.node.expression))
        return false;
    
    return isFunction$3(next.node.expression.right);
};

const {
    isBlockStatement: isBlockStatement$2,
    isProgram: isProgram$4,
    isIfStatement,
} = lib_exports;

const printLeadingCommentLine$1 = (path, printer, semantics, {index, isLast, printComment}) => {
    const {print, indent} = printer;
    const prev = path.getPrevSibling();
    const {parentPath} = path;
    
    if (hasTrailingComment(prev))
        return;
    
    if (!index && !prev.node && (isIfStatement(parentPath) || isBlockStatement$2(parentPath)))
        indent();
    
    printComment();
    print.newline();
    
    if (!isLast && !path.parentPath.isIfStatement())
        print.indent();
};

const printLeadingCommentBlock$1 = (path, printer, semantics, {printComment}) => {
    const {indent} = printer;
    const prev = path.getPrevSibling();
    
    if (hasTrailingComment(prev))
        return;
    
    if (isBlockStatement$2(path.parentPath) && !isProgram$4(path.parentPath.parentPath))
        indent();
    
    printComment();
};

const isCommentBlock = (a) => a?.type === 'CommentBlock';

const {
    isCallExpression: isCallExpression$2,
    isExpressionStatement: isExpressionStatement$2,
    isAssignmentExpression,
} = lib_exports;

const not = (fn) => (...a) => !fn(...a);

const isBeforeElse = (path) => {
    if (!path.parentPath.isIfStatement())
        return false;
    
    if (path !== path.parentPath.get('consequent'))
        return false;
    
    return Boolean(path.parentPath.node.alternate);
};

const isInsideReturn = ({parentPath}) => parentPath.isReturnStatement();
const notInsideReturn = not(isInsideReturn);

const satisfyAfter = satisfy([
    isNotLastOrParentLast,
    isParentBlock$1,
    isNext,
    isNextUp,
]);

const isNextIf = (path) => path
    .getNextSibling()
    .isIfStatement();

const shouldBreakline = satisfy([
    isNewlineBetweenSiblings,
    isNotLastBody,
    isNextIf,
]);

const ExpressionStatement = {
    beforeIf(path) {
        if (isInsideReturn(path))
            return false;
        
        return !isInsideLabel(path);
    },
    before(path, {indent}) {
        indent();
    },
    print(path, {print, maybe, store, indent}) {
        const insideReturn = isInsideReturn(path);
        
        print('__expression');
        maybe.print(!insideReturn, ';');
        
        if (!isNext(path))
            return;
        
        if (!insideReturn && shouldBreakline(path)) {
            print.newline();
            
            const condition = isNext(path)
                && noTrailingComment(path)
                || isNextToAssignmentCall(path)
                || isNextStatementWithBlockComment(path);
            
            if (condition)
                indent();
            
            store(true);
        }
    },
    afterIf: (path) => {
        if (satisfyAfter(path))
            return true;
        
        if (hasTrailingComment(path) && isLast$2(path))
            return true;
        
        return isBeforeElse(path);
    },
    after(path, {print, maybe, store, indent}) {
        if (hasTrailingComment(path) && isLast$2(path) && isCoupleLines(path))
            print.breakline();
        
        if (hasTrailingComment(path) && !isCoupleLines(path))
            return;
        
        if (isTopParentLast(path))
            return;
        
        if (notInsideReturn(path)) {
            if (isInsideAssignNextAssignFunction(path))
                indent();
            
            print.newline();
            maybe.markAfter(store(), path);
        }
    },
};
ExpressionStatement.printLeadingCommentLine = printLeadingCommentLine$1;
ExpressionStatement.printLeadingCommentBlock = printLeadingCommentBlock$1;

function isTopParentLast({parentPath}) {
    if (!parentPath.isIfStatement())
        return false;
    
    const nextParent = parentPath.parentPath;
    
    if (!nextParent.isIfStatement())
        return false;
    
    const nextNext = nextParent.parentPath;
    
    if (!nextNext.isIfStatement())
        return false;
    
    return isLast$2(nextNext);
}

function isNotLastBody(path) {
    return path.parentPath.get('body') === path;
}

function isNotLastOrParentLast(path) {
    return !isLast$2(path) && !isParentLast(path);
}

function isNextUp(path) {
    return path.findParent(isNext);
}

function isNextToAssignmentCall(path) {
    if (isAssignmentExpression(path.node.expression))
        return false;
    
    const nextPath = path.getNextSibling();
    
    if (!isExpressionStatement$2(nextPath))
        return false;
    
    const {expression} = nextPath.node;
    
    return isCallExpression$2(expression);
}

function isNextStatementWithBlockComment(path) {
    const {expression} = path.node;
    
    if (!isCallExpression$2(expression))
        return false;
    
    if (!isCallExpression$2(expression.arguments[0]))
        return false;
    
    return hasTrailingBlock(path);
}

function hasTrailingBlock(path) {
    const {trailingComments} = path.node;
    const [first] = trailingComments;
    
    return isCommentBlock(first);
}

const SHEBANG_HASHBANG = '#!';

const InterpreterDirective = (path, {print}) => {
    print(`${SHEBANG_HASHBANG}${path.node.value}\n`);
    print.newline();
};

const writeTemplateLiteral = (quasis, expressions, {write, traverse}) => {
    write('`');
    let i = 0;
    
    for (const element of quasis) {
        write(element.node.value.raw);
        
        const exp = expressions[i++];
        
        if (exp) {
            write('${');
            traverse(exp);
            write('}');
        }
    }
    
    write('`');
};

const TemplateLiteral = (path, printer) => {
    const expressions = path.get('expressions');
    const quasis = path.get('quasis');
    
    writeTemplateLiteral(quasis, expressions, printer);
};

const maybeDecorators = (path) => {
    if (!path.node.decorators)
        return [];
    
    return path.get('decorators');
};

const Identifier = maybeParens(maybeTypeAnnotation((path, printer) => {
    const {
        write,
        maybe,
        traverse,
        print,
    } = printer;
    
    const {node} = path;
    const {name, optional} = node;
    
    for (const decorator of maybeDecorators(path)) {
        traverse(decorator);
        print(' ');
    }
    
    write(name);
    maybe.write(optional, '?');
}));

const {isMemberExpression} = lib_exports;

const Decorator = (path, {print, maybe}) => {
    const {expression} = path.node;
    const isMember = isMemberExpression(expression);
    
    print('@');
    
    maybe.print(isMember, '(');
    print('__expression');
    maybe.print(isMember, ')');
};

Decorator.printLeadingCommentLine = (path, printer, semantics, {printComment}) => {
    const {print} = printer;
    printComment();
    print.breakline();
};

const StringLiteral = (path, {write}, semantics) => {
    const {value, raw = `'${value}'`} = path.node;
    
    if (path.parentPath.isJSXAttribute()) {
        write(`"${value}"`);
        return;
    }
    
    const newValue = raw.slice(1, -1);
    write.quote();
    write(maybeEscape(newValue, semantics));
    write.quote();
};

const maybeEscape = (value, {escapeDoubleQuote, escapeSingleQuote}) => {
    const list = value.split('');
    const slash = '\\';
    
    if (escapeSingleQuote)
        return escape$1(list, {
            slash,
            quote: `'`,
        });
    
    if (escapeDoubleQuote)
        return escape$1(list, {
            slash,
            quote: `"`,
        });
    
    return value;
};

const escape$1 = (list, {slash, quote}) => {
    const res = [];
    
    for (const [index, char] of list.entries()) {
        const prev = list[index - 1];
        
        if (char === quote && prev !== slash) {
            res.push(`${slash}${char}`);
            continue;
        }
        
        res.push(char);
    }
    
    return res.join('');
};

const DirectiveLiteral = (path, {write}) => {
    write.indent();
    write(path.node.raw || `'${path.node.value}'`);
    write(';');
    write.newline();
};

const VoidPattern = (path, {write}) => {
    write('void');
};

const BigIntLiteral = (path, {write}) => {
    write(path.node.raw);
};

const NumericLiteral = (path, {write}) => {
    const {
        raw,
        extra,
        value,
    } = path.node;
    
    write(raw || extra?.raw || value);
};

const Directive = (path, {print, maybe}) => {
    maybe.print.breakline(path.node.leadingComments?.length);
    print('__value');
};

const BooleanLiteral = (path, {write}) => {
    write(path.node.value);
};

const RegExpLiteral = (path, {print}) => {
    const {raw, pattern} = path.node;
    print(raw || `/${pattern}/`);
};

const NullLiteral = (path, {write}) => {
    write('null');
};

const MetaProperty = (path, {write}) => {
    write('import.meta');
};

const Super = (path, {write}) => {
    write('super');
};

const TSTypeLiteral = (path, {indent, traverse, write}) => {
    const members = path.get('members');
    write('{');
    
    const is = isNewline(path);
    
    if (is) {
        write.newline();
        indent.inc();
    }
    
    for (const member of members) {
        indent();
        traverse(member);
    }
    
    if (is) {
        indent.dec();
        write.indent();
    }
    
    write('}');
};

function isNewline(path) {
    const {parentPath} = path;
    
    const {length} = path.get('members');
    
    if (!length)
        return false;
    
    if (length > 1)
        return true;
    
    return !parentPath.isTSTypeParameterInstantiation();
}

const isNextType = (a) => a
    .getNextSibling()
    .isTSTypeAliasDeclaration();

const isNextExport = (a) => a
    .getNextSibling()
    .isExportDeclaration();

const TSTypeAliasDeclaration = {
    beforeIf: (path) => !path.parentPath.isExportDeclaration(),
    before: (path, {indent}) => {
        indent();
    },
    print: maybeDeclare((path, {print, maybe, store}) => {
        const typeAnnotation = path.get('typeAnnotation');
        const isConditional = typeAnnotation.isTSConditionalType();
        
        print('type ');
        print('__id');
        print('__typeParameters');
        
        print.space();
        print('=');
        maybe.print.space(!isConditional);
        
        print('__typeAnnotation');
        print(';');
        
        const is = store(isLast$2(path) || isLast$2(path.parentPath));
        maybe.print.newline(!is);
    }),
    afterIf(path, {store}) {
        const last = store();
        
        if (last)
            return false;
        
        if (!isNext(path) && !isNextParent(path))
            return false;
        
        return !isNextType(path);
    },
    after(path, {print, maybe}) {
        maybe.indent(isNextExport(path));
        print.newline();
        markAfter(path);
    },
};

const {isTSConditionalType} = lib_exports;

const TSMappedType = (path, {print, indent, maybe}) => {
    const {
        readonly,
        optional,
        nameType,
        typeAnnotation,
    } = path.node;
    
    print('{');
    print.newline();
    indent.inc();
    indent();
    
    if (readonly) {
        maybe.print(readonly === '-', '-');
        print('readonly ');
    }
    
    print('[');
    print('__key');
    print(' ');
    print('in');
    print(' ');
    print('__constraint');
    
    if (nameType) {
        print(' as');
        maybe.space(!isTSConditionalType(nameType));
        print('__nameType');
    }
    
    print(']');
    
    if (optional) {
        maybe.print(optional === '+', '+');
        maybe.print(optional === '-', '-');
        print('?');
    }
    
    if (typeAnnotation) {
        print(':');
        print.space();
        print('__typeAnnotation');
    }
    
    print(';');
    indent.dec();
    print.breakline();
    print('}');
};

const TSConditionalType = (path, {print, indent}) => {
    indent.inc();
    print.breakline();
    print('__checkType');
    print(' extends ');
    print('__extendsType');
    
    indent.inc();
    print.breakline();
    
    print('? ');
    print('__trueType');
    
    print.breakline();
    
    print(': ');
    print('__falseType');
    
    indent.dec();
    indent.dec();
};

const TSTypeParameter = (path, {write, traverse}) => {
    const constraint = path.get('constraint');
    
    if (path.node.in)
        write('in ');
    else if (path.node.out)
        write('out ');
    else if (path.node.const)
        write('const ');
    
    write(path.node.name.name);
    
    if (exists(constraint)) {
        write(' extends ');
        traverse(constraint);
    }
    
    const defaultPath = path.get('default');
    
    if (exists(defaultPath)) {
        write.space();
        write('=');
        write.space();
        traverse(defaultPath);
    }
};

const isInsideDefaultExport = (path) => {
    return path.parentPath.isExportDefaultDeclaration();
};

const isInsideNamedExport = (path) => {
    return path.parentPath.isExportNamedDeclaration();
};

const TSDeclareFunction = {
    beforeIf: (path) => !isInsideNamedExport(path),
    before: (path, {indent}) => {
        indent();
    },
    print: maybeDeclare((path, printer, semantics) => {
        const {print} = printer;
        
        print('function ');
        print('__id');
        
        printParams(path, printer, semantics);
        
        print(':');
        print.space();
        print('__returnType');
    }),
    afterIf: (path) => !isInsideDefaultExport(path),
    after: (path, {print}) => {
        print(';');
        
        if (isNext(path) || isNext(path.parentPath) || isInsideNamedExport(path))
            print.newline();
    },
};

const TSDeclareMethod = (path, printer, semantics) => {
    const {print} = printer;
    const {
        accessibility,
        abstract,
        returnType,
    } = path.node;
    
    if (accessibility) {
        print(accessibility);
        print(' ');
    }
    
    if (abstract) {
        print('abstract');
        print(' ');
    }
    
    print('__key');
    
    printParams(path, printer, semantics);
    
    if (returnType) {
        print(':');
        print.space();
        print('__returnType');
    }
    
    print(';');
    print.newline();
};

const TSModuleDeclaration = {
    print: maybeDeclare((path, {print}) => {
        const {kind} = path.node;
        const id = path.get('id');
        
        if (id.isStringLiteral())
            print('module ');
        else if (kind === 'namespace')
            print('namespace ');
        
        print('__id');
        print.space();
        print('__body');
    }),
    afterSatisfy: () => [isNext],
    after(path, {print}) {
        print.newline();
        print.newline();
    },
};

const TSModuleBlock = (path, {print, traverse, indent}) => {
    print('{');
    print.breakline();
    indent.inc();
    
    for (const child of path.get('body')) {
        traverse(child);
    }
    
    indent.dec();
    print('}');
};

const {
    isTSTypeAliasDeclaration,
    isExportNamedDeclaration,
    isTSModuleBlock: isTSModuleBlock$1,
} = lib_exports;

const isInsideNamespace = (path) => isTSModuleBlock$1(path.parentPath.parentPath);

const TSInterfaceDeclaration = {
    print: maybeDeclare((path, {print, maybe}) => {
        const {node} = path;
        const {typeParameters} = node;
        
        maybe.indent(!isExportNamedDeclaration(path.parentPath));
        print('interface ');
        print('__id');
        
        print('__typeParameters');
        
        if (node.extends) {
            if (!typeParameters || typeParameters.length < 2)
                print(' ');
            
            print('extends ');
            
            const extendsPaths = path.get('extends');
            const n = extendsPaths.length - 1;
            
            for (const [i, current] of extendsPaths.entries()) {
                print(current);
                maybe.print(i < n, ', ');
            }
        }
        
        print('__body');
    }),
    afterSatisfy: () => [isNext, isNextParent],
    after(path, {print}) {
        print.linebreak();
        const exportNamed = isExportNamedDeclaration(path.parentPath);
        
        if (exportNamed && isInsideNamespace(path))
            markAfter(path);
        
        if (!exportNamed && !isTSTypeAliasDeclaration(path))
            print.newline();
    },
};

const {
    isVariableDeclarator,
    isObjectExpression: isObjectExpression$1,
} = lib_exports;

const TSAsExpression = maybeParens((path, {print, maybe}) => {
    const is = isParens(path);
    
    maybe.print(is, '(');
    print('__expression');
    maybe.print(is, ')');
    
    print(' as ');
    print('__typeAnnotation');
});

function isParens(path) {
    const {expression} = path.node;
    
    if (isVariableDeclarator(path.parentPath))
        return false;
    
    return isObjectExpression$1(expression);
}

const TSInterfaceBody = (path, printer, semantics) => {
    const body = path.get('body');
    const {
        traverse,
        write,
        indent,
        maybe,
    } = printer;
    
    write.space();
    write('{');
    
    maybe.write.newline(hasNoLeadingComments(path));
    indent.inc();
    
    parseComments(path, printer, semantics);
    
    for (const [index, item] of body.entries()) {
        if (index || !item.node.leadingComments)
            indent();
        
        traverse(item);
    }
    
    indent.dec();
    indent();
    
    write('}');
    maybe.write.newline(findTSModuleBlock(path));
};

function hasNoLeadingComments(path) {
    const {body} = path.node;
    
    if (!body.length)
        return false;
    
    const [first] = body;
    const {leadingComments} = first;
    
    return !leadingComments;
}

function findTSModuleBlock(path) {
    if (path.parentPath.parentPath.isTSModuleBlock())
        return true;
    
    return path.parentPath.parentPath.parentPath?.isTSModuleBlock();
}

const TSIntersectionType = (path, {traverse, write}) => {
    const types = path.get('types');
    const n = types.length - 1;
    
    for (const [i, type] of types.entries()) {
        const isLast = i === n;
        
        traverse(type);
        
        if (!isLast) {
            write.space();
            write('&');
            write.space();
        }
    }
};

const printLeadingCommentLine = (path, printer, semantics, {printComment}) => {
    const {print} = printer;
    print.breakline();
    printComment();
    print.breakline();
};

const printLeadingCommentBlock = (path, printer, semantics, {printComment}) => {
    const {print, maybe} = printer;
    
    maybe.print.breakline(!isPrev(path));
    printComment();
    print.indent();
};

const printTrailingCommentBlock = () => {};

const TSPropertySignature = (path, printer) => {
    const {maybe, write} = printer;
    const {optional, readonly} = path.node;
    
    maybe.print(readonly, 'readonly ');
    printKey(path, printer);
    maybe.print(optional, '?');
    
    maybePrintTypeAnnotation(path, printer);
    
    if (!isTSTypeLiteralWithOneMember(path)) {
        write(';');
        write.newline();
    }
    
    if (isNext(path) && hasTrailingComment(path))
        write.newline();
};
TSPropertySignature.printLeadingCommentLine = printLeadingCommentLine;
TSPropertySignature.printLeadingCommentBlock = printLeadingCommentBlock;
TSPropertySignature.printTrailingCommentBlock = printTrailingCommentBlock;

function isTSTypeLiteralWithOneMember({parentPath}) {
    if (!parentPath.parentPath.isTSTypeParameterInstantiation())
        return false;
    
    return parentPath.node.members.length === 1;
}

const hasReturnType = (path) => path.node.returnType;

const printReturnType = (path, {traverse}) => {
    traverse(path.get('returnType'));
};

const TSFunctionType = maybeParens((path, printer, semantics) => {
    const {print} = printer;
    
    printParams(path, printer, semantics);
    print.space();
    print('=>');
    print.space();
    printReturnType(path, printer);
});

const TSEnumDeclaration = {
    beforeIf(path) {
        return path.node.const;
    },
    before(path, {print}) {
        print('const ');
    },
    print(path, {print, traverse, indent}) {
        print('enum ');
        print('__id');
        print(' ');
        print('{');
        
        indent.inc();
        print.newline();
        
        for (const member of path.get('body.members')) {
            traverse(member);
            print(',');
            print.newline();
        }
        
        indent.dec();
        indent();
        print('}');
        
        if (isLast$2(path))
            return;
        
        print.newline();
        markAfter(path);
    },
    afterSatisfy: () => [isNext, isNextParent],
    after(path, {print}) {
        print.linebreak();
    },
};

const TSEnumMember = (path, {print, indent}) => {
    const {initializer} = path.node;
    indent();
    print('__id');
    
    if (initializer) {
        print.space();
        print('=');
        print.space();
        print('__initializer');
    }
};

const TSTupleType = (path, {write, traverse, indent, maybe}) => {
    const elementTypes = path.get('elementTypes');
    
    write('[');
    indent.inc();
    
    const isSame = isSameType(elementTypes);
    maybe.write.newline(isSame && elementTypes.length);
    const n = elementTypes.length - 1;
    
    for (const [i, elementType] of elementTypes.entries()) {
        maybe.indent(isSame);
        traverse(elementType);
        maybe.write(i < n || isSame, ',');
        maybe.write.newline(isSame);
        maybe.write.space(i < n && !isSame);
    }
    
    indent.dec();
    maybe.indent(isSame && elementTypes.length);
    write(']');
};

function isSameType(array) {
    let type;
    
    for (const current of array) {
        if (type && current.type !== type)
            return false;
        
        ({type} = current);
    }
    
    return true;
}

const TSNamedTupleMember = (path, {print}) => {
    print('__label');
    print(':');
    print.space();
    print('__elementType');
};

const TSConstructorType = (path, printer, semantics) => {
    const {print} = printer;
    
    print('new');
    print(' ');
    
    printParams(path, printer, semantics);
    print.space();
    print('=>');
    print.space();
    printReturnType(path, printer);
};

const TSCallSignatureDeclaration = (path, printer, semantics) => {
    const {print} = printer;
    printParams(path, printer, semantics);
    print(':');
    print.space();
    printReturnType(path, printer);
    print(';');
    print.newline();
};

const TSConstructSignatureDeclaration = (path, printer, semantics) => {
    const {write} = printer;
    
    write('new');
    printParams(path, printer, semantics);
    
    if (hasReturnType(path)) {
        write(':');
        write.space();
        printReturnType(path, printer);
    }
    
    write(';');
    write.newline();
};

const TSMethodSignature = (path, printer, semantics) => {
    const {write} = printer;
    
    printKind(path, printer);
    printKey(path, printer);
    printParams(path, printer, semantics);
    
    if (hasReturnType(path)) {
        write(':');
        write.space();
        printReturnType(path, printer);
    }
    
    write(';');
    write.newline();
};

const insideTypeDeclaration = ({parentPath}) => parentPath.isTSTypeAliasDeclaration();

const TSUnionType = maybeParens({
    condition: (path) => {
        return path.parentPath.isTSArrayType();
    },
    print: (path, printer, {maxTypesInOneLine}) => {
        const types = path.get('types');
        const {length} = types;
        
        if (!insideTypeDeclaration(path) || length <= maxTypesInOneLine)
            printInOneLine(types, printer);
        else
            printInCoupleLines(types, printer);
    },
});

function printInOneLine(types, {traverse, write}) {
    const n = types.length - 1;
    
    for (const [i, type] of types.entries()) {
        traverse(type);
        
        if (i < n) {
            write.space();
            write('|');
            write.space();
        }
    }
}

function printInCoupleLines(types, {traverse, write, indent}) {
    indent.inc();
    
    for (const type of types) {
        write.breakline();
        write('|');
        write.space();
        traverse(type);
    }
    
    indent.dec();
}

const TSImportType = (path, printer) => {
    createImportExpression(path, printer);
};

const TSExportAssignment = {
    print: (path, {print}) => {
        print('export = ');
        print('__expression');
        print(';');
    },
    afterSatisfy: () => [isNext],
    after: (path, {print}) => {
        print.newline();
    },
};

const TSTypeReference = (path, {print}) => {
    print('__typeName');
    print('__typeArguments');
};

const TSInferType = maybeParens((path, {print}) => {
    print('infer ');
    print('__typeParameter');
});

const TSParameterProperty = (path, {print, maybe, indent}) => {
    const {
        decorators,
        readonly,
        accessibility,
    } = path.node;
    
    const decoratorsLength = decorators?.length > 1;
    
    maybe.print.breakline(decoratorsLength);
    
    if (decorators) {
        for (const decorator of path.get('decorators')) {
            maybe.indent(decoratorsLength);
            print(decorator);
        }
        
        maybe.print.breakline(decoratorsLength);
        
        if (!hasLeadingComment(path))
            indent();
        else
            print(' ');
    }
    
    if (accessibility) {
        print(accessibility);
        print.space();
    }
    
    if (readonly) {
        print('readonly');
        print.space();
    }
    
    print('__parameter');
    
    if (hasLeadingComment(path) && !path.node.decorators)
        print.breakline();
};

TSParameterProperty.printLeadingCommentLine = (path, printer, semantics, {printComment}) => {
    const {indent, print} = printer;
    
    if (path.node.decorators) {
        printComment();
        print.breakline();
        
        return;
    }
    
    if (path.parentPath.isClassMethod()) {
        indent.inc();
        print.breakline();
        
        printComment();
        print.breakline();
        indent.dec();
        
        return;
    }
};

const {isTSUnionType} = lib_exports;
const noop$4 = () => {};

const TSTypeParameterDeclaration = (path, printer, semantics) => {
    const {print, indent} = printer;
    const isNewline = hasComplexParameters(path);
    const printSpace = createPrintSpace({
        isNewline,
        printer,
    });
    
    const printAfterOpen = !isNewline ? noop$4 : () => {
        indent.inc();
        print.breakline();
    };
    
    const printAfterClose = !isNewline ? noop$4 : () => {
        print.breakline();
    };
    
    const printBeforeClose = !isNewline ? noop$4 : () => {
        indent.dec();
        print.breakline();
    };
    
    printParams(path, printer, semantics, {
        printSpace,
        braceOpen: '<',
        braceClose: '>',
        printAfterOpen,
        printBeforeClose,
        printAfterClose,
    });
};

function hasComplexParameters({node}) {
    const {params} = node;
    
    for (const {constraint} of params) {
        if (isTSUnionType(constraint))
            return true;
    }
    
    return false;
}

const TSTypeQuery = maybeParens((path, {print}) => {
    print('typeof ');
    print('__exprName');
});

const TSParenthesizedType = (path, {print}) => {
    print('(');
    print('__typeAnnotation');
    print(')');
};

const TSTemplateLiteralType = (path, printer) => {
    const quasis = path.get('quasis');
    const types = path.get('types');
    
    writeTemplateLiteral(quasis, types, printer);
};

const TSOptionalType = (path, {print}) => {
    print('__typeAnnotation');
    print('?');
};

const TSBigIntKeyword = (path, {write}) => {
    write('bigint');
};
const TSNullKeyword = (path, {write}) => {
    write('null');
};
const TSSymbolKeyword = (path, {write}) => {
    write('symbol');
};
const TSNeverKeyword = (path, {write}) => {
    write('never');
};
const TSUnknownKeyword = (path, {write}) => {
    write('unknown');
};
const TSObjectKeyword = (path, {write}) => {
    write('object');
};
const TSLiteralType = (path, {print}) => {
    print('__literal');
};
const TSRestType = (path, {print}) => {
    print('...');
    print('__typeAnnotation');
};
const TSTypeParameterInstantiation = (path, printer, semantics) => {
    printParams(path, printer, semantics, {
        braceOpen: '<',
        braceClose: '>',
    });
};
const TSArrayType = (path, {print}) => {
    print('__elementType');
    print('[]');
};
const TSTypeOperator = (path, {write, print}) => {
    const {operator} = path.node;
    write(`${operator} `);
    print('__typeAnnotation');
};
const TSTypeAssertion = (path, {print}) => {
    print('<');
    print('__typeAnnotation');
    print('>');
    print('__expression');
};
const TSUndefinedKeyword = (path, {write}) => {
    write('undefined');
};
const TSBooleanKeyword = (path, {write}) => {
    write('boolean');
};
const TSSatisfiesExpression = (path, {print}) => {
    print('__expression');
    print(' satisfies ');
    print('__typeAnnotation');
};
const TSNumberKeyword = (path, {write}) => {
    write('number');
};
const TSIndexedAccessType = (path, {print}) => {
    print('__objectType');
    print('[');
    print('__indexType');
    print(']');
};
const TSStringKeyword = (path, {write}) => {
    write('string');
};
const TSInstantiationExpression = (path, {print}) => {
    print('__expression');
    print('__typeArguments');
};
const TSAnyKeyword = (path, {write}) => {
    write('any');
};
const TSVoidKeyword = (path, {write}) => {
    write('void');
};
const TSQualifiedName = (path, {print}) => {
    print('__left');
    print('.');
    print('__right');
};
const TSTypeAnnotation = (path, {print}) => {
    print('__typeAnnotation');
};

const TSIndexSignature = (path, printer) => {
    const {print} = printer;
    print('[');
    print('__parameters.0');
    print(']');
    maybePrintTypeAnnotation(path, printer);
    print(';');
    print.newline();
};

const TSClassImplements = (path, {print}) => {
    print('__expression');
    print('__typeArguments');
};

const TSInterfaceHeritage = (path, {print}) => {
    print('__expression');
    print('__typeArguments');
};

const TSTypePredicate = (path, {print}) => {
    print('__parameterName');
    print(' is ');
    print('__typeAnnotation');
};

const TSNonNullExpression = (path, {print}) => {
    print('__expression');
    print('!');
};

const TSImportEqualsDeclaration = (path, {print, maybe}) => {
    maybe.print(path.node.isExport, 'export ');
    print('import ');
    print('__id');
    print.space();
    print('=');
    print.space();
    print('__moduleReference');
    print(';');
    maybe.print.newline(isNext(path));
};
const TSExternalModuleReference = (path, {print}) => {
    print('require(');
    print('__expression');
    print(')');
};

const TSThisType = (path, {print}) => {
    print('this');
};

const {
    isJSXElement: isJSXElement$2,
    isJSXExpressionContainer,
    isFunction: isFunction$2,
    isJSXSpreadAttribute,
} = lib_exports;

const isInsideArrow = ({parentPath}) => parentPath.isArrowFunctionExpression();

const JSXElement = {
    condition: condition$1,
    before(path, {write, indent, maybe}) {
        const {leadingComments} = path.node;
        const leadingCommentsCount = leadingComments?.length;
        
        maybe.write.space(!leadingCommentsCount && isInsideArrow(path));
        indent.inc();
        
        if (!leadingCommentsCount) {
            write('(');
            write.newline();
        }
    },
    print(path, {print, traverse, maybe}) {
        const needIndent = isNeedIndent(path);
        maybe.indent.inc(needIndent);
        
        print('__openingElement');
        path.get('children').map(traverse);
        
        print('__closingElement');
        
        maybe.indent.dec(needIndent);
    },
    after(path, {write, indent, maybe}) {
        const {leadingComments} = path.node;
        const isJSX = isJSXElement$2(path.parentPath.parentPath?.parentPath?.parentPath);
        
        if (isJSX) {
            write.breakline();
            indent.dec();
        } else {
            indent.dec();
            write.breakline();
        }
        
        maybe.write(!leadingComments?.length, ')');
    },
};

function condition$1(path) {
    if (path.parentPath.isReturnStatement())
        return true;
    
    if (path.parentPath.isParenthesizedExpression())
        return true;
    
    if (path.node.extra?.parenthesized)
        return true;
    
    if (path.parentPath.isArrowFunctionExpression())
        return true;
    
    return path.parentPath.isVariableDeclarator();
}

function hasComplexAttribute(path) {
    const {attributes} = path.node.openingElement;
    
    for (const attribute of attributes) {
        const {value} = attribute;
        
        if (isJSXSpreadAttribute(attribute))
            return true;
        
        if (!isJSXExpressionContainer(value))
            continue;
        
        const {expression} = value;
        
        if (isFunction$2(expression))
            return true;
    }
    
    return false;
}

function isNeedIndent(path) {
    if (hasComplexAttribute(path))
        return false;
    
    const insideFn = path.parentPath.isArrowFunctionExpression();
    const insideJSX = path.parentPath.isJSXElement();
    const insideCall = path.parentPath.parentPath.isCallExpression();
    
    return insideJSX || insideFn && insideCall;
}

const JSXAttribute = {
    condition(path) {
        return isCoupleLines(path.parentPath);
    },
    before(path, {print, indent}) {
        indent.inc();
        print.breakline();
    },
    print(path, {print, maybe}) {
        const {value} = path.node;
        
        print('__name');
        maybe.print(value, '=');
        print('__value');
    },
    after(path, {indent}) {
        indent.dec();
    },
};

const isNotJSX = ({parentPath}) => {
    const grandPath = parentPath.parentPath;
    
    if (grandPath.isObjectProperty())
        return false;
    
    if (grandPath.isCallExpression())
        return false;
    
    if (grandPath.isJSXElement())
        return false;
    
    if (grandPath.isJSXExpressionContainer())
        return false;
    
    if (grandPath.isJSXFragment())
        return false;
    
    return !grandPath.isLogicalExpression();
};

const JSXOpeningElement = {
    print(path, {print, maybe}) {
        maybe.indent(isNotJSX(path));
        print('<');
        print('__name');
        
        const coupleLines = isCoupleLines(path);
        const noCoupleLines = !coupleLines;
        const shouldIndent = coupleLines && path.parentPath.parentPath.isJSXElement();
        
        maybe.indent.inc(shouldIndent);
        
        for (const attr of path.get('attributes')) {
            maybe.print.space(noCoupleLines);
            print(attr);
        }
        
        if (isCoupleLines(path))
            print.breakline();
        
        if (path.node.selfClosing)
            print('/');
        
        print('>');
        maybe.indent.dec(shouldIndent);
    },
};

const JSXFragment = {
    condition,
    before(path, {write, indent}) {
        write('(');
        indent.inc();
        write.breakline();
    },
    print(path, {print, traverse}) {
        print('__openingFragment');
        path.get('children').map(traverse);
        print('__closingFragment');
    },
    after(path, {write, indent}) {
        indent.dec();
        write.breakline();
        write(')');
    },
};

const JSXOpeningFragment = (path, {write}) => {
    write('<>');
};

const JSXClosingFragment = (path, {write}) => {
    write('</>');
};

function condition(path) {
    if (path.parentPath.isReturnStatement())
        return true;
    
    return path.parentPath.isVariableDeclarator();
}

const JSXText = (path, {write, indent}) => {
    const {node} = path;
    const {value, extra} = node;
    const isSpacesOnly = /^\s+$/.test(value);
    const hasNext = isNext(path);
    
    if (extra?.raw.includes('&'))
        return write(extra.raw);
    
    if (isSpacesOnly && hasNext) {
        indent.inc();
        write.breakline();
        indent.dec();
        
        return;
    }
    
    if (isSpacesOnly) {
        write.breakline();
        return;
    }
    
    write(value);
};

const JSXEmptyExpression = (path, operations, semantics) => {
    parseComments(path, operations, semantics);
};
const JSXExpressionContainer = (path, {print}) => {
    print('{');
    print('__expression');
    print('}');
};
const JSXIdentifier = (path, {write}) => {
    write(path.node.name);
};
const JSXMemberExpression = (path, {print}) => {
    print('__object');
    print('.');
    print('__property');
};
const JSXSpreadAttribute = (path, {print, maybe}) => {
    const isNewline = isCoupleLines(path.parentPath);
    maybe.indent.inc(isNewline);
    maybe.print.breakline(isNewline);
    print('{');
    print('...');
    print('__argument');
    print('}');
    maybe.indent.dec(isNewline);
};
const JSXClosingElement = (path, {print}) => {
    print('</');
    print('__name');
    print('>');
};

var baseVisitors = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ArrayExpression: ArrayExpression,
	ArrayPattern: ArrayPattern,
	ArrowFunctionExpression: ArrowFunctionExpression,
	AssignmentExpression: AssignmentExpression,
	AssignmentPattern: AssignmentPattern,
	AwaitExpression: AwaitExpression,
	BigIntLiteral: BigIntLiteral,
	BinaryExpression: BinaryExpression,
	BlockStatement: BlockStatement,
	BooleanLiteral: BooleanLiteral,
	BreakStatement: BreakStatement,
	CallExpression: CallExpression,
	CatchClause: CatchClause,
	ClassAccessorProperty: ClassAccessorProperty,
	ClassDeclaration: ClassDeclaration,
	ClassExpression: ClassExpression,
	ClassMethod: ClassMethod,
	ClassPrivateMethod: ClassPrivateMethod,
	ClassPrivateProperty: ClassPrivateProperty,
	ClassProperty: ClassProperty,
	ConditionalExpression: ConditionalExpression,
	ContinueStatement: ContinueStatement,
	DebuggerStatement: DebuggerStatement,
	Decorator: Decorator,
	Directive: Directive,
	DirectiveLiteral: DirectiveLiteral,
	DoWhileStatement: DoWhileStatement,
	EmptyStatement: EmptyStatement,
	ExportAllDeclaration: ExportAllDeclaration,
	ExportDefaultDeclaration: ExportDefaultDeclaration,
	ExportDefaultSpecifier: ExportDefaultSpecifier,
	ExportNamedDeclaration: ExportNamedDeclaration,
	ExportNamespaceSpecifier: ExportNamespaceSpecifier,
	ExportSpecifier: ExportSpecifier,
	ExpressionStatement: ExpressionStatement,
	ForInStatement: ForInStatement,
	ForOfStatement: ForOfStatement,
	ForStatement: ForStatement,
	FunctionDeclaration: FunctionDeclaration,
	FunctionExpression: FunctionExpression,
	Identifier: Identifier,
	IfStatement: IfStatement,
	ImportAttribute: ImportAttribute,
	ImportDeclaration: ImportDeclaration,
	ImportExpression: ImportExpression,
	InterpreterDirective: InterpreterDirective,
	JSXAttribute: JSXAttribute,
	JSXClosingElement: JSXClosingElement,
	JSXClosingFragment: JSXClosingFragment,
	JSXElement: JSXElement,
	JSXEmptyExpression: JSXEmptyExpression,
	JSXExpressionContainer: JSXExpressionContainer,
	JSXFragment: JSXFragment,
	JSXIdentifier: JSXIdentifier,
	JSXMemberExpression: JSXMemberExpression,
	JSXOpeningElement: JSXOpeningElement,
	JSXOpeningFragment: JSXOpeningFragment,
	JSXSpreadAttribute: JSXSpreadAttribute,
	JSXText: JSXText,
	LabeledStatement: LabeledStatement,
	LogicalExpression: LogicalExpression,
	MemberExpression: MemberExpression,
	MetaProperty: MetaProperty,
	NewExpression: NewExpression,
	NullLiteral: NullLiteral,
	NumericLiteral: NumericLiteral,
	ObjectExpression: ObjectExpression,
	ObjectMethod: ObjectMethod,
	ObjectPattern: ObjectPattern,
	ObjectProperty: ObjectProperty,
	OptionalCallExpression: OptionalCallExpression,
	OptionalMemberExpression: OptionalMemberExpression,
	ParenthesizedExpression: ParenthesizedExpression,
	PrivateName: PrivateName,
	Program: Program,
	RegExpLiteral: RegExpLiteral,
	RestElement: RestElement,
	ReturnStatement: ReturnStatement,
	SequenceExpression: SequenceExpression,
	SpreadElement: SpreadElement,
	StaticBlock: StaticBlock,
	StringLiteral: StringLiteral,
	Super: Super,
	SwitchStatement: SwitchStatement,
	TSAnyKeyword: TSAnyKeyword,
	TSArrayType: TSArrayType,
	TSAsExpression: TSAsExpression,
	TSBigIntKeyword: TSBigIntKeyword,
	TSBooleanKeyword: TSBooleanKeyword,
	TSCallSignatureDeclaration: TSCallSignatureDeclaration,
	TSClassImplements: TSClassImplements,
	TSConditionalType: TSConditionalType,
	TSConstructSignatureDeclaration: TSConstructSignatureDeclaration,
	TSConstructorType: TSConstructorType,
	TSDeclareFunction: TSDeclareFunction,
	TSDeclareMethod: TSDeclareMethod,
	TSEnumDeclaration: TSEnumDeclaration,
	TSEnumMember: TSEnumMember,
	TSExportAssignment: TSExportAssignment,
	TSExternalModuleReference: TSExternalModuleReference,
	TSFunctionType: TSFunctionType,
	TSImportEqualsDeclaration: TSImportEqualsDeclaration,
	TSImportType: TSImportType,
	TSIndexSignature: TSIndexSignature,
	TSIndexedAccessType: TSIndexedAccessType,
	TSInferType: TSInferType,
	TSInstantiationExpression: TSInstantiationExpression,
	TSInterfaceBody: TSInterfaceBody,
	TSInterfaceDeclaration: TSInterfaceDeclaration,
	TSInterfaceHeritage: TSInterfaceHeritage,
	TSIntersectionType: TSIntersectionType,
	TSLiteralType: TSLiteralType,
	TSMappedType: TSMappedType,
	TSMethodSignature: TSMethodSignature,
	TSModuleBlock: TSModuleBlock,
	TSModuleDeclaration: TSModuleDeclaration,
	TSNamedTupleMember: TSNamedTupleMember,
	TSNeverKeyword: TSNeverKeyword,
	TSNonNullExpression: TSNonNullExpression,
	TSNullKeyword: TSNullKeyword,
	TSNumberKeyword: TSNumberKeyword,
	TSObjectKeyword: TSObjectKeyword,
	TSOptionalType: TSOptionalType,
	TSParameterProperty: TSParameterProperty,
	TSParenthesizedType: TSParenthesizedType,
	TSPropertySignature: TSPropertySignature,
	TSQualifiedName: TSQualifiedName,
	TSRestType: TSRestType,
	TSSatisfiesExpression: TSSatisfiesExpression,
	TSStringKeyword: TSStringKeyword,
	TSSymbolKeyword: TSSymbolKeyword,
	TSTemplateLiteralType: TSTemplateLiteralType,
	TSThisType: TSThisType,
	TSTupleType: TSTupleType,
	TSTypeAliasDeclaration: TSTypeAliasDeclaration,
	TSTypeAnnotation: TSTypeAnnotation,
	TSTypeAssertion: TSTypeAssertion,
	TSTypeLiteral: TSTypeLiteral,
	TSTypeOperator: TSTypeOperator,
	TSTypeParameter: TSTypeParameter,
	TSTypeParameterDeclaration: TSTypeParameterDeclaration,
	TSTypeParameterInstantiation: TSTypeParameterInstantiation,
	TSTypePredicate: TSTypePredicate,
	TSTypeQuery: TSTypeQuery,
	TSTypeReference: TSTypeReference,
	TSUndefinedKeyword: TSUndefinedKeyword,
	TSUnionType: TSUnionType,
	TSUnknownKeyword: TSUnknownKeyword,
	TSVoidKeyword: TSVoidKeyword,
	TaggedTemplateExpression: TaggedTemplateExpression,
	TemplateLiteral: TemplateLiteral,
	ThisExpression: ThisExpression,
	ThrowStatement: ThrowStatement,
	TryStatement: TryStatement,
	UnaryExpression: UnaryExpression,
	UpdateExpression: UpdateExpression,
	VariableDeclaration: VariableDeclaration,
	VoidPattern: VoidPattern,
	WhileStatement: WhileStatement,
	WithStatement: WithStatement,
	YieldExpression: YieldExpression
});

const isString$c = (a) => typeof a === 'string';
const constant = (a) => () => a;
const {keys: keys$3} = Object;

var rendy = (template, values, modifiers) => {
    check$e(template, values);
    
    let result = template;
    
    const names = !modifiers ? keys$3(values) : template.match(/{{(.*?)}}/g);
    
    for (const key of names) {
        const [parsedKey, value] = parseValue$1(key, values, modifiers);
        const str = constant(value);
        
        while (result.includes(parsedKey))
            result = result.replace(parsedKey, str);
    }
    
    if (result.includes('{{'))
        result = result.replace(/{{.*?}}/g, '');
    
    return result;
};

function check$e(template, values) {
    if (!isString$c(template))
        throw Error('template should be a string!');
    
    if (typeof values !== 'object')
        throw Error('values should be an object!');
}

function parseValue$1(key, values, modifiers) {
    if (!modifiers)
        return [
            `{{ ${key} }}`,
            values[key],
        ];
    
    const preparedKey = key
        .replaceAll('{{', '')
        .replaceAll('}}', '')
        .replaceAll(' ', '');
    
    const value = values[preparedKey] || '';
    
    if (!preparedKey.includes('|'))
        return [key, value];
    
    const [name, modifierName] = preparedKey.split('|');
    const fn = modifiers[modifierName];
    const currentValue = values[name];
    
    if (!fn)
        return [key, currentValue];
    
    return [key, fn(currentValue)];
}

var rendy$1 = rendy.default;

var maybeSatisfy = (plugin) => {
    if (!plugin.afterSatisfy && !plugin.beforeSatisfy && !plugin.satisfy)
        return plugin;
    
    const {
        satisfy,
        afterSatisfy = satisfy,
        beforeSatisfy = satisfy,
    } = plugin;
    
    return {
        afterIf: createIf(afterSatisfy),
        beforeIf: createIf(beforeSatisfy),
        ...plugin,
    };
};

const createIf = (getConditions) => {
    const conditions = getConditions?.() || [];
    return satisfy(conditions);
};

const {
    isProgram: isProgram$3,
    isFile: isFile$1,
    isStatement: isStatement$2,
    expressionStatement,
    program,
    file,
} = lib_exports;

const isFn$6 = (a) => typeof a === 'function';

const maybeThrow = (a, path, b) => {
    if (!a)
        return;
    
    throw Error(rendy$1(b, {
        path,
        type: path.type,
    }));
};

const maybeStatement = (ast) => isStatement$2(ast) ? ast : expressionStatement(ast);

const maybeProgram = (ast) => isProgram$3(ast) ? ast : program([
    maybeStatement(ast),
]);

const maybeFile = (ast) => isFile$1(ast) ? ast : file(maybeProgram(ast));

const maybeVisitor = (plugin, path, printer, options) => {
    if (isFn$6(plugin))
        return plugin(path, printer, options);
    
    return objectPlugin(plugin, path, printer, options);
};

function objectPlugin(plugin, path, printer, semantics) {
    const {
        print,
        split,
        condition,
        before = split,
        beforeIf = condition,
        after = split,
        afterIf = condition,
    } = maybeSatisfy(plugin);
    
    if (beforeIf?.(path, printer, semantics))
        before(path, printer, semantics);
    
    print(path, printer, semantics);
    
    if (afterIf?.(path, printer, semantics))
        after(path, printer, semantics);
}

var stringSnakeCase = snakeCase;

/*
  snakeCase('the quick brown fox'); // 'the_quick_brown_fox'
  snakeCase('the-quick-brown-fox'); // 'the_quick_brown_fox'
  snakeCase('the_quick_brown_fox'); // 'the_quick_brown_fox'
  snakeCase('theQuickBrownFox'); // 'the_quick_brown_fox'
  snakeCase('theQuickBrown Fox'); // 'the_quick_brown_Fox'
  snakeCase('thequickbrownfox'); // 'thequickbrownfox'
  snakeCase('the - quick * brown# fox'); // 'the_quick_brown_fox'
  snakeCase('theQUICKBrownFox'); // 'the_q_u_i_c_k_brown_fox'
*/

// any combination of spaces and punctuation characters
// thanks to http://stackoverflow.com/a/25575009
var wordSeparators = /[\s\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,\-.\/:;<=>?@\[\]^_`{|}~]+/;
var capitals = /[A-Z\u00C0-\u00D6\u00D9-\u00DD]/g;

function snakeCase(str) {
  //replace capitals with space + lower case equivalent for later parsing
  str = str.replace(capitals, function(match) {
    return ' ' + (match.toLowerCase() || match);
  });
  return str
    .trim()
    .split(wordSeparators)
    .join('_');
}

const {stringify: stringify$7} = JSON;
const {
    LOG,
    LOG_ALL,
    LOG_TOKENS,
    LOG_TERM,
    LOG_DEBUG,
} = {};

const createDebug$3 = (tokens) => (a) => {
    if (!LOG_DEBUG)
        return;
    
    tokens.push({
        type: TYPES$3.DEBUG,
        value: `/*__${stringSnakeCase(a)}*/`,
    });
};

const createLog = ({newline = '\n', store = createStore$1()} = {}) => ({type, value}) => {
    if (LOG_TOKENS) {
        console.log(codeFrameColumns(stringify$7({
            type,
            value,
        }), {}, {
            highlightCode: true,
        }));
        
        return;
    }
    
    if (LOG_ALL) {
        console.log(codeFrameColumns(value, {}, {
            highlightCode: true,
        }));
        
        return;
    }
    
    if (LOG) {
        if (value === newline) {
            console.log(codeFrameColumns(store(), {}, {
                highlightCode: true,
            }));
            
            return;
        }
        
        store(value);
    }
    
    if (LOG_TERM)
        browser$1.stdout.write(value);
};

function createStore$1() {
    let chunks = [];
    
    return (...args) => {
        const [chunk] = args;
        
        if (args.length) {
            chunks.push(chunk);
            return;
        }
        
        const result = chunks.join('');
        
        chunks = [];
        
        return result;
    };
}

const isObject$6 = (a) => a && typeof a === 'object';
const isBool$3 = (a) => typeof a === 'boolean';

const ROUND_BRACES_DEFAULTS = {
    arrow: true,
    sequence: true,
    assign: false,
    new: true,
};

const ROUND_BRACES_ENABLED = {
    arrow: true,
    sequence: true,
    assign: true,
    new: true,
};

const ROUND_BRACES_DISABLED = {
    arrow: false,
    sequence: false,
    assign: false,
    new: false,
};

const parseRoundBraces = ({roundBraces}) => {
    if (isObject$6(roundBraces))
        return {
            ...ROUND_BRACES_DEFAULTS,
            ...roundBraces,
        };
    
    if (isBool$3(roundBraces) && roundBraces)
        return ROUND_BRACES_ENABLED;
    
    if (isBool$3(roundBraces) && !roundBraces)
        return ROUND_BRACES_DISABLED;
    
    return ROUND_BRACES_DEFAULTS;
};

const parseQuotes = ({quote}) => {
    if (quote === '"')
        return {
            escapeSingleQuote: false,
            escapeDoubleQuote: true,
        };
    
    return {
        escapeSingleQuote: true,
        escapeDoubleQuote: false,
    };
};

const parseOverrides = (overrides = {}) => {
    const {
        format,
        semantics,
        visitors,
    } = overrides;
    
    const initiatedFormat = initFormat(format);
    
    return {
        format: initiatedFormat,
        semantics: initSemantics(initiatedFormat, semantics),
        visitors,
    };
};

const initFormat = (format) => ({
    indent: '    ',
    newline: '\n',
    space: ' ',
    splitter: '\n',
    quote: `'`,
    endOfFile: '\n',
    ...format,
});

const initSemantics = (format, semantics = {}) => ({
    comments: true,
    maxPropertiesInOneLine: 2,
    maxPropertiesLengthInOneLine: 15,
    maxSpecifiersInOneLine: 2,
    maxElementsInOneLine: 5,
    maxElementLengthInOneLine: 10,
    maxLogicalsInOneLine: 3,
    maxVariablesInOneLine: 4,
    maxTypesInOneLine: 3,
    trailingComma: true,
    ...parseQuotes(format),
    ...semantics,
    roundBraces: parseRoundBraces(semantics),
});

const isObject$5 = (a) => a && typeof a === 'object';
const {round} = Math;
const isString$b = (a) => typeof a === 'string';
const {assign: assign$9, freeze} = Object;

const GET = '__';
const get = (path, command) => path.get(command.replace(GET, ''));

const createAddToken = (tokens) => {
    const log = createLog();
    
    return (token) => {
        log(token);
        tokens.push(token);
    };
};

const tokenize = (ast, overrides) => {
    const {
        visitors,
        format,
        semantics,
    } = parseOverrides(overrides);
    
    const tokens = [];
    const addToken = createAddToken(tokens);
    const debug = createDebug$3(tokens);
    
    const write = (value) => {
        addToken({
            type: TYPES$3.TOKEN,
            value,
        });
    };
    
    const indent = () => {
        addToken({
            type: TYPES$3.INDENT,
            value: printIndent(i, format.indent),
        });
    };
    
    const maybeIndent = (a) => a && indent();
    
    const maybeIndentInc = (a) => a && indent.inc();
    
    const maybeIndentDec = (a) => a && indent.dec();
    
    const newline = () => {
        addToken({
            type: TYPES$3.NEWLINE,
            value: format.newline,
        });
    };
    
    const maybeNewline = (a) => a && newline();
    
    const breakline = () => {
        newline();
        indent();
    };
    
    const maybeBreakline = (a) => a && breakline();
    
    const linebreak = () => {
        indent();
        newline();
    };
    
    const maybeLinebreak = (a) => a && linebreak();
    const maybeWrite = (a, b) => a && write(b);
    
    const space = () => {
        addToken({
            type: TYPES$3.SPACE,
            value: format.space,
        });
    };
    
    const maybeSpace = (a) => a && space();
    let i = 0;
    const incIndent = () => ++i;
    const decIndent = () => --i;
    
    assign$9(indent, {
        inc: incIndent,
        dec: decIndent,
    });
    
    const splitter = () => {
        addToken({
            type: TYPES$3.SPLITTER,
            value: format.splitter,
        });
    };
    
    const quote = () => {
        addToken({
            type: TYPES$3.QUOTE,
            value: format.quote,
        });
    };
    
    const endOfFile = () => {
        addToken({
            type: TYPES$3.END_OF_FILE,
            value: format.endOfFile,
        });
    };
    
    assign$9(write, {
        indent,
        newline,
        linebreak,
        breakline,
        space,
        splitter,
        quote,
        endOfFile,
    });
    
    assign$9(maybeWrite, {
        newline: maybeNewline,
        breakline: maybeBreakline,
        linebreak: maybeLinebreak,
        space: maybeSpace,
    });
    
    const maybe = {
        indent: maybeIndent,
        markAfter: maybeMarkAfter,
        write: maybeWrite,
        space: maybeSpace,
    };
    
    assign$9(maybe.indent, {
        inc: maybeIndentInc,
        dec: maybeIndentDec,
    });
    
    // should never change to avoid unexpected errors related to printing path, since it hard to debug
    const mainPrinter = freeze({
        indent,
        write,
        debug,
        traverse,
        maybe,
        quote,
        store: fullstore$1(),
    });
    
    const currentTraversers = {
        ...baseVisitors,
        ...visitors,
    };
    
    if (ast.parentPath)
        pathTraverse(ast, traverse);
    else
        traverse3(maybeFile(ast), {
            Program(path) {
                traverse(path);
                path.stop();
            },
        });
    
    function traverse(path) {
        const {type} = path;
        const currentTraverse = currentTraversers[type];
        
        if (!path.node)
            return;
        
        const print = createPrint(path, {
            write,
            traverse,
        });
        
        assign$9(print, write, {
            space,
            round,
        });
        
        const printer = {
            ...mainPrinter,
            print,
        };
        
        const maybePrint = (a, b) => a && print(b);
        
        assign$9(maybePrint, {
            newline: maybeNewline,
            breakline: maybeBreakline,
            linebreak: maybeLinebreak,
            space: maybeSpace,
        });
        
        assign$9(printer.maybe, {
            print: maybePrint,
        });
        
        maybeThrow(!currentTraverse, path, ` Node type '{{ type }}' is not supported yet by @putout/printer: '{{ path }}'`);
        
        const currentIndent = i;
        parseLeadingComments(path, printer, semantics, {
            currentTraverse,
        });
        
        // this is main thing
        maybeVisitor(currentTraverse, path, printer, semantics);
        parseTrailingComments(path, printer, semantics, {
            currentTraverse,
        });
        maybeThrow(i !== currentIndent, path, `Looks like indent level changed after token visitor: '{{ type }}', for code: '{{ path }}'`);
        
        debug(path.type);
    }
    
    return tokens;
};

function printIndent(i, indent) {
    let result = '';
    ++i;
    
    while (--i > 0) {
        result += indent;
    }
    
    return result;
}

const createPrint = (path, {traverse, write}) => (maybeLine) => {
    if (maybeLine === path)
        return null;
    
    const computed = computePath(path, maybeLine);
    
    if (isObject$5(computed))
        return traverse(computed);
    
    return write(computed);
};

const computePath = (path, maybeLine) => {
    if (isString$b(maybeLine) && maybeLine.startsWith(GET))
        return get(path, maybeLine);
    
    if (isObject$5(maybeLine))
        return maybeLine;
    
    return maybeLine;
};

function pathTraverse(ast, traverse) {
    ast.parentPath.traverse({
        enter(path) {
            if (path === ast) {
                traverse(path);
                path.stop();
            }
        },
    });
}

const cook = (tokens) => {
    const cookedTokens = [];
    
    for (const {value} of tokens) {
        cookedTokens.push(value);
    }
    
    return cookedTokens;
};

const printTokens = (tokens) => {
    const cookedTokens = cook(tokens);
    return cookedTokens.join('');
};

/**
 * Variable with regex to validate blank lines
 * @name removeBlankLines
 * @var
 * @returns {Regex}
 */

var blankLines = new RegExp(/(^[ \t]*\n)/, "gm");

/**
 * removeBlankLines
 * Remove blank lines from a string.
 *
 * @name removeBlankLines
 * @function
 * @param {String} input The input string.
 * @returns {String} The result string (without blank lines).
 */
var removeBlankLines = function removeBlankLines(input) {
  return input.replace(blankLines, "");
};

var lib = removeBlankLines;

var removeBlankLines$1 = lib.default;

const __json_name$1 = '__putout_processor_json';
const __yaml_name$1 = '__putout_processor_yaml';
const __filesystem_name$4 = '__putout_processor_filesystem';
const __ignore_name$1 = '__putout_processor_ignore';

const TYPES$1 = [
    __json_name$1,
    __yaml_name$1,
    __filesystem_name$4,
    __ignore_name$1,
];

var isJSON$1 = (source) => {
    for (const type of TYPES$1) {
        if (!source.indexOf(type))
            return true;
    }
    
    return false;
};

const {
    isCallExpression: isCallExpression$1,
    isIdentifier: isIdentifier$5,
} = lib_exports;

const maybeJSON = (ast, overrides) => {
    if (isASTJSON(ast))
        return {
            ...overrides,
            format: {
                ...overrides?.format,
                quote: `"`,
            },
            semantics: {
                ...overrides?.semantics,
                trailingComma: false,
                escapeSingleQuote: false,
                escapeDoubleQuote: true,
            },
        };
    
    return overrides;
};

function isASTJSON(ast) {
    const {program} = ast;
    
    if (!program)
        return false;
    
    const {body} = ast.program;
    
    if (!body.length)
        return false;
    
    const {expression} = ast.program.body[0];
    
    if (!isCallExpression$1(expression))
        return false;
    
    const {callee} = expression;
    
    if (!isIdentifier$5(callee))
        return false;
    
    return isJSON$1(callee.name);
}

const print$2 = (ast, overrides = {}) => {
    check$d(ast);
    
    const options = maybeJSON(ast, overrides);
    const tokens = tokenize(ast, options);
    
    return printTokens(tokens);
};

function check$d(ast) {
    if (typeof ast !== 'object')
        throw Error('Looks like ast not an object');
}

const isString$a = (a) => typeof a === 'string';

var alignSpaces = (str) => {
    check$c(str);
    
    const array = str.split('\n');
    const n = array.length - 1;
    
    for (let i = 0; i < n; i++) {
        const str = array[i];
        
        if (!i || isNotSpaceString(str))
            continue;
        
        array[i] = getSpaces(array[i + 1]);
    }
    
    return array.join('\n');
};

function isNotSpaceString(s) {
    let i = s.length;
    
    if (!i)
        return false;
    
    while (--i > -1) {
        if (s[i] !== ' ')
            return true;
    }
    
    return false;
}

function getSpaces(s) {
    let spaces = '';
    
    for (let i = 0; i < s.length; i++) {
        if (s[i] !== ' ')
            return spaces;
        
        spaces += ' ';
    }
    
    return spaces;
}

function check$c(str) {
    if (!isString$a(str))
        throw Error('str should be a string!');
}

var align = alignSpaces.default;

const defaultOptions$4 = {
    alignSpaces: true,
};

const print$1 = (ast, options) => {
    const {source, alignSpaces} = {
        ...defaultOptions$4,
        ...options,
    };
    
    let {code} = generate$1(
        ast,
        source && {
            experimental_preserveFormat: true,
            retainLines: true,
        },
        source,
    );
    
    if (code[0] === '\n')
        code = code.trimStart();
    
    code += '\n';
    
    if (!alignSpaces)
        return code;
    
    return align(code);
};

const {isArray: isArray$b} = Array;

const maybeArray$4 = (a) => isArray$b(a) ? a : [a, {}];

const print = (ast, options = {}) => {
    const [printer = 'putout', printerOptions] = maybeArray$4(options.printer);
    
    if (printer === 'babel')
        return print$1(ast, {
            ...options,
            ...printerOptions,
        });
    
    return print$2(ast, printerOptions);
};

const {
    isFunctionExpression,
    objectMethod,
} = lib_exports;

const {assign: assign$8} = Object;

var traverseObjectExpression = (propertiesPaths) => {
    for (const propPath of propertiesPaths) {
        const {
            computed,
            key,
            method,
            value,
        } = propPath.node;
        
        if (method && isFunctionExpression(value)) {
            propPath.replaceWith(objectMethod('method', key, value.params, value.body, computed));
            
            assign$8(propPath.node, {
                id: null,
                method: true,
                generator: value.generator,
                loc: getObjectMethodLoc(key, value),
                async: value.async,
                type: 'ObjectMethod',
            });
        }
    }
};

function getObjectMethodLoc(key, value) {
    if (key.loc && value.loc)
        return {
            start: key.loc.start,
            end: value.loc.end,
        };
    
    return null;
}

const {
    classPrivateMethod,
    classMethod,
    privateName,
    identifier: identifier$1,
} = lib_exports;

const {assign: assign$7} = Object;

var setClassMethod = (path) => {
    const {node} = path;
    const {
        key,
        kind,
        computed,
        loc,
    } = node;
    
    const {
        body,
        params,
        expression,
        generator,
    } = node.value;
    
    const method = getClassMethod({
        kind,
        key,
        params,
        body,
        computed,
        nodeStatic: node.static,
    });
    
    path.replaceWith(method);
    assign$7(path.node, {
        loc,
        expression,
        generator,
    });
};

const isPrivateIdentifier = ({type}) => type === 'PrivateIdentifier';

function getClassMethod({kind, key, params, body, computed, nodeStatic}) {
    if (isPrivateIdentifier(key)) {
        const newKey = convertPrivateIdentifier$1(key);
        return classPrivateMethod(kind, newKey, params, body, computed);
    }
    
    return classMethod(kind, key, params, body, computed, nodeStatic);
}

function convertPrivateIdentifier$1(node) {
    return privateName(identifier$1(node.name));
}

var setClassPrivateProperty = (path) => {
    path.node.type = 'ClassPrivateProperty';
};

const {identifier} = lib_exports;

// acorn stores name in PrivateName.name
// babel stores name in PrivateName.id.name
var setClassPrivateName = ({node}) => {
    if (!node.name)
        return;
    
    node.id = identifier(node.name);
    node.id.loc = {
        start: {
            line: node.loc.start.line,
            column: node.loc.start.column + 1,
        },
        end: node.loc.end,
    };
    delete node.name;
};

const {
    directive,
    directiveLiteral,
} = lib_exports;

var setDirectives = (path) => {
    const {node} = path;
    
    if (node.directives)
        return;
    
    node.directives = [];
    for (const statementPath of path.get('body')) {
        if (statementPath.type !== 'ExpressionStatement')
            continue;
        
        const statement = statementPath.node;
        
        if (!('directive' in statement))
            continue;
        
        if (!statement.directive)
            continue;
        
        const literal = directiveLiteral(statement.directive);
        const currentDirective = directive(literal);
        
        node.directives.push(currentDirective);
        statementPath.remove();
    }
};

var convertChainExpression = (path) => {
    const expressionPath = path.get('expression');
    const {expression} = path.node;
    
    if (expressionPath.isCallExpression()) {
        const calleePath = expressionPath.get('callee');
        
        expression.type = 'OptionalCallExpression';
        
        if (calleePath.isMemberExpression())
            expression.callee.type = 'OptionalMemberExpression';
    } else {
        expression.type = 'OptionalMemberExpression';
    }
    
    path.replaceWith(expression);
};

var convertImportDeclaration = (path) => {
    const {attributes = []} = path.node;
    path.node.attributes = attributes;
};

const {assign: assign$6} = Object;

var convertExportDeclaration = (path) => {
    const {attributes = []} = path.node;
    
    assign$6(path.node, {
        attributes,
    });
};

const convertParenthesizedExpression = ({convertParens}) => (path) => {
    if (!convertParens)
        return;
    
    const {expression} = path.node;
    
    expression.extra = expression.extra || {};
    expression.extra.parenthesized = true;
    
    path.replaceWith(expression);
};

const convertTSParenthesizedType = ({convertParens}) => (path) => {
    if (!convertParens)
        return;
    
    const {typeAnnotation} = path.node;
    
    typeAnnotation.extra = typeAnnotation.extra || {};
    typeAnnotation.extra.parenthesized = true;
    
    path.replaceWith(typeAnnotation);
};

const convertNodeComments = (node) => {
    const {comments} = node;
    
    if (!comments)
        return;
    
    delete node.comments;
    node.leadingComments = undefined;
    node.trailingComments = undefined;
    node.innerComments = undefined;
    
    for (const comment of comments) {
        const group = getCommentGroup(comment);
        
        if (!node[group])
            node[group] = [];
        
        delete comment.leading;
        delete comment.trailing;
        comment.type = getCommentType(comment);
        node[group].push(comment);
    }
};

const convertProgramComments = (comments) => {
    for (const comment of comments) {
        comment.type = getCommentType(comment);
    }
    
    return comments;
};

const getCommentType = ({type}) => `Comment${type}`;

function getCommentGroup({trailing, leading}) {
    if (trailing)
        return 'trailingComments';
    
    if (leading)
        return 'leadingComments';
    
    return 'innerComments'; // Dangling comments, such as `[/* a */]`.
}

const isString$9 = (a) => typeof a === 'string';
const isNumber$2 = (a) => typeof a === 'number';
const isNull = (a) => a === null;
const isBool$2 = (a) => typeof a === 'boolean';

var setLiteral = (node) => {
    const {type, value} = node;
    
    if (type !== 'Literal')
        return;
    
    if (isNull(value)) {
        node.type = 'NullLiteral';
        return;
    }
    
    if (isString$9(value)) {
        node.type = 'StringLiteral';
        return;
    }
    
    if (isNumber$2(value)) {
        node.type = 'NumericLiteral';
        return;
    }
    
    if (isBool$2(value)) {
        node.type = 'BooleanLiteral';
        return;
    }
    
    if (node.regex) {
        transformRegExp$1(node);
        return;
    }
};

function transformRegExp$1(node) {
    node.type = 'RegExpLiteral';
    
    for (const key of Object.keys(node.regex)) {
        node[key] = node.regex[key];
    }
    
    delete node.regex;
}

var getAST = (node) => {
    if (node.type === 'File')
        return node;
    
    const {
        comments = [],
        tokens,
        ...program
    } = node;
    
    const ast = {
        type: 'File',
        program: {
            ...program,
            directives: [],
        },
        comments: convertProgramComments(comments),
        tokens,
    };
    
    return ast;
};

const convertPropertyDefinition = (path) => {
    const {node} = path;
    
    if (node.key.type === 'PrivateIdentifier') {
        const {key} = node;
        
        node.type = 'ClassPrivateProperty';
        node.key = createPrivateName(key);
        
        return;
    }
    
    path.node.type = 'ClassProperty';
};

const convertTSInterfaceHeritage = (path) => {
    let {expression} = path.node;
    
    while (expression.type === 'MemberExpression') {
        const {object, property} = expression;
        
        expression.type = 'TSQualifiedName';
        expression.left = object;
        expression.right = property;
        
        delete expression.object;
        delete expression.property;
        
        expression = object;
    }
};

const convertPrivateIdentifier = (path) => {
    path.replaceWith(createPrivateName(path.node));
};

const convertTSAbstractMethodDefinition = (path) => {
    const {node} = path;
    
    const {
        generator,
        async,
        params,
        id,
        returnType,
    } = node.value;
    
    const newNode = {
        ...node,
        abstract: true,
        generator,
        async,
        params,
        id,
        returnType,
        type: 'TSDeclareMethod',
    };
    
    delete newNode.value;
    
    path.replaceWith(newNode);
};

const createPrivateName = (node) => ({
    type: 'PrivateName',
    id: {
        ...node,
        type: 'Identifier',
    },
    loc: node.loc,
});

const {
    isObjectExpression,
    isExportDeclaration,
} = lib_exports;

const defaultOptions$3 = {
    convertParens: true,
};

const estreeToBabel = (node, options) => {
    const ast = getAST(node);
    
    const allOptions = {
        ...defaultOptions$3,
        ...options,
    };
    
    traverse3(ast, {
        noScope: true,
        ParenthesizedExpression: convertParenthesizedExpression(allOptions),
        TSParenthesizedType: convertTSParenthesizedType(allOptions),
        enter(path) {
            const {type, node} = path;
            
            if (type.endsWith('Literal')) {
                setLiteral(node);
                return setEsprimaRaw(node);
            }
            
            if (type === 'JSXText')
                return setEsprimaRaw(node);
            
            if (type === 'BlockStatement' || type === 'Program')
                return setDirectives(path);
            
            if (type === 'Property')
                return setObjectProperty(node);
            
            if (type === 'MethodDefinition')
                return setClassMethod(path);
            
            if (type === 'FieldDefinition')
                return setClassPrivateProperty(path);
            
            if (type === 'PrivateName')
                return setClassPrivateName(path);
            
            if (type === 'ImportDeclaration')
                return convertImportDeclaration(path);
            
            if (isExportDeclaration(path))
                return convertExportDeclaration(path);
            
            if (type === 'ChainExpression')
                return convertChainExpression(path);
            
            if (type === 'TSAbstractMethodDefinition')
                return convertTSAbstractMethodDefinition(path);
            
            if (type === 'TSInterfaceHeritage')
                return convertTSInterfaceHeritage(path);
            
            if (type === 'PropertyDefinition')
                return convertPropertyDefinition(path);
            
            if (type === 'PrivateIdentifier')
                return convertPrivateIdentifier(path);
        },
        exit(path) {
            const {node} = path;
            
            convertNodeComments(node);
            
            if (isObjectExpression(node))
                return traverseObjectExpression(path.get('properties'));
        },
    });
    return ast;
};

function setObjectProperty(node) {
    node.type = 'ObjectProperty';
}

// avoid additional traversing in @putout/engine-parser
// add "raw" field, that exists in all ESTree AST
// but located in "extra.raw" in Babel AST
// which makes writing transforms more long and error prone
function setEsprimaRaw(node) {
    const {raw} = node;
    
    node.raw = raw || node.extra?.raw;
    node.extra = node.extra || {
        raw,
    };
}

var _module = {};

var once$6 = {exports: {}};

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
var wrappy_1 = wrappy$1;
function wrappy$1 (fn, cb) {
  if (fn && cb) return wrappy$1(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k];
  });

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    var ret = fn.apply(this, args);
    var cb = args[args.length-1];
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k];
      });
    }
    return ret
  }
}

var wrappy = wrappy_1;
once$6.exports = wrappy(once$5);
once$6.exports.strict = wrappy(onceStrict);

once$5.proto = once$5(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once$5(this)
    },
    configurable: true
  });

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  });
});

function once$5 (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true;
    return f.value = fn.apply(this, arguments)
  };
  f.called = false;
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true;
    return f.value = fn.apply(this, arguments)
  };
  var name = fn.name || 'Function wrapped with `once`';
  f.onceError = name + " shouldn't be called more than once";
  f.called = false;
  return f
}

var onceExports = once$6.exports;

const noop$3 = () => {};

var empty = /*#__PURE__*/Object.freeze({
	__proto__: null,
	default: noop$3
});

var require$$1$1 = /*@__PURE__*/getAugmentedNamespace(empty);

// eslint-disable-next-line node/no-unsupported-features/es-syntax

// eslint-disable-next-line node/no-unsupported-features/es-syntax
function privateMethods(Parser) {
  const ExtendedParser = noop$3();

  return class extends ExtendedParser {
    // Parse private methods
    parseClassElement(_constructorAllowsSuper) {
      const oldInClassMemberName = this._inClassMemberName;
      this._inClassMemberName = true;
      const result = super.parseClassElement.apply(this, arguments);
      this._inClassMemberName = oldInClassMemberName;
      return result
    }

    parsePropertyName(prop) {
      const isPrivate = this.options.ecmaVersion >= 8 && this._inClassMemberName && this.type == this.privateNameToken && !prop.static;
      this._inClassMemberName = false;
      if (!isPrivate) return super.parsePropertyName(prop)
      return this.parsePrivateClassElementName(prop)
    }
  }
}

var acornPrivateMethods = /*#__PURE__*/Object.freeze({
	__proto__: null,
	default: privateMethods
});

var require$$2$1 = /*@__PURE__*/getAugmentedNamespace(acornPrivateMethods);

var acornStage3;
var hasRequiredAcornStage3;

function requireAcornStage3 () {
	if (hasRequiredAcornStage3) return acornStage3;
	hasRequiredAcornStage3 = 1;

	acornStage3 = function(Parser) {
	  return Parser.extend(
	    require$$1$1,
	    require$$1$1,
	    require$$2$1
	  )
	};
	return acornStage3;
}

const once$4 = onceExports;

const initAcorn = once$4(() => {
    const {Parser} = require$$1$1;
    
    const stage3 = requireAcornStage3();
    const typescript = require$$1$1.default;
    
    return Parser.extend(typescript(), stage3);
});

var parse$8 = (source) => {
    const parser = initAcorn();
    const options = {
        locations: true,
        comment: true,
        ecmaVersion: 2023,
        sourceType: 'module',
        allowAwaitOutsideFunction: true,
        allowReturnOutsideFunction: true,
        allowImportExportEverywhere: true,
        preserveParens: true,
    };
    
    const tokensToAvoidEsprima = Array.from(parser.tokenizer(source, options));
    const result = parser.parse(source, options);
    
    return {
        ...result,
        tokens: tokensToAvoidEsprima,
    };
};

var plugins = [
    'importMeta',
    'importAttributes',
    'dynamicImport',
    'bigInt',
    'classProperties',
    'decorators-legacy',
    'decoratorAutoAccessors',
    'destructuringPrivate',
    'exportDefaultFrom',
    'throwExpressions',
    'deferredImportEvaluation',
    ['discardBinding', {
        syntaxType: 'void',
    }],
    'sourcePhaseImports',
    ['optionalChainingAssign', {
        version: '2023-07',
    }],
];

const allowReturnOutsideFunction = true;
const allowUndeclaredExports = true;
const allowImportExportEverywhere = true;

var options = /*#__PURE__*/Object.freeze({
	__proto__: null,
	allowImportExportEverywhere: allowImportExportEverywhere,
	allowReturnOutsideFunction: allowReturnOutsideFunction,
	allowUndeclaredExports: allowUndeclaredExports
});

const {assign: assign$5} = Object;
const getFlow = (a) => !a.indexOf('// @flow');
const clean = (a) => a.filter(Boolean);

const parse$7 = (source, overrides) => {
    const {
        sourceFileName,
        isTS,
        isJSX = true,
        isFlow = getFlow(source),
        isRecovery,
        printer,
    } = overrides;
    
    const parserOptions = {
        sourceFileName,
        sourceType: 'module',
        ...options,
        errorRecovery: isRecovery,
        plugins: clean([
            ...plugins,
            ...getBabelLangExts({
                isTS,
                isFlow,
                isJSX,
            }),
        ]),
    };
    
    if (printer === 'babel')
        assign$5(parserOptions, {
            createParenthesizedExpressions: true,
            tokens: true,
        });
    
    const ast = parse$9(source, parserOptions);
    
    ast.program.extra.__putout_printer = printer;
    return ast;
};

function getBabelLangExts({isTS, isFlow, isJSX}) {
    const langs = [
        isJSX && 'jsx',
    ];
    
    if (isTS || isFlow)
        return langs.concat(['typescript']);
    
    return langs;
}

const once$3 = onceExports;

const initEspree = once$3(() => require$$1$1);

var parse$6 = (source) => {
    const {parse} = initEspree();
    const preventUsingEsprima = true;
    
    return parse(source, {
        loc: true,
        tokens: preventUsingEsprima,
        comment: true,
        ecmaVersion: 2023,
        sourceType: 'module',
        ecmaFeatures: {
            jsx: true,
        },
    });
};

const once$2 = onceExports;

const initEsprima = once$2(() => require$$1$1);

var parse$5 = (source) => {
    const {parse} = initEsprima();
    
    return parse(source, {
        loc: true,
        tokens: true,
        comment: true,
        sourceType: 'module',
        jsx: true,
    });
};

const once$1 = onceExports;

const initTenko = once$1(() => require$$1$1);

var parse$4 = (source) => {
    const {Tenko} = initTenko();
    const {ast} = Tenko(source, {
        goalMode: 'module',
        allowGlobalReturn: true,
        exposeScopes: true,
    });
    
    return ast;
};

const once = onceExports;
const initHermes = once(() => require$$1$1);

var parse$3 = (source) => {
    const parser = initHermes();
    const options = {
        babel: true,
        allowReturnOutsideFunction: true,
        flow: 'detect',
        locations: true,
        tokens: true,
    };
    
    return parser.parse(source, options);
};

const tryCatch = (fn, ...args) => {
    try {
        return [null, fn(...args)];
    } catch(e) {
        return [e];
    }
};

const secondChance = (fn, source, messages, args) => {
    const [a, ...others] = args;
    const [errorA, resultA] = tryCatch(fn, source, a);
    
    if (!errorA)
        return resultA;
    
    if (checkError(errorA, messages))
        throw errorA;
    
    for (const b of others) {
        const [errorB, resultB] = tryCatch(fn, source, b);
        
        if (!errorB)
            return resultB;
    }
    
    throw errorA;
};

function checkError(error, messages) {
    for (const message of messages) {
        if (error.message.includes(message))
            return true;
    }
    
    return false;
}

const isObject$4 = (a) => typeof a === 'object';

const MESSAGES = [
    'has already been declared',
];

var customParser = (source, parser, {isTS, isJSX, printer}) => {
    const options = {
        parser,
        printer,
        isTS,
        isJSX,
    };
    
    const optionsB = {
        ...options,
        isJSX: false,
    };
    
    const optionsC = {
        ...options,
        isRecovery: true,
    };
    
    return secondChance(customParse, source, MESSAGES, [
        options,
        optionsB,
        optionsC,
    ]);
};

function customParse(source, {parser, printer, isTS, isJSX, isRecovery}) {
    if (parser === 'babel')
        return parse$7(source, {
            isTS,
            isJSX,
            isRecovery,
            printer,
        });
    
    if (isObject$4(parser))
        return parser.parse(source, {
            isJSX,
            isTS,
        });
    
    if (parser === 'espree')
        return parse$6(source);
    
    if (parser === 'acorn')
        return parse$8(source);
    
    if (parser === 'esprima')
        return parse$5(source);
    
    if (parser === 'tenko')
        return parse$4(source);
    
    if (parser === 'hermes')
        return parse$3(source);
    
    const require = _module.createRequire(import.meta.url);
    
    return require(parser).parse(source);
}

const tryThrowWithReason$1 = (fn, ...args) => {
    const [error, result] = tryCatch(fn, ...args);
    
    if (error) {
        error.reason = 'parse';
        throw error;
    }
    
    return result;
};

const {assign: assign$4} = Object;
const isString$8 = (a) => typeof a === 'string';

const parse$2 = (source, options) => {
    check$b(source);
    
    const {
        parser,
        printer = 'putout',
        isTS,
        isJSX,
    } = options || {};
    
    const {parse} = getParser({
        printer,
        parser,
        isTS,
        isJSX,
    });
    
    return tryThrowWithReason$1(parse, source);
};

const getParser = ({parser = 'babel', isTS, isJSX, printer}) => ({
    parse(source) {
        const options = {};
        
        if (printer === 'babel')
            assign$4(options, {
                convertParens: false,
            });
        
        const ast = estreeToBabel(customParser(source, parser, {
            isTS,
            isJSX,
            printer,
        }), options);
        
        return ast;
    },
});

function check$b(source) {
    if (!isString$8(source))
        throw Error(` Looks like type of 'source' is not 'string', but '${typeof source}'`);
}

const generate = (node, options, sourceMaps) => {
    return generate$1(node, {
        comments: false,
        ...options,
    }, sourceMaps);
};

/*
MIT License

Copyright (c) 2018-2023 Simon Y. Blackwell

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/ function $cf838c15c8b009ba$var$vrgs(f) {
    var s = f + "", i = s.indexOf("...");
    return i >= 0 && (i < s.indexOf(")") || s.indexOf("arguments") >= 0);
}
function $cf838c15c8b009ba$export$22f15dd4e5be7e52(fn, o) {
    /*o = {
		serializer, // used to serialize arguments of single argument functions, multis are not serialized
		equals, // equality tester, will force use of slower multiarg approach even for single arg functions
		maxAge, // max cache age is ms, set > 0 && < Infinity if you want automatic clearing
		maxArgs, // max args to use for signature
		vargs = vrgs(fn) // set to true if function may have variable or beyond-signature arguments, default is best attempt at infering
	  } = {}
	*/ o || (o = {});
    var vargs = o.vargs || $cf838c15c8b009ba$var$vrgs(fn), k = [], cache = new Map(), u, to, d = function(key) {
        return to = setTimeout(function() {
            if (u) {
                cache.delete(key);
                return;
            }
            // dealing with multi-arg function, c and k are Arrays
            k.splice(key, 1);
        //v.splice(key,1);
        }, o.maxAge);
    }, c = o.maxAge > 0 && o.maxAge < Infinity ? d : 0, eq = o.equals ? o.equals : 0, maxargs = o.maxArgs, srlz = o.serializer, f; // memoized function to return
    if (fn.length === 1 && !o.equals && !vargs) {
        // for single argument functions, just use a Map lookup
        f = function(a) {
            if (srlz) a = srlz(a);
            var r;
            return cache.get(a) || (!c || c(a), cache.set(a, r = fn.call(this, a)), r);
        };
        u = 1;
    } else if (eq) // for multiple arg functions, loop through a cache of all the args
    // looking at each arg separately so a test can abort as soon as possible
    f = function() {
        var l = maxargs || arguments.length, kl = k.length, i = -1;
        while(++i < kl)if (k[i].length === l) {
            var j = -1;
            while(++j < l && eq(arguments[j], k[i][j])); // compare each arg
            if (j === l) return k[i].val //the args matched;
            ;
        }
        // set change timeout only when new value computed, hits will not push out the tte, but it is arguable they should not
        k[i] = arguments;
        return !c || c(i), arguments.val = fn.apply(this, k[i]);
    };
    else f = function() {
        var l = maxargs || arguments.length, kl = k.length, i = -1;
        while(++i < kl)if (k[i].length === l) {
            var j = -1;
            while(++j < l && arguments[j] === k[i][j]); // compare each arg
            if (j === l) return k[i].val //the args matched;
            ;
        }
        // set change timeout only when new value computed, hits will not push out the tte, but it is arguable they should not
        k[i] = arguments;
        return !c || c(i), arguments.val = fn.apply(this, k[i]);
    };
    // reset all the caches
    f.clear = function() {
        if (to) clearTimeout(to);
        cache.clear();
        k = [];
    };
    f.keys = function() {
        return u ? [
            ...cache.keys()
        ] : k.slice();
    };
    f.values = function() {
        return u ? [
            ...cache.values()
        ] : k.map((args)=>args.val);
    };
    return f;
}

const {
    nanomemoize = $cf838c15c8b009ba$export$22f15dd4e5be7e52,
} = $cf838c15c8b009ba$export$22f15dd4e5be7e52;

const defaults = {
    ...options,
    plugins: [
        ...plugins,
        'typescript',
        'jsx',
    ],
};

const {
    isExpressionStatement: isExpressionStatement$1,
    isTSExternalModuleReference,
} = lib_exports;

const extractExpression$2 = (a) => {
    if (isExpressionStatement$1(a))
        return a.expression;
    
    if (isTSExternalModuleReference(a))
        return a.expression;
    
    return a;
};

const template$1 = nanomemoize((value, options) => {
    const fn = index(value, {
        ...defaults,
        ...options,
    });
    
    return (...a) => {
        const result = fn(...a);
        return extractExpression$2(result);
    };
});

template$1.extractExpression = extractExpression$2;

template$1.ast = nanomemoize((value, options) => {
    const result = index.ast(value, {
        ...defaults,
        ...options,
    });
    
    return extractExpression$2(result);
});

template$1.program = nanomemoize((value, options) => {
    const result = index.program(value, {
        ...defaults,
        ...options,
    });
    
    return result;
});

template$1.program.ast = nanomemoize((value, options) => {
    const result = index.program.ast(value, {
        ...defaults,
        ...options,
    });
    
    return result;
});

template$1.ast.fresh = (value, options) => {
    const result = index.ast(value, {
        ...defaults,
        ...options,
    });
    
    return extractExpression$2(result);
};

const mergeShebang = (shebang, source) => {
    if (!shebang)
        return source;
    
    return `${shebang}\n${source}`;
};

const cutShebang = (source) => {
    if (source.indexOf('#'))
        return [source, ''];
    
    const lines = source.split('\n');
    
    const result = lines
        .slice(1)
        .join('\n');
    
    const [shebang] = lines;
    
    return [
        result,
        `${shebang}\n`,
    ];
};

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
function resolve() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : '/';

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter$1(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
}
// path.normalize(path)
// posix version
function normalize(path) {
  var isPathAbsolute = isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter$1(path.split('/'), function(p) {
    return !!p;
  }), !isPathAbsolute).join('/');

  if (!path && !isPathAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isPathAbsolute ? '/' : '') + path;
}
// posix version
function isAbsolute(path) {
  return path.charAt(0) === '/';
}

// posix version
function join$1() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return normalize(filter$1(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
}


// path.relative(from, to)
// posix version
function relative(from, to) {
  from = resolve(from).substr(1);
  to = resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
}

var sep = '/';
var delimiter = ':';

function dirname$1(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
}

function basename$1(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
}


function extname(path) {
  return splitPath(path)[3];
}
var path = {
  extname: extname,
  basename: basename$1,
  dirname: dirname$1,
  sep: sep,
  delimiter: delimiter,
  relative: relative,
  join: join$1,
  isAbsolute: isAbsolute,
  normalize: normalize,
  resolve: resolve
};
function filter$1 (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b' ?
    function (str, start, len) { return str.substr(start, len) } :
    function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

var _polyfillNode_path = /*#__PURE__*/Object.freeze({
	__proto__: null,
	basename: basename$1,
	default: path,
	delimiter: delimiter,
	dirname: dirname$1,
	extname: extname,
	isAbsolute: isAbsolute,
	join: join$1,
	normalize: normalize,
	relative: relative,
	resolve: resolve,
	sep: sep
});

const isFn$5 = (a) => typeof a === 'function';

const tryToCatch = async (fn, ...args) => {
    check$a(fn);
    
    try {
        return [null, await fn(...args)];
    } catch(e) {
        return [e];
    }
};

function check$a(fn) {
    if (!isFn$5(fn))
        throw Error('fn should be a function!');
}

const returns$1 = (a) => () => a;
const noop$2 = () => {};

const createRequire = (url, overrides = {}) => {
    const {module = _module} = overrides;
    const {createRequire = returns$1(noop$2)} = module;
    
    return createRequire(url);
};

// How in other way to mock import using mock require in CommonJS?
const simpleImport = async (url) => {
    const result = await import(url);
    return result.default || result;
};

const require$1 = createRequire(import.meta.url);

const {assign: assign$3} = Object;
const stub$2 = () => () => {};

const createAsyncLoader = (type, overrides = {}) => {
    const {
        simpleImport: simpleImport$1 = simpleImport,
    } = overrides;
    
    return async (name) => {
        if (name === 'none')
            return stub$2();
        
        if (name.startsWith('import:')) {
            const shortName = name.replace('import:', '');
            
            return await cleverLoad([require$1.resolve(shortName)], {
                simpleImport: simpleImport$1,
                require: require$1,
            });
        }
        
        const namesBase = [
            `@putout/${type}-${name}`,
            `putout-${type}-${name}`,
        ];
        
        const namesFromPluginsDirs = namesBase.flatMap(buildPluginsDirs);
        
        const names = Array.from(new Set([
            ...namesBase,
            ...namesFromPluginsDirs,
        ]));
        
        return await cleverLoad(names, {
            simpleImport: simpleImport$1,
            require: require$1,
        });
    };
};

async function cleverLoad(names, overrides) {
    const {simpleImport, require} = overrides;
    
    let e;
    let reporter;
    
    for (const name of names) {
        [e, reporter] = await tryToCatch(simpleImport, name);
        
        if (!e)
            return reporter;
        
        if (e.code === 'ERR_UNSUPPORTED_DIR_IMPORT') {
            const fullName = require.resolve(name);
            
            [e, reporter] = await tryToCatch(simpleImport, fullName);
            
            if (!e)
                return reporter;
        }
        
        if (e.code === 'ERR_MODULE_NOT_FOUND')
            continue;
        
        assign$3(e, {
            message: `${name}: ${e.message}`,
        });
        
        throw e;
    }
    
    assign$3(e, {
        message: e.message.replace(/\simported.*/, ''),
    });
    
    throw e;
}

const getPutoutLoadDir = () => browser$1.env.PUTOUT_LOAD_DIR;

function buildPluginsDirs(name) {
    const dir = getPutoutLoadDir();
    
    if (!dir)
        return [name];
    
    const base = join$1(dir, name);
    
    return [
        base,
        `${base}.js`,
    ];
}

const isStr$2 = (a) => typeof a === 'string';
const {isArray: isArray$a} = Array;
const {entries: entries$9} = Object;

const parsePluginNames = (plugins) => {
    const result = [];
    
    for (const plugin of plugins) {
        if (isStr$2(plugin)) {
            result.push([plugin]);
            continue;
        }
        
        if (isArray$a(plugin)) {
            const [pluginName, fn] = plugin;
            result.push([pluginName, fn]);
            continue;
        }
        
        result.push(...entries$9(plugin));
    }
    
    return result;
};

const {isArray: isArray$9} = Array;
const isBool$1 = (a) => typeof a === 'boolean';
const isStr$1 = (a) => typeof a === 'string';
const isObj = (a) => typeof a === 'object';
const {entries: entries$8} = Object;
const {stringify: stringify$6} = JSON;

const notSupportedError = (a) => Error(` Rule format not supported ${a}: ${typeof a}`);
const rulesUsedInsteadOfMatchError = (a) => Error(` Looks like you need to change "rules" to "match" for ${stringify$6(a)}`);
const stateOptionError = ({rule, value}) => Error(` ${rule}: state option can be "on" or "off" only, when used as string, received: "${value}"`);
const defaultOptions$2 = () => Object.create(null);

const parseState = (rule, value) => {
    validateState(rule, value);
    
    if (value === 'on')
        return true;
    
    if (value === 'off')
        return false;
    
    return value;
};

const parseRules = (rules) => {
    const result = [];
    const plugin = null;
    const msg = '';
    
    check$9(rules);
    
    for (const [rule, value] of entries$8(rules)) {
        if (isStr$1(value)) {
            result.push({
                rule,
                state: parseState(rule, value),
                plugin,
                msg,
                options: defaultOptions$2(),
            });
            continue;
        }
        
        if (isBool$1(value)) {
            result.push({
                rule,
                state: value,
                plugin,
                msg,
                options: defaultOptions$2(),
            });
            continue;
        }
        
        const looksLikeArray = isArray$9(value);
        const looksLikeNormalArray = looksLikeArray && value.length;
        
        if (looksLikeNormalArray) {
            result.push(parseArray(rule, value));
            continue;
        }
        
        if (isObj(value))
            throw rulesUsedInsteadOfMatchError(value);
        
        throw notSupportedError(value);
    }
    
    return result;
};

function parseArray(rule, args) {
    const plugin = null;
    const [rawState] = args;
    
    const state = parseState(rule, rawState);
    
    if (args.length === 3) {
        const [, msg, options] = args;
        
        return {
            rule,
            state,
            plugin,
            msg,
            options,
        };
    }
    
    const [, msg = ''] = args;
    
    return {
        rule,
        state,
        plugin,
        msg: '',
        options: msg,
    };
}

function validateState(rule, value) {
    if (isBool$1(value))
        return true;
    
    if (/^(on|off)$/.test(value))
        return true;
    
    if (isObj(value))
        return true;
    
    throw stateOptionError({
        rule,
        value,
    });
}

const cut$1 = (a) => a.split('/')[0];

const enableNestedRules = (rules) => {
    const newRules = {};
    
    for (const [rule, value] of entries$8(rules)) {
        if (rule.includes('/') && parseState(rule, value))
            newRules[cut$1(rule)] = 'on';
        
        newRules[rule] = value;
    }
    
    return newRules;
};

function check$9(rules) {
    if (isArray$9(rules))
        throw Error(`Looks like type of 'rules' passed to @putout/engine-loader is 'array', expected: 'object'.`);
}

const defaultOptions$1 = () => Object.create(null);

const mergeRules = ([rule, plugin], rules) => {
    for (const currentRule of rules) {
        if (currentRule.rule !== rule)
            continue;
        
        const {msg, options} = currentRule;
        
        return {
            rule,
            plugin,
            msg,
            options,
        };
    }
    
    return {
        rule,
        plugin,
        msg: '',
        options: defaultOptions$1(),
    };
};

const parseSlashes = (rule) => {
    if (rule.includes('/'))
        return rule
            .split('/')
            .shift();
    
    return rule;
};

const parsePluginName = (a) => {
    return a
        .replace('import:@putout/plugin-', '')
        .replace('@putout/plugin-', '');
};

const validateRules = ({items, rules}) => {
    const ruleItems = Object.keys(rules);
    
    for (const rule of ruleItems) {
        let isName = false;
        let isWithSlash = false;
        let isIncludes = false;
        
        for (const [pluginName, plugin = {}] of items) {
            const parsedPluginName = parsePluginName(pluginName);
            
            isName = parsedPluginName === rule;
            isWithSlash = parsedPluginName === parseSlashes(rule);
            isIncludes = rule.includes(parsedPluginName);
            
            if (isName && plugin.rules)
                throw Error(`Rule '${rule}' cannot be applied to nested plugin '${pluginName}'`);
            
            if (isName || isWithSlash || isIncludes)
                break;
        }
        
        if (!isName && !isWithSlash && !isIncludes)
            throw Error(`No plugin found for a rule: '${rule}'`);
    }
};

const isEnabled = (name, rules) => {
    for (const {rule, state} of rules) {
        if (rule === name)
            return state;
    }
    
    for (const {rule, state} of rules) {
        if (rule.includes('/') && RegExp(`^${rule}`).test(name))
            return state;
    }
    
    for (const {rule, state} of rules) {
        if (RegExp(`^${rule}/`).test(name))
            return state;
    }
    
    return true;
};

const getLoadedRules = (rules) => {
    const loadedRules = [];
    
    for (const item of rules) {
        const {rule} = item;
        
        if (rule.includes('/'))
            continue;
        
        loadedRules.push(item);
    }
    
    return loadedRules;
};

const isString$7 = (a) => typeof a === 'string';

const check$8 = (options) => {
    if (!options || typeof options !== 'object')
        throw Error('options should be an object!');
};

const checkRule = (rule) => {
    if (!isString$7(rule))
        throw Error(` Looks like plugin name type is not 'string', but: '${typeof rule}'`);
};

const validateRulesRelations = (options) => {
    check$8(options);
    
    const {pluginNames = [], rules = {}} = options;
    const items = parsePluginNames(pluginNames);
    
    validateRules({
        rules,
        items,
    });
};

const prepareRules = ({rules, pluginNames}) => {
    const enabledRules = enableNestedRules(rules);
    const cookedEnabledRules = parseRules(enabledRules);
    const loadedRules = getLoadedRules(cookedEnabledRules);
    const items = parsePluginNames(pluginNames);
    const cookedRules = parseRules(rules);
    
    return {
        items,
        loadedRules,
        cookedRules,
    };
};

const supportedKeys = [
    'find',
    'traverse',
    'replace',
    'include',
    'exclude',
    'rules',
    'declare',
    'scan',
];

var validatePlugin = ({plugin, rule}) => {
    const keys = Object.keys(plugin);
    
    for (const key of supportedKeys) {
        if (keys.includes(key))
            return;
    }
    
    throw Error(` Cannot determine type of plugin '${rule}'. Here is list of supported plugins: https://git.io/JqcMn`);
};

const {isArray: isArray$8} = Array;
const maybeTuple = (a) => isArray$8(a) ? a : ['on', a];

// Would be great to have ability to filter
// disabled plugins and prevent them from loading
// but we can't because of a way multi-rule plugins
// works. We can't determine count and names of all
// rules of a plugin before load.
const filterEnabledPlugins = ({plugins, cookedRules}) => {
    const result = [];
    
    for (const [name, plugin] of plugins) {
        if (!isEnabled(name, cookedRules))
            continue;
        
        const [status, currentPlugin] = maybeTuple(plugin);
        
        if (!isExactRuleEnabled(name, status, cookedRules))
            continue;
        
        result.push(mergeRules(
            [name, currentPlugin],
            cookedRules,
        ));
    }
    
    return result;
};

function isExactRuleEnabled(name, status, rules) {
    if (status === 'on')
        return true;
    
    for (const {rule, state} of rules) {
        if (rule.includes('/') && RegExp(`^${rule}`).test(name))
            return state;
    }
    
    return false;
}

const loadPluginAsync = createAsyncLoader('plugin');

const loadPluginsAsync = async (options) => {
    check$8(options);
    
    const {pluginNames = [], rules = {}} = options;
    const {
        items,
        loadedRules,
        cookedRules,
    } = prepareRules({
        rules,
        pluginNames,
    });
    
    const plugins = await loadPlugins$1({
        items,
        loadedRules,
    });
    
    return filterEnabledPlugins({
        plugins,
        cookedRules,
    });
};

const splitRule$1 = (rule) => [rule, 'putout'];

async function loadPlugins$1({items, loadedRules}) {
    const promises = [];
    const enabledRules = [];
    
    for (const [rule, itemPlugin] of items) {
        if (!isEnabled(rule, loadedRules))
            continue;
        
        checkRule(rule);
        
        const [name] = splitRule$1(rule);
        const plugin = itemPlugin || loadPluginAsync(name);
        
        enabledRules.push(parseRuleName(rule));
        promises.push(plugin);
    }
    
    const resolvedPlugins = await Promise.all(promises);
    const plugins = [];
    
    for (const [i, rule] of enabledRules.entries()) {
        const plugin = resolvedPlugins[i];
        
        validatePlugin({
            plugin,
            rule,
        });
        
        const {rules} = plugin;
        
        if (rules) {
            plugins.push(...extendRules$1(rule, rules));
            continue;
        }
        
        plugins.push([rule, plugin]);
    }
    
    return plugins;
}

function extendRules$1(rule, plugin) {
    const result = [];
    const entries = Object.entries(plugin);
    
    for (const [name, plugin] of entries) {
        result.push([`${rule}/${name}`, plugin]);
    }
    
    return result;
}

function parseRuleName(rule) {
    if (rule.startsWith('import:')) {
        const shortName = basename$1(rule.replace('import:', ''));
        
        return shortName.replace('plugin-', '');
    }
    
    return rule;
}

const {isArray: isArray$7} = Array;

const loadPlugins = (options) => {
    check$8(options);
    
    const {pluginNames = [], rules = {}} = options;
    const {
        items,
        loadedRules,
        cookedRules,
    } = prepareRules({
        rules,
        pluginNames,
    });
    
    const plugins = loadAllPlugins({
        items,
        loadedRules,
    });
    
    return filterEnabledPlugins({
        plugins,
        cookedRules,
    });
};

const splitRule = (rule) => [rule, 'putout'];

const parseRule = (rule) => rule
    .replace('import:@putout/plugin-', '')
    .replace('@putout/plugin-', '');

const maybeFromTuple = (a) => isArray$7(a) ? a[1] : a;

function loadAllPlugins({items, loadedRules}) {
    const plugins = [];
    
    for (const [rule, itemPlugin] of items) {
        if (!isEnabled(rule, loadedRules))
            continue;
        
        checkRule(rule);
        const parsedRule = parseRule(rule);
        
        const [name, namespace] = splitRule(rule);
        const plugin = maybeFromTuple(itemPlugin) || loadOnePlugin({
            name,
            namespace,
        });
        
        validatePlugin({
            plugin,
            rule,
        });
        
        const {rules} = plugin;
        
        if (rules) {
            plugins.push(...extendRules(parsedRule, rules));
            continue;
        }
        
        plugins.push([parsedRule, plugin]);
    }
    
    return plugins;
}

function extendRules(rule, plugin) {
    const result = [];
    const entries = Object.entries(plugin);
    
    for (const [name, plugin] of entries) {
        result.push([`${rule}/${name}`, plugin]);
    }
    
    return result;
}

// add support of esm.sh
// https://github.com/esm-dev/esm.sh/issues/1045
function loadOnePlugin({name, namespace}) {
    const require = createRequire(import.meta.url);
    const {loadPlugin} = require('../load/load.js');
    
    return loadPlugin({
        name,
        namespace,
    });
}

function createDebug$2() {
    return () => {}
}

const createDebug$1 = (namespace) => {
    const log = createDebug$2();
    
    return new Proxy(log, {
        apply(target, thisArg, args) {
            globalThis.__putout_debug?.(namespace, ...args);
            return target(...args);
        },
        get(target, prop) {
            if (globalThis.__putout_debug?.[prop])
                return true;
            
            return target[prop];
        },
    });
};

const {stringify: stringify$5} = JSON;

const isFn$4 = (a) => typeof a === 'function';
const getPath$1 = (path) => path.path || path;
const debug$4 = createDebug$1('putout:runner:fix');

const chooseFixArgs = ({path, pathOptions, options}) => {
    if (pathOptions)
        return [
            path,
            pathOptions, {
                options,
            },
        ];
    
    return [
        path, {
            options,
        },
    ];
};

const tryToFix = (fix, {path, pathOptions, position, options}) => {
    const [e] = tryCatch(fix, ...chooseFixArgs({
        path,
        pathOptions,
        options,
    }));
    
    const {scope} = path.path || path;
    
    if (!e && scope)
        scope
            .getProgramParent()
            .crawl();
    
    if (!e)
        return;
    
    e.loc = e.loc || position;
    e.reason = 'fix';
    
    throw e;
};

var runFix$1 = (is, fix, {path, pathOptions, rule, position, options}) => {
    if (!is)
        return;
    
    if (debug$4.enabled)
        debug$4(`${rule}:`, position, getPath$1(path).toString());
    
    validate$1('fix', fix);
    
    tryToFix(fix, {
        path,
        pathOptions,
        position,
        options,
    });
};

function validate$1(name, fn) {
    if (!isFn$4(fn))
        throw Error(` Looks like '${name}' is not a 'function' but '${typeof fn}' with value: '${stringify$5(fn)}'. More on writing Putout Plugins: https://git.io/JqcMn`);
}

const getPath = (item) => item.path || item[0] || item;

const getPosition = (path, shebang) => {
    const parsedPath = getPath(path);
    
    validatePath(parsedPath);
    
    const {node} = parsedPath;
    const {loc} = node;
    
    if (!loc)
        return {
            line: 0,
            column: 0,
        };
    
    const {line, column} = node.loc.start;
    
    return {
        line: shebang ? line + 1 : line,
        column,
    };
};

function validatePath(path) {
    if (!path.node)
        throw Error(` Looks like 'push' called without a 'path' argument.`);
}

const {isArray: isArray$6} = Array;
const maybeArray$2 = (a) => isArray$6(a) ? a : [a];

var maybeArray$3 = (a) => {
    if (!a)
        return [];
    
    return maybeArray$2(a);
};

const isFn$3 = (a) => typeof a === 'function';
const {stringify: stringify$4} = JSON;

const validate = (name, fn) => {
    if (!isFn$3(fn))
        throw Error(` Looks like '${name}' is not a 'function' but '${typeof fn}' with value: '${stringify$4(fn)}'. More on using Includer: https://git.io/JqcMn`);
};

const {
    values,
    entries: entries$7,
    assign: assign$2,
} = Object;

const toArray = (a) => Array.from(a);
const isNotRemoved = (a) => a.node;
const notRemoved = (a) => toArray(a).filter(isNotRemoved);
const id = (a) => a;

const listStore = createListStore();
const pathStore = createListStore(notRemoved);

const mapStore = createStore({
    get(map) {
        return values(map);
    },
    set(map, name, data) {
        map[name] = data;
    },
});

const upStore = createStore({
    get(map) {
        return values(map);
    },
    set(map, name, data) {
        map[name] = map[name] || {};
        assign$2(map[name], data);
    },
});

const upListStore = createStore({
    get(map) {
        return values(map).map(notRemoved);
    },
    set(map, name, data) {
        map[name] = map[name] || new Set();
        map[name].add(data);
    },
});

function createStore({set, get}) {
    return (map = {}) => {
        const fn = (...args) => {
            if (!args.length)
                return get(map);
            
            const [name, data] = args;
            
            if (args.length === 1)
                return map[name];
            
            set(map, name, data);
        };
        
        fn.clear = () => {
            map = {};
        };
        
        fn.entries = () => entries$7(map);
        
        return fn;
    };
}

function createListStore(returns = id) {
    return (list = new Set()) => {
        const fn = (...args) => {
            if (!args.length)
                return returns(toArray(list));
            
            const [a] = args;
            list.add(a);
        };
        
        fn.clear = () => {
            const a = list;
            
            list = new Set();
            
            return returns(toArray(a));
        };
        
        return fn;
    };
}

const {merge: merge$2} = traverse3.visitors;
const {assign: assign$1} = Object;

const parse$1 = (name, plugin, options) => {
    const list = [];
    
    if (plugin[name]) {
        validate(name, plugin[name]);
        list.push(...maybeArray$3(plugin[name]()));
    }
    
    if (options[name])
        list.push(...maybeArray$3(options[name]));
    
    return list;
};

var mergeVisitors = (pluginsToMerge, {fix, shebang, template}) => {
    const mergeItems = [];
    const pushed = {};
    
    for (const {rule, plugin, msg, options} of pluginsToMerge) {
        const {
            push,
            pull,
            store,
            upstore,
            listStore,
            pathStore,
            uplist,
        } = getStore(plugin, {
            fix,
            rule,
            shebang,
            msg,
            options,
        });
        
        pushed[rule] = pull;
        
        const visitor = plugin.traverse({
            push,
            store,
            listStore,
            pathStore,
            upstore,
            uplist,
            generate,
            options,
        });
        
        if (!visitor)
            throw Error(` Visitors cannot be empty in "${rule}"`);
        
        assign$1(options, {
            include: parse$1('include', plugin, options),
            exclude: parse$1('exclude', plugin, options),
        });
        
        mergeItems.push(...template({
            rule,
            visitor,
            options,
        }));
    }
    
    const entries = Object.entries(pushed);
    
    const visitor = merge$2(mergeItems);
    
    return {
        entries,
        visitor,
    };
};

function getStore(plugin, {fix, rule, shebang, msg, options}) {
    const store = mapStore();
    const list = listStore();
    const upstore = upStore();
    const placesStore = listStore();
    const uplist = upListStore();
    const paths = pathStore();
    
    const push = (path, pathOptions) => {
        const position = getPosition(path, shebang);
        const message = msg || plugin.report(path, pathOptions);
        
        placesStore({
            message,
            position,
        });
        
        runFix$1(fix, plugin.fix, {
            path,
            pathOptions,
            rule,
            position,
            options,
        });
    };
    
    const pull = () => {
        store.clear();
        list.clear();
        upstore.clear();
        uplist.clear();
        paths.clear();
        
        return placesStore.clear();
    };
    
    return {
        push,
        pull,
        store,
        listStore: list,
        upstore,
        uplist,
        pathStore: paths,
    };
}

const {merge: merge$1} = traverse3.visitors;

function superFind({rule, find, ast, options, template, traverse = traverse3}) {
    const pushItems = [];
    
    const push = (a) => {
        pushItems.push(a);
    };
    
    const returnItems = find(ast, {
        traverse: createTraverse$1({
            rule,
            options,
            template,
            traverse,
        }),
        generate,
        types: lib_exports,
        push,
        options,
    });
    
    return [
        ...pushItems,
        ...returnItems || [],
    ];
}

const createTraverse$1 = ({rule, options, template, traverse}) => (ast, visitor) => {
    const templateVisitors = merge$1(template({
        rule,
        visitor,
        options,
    }));
    
    return traverse(ast, templateVisitors);
};

const isString$6 = (a) => typeof a === 'string';
const isUndefined = (a) => typeof a === 'undefined';
const isEmpty = (obj) => !Object.keys(obj).length;

var jessy = (selector, divider, value) => {
    if (!value) {
        value = divider;
        divider = '.';
    }
    
    check$7(selector, value);
    
    if (!selector)
        return value;
    
    if (isEmpty(value))
        return undefined;
    
    const selects = selector
        .split(divider)
        .filter(Boolean);
    
    for (const [i, name] of selects.entries()) {
        const nestedName = selects
            .slice(i)
            .join(divider);
        
        if (!isUndefined(value[nestedName])) {
            value = value[nestedName];
            break;
        }
        
        if (!value[name]) {
            value = undefined;
            break;
        }
        
        value = value[name];
    }
    
    return value;
};

function check$7(selector, obj) {
    if (!isString$6(selector))
        throw Error('selector should be string!');
    
    if (typeof obj !== 'object')
        throw Error('obj should be object!');
}

var jessy$1 = jessy.default;

const isNumber$1 = (a) => !Number.isNaN(a) && typeof a === 'number';
const isNumberLike = (a, b = Number(a)) => isNumber$1(b);
const isString$5 = (a) => typeof a === 'string';
const notSecure = (a) => /__proto__|prototype/.test(a);

var nessy = (selector, value, divider, obj) => {
    if (!obj) {
        obj = divider || {};
        divider = '.';
    }
    
    const result = obj;
    
    check$6(selector);
    
    const array = selector
        .split(divider)
        .filter(Boolean);
    const n = array.length - 1;
    
    for (const [i, name] of array.entries()) {
        if (notSecure(name))
            continue;
        
        if (i === n) {
            obj[name] = value;
        } else if (!obj[name]) {
            const nextKey = array[i + 1];
            
            obj[name] = isNumberLike(nextKey) ? [] : {};
        }

        
        obj = obj[name];
    }
    
    return result;
};

function check$6(selector) {
    if (!isString$5(selector))
        throw Error('selector should be string!');
}

var nessy$1 = nessy.default;

const TS_MODULE_REG = /\.body\.0\.expression$/;
const CLASS_BODY_REG = /\.body\.0\.key$/;
const BODY_REG = /\.body\.0$/;

const prepareBodyWay = (way) => {
    return way
        .replace(TS_MODULE_REG, '')
        .replace(CLASS_BODY_REG, '')
        .replace(BODY_REG, '');
};

const {
    isBlockStatement: isBlockStatement$1,
    isTSModuleBlock,
    isBooleanLiteral,
    isIdentifier: isIdentifier$4,
    isLiteral: isLiteral$1,
    isTemplateElement: isTemplateElement$2,
    isFunction: isFunction$1,
    isImportDefaultSpecifier,
    isExportSpecifier,
    isRegExpLiteral,
    isJSXText: isJSXText$2,
    isJSXIdentifier: isJSXIdentifier$1,
    isJSXAttribute: isJSXAttribute$1,
    isTSTypeReference: isTSTypeReference$1,
    isTSTypeParameterDeclaration,
} = lib_exports;

const isStr = (a) => typeof a === 'string';

const ANY_OBJECT = '__object';
const ANY_ARRAY = '__array';
const ARGS = '__args';
const TYPE_PARAMS = '__type_params';
const IMPORTS = '__imports';
const EXPORTS = '__exports';
const BODY = '__body';
const JSX_CHILDREN = '__jsx_children';
const JSX_ATTRIBUTES = '__jsx_attributes';
const NOP = '__nop';
const ANY = '__';
const ID = '__identifier';
const BOOL = '__bool';

const LINKED_NODE = /^__[a-z]$/;
const LINKED_ARGS = /__args__[a-z]$/;
const LINKED_ID = /^__identifier__[a-z]$/;
const LINKED_BOOL = /^__bool__[a-z]$/;

const ALL = [
    ANY_OBJECT,
    ANY_ARRAY,
    ARGS,
    TYPE_PARAMS,
    BOOL,
    JSX_CHILDREN,
    JSX_ATTRIBUTES,
    IMPORTS,
    EXPORTS,
    BODY,
    ANY,
    ID,
    LINKED_NODE,
    LINKED_ARGS,
    LINKED_ID,
    LINKED_BOOL,
];

const isTemplate = (a) => /[(;={.\s]/.test(a) || !/^[A-Z]/.test(a);

const is = (str, array = ALL) => {
    for (const item of array) {
        if (check$5(str, item))
            return true;
    }
    
    return false;
};

function check$5(str, item) {
    if (isStr(item))
        return str === item;
    
    return item.test(str);
}
const isImportsStr = (a) => a === IMPORTS;
const isExportsStr = (a) => a === EXPORTS;
const isArgsStr = (a) => a === ARGS || LINKED_ARGS.test(a);
const isTypeParamsStr = (a) => a === TYPE_PARAMS;
const isJSXChildrenStr = (a) => a === JSX_CHILDREN;
const isJSXAttributesStr = (a) => a === JSX_ATTRIBUTES;
const isBodyStr = (a) => a === BODY;

const isBody = (a) => isIdentifier$4(a, {
    name: BODY,
});

const isFunctionDeclarationBody = (a) => {
    if (isBody(a))
        return true;
    
    if (!isBlockStatement$1(a) && !isTSModuleBlock(a))
        return false;
    
    return isBody(a.body[0].expression);
};

const isNop = (a) => isIdentifier$4(a, {
    name: NOP,
});

const isAnyObject = (a) => isIdentifier$4(a, {
    name: ANY_OBJECT,
});

const isAnyArray = (a) => isIdentifier$4(a, {
    name: ANY_ARRAY,
});

const isId = (a, b) => {
    if (!isIdentifier$4(b, {name: ID}))
        return false;
    
    return isIdentifier$4(a);
};

const isBool = (a, b) => {
    if (!isIdentifier$4(b, {name: BOOL}))
        return false;
    
    return isBooleanLiteral(a);
};

const isEqualType = (a, b) => a.type === b.type;
const {isArray: isArray$5} = Array;

const isAny = (a) => {
    if (isIdentifier$4(a, {name: ANY}))
        return true;
    
    return isJSXText$2(a, {
        value: ANY,
    });
};

const isAnyLiteral = (a, b) => {
    if (!isLiteral$1(b, {value: ANY}))
        return false;
    
    return isEqualType(a, b);
};

const isArgs = (a) => {
    const b = !isArray$5(a) ? a : a[0];
    
    return isIdentifier$4(b, {
        name: ARGS,
    });
};

const isTypeParams = (node) => {
    if (!isTSTypeParameterDeclaration(node))
        return false;
    
    const {params} = node;
    const {name} = params[0];
    
    return isIdentifier$4(name, {
        name: TYPE_PARAMS,
    });
};

const isEqualTypeParams = (a, b) => {
    if (!a)
        return false;
    
    if (!isTypeParams(b))
        return false;
    
    return isEqualType(a, b);
};

const isLinkedArgs = (a) => {
    const b = !isArray$5(a) ? a : a[0];
    return isIdentifier$4(b) && LINKED_ARGS.test(b.name);
};

const isJSXChildren = (a) => {
    const b = !isArray$5(a) ? a : a[0];
    
    return isJSXText$2(b, {
        value: JSX_CHILDREN,
    });
};

const isJSXAttributes = (a) => {
    const b = !isArray$5(a) ? a : a[0];
    
    if (!isJSXAttribute$1(b))
        return false;
    
    return isJSXIdentifier$1(b.name, {
        name: JSX_ATTRIBUTES,
    });
};

const isLinkedId = (a, b) => {
    if (!isIdentifier$4(b) || !LINKED_ID.test(b.name))
        return false;
    
    return isIdentifier$4(a);
};

const isLinkedBool = (a, b) => {
    if (!isIdentifier$4(b) || !LINKED_BOOL.test(b.name))
        return false;
    
    return isBooleanLiteral(a);
};

const isLinkedRegExp = (a, b) => {
    if (!isRegExpLiteral(b) || !LINKED_NODE.test(b.pattern))
        return false;
    
    return isRegExpLiteral(a);
};

const isPath$1 = (path) => Boolean(path.node);

const isObject$3 = (a) => {
    if (!a)
        return false;
    
    if (isArray$5(a))
        return false;
    
    return typeof a === 'object';
};

const isArrays = (a, b) => {
    if (!isArray$5(a) || !isArray$5(b))
        return false;
    
    return a.length === b.length;
};

const isImports = (a) => {
    const b = !isArray$5(a) ? a : a[0];
    
    if (!isImportDefaultSpecifier(b))
        return false;
    
    return isIdentifier$4(b.local, {
        name: IMPORTS,
    });
};

const isExports = (a) => {
    const b = !isArray$5(a) ? a : a[0];
    
    if (!isExportSpecifier(b))
        return false;
    
    return isIdentifier$4(b.local, {
        name: EXPORTS,
    });
};

const __OBJECT_TYPE = 'ObjectPattern|ObjectExpression';
const __ARRAY_TYPE = 'ArrayPattern|ArrayExpression';

const isEqualAnyArray = (node, templateNode) => {
    if (!isAnyArray(templateNode))
        return false;
    
    const {type} = node;
    
    return __ARRAY_TYPE.includes(type);
};

const isEqualAnyObject = (node, templateNode) => {
    if (!isAnyObject(templateNode))
        return false;
    
    const {type} = node;
    
    return __OBJECT_TYPE.includes(type);
};

const isEqualBody = (node, templateNode) => {
    if (!node)
        return false;
    
    if (!isBody(templateNode))
        return false;
    
    return node.type === 'BlockStatement';
};

const isEqualFunctionDeclarationBody = (node, templateNode) => {
    if (!node)
        return false;
    
    if (!isFunctionDeclarationBody(templateNode))
        return false;
    
    const {type} = node;
    
    return /BlockStatement|TSModuleBlock/.test(type);
};

const isEqualNop = (node, templateNode) => {
    if (!isNop(templateNode))
        return false;
    
    if (!isFunction$1(node))
        return false;
    
    const {body} = node;
    
    if (!isBlockStatement$1(body))
        return false;
    
    return !body.body.length;
};

const isLinkedNode = (a) => {
    if (isIdentifier$4(a) && LINKED_NODE.test(a.name))
        return true;
    
    if (isLiteral$1(a) && LINKED_NODE.test(a.value))
        return true;
    
    if (isJSXText$2(a) && LINKED_NODE.test(a.value))
        return true;
    
    if (isJSXIdentifier$1(a) && LINKED_NODE.test(a.name))
        return true;
    
    if (isTemplateElement$2(a) && LINKED_NODE.test(a.value.raw))
        return true;
    
    return isTSTypeReference$1(a) && LINKED_NODE.test(a.typeName.name);
};

const parseTemplate = (tmpl, {program} = {}) => {
    const parse = !program ? template$1.ast : template$1.program.ast;
    const node = parse(tmpl) || template$1.ast.fresh(tmpl);
    
    if (tmpl === ANY_OBJECT)
        return [node, __OBJECT_TYPE];
    
    if (tmpl === ANY_ARRAY)
        return [node, __ARRAY_TYPE];
    
    const {type} = node;
    
    return [node, type];
};

const isInsideTypeReference = (path) => path.isIdentifier() && path.parentPath?.isTSTypeReference();
const isInsideTypeParameter = (path) => path.isIdentifier() && path.parentPath?.isTSTypeParameter();

const {
    isIdentifier: isIdentifier$3,
    isStatement: isStatement$1,
    isJSXElement: isJSXElement$1,
    isJSXAttribute,
    isStringLiteral: isStringLiteral$3,
    isTemplateLiteral: isTemplateLiteral$1,
    templateElement,
} = lib_exports;

const {extractExpression: extractExpression$1} = template$1;

const {entries: entries$6} = Object;
const isNumber = (a) => typeof a === 'number';
const isString$4 = (a) => typeof a === 'string';

const parseNode$1 = (a) => a.node || a;
const {stringify: stringify$3} = JSON;

const getTemplateValues = (node, str) => {
    if (!isString$4(str))
        throw Error(` Looks like argument 'template' of 'getTemplateValues(node, template)': is not a string, but '${stringify$3(str)}'`);
    
    node = parseNode$1(node);
    
    const templateNode = template$1.ast(str);
    const waysFrom = findVarsWays(templateNode);
    
    return getValues({
        node,
        waysFrom,
    });
};

function findVarsWays(node) {
    if (isIdentifier$3(node) && is(node.name))
        return {
            [node.name]: [''],
        };
    
    const vars = {};
    
    traverse3(node, {
        noScope: true,
        'Identifier|JSXIdentifier|BooleanLiteral|StringLiteral|TemplateElement|RegExpLiteral|JSXText|JSXAttribute|TSTypeReference|TSTypeParameter'(path) {
            if (isInsideTypeReference(path))
                return;
            
            if (isInsideTypeParameter(path))
                return;
            
            const {node} = path;
            
            if (isJSXAttribute(path.parentPath) && path.parentPath.node.name === node)
                return;
            
            const way = [];
            const name = extract(node);
            
            if (!is(name))
                return;
            
            path.find(({key, listKey}) => {
                if (isNumber(key)) {
                    way.unshift(`${listKey}.${key}`);
                    return;
                }
                
                way.unshift(key);
            });
            
            vars[name] = vars[name] || [];
            vars[name].push(way.join('.'));
        },
    });
    
    return vars;
}

function getValues({waysFrom, node}) {
    const result = {};
    
    for (const [name, ways] of entries$6(waysFrom)) {
        for (let way of ways) {
            if (isImportsStr(name) || isExportsStr(name))
                way = way.replace(/\.0.local$/, '');
            else if (isArgsStr(name) || isJSXChildrenStr(name) || isJSXAttributesStr(name) || isTypeParamsStr(name))
                way = way.replace(/\.0$/, '');
            
            if (!isJSXElement$1(node))
                way = way.replace(/\.expression$/, '');
            
            if (isBodyStr(name))
                way = prepareBodyWay(way);
            
            result[name] = result[name] || extractExpression$1(jessy$1(way, node));
        }
    }
    
    return result;
}

const makeRaw = (a) => a.replace('`', '\\`');

function setValues({waysTo, values, path}) {
    const node = extractExpression$1(path.node);
    
    for (const [name, ways] of entries$6(waysTo)) {
        for (let way of ways) {
            if (!way) {
                replaceWith$2(path, values[name]);
                continue;
            }
            
            if (isImportsStr(name) || isExportsStr(name))
                way = way.replace(/\.0.local$/, '');
            
            if (isArgsStr(name) || isJSXChildrenStr(name) || isJSXAttributesStr(name))
                way = way.replace(/\.0$/, '');
            
            if (isStatement$1(values[name]))
                way = way.replace(/\.expression$/, '');
            
            if (isStringLiteral$3(values[name]) && isTemplateLiteral$1(node)) {
                const {value} = values[name];
                
                const element = templateElement({
                    raw: makeRaw(value),
                });
                
                nessy$1(way, element, node);
                continue;
            }
            
            if (isBodyStr(name))
                way = prepareBodyWay(way);
            
            const {extra} = jessy$1(way, node);
            
            if (extra) {
                const valueExtra = values[name].extra;
                
                values[name].extra = {
                    ...extra,
                    ...valueExtra,
                };
            }
            
            nessy$1(way, values[name], node);
        }
    }
}

const createDebug = (namespace) => {
    const log = createDebug$2();
    
    return new Proxy(log, {
        apply(target, thisArg, args) {
            globalThis.__putout_debug?.(namespace, ...args);
            return target(...args);
        },
        get(target, prop) {
            if (globalThis.__putout_debug?.[prop])
                return true;
            
            return target[prop];
        },
    });
};

const debug$3 = createDebug('putout:compare');

const {isArray: isArray$4} = Array;
const isObject$2 = (a) => a && typeof a === 'object';

var log$4 = (a, b) => {
    if (!debug$3.enabled)
        return;
    
    const parsedValue = parseValue(a);
    const parsedPathValue = parseValue(b);
    
    return debug$3(`${parsedValue} = ${parsedPathValue}`);
};

function parseValue(a) {
    if (isArray$4(a) && a[0]) {
        const [{
            type,
            name,
            value,
        }] = a;
        
        return `${type}: ["${name || value}"]`;
    }
    
    if (isObject$2(a)) {
        const {
            type,
            name,
            value,
        } = a;
        
        return `${type}: "${name || value}"`;
    }
    
    return `${typeof a}: "${a}"`;
}

const {
    isIdentifier: isIdentifier$2,
    isLiteral,
    isStringLiteral: isStringLiteral$2,
    isTemplateElement: isTemplateElement$1,
    isTSTypeReference,
    isJSXText: isJSXText$1,
    isJSXIdentifier,
} = lib_exports;

const parseName = (node) => {
    node = node[0] || node;
    const {name, value} = node;
    
    if (isIdentifier$2(node) || isJSXIdentifier(node))
        return name;
    
    if (isLiteral(node))
        return value;
    
    if (isTemplateElement$1(node))
        return node.value.cooked;
    
    if (isTSTypeReference(node))
        return node.typeName.name;
    
    if (isJSXText$1(node))
        return node.value;
    
    throw Error(` Looks like type of node '${node.type}' not supported by 'compare -> link -> parseName()'`);
};

var link = ({add, value, nodeValue, templateStore}) => {
    const name = parseName(value);
    
    if (isStringLiteral$2(value) && !isStringLiteral$2(nodeValue))
        return false;
    
    if (!templateStore[name]) {
        templateStore[name] = nodeValue;
        return true;
    }
    
    if (isIdentifier$2(templateStore[name]) && isTSTypeReference(nodeValue))
        return true;
    
    add(templateStore[name], nodeValue, {
        plain: true,
    });
    
    return true;
};

const isPrimitive = (a) => typeof a !== 'object' || a === null;

const comparePrimitives = (node, template) => {
    return isPrimitive(template) && !is(template) && template === node;
};

const {isIdentifier: isIdentifier$1} = lib_exports;

const comparePlain = (node, template, {add}) => {
    if (!node && node === template)
        return true;
    
    if (!node)
        return false;
    
    if (comparePrimitives(node, template))
        return true;
    
    if (isIdentifier$1(node) && node.name === template.name)
        return true;
    
    if (isObject$3(template) && !Array.isArray(template))
        return add(node, template, {
            plain: true,
        });
    
    if (isArrays(node, template))
        return add(node, template, {
            plain: true,
        });
    
    return false;
};

const {
    isClassBody,
    isBlock,
    isJSXText,
    isTemplateElement,
} = lib_exports;

const isEmptyBlock = (a) => isBlock(a) && !a.body.length;

const second = (f) => (a, b) => f(b);

const comparators$1 = [
    comparePrimitives,
    compareTemplateElements,
    compareJSXTexts,
    compareAny$1,
    second(isClassBody),
    second(isEmptyBlock),
    second(isAny),
    isId,
    isBool,
    isEqualAnyArray,
    isEqualAnyObject,
    isEqualBody,
    isEqualFunctionDeclarationBody,
    isEqualNop,
    isEqualTypeParams,
    isLinkedRegExp,
    linkNodes,
    isAnyLiteral,
    second(isImports),
    second(isExports),
    second(isArgs),
    second(isJSXChildren),
    second(isJSXAttributes),
    addObject,
    compareArrays,
];

const runComparators = (node, template, {add, templateStore, plain}) => {
    let i = -1;
    const n = comparators$1.length;
    
    log$4(template, node);
    
    if (plain)
        return comparePlain(node, template, {
            add,
        });
    
    while (++i < n) {
        const compare = comparators$1[i];
        
        if (compare(node, template, {add, templateStore}))
            return true;
    }
    
    return false;
};

function compareAny$1(node, template) {
    return template === '__';
}

function compareArrays(node, template, {add}) {
    const is = isArrays(node, template);
    
    if (is)
        add(node, template);
    
    return is;
}

function compareTemplateElements(node, template) {
    if (!isTemplateElement(node) || !isTemplateElement(template))
        return false;
    
    const isValue = node.value.raw === template.value.raw;
    const isCooked = node.value.cooked === template.value.cooked;
    const isTail = node.tail === template.tail;
    
    return isValue && isCooked && isTail;
}

function linkNodes(node, template, {add, templateStore}) {
    const is = node
        && (isLinkedNode(template)
        || isLinkedArgs(template)
        || isLinkedId(node, template)
        || isLinkedBool(node, template));
    
    if (is)
        return link({
            add,
            value: template,
            nodeValue: node,
            templateStore,
        });
    
    return false;
}

function addObject(node, template, {add}) {
    const is = isObject$3(template);
    
    if (is)
        add(node, template);
    
    return is;
}

function compareJSXTexts(node, template) {
    if (!isJSXText(node) || !isJSXText(template))
        return false;
    
    return /^\s+$/.test(template.value) && /^\s+$/.test(node.value);
}

const {
    isIdentifier,
    isStringLiteral: isStringLiteral$1,
} = lib_exports;

const comparators = [
    isEqualAnyObject,
    isEqualAnyArray,
    isEqualNop,
    isLinkedAndIdentifier,
    isLinkedAndStringLiteral,
    isLinkedId,
    isLinkedRegExp,
    isEqualBody,
];

const runTopLevelComparators = (node, templateNode) => {
    let i = -1;
    const n = comparators.length;
    
    while (++i < n) {
        const compare = comparators[i];
        
        if (compare(node, templateNode))
            return true;
    }
    
    return false;
};

function isLinkedAndIdentifier(node, templateNode) {
    return isIdentifier(node) && isLinkedNode(templateNode);
}

function isLinkedAndStringLiteral(node, templateNode) {
    return isStringLiteral$1(node) && isLinkedNode(templateNode);
}

const {extractExpression} = template$1;
const addWaterMark = (a) => a;

const {keys: keys$2} = Object;
const {isArray: isArray$3} = Array;
const noop$1 = () => {};
const isEmptyArray = (a) => isArray$3(a) && !a.length;

const compareType = (type) => (path) => path.type === type;
const superPush = (array) => (a, b, c = {}) => array.push([a, b, c]);
const maybeArray$1 = (a) => isArray$3(a) ? a : [a];

const findParent = (path, type) => {
    const newPathNode = path.findParent(compareType(type));
    
    if (!newPathNode)
        return null;
    
    return newPathNode.node;
};

function parseNode(a) {
    if (isStr(a))
        return template$1.ast(a);
    
    if (!a.node)
        return a;
    
    return a.node;
}

function compare(path, template, options = {}, equal = noop$1) {
    const {findUp = true} = options;
    
    if (!path && !template)
        return true;
    
    if (!path)
        return false;
    
    if (!template)
        return false;
    
    const node = addWaterMark(extractExpression(parseNode(path)));
    const templateNode = extractExpression(parseNode(template));
    
    equal(node, templateNode);
    
    if (isId(node, templateNode))
        return true;
    
    if (node.type === template)
        return true;
    
    if (runTopLevelComparators(node, templateNode))
        return true;
    
    if (findUp && isPath$1(path) && !isEqualType(node, templateNode)) {
        const {type} = templateNode;
        const newPathNode = findParent(path, type);
        
        return superCompareIterate(newPathNode, templateNode);
    }
    
    return superCompareIterate(node, templateNode);
}

const compareAny = (path, templateNodes, options) => {
    templateNodes = maybeArray$1(templateNodes);
    
    for (const template of templateNodes) {
        if (compare(path, template, options))
            return true;
    }
    
    return false;
};

const compareAll = (path, templateNodes, options) => {
    templateNodes = maybeArray$1(templateNodes);
    
    for (const template of templateNodes) {
        if (!compare(path, template, options))
            return false;
    }
    
    return true;
};

// @babel/template creates empty array directives
// extra duplicate value
const ignore$1 = [
    'loc',
    'start',
    'end',
    'directives',
    'extra',
    'raw',
    'comments',
    'leadingComments',
    'innerComments',
    'parent',
    'phase',
    'range',
    'trailingComments',
    'importKind',
    'exportKind',
    '__putout_runner_replace',
];

function superCompareIterate(node, template) {
    let item = [node, template];
    
    const array = [item];
    const templateStore = {};
    const add = superPush(array);
    
    while (item = array.pop()) {
        const [node, template, {plain} = {}] = item;
        
        if (!node || isEmptyArray(node) && !isEmptyArray(template))
            return false;
        
        for (const key of keys$2(template)) {
            if (ignore$1.includes(key))
                continue;
            
            const nodeValue = extractExpression(node[key]);
            const value = extractExpression(template[key]);
            
            const is = runComparators(nodeValue, value, {
                add,
                templateStore,
                plain,
            });
            
            if (!is)
                return false;
        }
    }
    
    return true;
}

const debug$2 = createDebug$1('putout:runner:template');

const {entries: entries$5} = Object;
const isFn$2 = (a) => typeof a === 'function';

const log$3 = (rule, path) => {
    debug$2.enabled && debug$2(rule, path.toString());
};

const {stringify: stringify$2} = JSON;

const exclude = ({rule, tmpl, fn, nodesExclude}) => {
    if (!isFn$2(fn) || !nodesExclude.length)
        return {
            [tmpl]: fn,
        };
    
    const visit = wrapWithCheck({
        rule,
        fn,
        nodesExclude,
        nodesInclude: [],
    });
    
    return {
        [tmpl]: visit,
    };
};

var template = ({rule, visitor, options}) => {
    const parsed = [];
    const nodesExclude = maybeArray$3(options.exclude);
    const nodesInclude = maybeArray$3(options.include);
    
    for (const [tmpl, fn] of entries$5(visitor)) {
        if (!tmpl)
            continue;
        
        if (!isTemplate(tmpl)) {
            parsed.push(exclude({
                rule,
                tmpl,
                fn,
                nodesExclude,
            }));
            continue;
        }
        
        const [node, type] = parseTemplate(tmpl);
        
        const visit = wrapWithCheck({
            rule,
            fn,
            nodesExclude,
            nodesInclude: [
                node,
                ...nodesInclude,
            ],
        });
        
        parsed.push({
            [type]: visit,
        });
    }
    
    return parsed;
};

const wrapWithCheck = ({rule, nodesInclude, nodesExclude, fn}) => (path) => {
    log$3(rule, path);
    
    if (nodesExclude.length && compareAny(path, nodesExclude))
        return;
    
    if (nodesInclude.length && !compareAll(path, nodesInclude))
        return;
    
    if (!isFn$2(fn))
        throw Error(` Looks like provided visitor is not a function: ${stringify$2(fn)}. More on using Traverser: https://git.io/JqcMn`);
    
    const [e] = tryCatch(fn, path);
    
    if (e) {
        e.rule = rule;
        throw e;
    }
};

var domain;

// This constructor is used to store event handlers. Instantiating this is
// faster than explicitly calling `Object.create(null)` to get a "clean" empty
// object (tested with v8 v4.9).
function EventHandlers() {}
EventHandlers.prototype = Object.create(null);

function EventEmitter() {
  EventEmitter.init.call(this);
}

// nodejs oddity
// require('events') === require('events').EventEmitter
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.usingDomains = false;

EventEmitter.prototype.domain = undefined;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

EventEmitter.init = function() {
  this.domain = null;
  if (EventEmitter.usingDomains) {
    // if there is an active domain, then attach to it.
    if (domain.active && !(this instanceof domain.Domain)) {
      this.domain = domain.active;
    }
  }

  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events, domain;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no 'error' event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] :
                                          [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
                            existing.length + ' ' + type + ' listeners added. ' +
                            'Use emitter.setMaxListeners() to increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }

  return target;
}
function emitWarning(e) {
  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || (list.listener && list.listener === listener)) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length; i-- > 0;) {
          if (list[i] === listener ||
              (list[i].listener && list[i].listener === listener)) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (list.length === 1) {
          list[0] = undefined;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };
    
// Alias for removeListener added in NodeJS 10.0
// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener
EventEmitter.prototype.off = function(type, listener){
    return this.removeListener(type, listener);
};

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        for (var i = 0, key; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        do {
          this.removeListener(type, listeners[listeners.length - 1]);
        } while (listeners[0]);
      }

      return this;
    };

EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === 'function')
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }

  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, i) {
  var copy = new Array(i);
  while (i--)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

const createProgress = () => {
    let pluginsCount = 0;
    let pluginsIndex = 0;
    
    const progress = new EventEmitter();
    
    progress.reset = () => {
        pluginsIndex = 0;
        pluginsCount = 0;
    };
    
    progress.file = ({i, n, percent, rule}) => {
        progress.emit('file', {
            i,
            n,
            rule,
            percent,
        });
    };
    
    progress.inc = () => {
        ++pluginsCount;
    };
    
    progress.start = (rule) => {
        ++pluginsIndex;
        progress.emit('start', {
            pluginsIndex,
            pluginsCount,
            rule,
        });
    };
    
    progress.push = (rule) => {
        progress.emit('push', {
            pluginsIndex,
            pluginsCount,
            rule,
        });
    };
    
    progress.end = (rule) => {
        progress.emit('end', {
            rule,
            pluginsIndex,
            pluginsCount,
        });
    };
    
    return progress;
};

const tryThrowWithReason = (fn, ...args) => {
    const [error, result] = tryCatch(fn, ...args);
    
    if (error) {
        error.reason ??= 'traverse';
        throw error;
    }
    
    return result;
};

const log$2 = createDebug$1('putout:runner:include');
const stub$1 = () => [];
const good = () => true;

const include$1 = ({rule, plugin, msg, options}) => {
    const {
        fix,
        report,
        include,
        exclude = stub$1,
        filter = good,
    } = plugin;
    
    validate('include', include);
    validate('report', report);
    
    const traverse = getTraverse$1(include(), filter, rule);
    
    return {
        rule,
        msg,
        options: {
            ...options,
            exclude: [
                ...exclude(),
                ...maybeArray$3(options.exclude),
            ],
        },
        plugin: {
            report,
            fix,
            traverse,
        },
    };
};

const prePush = ({rule, filter, push, options}) => (path) => {
    log$2(rule);
    
    if (!filter(path, {options}))
        return;
    
    push(path);
};

const getTraverse$1 = (include, filter, rule) => ({push, options}) => {
    const result = {};
    const visitor = prePush({
        rule,
        filter,
        push,
        options,
    });
    
    for (const str of include)
        result[str] = visitor;
    
    return result;
};

const wrap = (fn) => (...a) => (...b) => fn(...a, ...b);

var wraptile = (fn, ...a) => {
    check$4(fn);
    
    if (a.length)
        return wrap(fn)(...a);
    
    return wrap(fn);
};

function check$4(fn) {
    if (typeof fn !== 'function')
        throw Error('fn should be a function!');
}

var wraptile$1 = wraptile;

const {entries: entries$4} = Object;
const {isArray: isArray$2} = Array;

var findPath = (parentPath) => {
    let current = {
        parentPath,
    };
    
    const path = [];
    
    while (current = current.parentPath) {
        path.unshift(findKey(current, current.parent));
    }
    
    return path.join('.');
};

function findKey(path, parent) {
    const {node} = path;
    let key;
    let value;
    
    for ([key, value] of entries$4(parent)) {
        if (isArray$2(value)) {
            const index = value.indexOf(node);
            
            if (index >= 0)
                return `${key}.${index}`;
            
            continue;
        }
        
        if (value === node)
            break;
    }
    
    return key;
}

const {isProgram: isProgram$2} = lib_exports;
const name = '__putout_runner_replace';
const hasWatermark = (watermark) => (path) => path.node?.[name]?.has(watermark);

const watermark = (from, to, path) => {
    const {watermark, highWatermark} = create(from, to, path);
    const program = path.findParent(isProgram$2);
    const options = {
        watermark,
        highWatermark,
        program,
        path,
    };
    
    return {
        init: wraptile$1(init$2, options),
        has: wraptile$1(has, options),
        add: wraptile$1(add, options),
    };
};

const REPLACE_WATERMARK = name;

function create(from, to, path) {
    const watermark = `${from} -> ${to}`;
    const highWatermark = `${findPath(path)}: ${watermark}`;
    
    return {
        watermark,
        highWatermark,
    };
}

function init$2({path, program}) {
    if (path.node)
        path.node[name] = path.node[name] || new Set();
    
    program.node[name] = program.node[name] || new Set();
}

function add({path, program, watermark, highWatermark}) {
    init$2({
        path,
        program,
    });
    
    path?.node[name].add(watermark);
    program.node[name].add(highWatermark);
}

function has({path, program, watermark, highWatermark}) {
    const {node} = path;
    const {loc} = node;
    
    if (node?.[name].has(watermark) || path.findParent(hasWatermark(watermark)) && !loc)
        return true;
    
    return program.node[name].has(highWatermark);
}

const debug$1 = createDebug$1('putout:runner:replace');

const log$1 = (from, path) => {
    debug$1.enabled && debug$1(`${from} -> ${path}\n`);
};

const {
    isExpression,
    isStatement,
    isExpressionStatement,
} = lib_exports;

const PRINT_OPTIONS = {
    printer: ['putout', {
        format: {
            newline: '',
            indent: '',
            splitter: ' ',
            endOfFile: '',
        },
    }],
};

const isString$3 = (a) => typeof a === 'string';

const {keys: keys$1, entries: entries$3} = Object;
const {stringify: stringify$1} = JSON;

const stub = () => [];
const stubMatch = () => ({});
const packKeys = (a) => () => keys$1(a);
const isObject$1 = (a) => typeof a === 'object';

const replace = ({rule, plugin, msg, options}) => {
    const maybeMatch = plugin.match || stubMatch;
    const match = maybeMatch({
        options,
    });
    
    const {
        report,
        exclude = stub,
        replace,
        filter = getFilter(match),
    } = plugin;
    
    const replaceItems = replace({
        options,
    });
    
    const fix = getFix(replaceItems, match);
    const include = packKeys(replaceItems);
    
    return {
        rule,
        msg,
        options: {
            ...options,
            exclude: [
                ...exclude(),
                ...maybeArray$3(options.exclude),
            ],
        },
        plugin: {
            report,
            fix,
            filter,
            include,
        },
    };
};

const clearWatermark = (ast) => {
    delete ast.program[REPLACE_WATERMARK];
};

const isFn$1 = (a) => typeof a === 'function';

const parseExpression = (nodeFrom, {node}) => {
    if (nodeFrom.type !== node.type && isExpressionStatement(node))
        return node.expression;
    
    return node;
};

const fix$4 = (from, to, path) => {
    const nodeFrom = template$1.ast(from);
    const mark = watermark(from, to, path);
    
    mark.init();
    
    if (mark.has())
        return;
    
    const waysFrom = findVarsWays(nodeFrom);
    const node = parseExpression(nodeFrom, path);
    
    const values = getValues({
        waysFrom,
        node,
    });
    
    const nodeTo = parseTo(to, values, path);
    
    if (!nodeTo) {
        log$1(from, `''`);
        return remove(path);
    }
    
    checkExpressionStatement(nodeFrom, nodeTo, path);
    
    const waysTo = findVarsWays(nodeTo);
    const newPath = replaceWith$2(path, nodeTo);
    
    if (!nodeTo.__putout_replace_cooked) {
        validateTemplateValues(waysTo, waysFrom);
        
        setValues({
            waysTo,
            values,
            path: newPath,
        });
    }
    
    mark.add();
    path.scope
        .getBlockParent()
        .crawl();
    
    log$1(from, newPath);
};

const getFix = (items, match) => (path) => {
    for (const [from, to] of entries$3(items)) {
        const nodeFrom = template$1.ast(from);
        
        if (compare(path, nodeFrom, {findUp: false})) {
            const matchFn = match[from];
            
            if (!matchFn || runMatch(path, nodeFrom, matchFn))
                fix$4(from, to, path);
        }
    }
};

const getFilter = (match) => (path) => {
    const all = entries$3(match);
    
    for (const [from, matchProperty] of all) {
        const nodeFrom = template$1.ast(from);
        
        if (!compare(path.node, nodeFrom, {findUp: false}))
            continue;
        
        return runMatch(path, nodeFrom, matchProperty);
    }
    
    return true;
};

function runMatch(path, nodeFrom, matchProperty) {
    const waysFrom = findVarsWays(nodeFrom);
    const {node} = path;
    
    const values = getValues({
        waysFrom,
        node,
    });
    
    validateMatchProperty(matchProperty);
    
    return matchProperty(values, path);
}

function parseTo(to, values, path) {
    const toStr = isFn$1(to) ? to(values, path) : to;
    
    if (!toStr)
        return null;
    
    if (isObject$1(toStr) && toStr.type) {
        toStr.__putout_replace_cooked = true;
        return toStr;
    }
    
    if (!isString$3(toStr))
        throw Error(` Looks like you passed 'replace' value with a wrong type. Allowed: 'string', 'node' and 'path'. Received: '${typeof toStr}' with value '${toStr}'.`);
    
    return template$1.ast.fresh(toStr);
}

function validateMatchProperty(match) {
    if (!isFn$1(match))
        throw Error(` Looks like 'match' property value is not a 'function', but '${typeof match}' with value '${match}'.`);
}

const validateTemplateValues = (a, b) => {
    for (const key of keys$1(a)) {
        if (!b[key])
            throw Error(` Looks like template values not linked: ${stringify$1(keys$1(b))} -> ${stringify$1(keys$1(a))}`);
    }
};

function checkExpressionStatement(nodeFrom, nodeTo, path) {
    if (!isExpression(nodeFrom))
        return;
    
    if (!isStatement(nodeTo) || isExpressionStatement(nodeTo))
        return;
    
    if (isExpressionStatement(path) || isExpressionStatement(path.parentPath))
        return;
    
    throw Error(` Looks like a try to put Statement in place of Expression, use 'match' to filter out such cases: '${print(nodeFrom, PRINT_OPTIONS)} -> ${print(nodeTo, PRINT_OPTIONS)}'. For code: '${path}'`);
}

const prefix = '__putout_declare';
const getProgramParentPath = (path) => path.scope.getProgramParent().path;

const maybeInit = (a, b) => b[a] = b[a] || {};

const checkDeclarationForESLint = (name, path) => {
    const programPath = getProgramParentPath(path);
    maybeInit(prefix, programPath);
    
    return programPath[prefix][name];
};

const addDeclarationForESLint = (name, path) => {
    const programPath = getProgramParentPath(path);
    maybeInit(prefix, programPath);
    
    programPath[prefix][name] = true;
};

const setModuleType = (type, path) => {
    const programPath = getProgramParentPath(path);
    maybeInit(prefix, programPath);
    
    programPath[prefix].__putout_module_type = type;
    
    return type;
};

const getModuleType = (path) => {
    const programPath = getProgramParentPath(path);
    maybeInit(prefix, programPath);
    
    return programPath[prefix].__putout_module_type;
};

const {
    isImportDeclaration,
    isVariableDeclaration,
} = lib_exports;

const {keys} = Object;
const isString$2 = (a) => typeof a === 'string';

const getLastVarPath = (bodyPath) => bodyPath
    .filter(isVariableDeclaration)
    .pop();

const isLast = (insertionPath, bodyPath) => bodyPath.at(-1) === insertionPath;
const isLocalImport = (path) => path.node.source.value.includes('.');

const cutName = (a) => a
    .split('.')
    .shift();

const parseType = (path) => isESM(path) ? 'esm' : 'commonjs';

const TS_EXCLUDE = [
    'TSMethodSignature',
    'TSParameterProperty',
    'TSFunctionType',
    'TSDeclareMethod',
    'TSDeclareFunction',
    'TSTypeAliasDeclaration',
    'TSQualifiedName',
];

const declare$1 = (declarations) => ({
    report: report$3,
    include,
    fix: fix$3(declarations),
    filter: filter(declarations),
});

const report$3 = (path) => {
    const {name} = path.node;
    const peaceOfName = cutName(name);
    
    return `Declare '${peaceOfName}', it referenced but not defined`;
};

const include = () => [
    'ReferencedIdentifier',
];

const filter = (declarations) => (path, {options}) => {
    if (TS_EXCLUDE.includes(path.parentPath.type))
        return false;
    
    const {dismiss = [], type: typeOverride} = options;
    
    const allDeclarations = {
        ...declarations,
        ...options.declarations,
    };
    
    const names = keys(allDeclarations);
    const {scope, node} = path;
    const {name} = node;
    
    if (!names.includes(name))
        return false;
    
    if (dismiss.includes(name))
        return false;
    
    if (scope.hasBinding(name) || checkDeclarationForESLint(name, path))
        return false;
    
    const type = computeType(path, typeOverride);
    
    return parseCode(type, allDeclarations[name]);
};

const fix$3 = (declarations) => (path, {options}) => {
    const type = getModuleType(path);
    
    const allDeclarations = {
        ...declarations,
        ...options.declarations,
    };
    
    const {name} = path.node;
    const code = parseCode(type, allDeclarations[name]);
    
    const scope = path.scope.getProgramParent();
    const programPath = scope.path;
    const bodyPath = programPath.get('body');
    
    const node = template$1.ast.fresh(code);
    
    insert(node, bodyPath);
    addDeclarationForESLint(name, path);
};

const parseCode = (type, current) => {
    if (isString$2(current))
        return current;
    
    return current[type];
};

function getInsertionPath(node, bodyPath) {
    const lastImportPath = getLastImportPath(bodyPath);
    const lastVarPath = getLastVarPath(bodyPath);
    
    if (isVariableDeclaration(node) && lastImportPath)
        return lastImportPath;
    
    if ((isImportDeclaration(node) || isRequire(node)) && lastImportPath)
        return lastImportPath;
    
    if (isVariableDeclaration(node) && lastVarPath && !isLast(lastVarPath, bodyPath))
        return lastVarPath;
    
    return null;
}

const isRequire = (node) => compare(node, 'const __a = require(__b)');

function insert(node, bodyPath) {
    const insertionPath = getInsertionPath(node, bodyPath);
    const [first] = bodyPath;
    
    if (isVariableDeclaration(node) && isImportDeclaration(insertionPath) || isRequire(insertionPath))
        return insertAfter(insertionPath, node);
    
    if (isVariableDeclaration(node)) {
        if (isRequire(first))
            return first.insertAfter(node);
        
        return first.insertBefore(node);
    }
    
    if (!insertionPath)
        return first.insertBefore(node);
    
    if (insertionPath.isImportDeclaration() && isLocalImport(insertionPath))
        return insertionPath.insertBefore(node);
    
    return insertAfter(insertionPath, node);
}

const getLastImportPath = (bodyPath) => {
    const imports = [];
    const localImports = [];
    
    for (const path of bodyPath) {
        if (!path.isImportDeclaration())
            continue;
        
        if (isLocalImport(path)) {
            localImports.push(path);
            continue;
        }
        
        imports.push(path);
    }
    
    return imports.pop() || localImports.pop();
};

function computeType(path, type) {
    if (type)
        return setModuleType(type, path);
    
    const newType = getModuleType(path);
    
    if (newType)
        return newType;
    
    return setModuleType(parseType(path), path);
}

const {stringify} = JSON;
const isFn = (a) => typeof a === 'function';

const declare = ({rule, plugin, msg, options}) => {
    validateDeclare(plugin.declare);
    
    return {
        rule,
        plugin: declare$1(plugin.declare()),
        msg,
        options,
    };
};

function validateDeclare(declare) {
    if (!isFn(declare))
        throw Error(` Looks like 'declare' property value is not a 'function', but '${typeof declare}' with value '${stringify(declare)}'.`);
}

const __filesystem_name$3 = '__putout_processor_filesystem';
var __filesystem_name_1 = __filesystem_name$3;

const driverStore = fullstore$1();

const {assign} = Object;
const noop = () => {};
const returns = (a) => () => a;

const defaultFS = {
    renameFile: noop,
    removeFile: noop,
    createDirectory: noop,
    readFileContent: returns(''),
    writeFileContent: noop,
    copyFile: noop,
};

const maybeFS = assign({}, defaultFS);

const renameFile$1 = (oldName, newName) => {
    maybeFS.renameFile(oldName, newName);
};

const removeFile$1 = (name) => {
    maybeFS.removeFile(name);
};

const copyFile$1 = (from, to) => {
    maybeFS.copyFile(from, to);
};

const createDirectory$2 = (name) => {
    maybeFS.createDirectory(name);
};

const readFileContent$1 = (name) => {
    return maybeFS.readFileContent(name);
};

const writeFileContent$1 = (name, content) => {
    maybeFS.writeFileContent(name, content);
};

function init$1(fsDriver) {
    assign(maybeFS, fsDriver);
}

const pause$1 = () => {
    driverStore(maybeFS);
    deinit$1();
};

const start$1 = () => {
    init$1(driverStore());
};

function deinit$1() {
    assign(maybeFS, defaultFS);
}

var maybeFS$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	copyFile: copyFile$1,
	createDirectory: createDirectory$2,
	deinit: deinit$1,
	init: init$1,
	pause: pause$1,
	readFileContent: readFileContent$1,
	removeFile: removeFile$1,
	renameFile: renameFile$1,
	start: start$1,
	writeFileContent: writeFileContent$1
});

const {
    arrayExpression: arrayExpression$2,
    stringLiteral: stringLiteral$4,
    objectProperty: objectProperty$2,
} = lib_exports;

const createTypeProperty = (type) => {
    const value = stringLiteral$4(type);
    return createProperty$1('type', value);
};

const createFilesProperty = (files) => {
    const value = arrayExpression$2(files);
    return createProperty$1('files', value);
};

const createFilenameProperty = (filename) => {
    const value = stringLiteral$4(filename);
    return createProperty$1('filename', value);
};

const createContentProperty = (content) => {
    const value = stringLiteral$4(content);
    return createProperty$1('content', value);
};

function createProperty$1(name, value) {
    const key = stringLiteral$4(name);
    return objectProperty$2(key, value);
}

const {
    isProgram: isProgram$1,
    objectExpression: objectExpression$1,
} = lib_exports;

const isString$1 = (a) => typeof a === 'string';
const {isArray: isArray$1} = Array;
const maybeArray = (a) => isArray$1(a) ? a : [a];

const toBase64 = (content) => {
    const [e, result] = tryCatch(btoa, content);
    
    if (e)
        return btoa(escape(content));
    
    return result;
};

const fromBase64 = (content) => {
    if (content.includes(' '))
        return content;
    
    const [e, decoded] = tryCatch(atob, content);
    
    if (!e)
        return unescape(decoded);
    
    return content;
};

const getRegExp = (wildcard) => {
    const escaped = wildcard
        .replace(/\./g, '\\.')
        .replace(/\*/g, '.*')
        .replace('?', '.?');
    
    return RegExp(`^${escaped}$`);
};

function getParentDirectory(filePath) {
    if (!filePath.parentPath)
        return null;
    
    const {parentPath} = filePath.parentPath.parentPath;
    
    if (isProgram$1(parentPath))
        return null;
    
    return parentPath;
}

function isExcluded({name, base, exclude}) {
    for (const currentExclude of exclude) {
        if (name === currentExclude || getRegExp(currentExclude).test(base))
            return true;
    }
    
    return false;
}

function findFile$2(node, name, exclude = []) {
    checkName(name);
    
    const filePaths = [];
    const names = maybeArray(name);
    
    for (const filenamePath of traverseProperties(node, 'filename')) {
        const {value} = filenamePath.node.value;
        const base = basename$1(value);
        
        for (const name of names) {
            if (value === name || getRegExp(name).test(base)) {
                const path = filenamePath.parentPath;
                const excluded = isExcluded({
                    name,
                    base,
                    exclude,
                });
                
                if (excluded)
                    continue;
                
                filePaths.push(path);
            }
        }
    }
    
    return filePaths;
}

function checkName(name) {
    if (!isString$1(name) && !isArray$1(name))
        throw Error(` Looks like you forget to pass the 'name' of a file to 'findFile(filePath: Path|FilePath, name: string | string[]): FilePath'`);
}

function getFilenamePath(filePath) {
    const filenamePath = getProperty$2(filePath, 'filename');
    return filenamePath.get('value');
}

function getFilename$2(filePath) {
    const {value} = getFilenamePath(filePath).node;
    return value;
}

function getFileType$2(filePath) {
    const typePath = getProperty$2(filePath, 'type');
    return typePath.node.value.value;
}

function getFileContent(filePath) {
    const content = getProperty$2(filePath, 'content');
    
    return [
        Boolean(content),
        content?.node.value.value,
    ];
}

const renameFile = (filePath, name) => {
    const oldName = getFilename$2(filePath);
    const valuePath = getFilenamePath(filePath);
    const baseName = oldName
        .split('/')
        .pop();
    
    const newName = name
        .split('/')
        .pop();
    
    const newFilename = oldName.replace(baseName, newName);
    
    setLiteralValue(valuePath, newFilename);
    renameFile$1(oldName, newFilename);
};

function removeFile(filePath) {
    const filename = getFilename$2(filePath);
    
    if (!getParentDirectory(filePath))
        return;
    
    filePath.remove();
    removeFile$1(filename);
}

const removeEmptyDirectory = (dirPath) => {
    const type = getFileType$2(dirPath);
    
    if (type !== 'directory')
        return;
    
    let nextParentDir = dirPath;
    
    while (!readDirectory(dirPath).length) {
        const name = getFilename$2(dirPath);
        
        if (name === '/')
            break;
        
        nextParentDir = getParentDirectory(dirPath);
        
        if (!nextParentDir)
            break;
        
        removeFile(dirPath);
        dirPath = nextParentDir;
    }
};

const moveFile = (filePath, dirPath) => {
    if (filePath === dirPath)
        return;
    
    const dirname = getFilename$2(dirPath);
    const filename = getFilename$2(filePath);
    const dirPathFiles = getFiles$1(dirPath);
    const filenamePath = getProperty$2(filePath, 'filename');
    
    const basename = filename
        .split('/')
        .pop();
    
    const newFilename = join$1(dirname, basename);
    
    maybeRemoveFile(dirPath, newFilename);
    
    setLiteralValue(filenamePath.get('value'), newFilename);
    dirPathFiles.node.value.elements.push(filePath.node);
    
    filePath.remove();
    renameFile$1(filename, newFilename);
};

const copyFile = (filePath, dirPath) => {
    const dirname = getFilename$2(dirPath);
    const filename = getFilename$2(filePath);
    
    const basename = filename
        .split('/')
        .pop();
    
    const newFilename = join$1(dirname, basename);
    const [hasContent, content] = getFileContent(filePath);
    
    const copiedFile = objectExpression$1([
        createTypeProperty('file'),
        createFilenameProperty(newFilename),
        hasContent && createContentProperty(content),
    ].filter(Boolean));
    
    maybeRemoveFile(dirPath, newFilename);
    
    const dirPathFiles = getFiles$1(dirPath);
    dirPathFiles.node.value.elements.push(copiedFile);
    
    copyFile$1(filename, newFilename);
};

function maybeRemoveFile(dirPath, filename) {
    const type = getFileType$2(dirPath);
    
    if (type !== 'directory') {
        const filename = getFilename$2(dirPath);
        throw Error(` Looks like '${filename}' is not a directory, but: '${type}'. Rename to '${filename}/'`);
    }
    
    const dirPathFiles = getProperty$2(dirPath, 'files');
    const name = join$1(getFilename$2(dirPath), basename$1(filename));
    const [fileToOverwrite] = findFile$2(dirPathFiles, name);
    
    if (!fileToOverwrite)
        return;
    
    fileToOverwrite.remove();
}

const createFile = (dirPath, name, content) => {
    maybeRemoveFile(dirPath, name);
    
    const dirPathFiles = getFiles$1(dirPath);
    const parentFilename = getFilename$2(dirPath);
    const filename = join$1(parentFilename, name);
    
    const typeProperty = createTypeProperty('file');
    const filenameProperty = createFilenameProperty(filename);
    
    const properties = [
        typeProperty,
        filenameProperty,
        content && createContentProperty(content),
    ].filter(Boolean);
    
    dirPathFiles.node.value.elements.push(objectExpression$1(properties));
    
    const filePath = dirPathFiles.get('value.elements').at(-1);
    
    if (isString$1(content))
        writeFileContent(filePath, content);
    
    return filePath;
};

const getFiles$1 = (dirPath) => getProperty$2(dirPath, 'files');

function readDirectory(dirPath) {
    const fileType = getFileType$2(dirPath);
    
    if (fileType !== 'directory')
        return [];
    
    return getFiles$1(dirPath).get('value.elements');
}

function createDirectory$1(dirPath, name) {
    const dirPathFiles = getFiles$1(dirPath);
    const parentFilename = getFilename$2(dirPath);
    const filename = join$1(parentFilename, name);
    
    const typeProperty = createTypeProperty('directory');
    const filesProperty = createFilesProperty([]);
    const filenameProperty = createFilenameProperty(filename);
    
    dirPathFiles.node.value.elements.push(objectExpression$1([
        typeProperty,
        filenameProperty,
        filesProperty,
    ]));
    
    createDirectory$2(filename);
    
    return dirPathFiles.get('value.elements').at(-1);
}

const readFileContent = (filePath) => {
    const fileType = getFileType$2(filePath);
    
    if (fileType === 'directory')
        return '';
    
    const [hasContent, content] = getFileContent(filePath);
    
    if (hasContent)
        return fromBase64(content);
    
    const filename = getFilename$2(filePath);
    const fileContent = readFileContent$1(filename);
    
    const property = createContentProperty(toBase64(fileContent));
    
    filePath.node.properties.push(property);
    
    return fileContent;
};

function writeFileContent(filePath, content) {
    const fileType = getFileType$2(filePath);
    
    if (fileType === 'directory')
        return;
    
    const filename = getFilename$2(filePath);
    
    writeFileContent$1(filename, content);
    
    const contentPath = getProperty$2(filePath, 'content');
    
    if (contentPath) {
        setLiteralValue(contentPath.node.value, toBase64(content));
        return;
    }
    
    const property = createContentProperty(toBase64(content));
    filePath.node.properties.push(property);
}

const createNestedDirectory = (path, name) => {
    const rootPath = getRootDirectory(path);
    const dir = dirname$1(name);
    
    if (dir === getFilename$2(path))
        return createDirectory$1(path, basename$1(name));
    
    let currentDir = name;
    
    const rootDir = getFilename$2(rootPath);
    const directories = [];
    let prevDir = currentDir;
    
    while (currentDir !== rootDir) {
        directories.unshift(currentDir);
        prevDir = currentDir;
        currentDir = dirname$1(currentDir);
        
        if (currentDir === prevDir) {
            currentDir = rootDir;
            
            for (const [i, dir] of directories.entries()) {
                directories[i] = join$1(rootDir, dir);
            }
            
            directories.shift();
            break;
        }
    }
    
    let lastDirectoryPath = findFile$2(rootPath, directories).at(-1) || rootPath;
    const lastDirectoryName = getFilename$2(lastDirectoryPath);
    
    const n = directories.length;
    
    let i = directories.indexOf(lastDirectoryName) + 1;
    
    for (; i < n; i++) {
        const name = basename$1(directories[i]);
        lastDirectoryPath = createDirectory$1(lastDirectoryPath, name);
    }
    
    return lastDirectoryPath;
};

function getRootDirectory(path) {
    let currentDirPath = getParentDirectory(path);
    
    if (!currentDirPath)
        return path;
    
    let prevPath = currentDirPath;
    
    while (currentDirPath = getParentDirectory(currentDirPath)) {
        prevPath = currentDirPath;
    }
    
    return prevPath;
}

const {
    init,
    deinit,
    pause,
    start,
} = maybeFS$1;

var filesystem = /*#__PURE__*/Object.freeze({
	__proto__: null,
	copyFile: copyFile,
	createDirectory: createDirectory$1,
	createFile: createFile,
	createNestedDirectory: createNestedDirectory,
	deinit: deinit,
	findFile: findFile$2,
	getFileContent: getFileContent,
	getFileType: getFileType$2,
	getFilename: getFilename$2,
	getParentDirectory: getParentDirectory,
	getRootDirectory: getRootDirectory,
	init: init,
	moveFile: moveFile,
	pause: pause,
	readDirectory: readDirectory,
	readFileContent: readFileContent,
	removeEmptyDirectory: removeEmptyDirectory,
	removeFile: removeFile,
	renameFile: renameFile,
	start: start,
	writeFileContent: writeFileContent
});

var convertSimpleFilesystemToFilesystem = {};

var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_path);

var require$$0 = /*@__PURE__*/getAugmentedNamespace(bundle);

var require$$3 = /*@__PURE__*/getAugmentedNamespace(filesystem);

const cut = (a) => a.slice(0, a.indexOf('('));
const createPrefix = (name) => {
    if (name.includes('('))
        return `${cut(name)}(`;
    
    return `${name}(`;
};

const createSuffix = () => ');\n';
const maybeNewline = (a) => a.at(-1) === '\n' ? a : `${a}\n`;

const __json_name = '__putout_processor_json';
const __yaml_name = '__putout_processor_yaml';
const __toml_name = '__putout_processor_toml';
const __filesystem_name$2 = '__putout_processor_filesystem';
const __ignore_name = '__putout_processor_ignore';

const __json = `${__json_name}(__object)`;
const __yaml = `${__yaml_name}(__object)`;
const __toml = `${__toml_name}(__object)`;
const __filesystem = `${__filesystem_name$2}(__object)`;
const __ignore = `${__ignore_name}(__array)`;

const TYPES = [
    __json_name,
    __yaml_name,
    __filesystem_name$2,
    __ignore_name,
];

const toJS = (source, name = __json) => {
    const prefix = createPrefix(name);
    const suffix = createSuffix();
    
    return `${prefix}${source}${suffix}`;
};

const fromJS = (source, name = __json) => {
    source = maybeNewline(source);
    const shortName = cut(name);
    
    source = source.slice(source.indexOf(shortName));
    
    const prefix = createPrefix(name);
    const suffix = createSuffix();
    const length = source.length - suffix.length;
    const sliced = source.slice(prefix.length, length);
    
    return maybeNewline(removeBlankLines$1(sliced));
};

const isJSON = (source) => {
    for (const type of TYPES) {
        if (!source.indexOf(type))
            return true;
    }
    
    return false;
};

var json = /*#__PURE__*/Object.freeze({
	__proto__: null,
	__filesystem: __filesystem,
	__filesystem_name: __filesystem_name$2,
	__ignore: __ignore,
	__ignore_name: __ignore_name,
	__json: __json,
	__json_name: __json_name,
	__toml: __toml,
	__toml_name: __toml_name,
	__yaml: __yaml,
	__yaml_name: __yaml_name,
	fromJS: fromJS,
	isJSON: isJSON,
	toJS: toJS
});

var require$$2 = /*@__PURE__*/getAugmentedNamespace(json);

var require$$1 = /*@__PURE__*/getAugmentedNamespace(operate);

const {basename, dirname} = require$$0$1;
const {types: types$1} = require$$0;
const {
    createDirectory,
    getFileType: getFileType$1,
    getFilename: getFilename$1,
    findFile: findFile$1,
} = require$$3;

const {__filesystem_name: __filesystem_name$1} = require$$2;
const {replaceWith: replaceWith$1, getProperty: getProperty$1} = require$$1;

const {
    objectExpression,
    arrayExpression: arrayExpression$1,
    stringLiteral: stringLiteral$3,
    isArrayExpression,
    isStringLiteral,
    isTemplateLiteral,
    objectProperty: objectProperty$1,
} = types$1;

convertSimpleFilesystemToFilesystem.report = () => `Convert Simple Filesystem to Filesystem`;

const isDirectory = (a) => a.endsWith('/');
const getType = (a) => {
    const type = isDirectory(a) ? 'directory' : 'file';
    
    return objectProperty$1(stringLiteral$3('type'), stringLiteral$3(type));
};

const createFilename = (filename) => {
    return objectProperty$1(stringLiteral$3('filename'), stringLiteral$3(filename));
};

const getFiles = (a) => {
    if (isDirectory(a))
        return objectProperty$1(stringLiteral$3('files'), arrayExpression$1([]));
    
    return null;
};

const getContent = (a) => {
    return objectProperty$1(stringLiteral$3('content'), stringLiteral$3(a));
};

function parseContent(node, path) {
    if (isStringLiteral(node))
        return node.value;
    
    if (isTemplateLiteral(node))
        return btoa(node.quasis[0].value.raw);
    
    throw Error(` Looks like wrong content type: '${node.type}' from file: '${path}'`);
}

convertSimpleFilesystemToFilesystem.fix = (path) => {
    const array = arrayExpression$1([]);
    
    for (const element of path.get('elements')) {
        if (isArrayExpression(element)) {
            const [nodeValue, nodeContent] = element.node.elements;
            const {value} = nodeValue;
            
            const content = parseContent(nodeContent, element);
            
            array.elements.push(objectExpression([
                getType(value),
                createFilename(value),
                getContent(content),
            ]));
            continue;
        }
        
        if (isStringLiteral(element)) {
            const {value} = element.node;
            
            array.elements.push(objectExpression([
                getType(value),
                createFilename(noTrailingSlash(value)),
                getFiles(value),
            ].filter(Boolean)));
            continue;
        }
        
        throw Error(` Looks like file '${element}' has wrong type: '${element.type}' expected: 'string | array'`);
    }
    
    buildTree(path, array);
};

convertSimpleFilesystemToFilesystem.traverse = ({push}) => ({
    [`${__filesystem_name$1}(__array)`]: (path) => {
        const root = path.get('arguments.0');
        push(root);
    },
});

const noTrailingSlash = (a) => {
    if (a === '/')
        return a;
    
    return a.endsWith('/') ? a.slice(0, -1) : a;
};

function buildTree(path, list) {
    const [root, ...files] = findFile$1(list, '*');
    
    for (const filePath of files) {
        const filename = getFilename$1(filePath);
        
        check$3(filename);
        
        const type = getFileType$1(filePath);
        const dir = dirname(filename);
        const name = basename(filename);
        const [dirPath] = findFile$1(root, dir);
        
        if (!dirPath || getFileType$1(dirPath) !== 'directory')
            throw Error(` Looks like directory '${dir}/' is missing`);
        
        if (type === 'directory') {
            createDirectory(dirPath, name);
            continue;
        }
        
        const filesProperty = getProperty$1(dirPath, 'files');
        filesProperty.node.value.elements.push(filePath.node);
    }
    
    replaceWith$1(path, root);
}

function check$3(filename) {
    if (!filename.includes('/'))
        throw Error(` Looks like directory path is missing: '${filename}'`);
}

var convertFilesystemToSimpleFilesystem = {};

const {types} = require$$0;
const {replaceWith, getProperty} = require$$1;
const {__filesystem_name} = require$$2;

const {
    findFile,
    getFilename,
    getFileType,
} = require$$3;

const {
    stringLiteral: stringLiteral$2,
    arrayExpression,
} = types;

const {isArray} = Array;
const maybeAddSlash = (a) => a === '/' ? a : `${a}/`;

convertFilesystemToSimpleFilesystem.report = () => `Convert Filesystem to Simple Filesystem`;

convertFilesystemToSimpleFilesystem.fix = (root, {files}) => {
    const names = [];
    
    for (const file of files) {
        const filename = getFilename(file);
        const type = getFileType(file);
        const contentPath = getProperty(file, 'content');
        const content = contentPath?.node?.value;
        
        if (content) {
            names.push([filename, content.value]);
            continue;
        }
        
        if (type === 'directory') {
            names.push(maybeAddSlash(filename));
            continue;
        }
        
        names.push(filename);
    }
    
    const list = [];
    
    for (const name of names) {
        if (isArray(name)) {
            list.push(arrayExpression([
                stringLiteral$2(name[0]),
                stringLiteral$2(name[1]),
            ]));
            continue;
        }
        
        list.push(stringLiteral$2(name));
    }
    
    replaceWith(root, arrayExpression(list));
};

convertFilesystemToSimpleFilesystem.traverse = ({push}) => ({
    [`${__filesystem_name}(__object)`]: (path) => {
        const root = path.get('arguments.0');
        const files = findFile(root, '*');
        
        push(root, {
            files,
        });
    },
});

const log = createDebug$1('putout:runner:scanner');

const scan$1 = ({rule, plugin, msg, options}, {progress}) => {
    const {
        scan,
        report,
        fix,
    } = plugin;
    
    progress.inc();
    
    const traverse = getTraverse({
        scan,
        rule,
        progress,
    });
    
    return {
        rule,
        msg,
        options,
        plugin: {
            report,
            fix,
            traverse,
        },
    };
};

const watchPush = ({push, rule, progress}) => (...a) => {
    progress.push(rule);
    push(...a);
};

const createFileProgress = ({rule, progress}) => ({i, n}) => {
    ++i;
    const percent = `${Math.round(i / n * 100)}%`;
    
    progress.file({
        i,
        n,
        percent,
        rule,
    });
};

const createTrackFile = (fileProgress) => function*(...a) {
    const files = findFile$2(...a);
    const n = files.length;
    
    for (const [i, file] of files.entries()) {
        fileProgress({
            i,
            n,
        });
        yield file;
    }
};

const getTraverse = ({scan, rule, progress}) => ({push, options}) => ({
    [`${__filesystem_name_1}(__)`](path) {
        log(rule);
        progress.start(rule);
        
        const rootPath = path.get('arguments.0');
        const isSimple = fullstore$1(false);
        
        const fileProgress = createFileProgress({
            rule,
            progress,
        });
        
        const trackFile = createTrackFile(fileProgress);
        
        runSimple(convertSimpleFilesystemToFilesystem, {
            shouldConvert: true,
            path,
            isSimple,
        });
        
        scan(rootPath, {
            push: watchPush({
                push,
                rule,
                progress,
            }),
            progress: fileProgress,
            trackFile,
            options,
        });
        
        runSimple(convertFilesystemToSimpleFilesystem, {
            shouldConvert: isSimple(),
            path,
            isSimple,
        });
        
        progress.end(rule);
    },
});

const runFix = ({fix, isSimple}) => (...a) => {
    isSimple(true);
    return fix(...a);
};

function runSimple(plugin, {path, isSimple, shouldConvert = true}) {
    const {traverse, fix} = plugin;
    
    if (!shouldConvert)
        return;
    
    const push = runFix({
        fix,
        isSimple,
    });
    
    const visitors = traverse({
        push,
    });
    
    const [visit, template] = parseVisitor(visitors);
    
    if (compare(path, template)) {
        pause();
        visit(path);
        start();
    }
}

function parseVisitor(visitors) {
    const to = visitors[`${__filesystem_name_1}(__object)`];
    const from = visitors[`${__filesystem_name_1}(__array)`];
    
    if (to)
        return [
            to,
            `${__filesystem_name_1}(__object)`,
        ];
    
    return [
        from,
        `${__filesystem_name_1}(__array)`,
    ];
}

const debug = createDebug$1('putout:runner:find');
const isRemoved = (a) => a?.removed;

const runPlugins = ({ast, shebang, fix, fixCount = 2, plugins, progress = createProgress(), traverse = traverse3}) => {
    let places = [];
    
    const merge = onceExports(mergeVisitors);
    const {
        pluginsFind,
        pluginsTraverse,
    } = splitPlugins(plugins, {
        progress,
    });
    
    for (let i = 0; i < fixCount; i++) {
        places = run({
            ast,
            fix,
            shebang,
            pluginsFind,
            pluginsTraverse,
            merge,
            template,
            traverse,
        });
        
        progress.reset();
        
        if (!fix || !places.length)
            return places;
        
        clearWatermark(ast);
    }
    
    return places;
};

const run = ({ast, fix, shebang, pluginsFind, pluginsTraverse, template, merge, traverse}) => [
    ...runWithoutMerge({
        ast,
        fix,
        shebang,
        template,
        pluginsFind,
        traverse,
    }),
    ...runWithMerge({
        ast,
        fix,
        shebang,
        template,
        pluginsTraverse,
        merge,
        traverse,
    }),
];

function runWithMerge({ast, fix, shebang, template, pluginsTraverse, merge, traverse}) {
    const {entries, visitor} = merge(pluginsTraverse, {
        fix,
        shebang,
        template,
    });
    
    tryThrowWithReason(traverse, ast, visitor);
    
    const places = [];
    
    for (const [rule, pull] of entries) {
        const items = pull();
        
        for (const {message, position} of items) {
            places.push({
                rule,
                message,
                position,
            });
        }
    }
    
    return places;
}

function runWithoutMerge({ast, fix, shebang, template, pluginsFind, traverse}) {
    const places = [];
    
    for (const {rule, plugin, msg, options} of pluginsFind) {
        debug(`find: ${rule}`);
        
        const {report, find} = plugin;
        
        const items = tryThrowWithReason(superFind, {
            rule,
            find,
            ast,
            options,
            fix,
            shebang,
            template,
            traverse,
        });
        
        if (!items.length)
            continue;
        
        for (const item of items) {
            const message = msg || report(item);
            const {parentPath} = getPath(item);
            const position = getPosition(item, shebang);
            
            places.push({
                rule,
                message,
                position,
            });
            
            if (isRemoved(parentPath))
                continue;
            
            runFix$1(fix, plugin.fix, {
                path: item,
                rule,
                position,
                options,
            });
        }
    }
    
    return places;
}

function splitPlugins(plugins, {progress}) {
    const pluginsFind = [];
    const pluginsTraverse = [];
    
    for (const item of plugins) {
        const {plugin} = item;
        
        if (plugin.find) {
            pluginsFind.push(item);
            continue;
        }
        
        if (plugin.traverse) {
            pluginsTraverse.push(item);
            continue;
        }
        
        if (plugin.replace) {
            pluginsTraverse.push(include$1(replace(item)));
            continue;
        }
        
        if (plugin.declare) {
            pluginsTraverse.push(include$1(declare(item)));
            continue;
        }
        
        if (plugin.include) {
            pluginsTraverse.push(include$1(item));
            continue;
        }
        
        if (plugin.scan) {
            pluginsTraverse.push(scan$1(item, {
                progress,
            }));
            continue;
        }
    }
    
    return {
        pluginsFind,
        pluginsTraverse,
    };
}

const defaultOptions = (opts = {}) => {
    const {
        parser = 'babel',
        printer = opts.printer || 'putout',
        fix = true,
        fixCount = 4,
        loadPlugins: loadPlugins$1 = loadPlugins,
        loadPluginsAsync: loadPluginsAsync$1 = loadPluginsAsync,
        runPlugins: runPlugins$1 = runPlugins,
        progress = createProgress(),
    } = opts;
    
    return {
        ...opts,
        parser,
        printer,
        fix,
        fixCount,
        loadPlugins: loadPlugins$1,
        loadPluginsAsync: loadPluginsAsync$1,
        runPlugins: runPlugins$1,
        progress,
    };
};

const parseError$1 = (e, type = 'parser') => {
    const {line, column} = e.loc || {
        line: 1,
        column: 1,
    };
    
    const rule = e.rule ? `${e.rule} (parser)` : type;
    const message = cutBrackets(e.message);
    
    return [{
        rule,
        message,
        position: {
            line,
            column,
        },
    }];
};

const cutBrackets = (a) => a.replace(/\s\(\d:\d+\)/, '');

const maybeParseError = (a) => !a ? [] : parseError$1(a, 'loader');

// why we pass 'source' to 'transform()'?
// because we need to calculate position in a right way
// and determine is shebang is existing
//
// 25     return {
// 26         line: shebang ? line + 1 : line,
// 27         column,
// 28     };
//
const transform = (ast, source, opts) => {
    opts = defaultOptions(opts);
    
    const {
        plugins: pluginNames,
        rules,
        fix,
        fixCount,
        loadPlugins,
        runPlugins,
        progress,
    } = opts;
    
    const [, shebang] = cutShebang(source);
    
    const [validationError] = tryCatch(validateRulesRelations, {
        rules,
        pluginNames,
    });
    
    const plugins = loadPlugins({
        pluginNames,
        rules,
    });
    
    const places = runPlugins({
        ast,
        shebang,
        fix,
        fixCount,
        plugins,
        progress,
    });
    
    return [
        ...maybeParseError(validationError),
        ...places,
    ];
};

const transformAsync = async (ast, source, opts) => {
    opts = defaultOptions(opts);
    
    const {
        plugins: pluginNames,
        rules,
        fix,
        fixCount,
        loadPluginsAsync,
        runPlugins,
        progress,
    } = opts;
    
    const [, shebang] = cutShebang(source);
    
    const [validationError] = tryCatch(validateRulesRelations, {
        rules,
        pluginNames,
    });
    
    const plugins = await loadPluginsAsync({
        pluginNames,
        rules,
    });
    
    const places = runPlugins({
        ast,
        shebang,
        fix,
        fixCount,
        plugins,
        progress,
    });
    
    return [
        ...maybeParseError(validationError),
        ...places,
    ];
};

const putout = (source, opts) => {
    check$2(source);
    opts = defaultOptions(opts);
    
    const {
        parser,
        isTS,
        isJSX,
        printer,
    } = opts;
    
    const [clearSource, shebang] = cutShebang(source);
    
    const ast = parse$2(clearSource, {
        parser,
        isTS,
        isJSX,
        printer,
    });
    
    const places = transform(ast, source, opts);
    
    if (!opts.fix)
        return {
            code: source,
            places,
        };
    
    const printed = print(ast, {
        printer,
        source,
    });
    
    const code = mergeShebang(shebang, printed);
    
    return {
        code,
        places,
    };
};

const putoutAsync = async (source, opts) => {
    check$2(source);
    opts = defaultOptions(opts);
    
    const {
        parser,
        isTS,
        isJSX,
        printer,
    } = opts;
    
    const [clearSource, shebang] = cutShebang(source);
    
    const ast = parse$2(clearSource, {
        parser,
        isTS,
        isJSX,
        printer,
    });
    
    const places = await transformAsync(ast, source, opts);
    
    if (!opts.fix)
        return {
            code: source,
            places,
        };
    
    const printed = print(ast, {
        printer,
    });
    
    const code = mergeShebang(shebang, printed);
    
    return {
        code,
        places,
    };
};

const isString = (a) => typeof a === 'string';

function check$2(source) {
    if (!isString(source))
        throw Error(` Looks like 'source' has type '${typeof source}', expected: 'string'`);
}

const {isFile, isProgram} = lib_exports;
const {merge} = traverse3.visitors;
const {entries: entries$2} = Object;

const isPath = (path) => Boolean(path.node);

const createTraverse = (path) => {
    if (isPath(path))
        return path.traverse.bind(path);
    
    const noScope = !isFile(path) && !isProgram(path);
    
    return (visitors) => {
        traverse3(path, {
            noScope,
            ...visitors,
        });
    };
};

const getTemplate = ([a]) => a;

function traverse$1(basePath, visitor) {
    const traverse = createTraverse(basePath);
    const items = [];
    const parsedVisitors = entries$2(visitor);
    
    const withTemplates = parsedVisitors
        .map(getTemplate)
        .find(isTemplate);
    
    if (!withTemplates)
        return traverse(visitor);
    
    for (const [tmpl, fn] of parsedVisitors) {
        if (!isTemplate(tmpl)) {
            items.push({
                [tmpl]: fn,
            });
            continue;
        }
        
        const [node, type] = parseTemplate(tmpl);
        const visit = getVisit({
            fn,
            node,
            tmpl,
        });
        
        items.push({
            [type]: visit,
        });
    }
    
    traverse(merge(items));
}

const getVisit = ({fn, node, tmpl}) => (path) => {
    if (!compare(path, node))
        return;
    
    fn(path, getTemplateValues(path.node, tmpl));
};

const contains = (path, items) => {
    let found = false;
    
    const visit = (path) => {
        found = true;
        path.stop();
    };
    
    const visitors = {};
    
    for (const item of items) {
        visitors[item] = visit;
    }
    
    traverse$1(path, visitors);
    
    return found;
};

const {
    isJSXElement,
    jsxAttribute,
    jsxIdentifier,
    stringLiteral: stringLiteral$1,
} = lib_exports;

const getNode = (a) => a.node || a;

const hasTagName = (path, name) => {
    const node = getNode(path);
    
    if (!isJSXElement(path))
        return false;
    
    return node.openingElement.name.name === name;
};

const getAttributePath = (path, name) => {
    const attributes = path.get('openingElement.attributes');
    
    for (const attr of attributes) {
        if (attr.node.name.name === name)
            return attr;
    }
    
    return null;
};

function getAttributeNode(path, name) {
    let result = null;
    const node = getNode(path);
    const {attributes} = node.openingElement;
    
    for (const attr of attributes) {
        if (attr.name.name === name) {
            result = attr;
            break;
        }
    }
    
    return result;
}

function getAttributeValue(path, attributeName) {
    const attribute = getAttributeNode(path, attributeName);
    
    if (!attribute)
        return '';
    
    return attribute.value.value;
}

function addAttributeValue(path, name, value) {
    const attributeNode = getAttributeNode(path, name);
    
    if (!attributeNode)
        return addAttribute(path, name, value);
    
    if (attributeNode.value.value.includes(value))
        return;
    
    setLiteralValue(attributeNode.value, `${attributeNode.value.value} ${value}`);
}

function addAttribute(path, name, value) {
    const node = getNode(path);
    let attributeNode = getAttributeNode(node, name);
    
    if (!attributeNode) {
        attributeNode = jsxAttribute(jsxIdentifier(name), stringLiteral$1(value));
        node.openingElement.attributes.push(attributeNode);
    }
}

function removeAttributeValue(path, name, attributeValue) {
    if (!path)
        return;
    
    const node = path.node || path;
    const classAttribute = getAttributeNode(node, name);
    
    const {value} = classAttribute.value;
    
    if (!value.includes(attributeValue))
        return;
    
    const newValue = value
        .replace(RegExp(`\\s?${attributeValue}`), '')
        .trim();
    
    setLiteralValue(classAttribute.value, newValue);
}

const setAttributeValue = (path, name, value) => {
    const attributeNode = getAttributeNode(path, name);
    
    if (!attributeNode)
        return addAttribute(path, name, value);
    
    setLiteralValue(attributeNode.value, value);
};

const addClassName = (path, name) => {
    addAttributeValue(path, 'className', name);
};

function getClassName(path) {
    return getAttributeValue(path, 'className');
}

const removeClassName = (path, name) => {
    removeAttributeValue(path, 'className', name);
};

const containsClassName = (path, className) => {
    const classNameValue = getClassName(path);
    return classNameValue.includes(className);
};

const hasDataName = (path, value = '') => {
    const attribute = getAttributeValue(path, 'data-name');
    return attribute === value;
};

const hasAttributeValue = (path, name, value = '') => {
    const attribute = getAttributeValue(path, name);
    return attribute === value;
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * Helper `gen` function calls node type handler.
 */

function gen(node) {
  return node ? generator$1[node.type](node) : '';
}

/**
 * AST handler.
 */
var generator$1 = {
  RegExp: function RegExp(node) {
    return '/' + gen(node.body) + '/' + node.flags;
  },
  Alternative: function Alternative(node) {
    return (node.expressions || []).map(gen).join('');
  },
  Disjunction: function Disjunction(node) {
    return gen(node.left) + '|' + gen(node.right);
  },
  Group: function Group(node) {
    var expression = gen(node.expression);

    if (node.capturing) {
      // A named group.
      if (node.name) {
        return '(?<' + (node.nameRaw || node.name) + '>' + expression + ')';
      }

      return '(' + expression + ')';
    }

    return '(?:' + expression + ')';
  },
  Backreference: function Backreference(node) {
    switch (node.kind) {
      case 'number':
        return '\\' + node.reference;
      case 'name':
        return '\\k<' + (node.referenceRaw || node.reference) + '>';
      default:
        throw new TypeError('Unknown Backreference kind: ' + node.kind);
    }
  },
  Assertion: function Assertion(node) {
    switch (node.kind) {
      case '^':
      case '$':
      case '\\b':
      case '\\B':
        return node.kind;

      case 'Lookahead':
        {
          var assertion = gen(node.assertion);

          if (node.negative) {
            return '(?!' + assertion + ')';
          }

          return '(?=' + assertion + ')';
        }

      case 'Lookbehind':
        {
          var _assertion = gen(node.assertion);

          if (node.negative) {
            return '(?<!' + _assertion + ')';
          }

          return '(?<=' + _assertion + ')';
        }

      default:
        throw new TypeError('Unknown Assertion kind: ' + node.kind);
    }
  },
  CharacterClass: function CharacterClass(node) {
    var expressions = node.expressions.map(gen).join('');

    if (node.negative) {
      return '[^' + expressions + ']';
    }

    return '[' + expressions + ']';
  },
  ClassRange: function ClassRange(node) {
    return gen(node.from) + '-' + gen(node.to);
  },
  Repetition: function Repetition(node) {
    return '' + gen(node.expression) + gen(node.quantifier);
  },
  Quantifier: function Quantifier(node) {
    var quantifier = void 0;
    var greedy = node.greedy ? '' : '?';

    switch (node.kind) {
      case '+':
      case '?':
      case '*':
        quantifier = node.kind;
        break;
      case 'Range':
        // Exact: {1}
        if (node.from === node.to) {
          quantifier = '{' + node.from + '}';
        }
        // Open: {1,}
        else if (!node.to) {
            quantifier = '{' + node.from + ',}';
          }
          // Closed: {1,3}
          else {
              quantifier = '{' + node.from + ',' + node.to + '}';
            }
        break;
      default:
        throw new TypeError('Unknown Quantifier kind: ' + node.kind);
    }

    return '' + quantifier + greedy;
  },
  Char: function Char(node) {
    var value = node.value;

    switch (node.kind) {
      case 'simple':
        {
          if (node.escaped) {
            return '\\' + value;
          }
          return value;
        }

      case 'hex':
      case 'unicode':
      case 'oct':
      case 'decimal':
      case 'control':
      case 'meta':
        return value;

      default:
        throw new TypeError('Unknown Char kind: ' + node.kind);
    }
  },
  UnicodeProperty: function UnicodeProperty(node) {
    var escapeChar = node.negative ? 'P' : 'p';
    var namePart = void 0;

    if (!node.shorthand && !node.binary) {
      namePart = node.name + '=';
    } else {
      namePart = '';
    }

    return '\\' + escapeChar + '{' + namePart + node.value + '}';
  }
};

var generator_1 = {
  /**
   * Generates a regexp string from an AST.
   *
   * @param Object ast - an AST node
   */
  generate: gen
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var NON_BINARY_PROP_NAMES_TO_ALIASES = {
  General_Category: 'gc',
  Script: 'sc',
  Script_Extensions: 'scx'
};

var NON_BINARY_ALIASES_TO_PROP_NAMES = inverseMap(NON_BINARY_PROP_NAMES_TO_ALIASES);

var BINARY_PROP_NAMES_TO_ALIASES = {
  ASCII: 'ASCII',
  ASCII_Hex_Digit: 'AHex',
  Alphabetic: 'Alpha',
  Any: 'Any',
  Assigned: 'Assigned',
  Bidi_Control: 'Bidi_C',
  Bidi_Mirrored: 'Bidi_M',
  Case_Ignorable: 'CI',
  Cased: 'Cased',
  Changes_When_Casefolded: 'CWCF',
  Changes_When_Casemapped: 'CWCM',
  Changes_When_Lowercased: 'CWL',
  Changes_When_NFKC_Casefolded: 'CWKCF',
  Changes_When_Titlecased: 'CWT',
  Changes_When_Uppercased: 'CWU',
  Dash: 'Dash',
  Default_Ignorable_Code_Point: 'DI',
  Deprecated: 'Dep',
  Diacritic: 'Dia',
  Emoji: 'Emoji',
  Emoji_Component: 'Emoji_Component',
  Emoji_Modifier: 'Emoji_Modifier',
  Emoji_Modifier_Base: 'Emoji_Modifier_Base',
  Emoji_Presentation: 'Emoji_Presentation',
  Extended_Pictographic: 'Extended_Pictographic',
  Extender: 'Ext',
  Grapheme_Base: 'Gr_Base',
  Grapheme_Extend: 'Gr_Ext',
  Hex_Digit: 'Hex',
  IDS_Binary_Operator: 'IDSB',
  IDS_Trinary_Operator: 'IDST',
  ID_Continue: 'IDC',
  ID_Start: 'IDS',
  Ideographic: 'Ideo',
  Join_Control: 'Join_C',
  Logical_Order_Exception: 'LOE',
  Lowercase: 'Lower',
  Math: 'Math',
  Noncharacter_Code_Point: 'NChar',
  Pattern_Syntax: 'Pat_Syn',
  Pattern_White_Space: 'Pat_WS',
  Quotation_Mark: 'QMark',
  Radical: 'Radical',
  Regional_Indicator: 'RI',
  Sentence_Terminal: 'STerm',
  Soft_Dotted: 'SD',
  Terminal_Punctuation: 'Term',
  Unified_Ideograph: 'UIdeo',
  Uppercase: 'Upper',
  Variation_Selector: 'VS',
  White_Space: 'space',
  XID_Continue: 'XIDC',
  XID_Start: 'XIDS'
};

var BINARY_ALIASES_TO_PROP_NAMES = inverseMap(BINARY_PROP_NAMES_TO_ALIASES);

var GENERAL_CATEGORY_VALUE_TO_ALIASES = {
  Cased_Letter: 'LC',
  Close_Punctuation: 'Pe',
  Connector_Punctuation: 'Pc',
  Control: ['Cc', 'cntrl'],
  Currency_Symbol: 'Sc',
  Dash_Punctuation: 'Pd',
  Decimal_Number: ['Nd', 'digit'],
  Enclosing_Mark: 'Me',
  Final_Punctuation: 'Pf',
  Format: 'Cf',
  Initial_Punctuation: 'Pi',
  Letter: 'L',
  Letter_Number: 'Nl',
  Line_Separator: 'Zl',
  Lowercase_Letter: 'Ll',
  Mark: ['M', 'Combining_Mark'],
  Math_Symbol: 'Sm',
  Modifier_Letter: 'Lm',
  Modifier_Symbol: 'Sk',
  Nonspacing_Mark: 'Mn',
  Number: 'N',
  Open_Punctuation: 'Ps',
  Other: 'C',
  Other_Letter: 'Lo',
  Other_Number: 'No',
  Other_Punctuation: 'Po',
  Other_Symbol: 'So',
  Paragraph_Separator: 'Zp',
  Private_Use: 'Co',
  Punctuation: ['P', 'punct'],
  Separator: 'Z',
  Space_Separator: 'Zs',
  Spacing_Mark: 'Mc',
  Surrogate: 'Cs',
  Symbol: 'S',
  Titlecase_Letter: 'Lt',
  Unassigned: 'Cn',
  Uppercase_Letter: 'Lu'
};

var GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES = inverseMap(GENERAL_CATEGORY_VALUE_TO_ALIASES);

var SCRIPT_VALUE_TO_ALIASES = {
  Adlam: 'Adlm',
  Ahom: 'Ahom',
  Anatolian_Hieroglyphs: 'Hluw',
  Arabic: 'Arab',
  Armenian: 'Armn',
  Avestan: 'Avst',
  Balinese: 'Bali',
  Bamum: 'Bamu',
  Bassa_Vah: 'Bass',
  Batak: 'Batk',
  Bengali: 'Beng',
  Bhaiksuki: 'Bhks',
  Bopomofo: 'Bopo',
  Brahmi: 'Brah',
  Braille: 'Brai',
  Buginese: 'Bugi',
  Buhid: 'Buhd',
  Canadian_Aboriginal: 'Cans',
  Carian: 'Cari',
  Caucasian_Albanian: 'Aghb',
  Chakma: 'Cakm',
  Cham: 'Cham',
  Cherokee: 'Cher',
  Common: 'Zyyy',
  Coptic: ['Copt', 'Qaac'],
  Cuneiform: 'Xsux',
  Cypriot: 'Cprt',
  Cyrillic: 'Cyrl',
  Deseret: 'Dsrt',
  Devanagari: 'Deva',
  Dogra: 'Dogr',
  Duployan: 'Dupl',
  Egyptian_Hieroglyphs: 'Egyp',
  Elbasan: 'Elba',
  Ethiopic: 'Ethi',
  Georgian: 'Geor',
  Glagolitic: 'Glag',
  Gothic: 'Goth',
  Grantha: 'Gran',
  Greek: 'Grek',
  Gujarati: 'Gujr',
  Gunjala_Gondi: 'Gong',
  Gurmukhi: 'Guru',
  Han: 'Hani',
  Hangul: 'Hang',
  Hanifi_Rohingya: 'Rohg',
  Hanunoo: 'Hano',
  Hatran: 'Hatr',
  Hebrew: 'Hebr',
  Hiragana: 'Hira',
  Imperial_Aramaic: 'Armi',
  Inherited: ['Zinh', 'Qaai'],
  Inscriptional_Pahlavi: 'Phli',
  Inscriptional_Parthian: 'Prti',
  Javanese: 'Java',
  Kaithi: 'Kthi',
  Kannada: 'Knda',
  Katakana: 'Kana',
  Kayah_Li: 'Kali',
  Kharoshthi: 'Khar',
  Khmer: 'Khmr',
  Khojki: 'Khoj',
  Khudawadi: 'Sind',
  Lao: 'Laoo',
  Latin: 'Latn',
  Lepcha: 'Lepc',
  Limbu: 'Limb',
  Linear_A: 'Lina',
  Linear_B: 'Linb',
  Lisu: 'Lisu',
  Lycian: 'Lyci',
  Lydian: 'Lydi',
  Mahajani: 'Mahj',
  Makasar: 'Maka',
  Malayalam: 'Mlym',
  Mandaic: 'Mand',
  Manichaean: 'Mani',
  Marchen: 'Marc',
  Medefaidrin: 'Medf',
  Masaram_Gondi: 'Gonm',
  Meetei_Mayek: 'Mtei',
  Mende_Kikakui: 'Mend',
  Meroitic_Cursive: 'Merc',
  Meroitic_Hieroglyphs: 'Mero',
  Miao: 'Plrd',
  Modi: 'Modi',
  Mongolian: 'Mong',
  Mro: 'Mroo',
  Multani: 'Mult',
  Myanmar: 'Mymr',
  Nabataean: 'Nbat',
  New_Tai_Lue: 'Talu',
  Newa: 'Newa',
  Nko: 'Nkoo',
  Nushu: 'Nshu',
  Ogham: 'Ogam',
  Ol_Chiki: 'Olck',
  Old_Hungarian: 'Hung',
  Old_Italic: 'Ital',
  Old_North_Arabian: 'Narb',
  Old_Permic: 'Perm',
  Old_Persian: 'Xpeo',
  Old_Sogdian: 'Sogo',
  Old_South_Arabian: 'Sarb',
  Old_Turkic: 'Orkh',
  Oriya: 'Orya',
  Osage: 'Osge',
  Osmanya: 'Osma',
  Pahawh_Hmong: 'Hmng',
  Palmyrene: 'Palm',
  Pau_Cin_Hau: 'Pauc',
  Phags_Pa: 'Phag',
  Phoenician: 'Phnx',
  Psalter_Pahlavi: 'Phlp',
  Rejang: 'Rjng',
  Runic: 'Runr',
  Samaritan: 'Samr',
  Saurashtra: 'Saur',
  Sharada: 'Shrd',
  Shavian: 'Shaw',
  Siddham: 'Sidd',
  SignWriting: 'Sgnw',
  Sinhala: 'Sinh',
  Sogdian: 'Sogd',
  Sora_Sompeng: 'Sora',
  Soyombo: 'Soyo',
  Sundanese: 'Sund',
  Syloti_Nagri: 'Sylo',
  Syriac: 'Syrc',
  Tagalog: 'Tglg',
  Tagbanwa: 'Tagb',
  Tai_Le: 'Tale',
  Tai_Tham: 'Lana',
  Tai_Viet: 'Tavt',
  Takri: 'Takr',
  Tamil: 'Taml',
  Tangut: 'Tang',
  Telugu: 'Telu',
  Thaana: 'Thaa',
  Thai: 'Thai',
  Tibetan: 'Tibt',
  Tifinagh: 'Tfng',
  Tirhuta: 'Tirh',
  Ugaritic: 'Ugar',
  Vai: 'Vaii',
  Warang_Citi: 'Wara',
  Yi: 'Yiii',
  Zanabazar_Square: 'Zanb'
};

var SCRIPT_VALUE_ALIASES_TO_VALUE = inverseMap(SCRIPT_VALUE_TO_ALIASES);

function inverseMap(data) {
  var inverse = {};

  for (var name in data) {
    if (!data.hasOwnProperty(name)) {
      continue;
    }
    var value = data[name];
    if (Array.isArray(value)) {
      for (var i = 0; i < value.length; i++) {
        inverse[value[i]] = name;
      }
    } else {
      inverse[value] = name;
    }
  }

  return inverse;
}

function isValidName(name) {
  return NON_BINARY_PROP_NAMES_TO_ALIASES.hasOwnProperty(name) || NON_BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name) || BINARY_PROP_NAMES_TO_ALIASES.hasOwnProperty(name) || BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name);
}

function isValidValue(name, value) {
  if (isGeneralCategoryName(name)) {
    return isGeneralCategoryValue(value);
  }

  if (isScriptCategoryName(name)) {
    return isScriptCategoryValue(value);
  }

  return false;
}

function isAlias(name) {
  return NON_BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name) || BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name);
}

function isGeneralCategoryName(name) {
  return name === 'General_Category' || name == 'gc';
}

function isScriptCategoryName(name) {
  return name === 'Script' || name === 'Script_Extensions' || name === 'sc' || name === 'scx';
}

function isGeneralCategoryValue(value) {
  return GENERAL_CATEGORY_VALUE_TO_ALIASES.hasOwnProperty(value) || GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES.hasOwnProperty(value);
}

function isScriptCategoryValue(value) {
  return SCRIPT_VALUE_TO_ALIASES.hasOwnProperty(value) || SCRIPT_VALUE_ALIASES_TO_VALUE.hasOwnProperty(value);
}

function isBinaryPropertyName(name) {
  return BINARY_PROP_NAMES_TO_ALIASES.hasOwnProperty(name) || BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name);
}

function getCanonicalName(name) {
  if (NON_BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name)) {
    return NON_BINARY_ALIASES_TO_PROP_NAMES[name];
  }

  if (BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name)) {
    return BINARY_ALIASES_TO_PROP_NAMES[name];
  }

  return null;
}

function getCanonicalValue(value) {
  if (GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES.hasOwnProperty(value)) {
    return GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES[value];
  }

  if (SCRIPT_VALUE_ALIASES_TO_VALUE.hasOwnProperty(value)) {
    return SCRIPT_VALUE_ALIASES_TO_VALUE[value];
  }

  if (BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(value)) {
    return BINARY_ALIASES_TO_PROP_NAMES[value];
  }

  return null;
}

var parserUnicodeProperties = {
  isAlias: isAlias,
  isValidName: isValidName,
  isValidValue: isValidValue,
  isGeneralCategoryValue: isGeneralCategoryValue,
  isScriptCategoryValue: isScriptCategoryValue,
  isBinaryPropertyName: isBinaryPropertyName,
  getCanonicalName: getCanonicalName,
  getCanonicalValue: getCanonicalValue,

  NON_BINARY_PROP_NAMES_TO_ALIASES: NON_BINARY_PROP_NAMES_TO_ALIASES,
  NON_BINARY_ALIASES_TO_PROP_NAMES: NON_BINARY_ALIASES_TO_PROP_NAMES,

  BINARY_PROP_NAMES_TO_ALIASES: BINARY_PROP_NAMES_TO_ALIASES,
  BINARY_ALIASES_TO_PROP_NAMES: BINARY_ALIASES_TO_PROP_NAMES,

  GENERAL_CATEGORY_VALUE_TO_ALIASES: GENERAL_CATEGORY_VALUE_TO_ALIASES,
  GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES: GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES,

  SCRIPT_VALUE_TO_ALIASES: SCRIPT_VALUE_TO_ALIASES,
  SCRIPT_VALUE_ALIASES_TO_VALUE: SCRIPT_VALUE_ALIASES_TO_VALUE
};

/**
 * LR parser generated by the Syntax tool.
 *
 * https://www.npmjs.com/package/syntax-cli
 *
 *   npm install -g syntax-cli
 *
 *   syntax-cli --help
 *
 * To regenerate run:
 *
 *   syntax-cli \
 *     --grammar ~/path-to-grammar-file \
 *     --mode <parsing-mode> \
 *     --output ~/path-to-output-parser-file.js
 */

/**
 * Matched token text.
 */

var _slicedToArray$2 = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toConsumableArray$7(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var yytext = void 0;

/**
 * Storage object.
 */
var yy = {};

/**
 * Result of semantic action.
 */
var __ = void 0;

/**
 * Result location object.
 */
var __loc = void 0;

function yyloc(start, end) {
  if (!yy.options.captureLocations) {
    return null;
  }

  // Epsilon doesn't produce location.
  if (!start || !end) {
    return start || end;
  }

  return {
    startOffset: start.startOffset,
    endOffset: end.endOffset,
    startLine: start.startLine,
    endLine: end.endLine,
    startColumn: start.startColumn,
    endColumn: end.endColumn
  };
}

var EOF = '$';

/**
 * List of productions (generated by Syntax tool).
 */
var productions = [[-1, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [0, 4, function (_1, _2, _3, _4, _1loc, _2loc, _3loc, _4loc) {
  __loc = yyloc(_1loc, _4loc);
  __ = Node({
    type: 'RegExp',
    body: _2,
    flags: checkFlags(_4)
  }, loc(_1loc, _4loc || _3loc));
}], [1, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [1, 0, function () {
  __loc = null;__ = '';
}], [2, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [2, 2, function (_1, _2, _1loc, _2loc) {
  __loc = yyloc(_1loc, _2loc);__ = _1 + _2;
}], [3, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [4, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [4, 3, function (_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  // Location for empty disjunction: /|/
  var _loc = null;

  if (_2loc) {
    _loc = loc(_1loc || _2loc, _3loc || _2loc);
  }
  __ = Node({
    type: 'Disjunction',
    left: _1,
    right: _3
  }, _loc);
}], [5, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  if (_1.length === 0) {
    __ = null;
    return;
  }

  if (_1.length === 1) {
    __ = Node(_1[0], __loc);
  } else {
    __ = Node({
      type: 'Alternative',
      expressions: _1
    }, __loc);
  }
}], [6, 0, function () {
  __loc = null;__ = [];
}], [6, 2, function (_1, _2, _1loc, _2loc) {
  __loc = yyloc(_1loc, _2loc);__ = _1.concat(_2);
}], [7, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Node(Object.assign({ type: 'Assertion' }, _1), __loc);
}], [7, 2, function (_1, _2, _1loc, _2loc) {
  __loc = yyloc(_1loc, _2loc);
  __ = _1;

  if (_2) {
    __ = Node({
      type: 'Repetition',
      expression: _1,
      quantifier: _2
    }, __loc);
  }
}], [8, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = { kind: '^' };
}], [8, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = { kind: '$' };
}], [8, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = { kind: '\\b' };
}], [8, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = { kind: '\\B' };
}], [8, 3, function (_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = {
    kind: 'Lookahead',
    assertion: _2
  };
}], [8, 3, function (_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = {
    kind: 'Lookahead',
    negative: true,
    assertion: _2
  };
}], [8, 3, function (_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = {
    kind: 'Lookbehind',
    assertion: _2
  };
}], [8, 3, function (_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = {
    kind: 'Lookbehind',
    negative: true,
    assertion: _2
  };
}], [9, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [9, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [9, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Char(_1, 'simple', __loc);
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Char(_1.slice(1), 'simple', __loc);__.escaped = true;
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Char(_1, 'unicode', __loc);__.isSurrogatePair = true;
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Char(_1, 'unicode', __loc);
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = UnicodeProperty(_1, __loc);
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Char(_1, 'control', __loc);
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Char(_1, 'hex', __loc);
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Char(_1, 'oct', __loc);
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = GroupRefOrDecChar(_1, __loc);
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Char(_1, 'meta', __loc);
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Char(_1, 'meta', __loc);
}], [10, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = NamedGroupRefOrChars(_1, _1loc);
}], [11, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [11, 0], [12, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [12, 2, function (_1, _2, _1loc, _2loc) {
  __loc = yyloc(_1loc, _2loc);
  _1.greedy = false;
  __ = _1;
}], [13, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Node({
    type: 'Quantifier',
    kind: _1,
    greedy: true
  }, __loc);
}], [13, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Node({
    type: 'Quantifier',
    kind: _1,
    greedy: true
  }, __loc);
}], [13, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Node({
    type: 'Quantifier',
    kind: _1,
    greedy: true
  }, __loc);
}], [13, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  var range = getRange(_1);
  __ = Node({
    type: 'Quantifier',
    kind: 'Range',
    from: range[0],
    to: range[0],
    greedy: true
  }, __loc);
}], [13, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Node({
    type: 'Quantifier',
    kind: 'Range',
    from: getRange(_1)[0],
    greedy: true
  }, __loc);
}], [13, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  var range = getRange(_1);
  __ = Node({
    type: 'Quantifier',
    kind: 'Range',
    from: range[0],
    to: range[1],
    greedy: true
  }, __loc);
}], [14, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [14, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [15, 3, function (_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  var nameRaw = String(_1);
  var name = decodeUnicodeGroupName(nameRaw);
  if (!yy.options.allowGroupNameDuplicates && namedGroups.hasOwnProperty(name)) {
    throw new SyntaxError('Duplicate of the named group "' + name + '".');
  }

  namedGroups[name] = _1.groupNumber;

  __ = Node({
    type: 'Group',
    capturing: true,
    name: name,
    nameRaw: nameRaw,
    number: _1.groupNumber,
    expression: _2
  }, __loc);
}], [15, 3, function (_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = Node({
    type: 'Group',
    capturing: true,
    number: _1.groupNumber,
    expression: _2
  }, __loc);
}], [16, 3, function (_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = Node({
    type: 'Group',
    capturing: false,
    expression: _2
  }, __loc);
}], [17, 3, function (_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = Node({
    type: 'CharacterClass',
    negative: true,
    expressions: _2
  }, __loc);
}], [17, 3, function (_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = Node({
    type: 'CharacterClass',
    expressions: _2
  }, __loc);
}], [18, 0, function () {
  __loc = null;__ = [];
}], [18, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [19, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = [_1];
}], [19, 2, function (_1, _2, _1loc, _2loc) {
  __loc = yyloc(_1loc, _2loc);__ = [_1].concat(_2);
}], [19, 4, function (_1, _2, _3, _4, _1loc, _2loc, _3loc, _4loc) {
  __loc = yyloc(_1loc, _4loc);
  checkClassRange(_1, _3);

  __ = [Node({
    type: 'ClassRange',
    from: _1,
    to: _3
  }, loc(_1loc, _3loc))];

  if (_4) {
    __ = __.concat(_4);
  }
}], [20, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [20, 2, function (_1, _2, _1loc, _2loc) {
  __loc = yyloc(_1loc, _2loc);__ = [_1].concat(_2);
}], [20, 4, function (_1, _2, _3, _4, _1loc, _2loc, _3loc, _4loc) {
  __loc = yyloc(_1loc, _4loc);
  checkClassRange(_1, _3);

  __ = [Node({
    type: 'ClassRange',
    from: _1,
    to: _3
  }, loc(_1loc, _3loc))];

  if (_4) {
    __ = __.concat(_4);
  }
}], [21, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Char(_1, 'simple', __loc);
}], [21, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [22, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = _1;
}], [22, 1, function (_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);__ = Char(_1, 'meta', __loc);
}]];

/**
 * Encoded tokens map.
 */
var tokens = { "SLASH": "23", "CHAR": "24", "BAR": "25", "BOS": "26", "EOS": "27", "ESC_b": "28", "ESC_B": "29", "POS_LA_ASSERT": "30", "R_PAREN": "31", "NEG_LA_ASSERT": "32", "POS_LB_ASSERT": "33", "NEG_LB_ASSERT": "34", "ESC_CHAR": "35", "U_CODE_SURROGATE": "36", "U_CODE": "37", "U_PROP_VALUE_EXP": "38", "CTRL_CH": "39", "HEX_CODE": "40", "OCT_CODE": "41", "DEC_CODE": "42", "META_CHAR": "43", "ANY": "44", "NAMED_GROUP_REF": "45", "Q_MARK": "46", "STAR": "47", "PLUS": "48", "RANGE_EXACT": "49", "RANGE_OPEN": "50", "RANGE_CLOSED": "51", "NAMED_CAPTURE_GROUP": "52", "L_PAREN": "53", "NON_CAPTURE_GROUP": "54", "NEG_CLASS": "55", "R_BRACKET": "56", "L_BRACKET": "57", "DASH": "58", "$": "59" };

/**
 * Parsing table (generated by Syntax tool).
 */
var table = [{ "0": 1, "23": "s2" }, { "59": "acc" }, { "3": 3, "4": 4, "5": 5, "6": 6, "23": "r10", "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "s7" }, { "23": "r6", "25": "s12" }, { "23": "r7", "25": "r7", "31": "r7" }, { "7": 14, "8": 15, "9": 16, "10": 25, "14": 27, "15": 42, "16": 43, "17": 26, "23": "r9", "24": "s28", "25": "r9", "26": "s17", "27": "s18", "28": "s19", "29": "s20", "30": "s21", "31": "r9", "32": "s22", "33": "s23", "34": "s24", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "52": "s44", "53": "s45", "54": "s46", "55": "s40", "57": "s41" }, { "1": 8, "2": 9, "24": "s10", "59": "r3" }, { "59": "r1" }, { "24": "s11", "59": "r2" }, { "24": "r4", "59": "r4" }, { "24": "r5", "59": "r5" }, { "5": 13, "6": 6, "23": "r10", "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "r8", "25": "r8", "31": "r8" }, { "23": "r11", "24": "r11", "25": "r11", "26": "r11", "27": "r11", "28": "r11", "29": "r11", "30": "r11", "31": "r11", "32": "r11", "33": "r11", "34": "r11", "35": "r11", "36": "r11", "37": "r11", "38": "r11", "39": "r11", "40": "r11", "41": "r11", "42": "r11", "43": "r11", "44": "r11", "45": "r11", "52": "r11", "53": "r11", "54": "r11", "55": "r11", "57": "r11" }, { "23": "r12", "24": "r12", "25": "r12", "26": "r12", "27": "r12", "28": "r12", "29": "r12", "30": "r12", "31": "r12", "32": "r12", "33": "r12", "34": "r12", "35": "r12", "36": "r12", "37": "r12", "38": "r12", "39": "r12", "40": "r12", "41": "r12", "42": "r12", "43": "r12", "44": "r12", "45": "r12", "52": "r12", "53": "r12", "54": "r12", "55": "r12", "57": "r12" }, { "11": 47, "12": 48, "13": 49, "23": "r38", "24": "r38", "25": "r38", "26": "r38", "27": "r38", "28": "r38", "29": "r38", "30": "r38", "31": "r38", "32": "r38", "33": "r38", "34": "r38", "35": "r38", "36": "r38", "37": "r38", "38": "r38", "39": "r38", "40": "r38", "41": "r38", "42": "r38", "43": "r38", "44": "r38", "45": "r38", "46": "s52", "47": "s50", "48": "s51", "49": "s53", "50": "s54", "51": "s55", "52": "r38", "53": "r38", "54": "r38", "55": "r38", "57": "r38" }, { "23": "r14", "24": "r14", "25": "r14", "26": "r14", "27": "r14", "28": "r14", "29": "r14", "30": "r14", "31": "r14", "32": "r14", "33": "r14", "34": "r14", "35": "r14", "36": "r14", "37": "r14", "38": "r14", "39": "r14", "40": "r14", "41": "r14", "42": "r14", "43": "r14", "44": "r14", "45": "r14", "52": "r14", "53": "r14", "54": "r14", "55": "r14", "57": "r14" }, { "23": "r15", "24": "r15", "25": "r15", "26": "r15", "27": "r15", "28": "r15", "29": "r15", "30": "r15", "31": "r15", "32": "r15", "33": "r15", "34": "r15", "35": "r15", "36": "r15", "37": "r15", "38": "r15", "39": "r15", "40": "r15", "41": "r15", "42": "r15", "43": "r15", "44": "r15", "45": "r15", "52": "r15", "53": "r15", "54": "r15", "55": "r15", "57": "r15" }, { "23": "r16", "24": "r16", "25": "r16", "26": "r16", "27": "r16", "28": "r16", "29": "r16", "30": "r16", "31": "r16", "32": "r16", "33": "r16", "34": "r16", "35": "r16", "36": "r16", "37": "r16", "38": "r16", "39": "r16", "40": "r16", "41": "r16", "42": "r16", "43": "r16", "44": "r16", "45": "r16", "52": "r16", "53": "r16", "54": "r16", "55": "r16", "57": "r16" }, { "23": "r17", "24": "r17", "25": "r17", "26": "r17", "27": "r17", "28": "r17", "29": "r17", "30": "r17", "31": "r17", "32": "r17", "33": "r17", "34": "r17", "35": "r17", "36": "r17", "37": "r17", "38": "r17", "39": "r17", "40": "r17", "41": "r17", "42": "r17", "43": "r17", "44": "r17", "45": "r17", "52": "r17", "53": "r17", "54": "r17", "55": "r17", "57": "r17" }, { "4": 57, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 59, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 61, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 63, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "r22", "24": "r22", "25": "r22", "26": "r22", "27": "r22", "28": "r22", "29": "r22", "30": "r22", "31": "r22", "32": "r22", "33": "r22", "34": "r22", "35": "r22", "36": "r22", "37": "r22", "38": "r22", "39": "r22", "40": "r22", "41": "r22", "42": "r22", "43": "r22", "44": "r22", "45": "r22", "46": "r22", "47": "r22", "48": "r22", "49": "r22", "50": "r22", "51": "r22", "52": "r22", "53": "r22", "54": "r22", "55": "r22", "57": "r22" }, { "23": "r23", "24": "r23", "25": "r23", "26": "r23", "27": "r23", "28": "r23", "29": "r23", "30": "r23", "31": "r23", "32": "r23", "33": "r23", "34": "r23", "35": "r23", "36": "r23", "37": "r23", "38": "r23", "39": "r23", "40": "r23", "41": "r23", "42": "r23", "43": "r23", "44": "r23", "45": "r23", "46": "r23", "47": "r23", "48": "r23", "49": "r23", "50": "r23", "51": "r23", "52": "r23", "53": "r23", "54": "r23", "55": "r23", "57": "r23" }, { "23": "r24", "24": "r24", "25": "r24", "26": "r24", "27": "r24", "28": "r24", "29": "r24", "30": "r24", "31": "r24", "32": "r24", "33": "r24", "34": "r24", "35": "r24", "36": "r24", "37": "r24", "38": "r24", "39": "r24", "40": "r24", "41": "r24", "42": "r24", "43": "r24", "44": "r24", "45": "r24", "46": "r24", "47": "r24", "48": "r24", "49": "r24", "50": "r24", "51": "r24", "52": "r24", "53": "r24", "54": "r24", "55": "r24", "57": "r24" }, { "23": "r25", "24": "r25", "25": "r25", "26": "r25", "27": "r25", "28": "r25", "29": "r25", "30": "r25", "31": "r25", "32": "r25", "33": "r25", "34": "r25", "35": "r25", "36": "r25", "37": "r25", "38": "r25", "39": "r25", "40": "r25", "41": "r25", "42": "r25", "43": "r25", "44": "r25", "45": "r25", "46": "r25", "47": "r25", "48": "r25", "49": "r25", "50": "r25", "51": "r25", "52": "r25", "53": "r25", "54": "r25", "55": "r25", "56": "r25", "57": "r25", "58": "r25" }, { "23": "r26", "24": "r26", "25": "r26", "26": "r26", "27": "r26", "28": "r26", "29": "r26", "30": "r26", "31": "r26", "32": "r26", "33": "r26", "34": "r26", "35": "r26", "36": "r26", "37": "r26", "38": "r26", "39": "r26", "40": "r26", "41": "r26", "42": "r26", "43": "r26", "44": "r26", "45": "r26", "46": "r26", "47": "r26", "48": "r26", "49": "r26", "50": "r26", "51": "r26", "52": "r26", "53": "r26", "54": "r26", "55": "r26", "56": "r26", "57": "r26", "58": "r26" }, { "23": "r27", "24": "r27", "25": "r27", "26": "r27", "27": "r27", "28": "r27", "29": "r27", "30": "r27", "31": "r27", "32": "r27", "33": "r27", "34": "r27", "35": "r27", "36": "r27", "37": "r27", "38": "r27", "39": "r27", "40": "r27", "41": "r27", "42": "r27", "43": "r27", "44": "r27", "45": "r27", "46": "r27", "47": "r27", "48": "r27", "49": "r27", "50": "r27", "51": "r27", "52": "r27", "53": "r27", "54": "r27", "55": "r27", "56": "r27", "57": "r27", "58": "r27" }, { "23": "r28", "24": "r28", "25": "r28", "26": "r28", "27": "r28", "28": "r28", "29": "r28", "30": "r28", "31": "r28", "32": "r28", "33": "r28", "34": "r28", "35": "r28", "36": "r28", "37": "r28", "38": "r28", "39": "r28", "40": "r28", "41": "r28", "42": "r28", "43": "r28", "44": "r28", "45": "r28", "46": "r28", "47": "r28", "48": "r28", "49": "r28", "50": "r28", "51": "r28", "52": "r28", "53": "r28", "54": "r28", "55": "r28", "56": "r28", "57": "r28", "58": "r28" }, { "23": "r29", "24": "r29", "25": "r29", "26": "r29", "27": "r29", "28": "r29", "29": "r29", "30": "r29", "31": "r29", "32": "r29", "33": "r29", "34": "r29", "35": "r29", "36": "r29", "37": "r29", "38": "r29", "39": "r29", "40": "r29", "41": "r29", "42": "r29", "43": "r29", "44": "r29", "45": "r29", "46": "r29", "47": "r29", "48": "r29", "49": "r29", "50": "r29", "51": "r29", "52": "r29", "53": "r29", "54": "r29", "55": "r29", "56": "r29", "57": "r29", "58": "r29" }, { "23": "r30", "24": "r30", "25": "r30", "26": "r30", "27": "r30", "28": "r30", "29": "r30", "30": "r30", "31": "r30", "32": "r30", "33": "r30", "34": "r30", "35": "r30", "36": "r30", "37": "r30", "38": "r30", "39": "r30", "40": "r30", "41": "r30", "42": "r30", "43": "r30", "44": "r30", "45": "r30", "46": "r30", "47": "r30", "48": "r30", "49": "r30", "50": "r30", "51": "r30", "52": "r30", "53": "r30", "54": "r30", "55": "r30", "56": "r30", "57": "r30", "58": "r30" }, { "23": "r31", "24": "r31", "25": "r31", "26": "r31", "27": "r31", "28": "r31", "29": "r31", "30": "r31", "31": "r31", "32": "r31", "33": "r31", "34": "r31", "35": "r31", "36": "r31", "37": "r31", "38": "r31", "39": "r31", "40": "r31", "41": "r31", "42": "r31", "43": "r31", "44": "r31", "45": "r31", "46": "r31", "47": "r31", "48": "r31", "49": "r31", "50": "r31", "51": "r31", "52": "r31", "53": "r31", "54": "r31", "55": "r31", "56": "r31", "57": "r31", "58": "r31" }, { "23": "r32", "24": "r32", "25": "r32", "26": "r32", "27": "r32", "28": "r32", "29": "r32", "30": "r32", "31": "r32", "32": "r32", "33": "r32", "34": "r32", "35": "r32", "36": "r32", "37": "r32", "38": "r32", "39": "r32", "40": "r32", "41": "r32", "42": "r32", "43": "r32", "44": "r32", "45": "r32", "46": "r32", "47": "r32", "48": "r32", "49": "r32", "50": "r32", "51": "r32", "52": "r32", "53": "r32", "54": "r32", "55": "r32", "56": "r32", "57": "r32", "58": "r32" }, { "23": "r33", "24": "r33", "25": "r33", "26": "r33", "27": "r33", "28": "r33", "29": "r33", "30": "r33", "31": "r33", "32": "r33", "33": "r33", "34": "r33", "35": "r33", "36": "r33", "37": "r33", "38": "r33", "39": "r33", "40": "r33", "41": "r33", "42": "r33", "43": "r33", "44": "r33", "45": "r33", "46": "r33", "47": "r33", "48": "r33", "49": "r33", "50": "r33", "51": "r33", "52": "r33", "53": "r33", "54": "r33", "55": "r33", "56": "r33", "57": "r33", "58": "r33" }, { "23": "r34", "24": "r34", "25": "r34", "26": "r34", "27": "r34", "28": "r34", "29": "r34", "30": "r34", "31": "r34", "32": "r34", "33": "r34", "34": "r34", "35": "r34", "36": "r34", "37": "r34", "38": "r34", "39": "r34", "40": "r34", "41": "r34", "42": "r34", "43": "r34", "44": "r34", "45": "r34", "46": "r34", "47": "r34", "48": "r34", "49": "r34", "50": "r34", "51": "r34", "52": "r34", "53": "r34", "54": "r34", "55": "r34", "56": "r34", "57": "r34", "58": "r34" }, { "23": "r35", "24": "r35", "25": "r35", "26": "r35", "27": "r35", "28": "r35", "29": "r35", "30": "r35", "31": "r35", "32": "r35", "33": "r35", "34": "r35", "35": "r35", "36": "r35", "37": "r35", "38": "r35", "39": "r35", "40": "r35", "41": "r35", "42": "r35", "43": "r35", "44": "r35", "45": "r35", "46": "r35", "47": "r35", "48": "r35", "49": "r35", "50": "r35", "51": "r35", "52": "r35", "53": "r35", "54": "r35", "55": "r35", "56": "r35", "57": "r35", "58": "r35" }, { "23": "r36", "24": "r36", "25": "r36", "26": "r36", "27": "r36", "28": "r36", "29": "r36", "30": "r36", "31": "r36", "32": "r36", "33": "r36", "34": "r36", "35": "r36", "36": "r36", "37": "r36", "38": "r36", "39": "r36", "40": "r36", "41": "r36", "42": "r36", "43": "r36", "44": "r36", "45": "r36", "46": "r36", "47": "r36", "48": "r36", "49": "r36", "50": "r36", "51": "r36", "52": "r36", "53": "r36", "54": "r36", "55": "r36", "56": "r36", "57": "r36", "58": "r36" }, { "10": 70, "18": 65, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "10": 70, "18": 83, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "23": "r47", "24": "r47", "25": "r47", "26": "r47", "27": "r47", "28": "r47", "29": "r47", "30": "r47", "31": "r47", "32": "r47", "33": "r47", "34": "r47", "35": "r47", "36": "r47", "37": "r47", "38": "r47", "39": "r47", "40": "r47", "41": "r47", "42": "r47", "43": "r47", "44": "r47", "45": "r47", "46": "r47", "47": "r47", "48": "r47", "49": "r47", "50": "r47", "51": "r47", "52": "r47", "53": "r47", "54": "r47", "55": "r47", "57": "r47" }, { "23": "r48", "24": "r48", "25": "r48", "26": "r48", "27": "r48", "28": "r48", "29": "r48", "30": "r48", "31": "r48", "32": "r48", "33": "r48", "34": "r48", "35": "r48", "36": "r48", "37": "r48", "38": "r48", "39": "r48", "40": "r48", "41": "r48", "42": "r48", "43": "r48", "44": "r48", "45": "r48", "46": "r48", "47": "r48", "48": "r48", "49": "r48", "50": "r48", "51": "r48", "52": "r48", "53": "r48", "54": "r48", "55": "r48", "57": "r48" }, { "4": 85, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 87, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 89, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "r13", "24": "r13", "25": "r13", "26": "r13", "27": "r13", "28": "r13", "29": "r13", "30": "r13", "31": "r13", "32": "r13", "33": "r13", "34": "r13", "35": "r13", "36": "r13", "37": "r13", "38": "r13", "39": "r13", "40": "r13", "41": "r13", "42": "r13", "43": "r13", "44": "r13", "45": "r13", "52": "r13", "53": "r13", "54": "r13", "55": "r13", "57": "r13" }, { "23": "r37", "24": "r37", "25": "r37", "26": "r37", "27": "r37", "28": "r37", "29": "r37", "30": "r37", "31": "r37", "32": "r37", "33": "r37", "34": "r37", "35": "r37", "36": "r37", "37": "r37", "38": "r37", "39": "r37", "40": "r37", "41": "r37", "42": "r37", "43": "r37", "44": "r37", "45": "r37", "52": "r37", "53": "r37", "54": "r37", "55": "r37", "57": "r37" }, { "23": "r39", "24": "r39", "25": "r39", "26": "r39", "27": "r39", "28": "r39", "29": "r39", "30": "r39", "31": "r39", "32": "r39", "33": "r39", "34": "r39", "35": "r39", "36": "r39", "37": "r39", "38": "r39", "39": "r39", "40": "r39", "41": "r39", "42": "r39", "43": "r39", "44": "r39", "45": "r39", "46": "s56", "52": "r39", "53": "r39", "54": "r39", "55": "r39", "57": "r39" }, { "23": "r41", "24": "r41", "25": "r41", "26": "r41", "27": "r41", "28": "r41", "29": "r41", "30": "r41", "31": "r41", "32": "r41", "33": "r41", "34": "r41", "35": "r41", "36": "r41", "37": "r41", "38": "r41", "39": "r41", "40": "r41", "41": "r41", "42": "r41", "43": "r41", "44": "r41", "45": "r41", "46": "r41", "52": "r41", "53": "r41", "54": "r41", "55": "r41", "57": "r41" }, { "23": "r42", "24": "r42", "25": "r42", "26": "r42", "27": "r42", "28": "r42", "29": "r42", "30": "r42", "31": "r42", "32": "r42", "33": "r42", "34": "r42", "35": "r42", "36": "r42", "37": "r42", "38": "r42", "39": "r42", "40": "r42", "41": "r42", "42": "r42", "43": "r42", "44": "r42", "45": "r42", "46": "r42", "52": "r42", "53": "r42", "54": "r42", "55": "r42", "57": "r42" }, { "23": "r43", "24": "r43", "25": "r43", "26": "r43", "27": "r43", "28": "r43", "29": "r43", "30": "r43", "31": "r43", "32": "r43", "33": "r43", "34": "r43", "35": "r43", "36": "r43", "37": "r43", "38": "r43", "39": "r43", "40": "r43", "41": "r43", "42": "r43", "43": "r43", "44": "r43", "45": "r43", "46": "r43", "52": "r43", "53": "r43", "54": "r43", "55": "r43", "57": "r43" }, { "23": "r44", "24": "r44", "25": "r44", "26": "r44", "27": "r44", "28": "r44", "29": "r44", "30": "r44", "31": "r44", "32": "r44", "33": "r44", "34": "r44", "35": "r44", "36": "r44", "37": "r44", "38": "r44", "39": "r44", "40": "r44", "41": "r44", "42": "r44", "43": "r44", "44": "r44", "45": "r44", "46": "r44", "52": "r44", "53": "r44", "54": "r44", "55": "r44", "57": "r44" }, { "23": "r45", "24": "r45", "25": "r45", "26": "r45", "27": "r45", "28": "r45", "29": "r45", "30": "r45", "31": "r45", "32": "r45", "33": "r45", "34": "r45", "35": "r45", "36": "r45", "37": "r45", "38": "r45", "39": "r45", "40": "r45", "41": "r45", "42": "r45", "43": "r45", "44": "r45", "45": "r45", "46": "r45", "52": "r45", "53": "r45", "54": "r45", "55": "r45", "57": "r45" }, { "23": "r46", "24": "r46", "25": "r46", "26": "r46", "27": "r46", "28": "r46", "29": "r46", "30": "r46", "31": "r46", "32": "r46", "33": "r46", "34": "r46", "35": "r46", "36": "r46", "37": "r46", "38": "r46", "39": "r46", "40": "r46", "41": "r46", "42": "r46", "43": "r46", "44": "r46", "45": "r46", "46": "r46", "52": "r46", "53": "r46", "54": "r46", "55": "r46", "57": "r46" }, { "23": "r40", "24": "r40", "25": "r40", "26": "r40", "27": "r40", "28": "r40", "29": "r40", "30": "r40", "31": "r40", "32": "r40", "33": "r40", "34": "r40", "35": "r40", "36": "r40", "37": "r40", "38": "r40", "39": "r40", "40": "r40", "41": "r40", "42": "r40", "43": "r40", "44": "r40", "45": "r40", "52": "r40", "53": "r40", "54": "r40", "55": "r40", "57": "r40" }, { "25": "s12", "31": "s58" }, { "23": "r18", "24": "r18", "25": "r18", "26": "r18", "27": "r18", "28": "r18", "29": "r18", "30": "r18", "31": "r18", "32": "r18", "33": "r18", "34": "r18", "35": "r18", "36": "r18", "37": "r18", "38": "r18", "39": "r18", "40": "r18", "41": "r18", "42": "r18", "43": "r18", "44": "r18", "45": "r18", "52": "r18", "53": "r18", "54": "r18", "55": "r18", "57": "r18" }, { "25": "s12", "31": "s60" }, { "23": "r19", "24": "r19", "25": "r19", "26": "r19", "27": "r19", "28": "r19", "29": "r19", "30": "r19", "31": "r19", "32": "r19", "33": "r19", "34": "r19", "35": "r19", "36": "r19", "37": "r19", "38": "r19", "39": "r19", "40": "r19", "41": "r19", "42": "r19", "43": "r19", "44": "r19", "45": "r19", "52": "r19", "53": "r19", "54": "r19", "55": "r19", "57": "r19" }, { "25": "s12", "31": "s62" }, { "23": "r20", "24": "r20", "25": "r20", "26": "r20", "27": "r20", "28": "r20", "29": "r20", "30": "r20", "31": "r20", "32": "r20", "33": "r20", "34": "r20", "35": "r20", "36": "r20", "37": "r20", "38": "r20", "39": "r20", "40": "r20", "41": "r20", "42": "r20", "43": "r20", "44": "r20", "45": "r20", "52": "r20", "53": "r20", "54": "r20", "55": "r20", "57": "r20" }, { "25": "s12", "31": "s64" }, { "23": "r21", "24": "r21", "25": "r21", "26": "r21", "27": "r21", "28": "r21", "29": "r21", "30": "r21", "31": "r21", "32": "r21", "33": "r21", "34": "r21", "35": "r21", "36": "r21", "37": "r21", "38": "r21", "39": "r21", "40": "r21", "41": "r21", "42": "r21", "43": "r21", "44": "r21", "45": "r21", "52": "r21", "53": "r21", "54": "r21", "55": "r21", "57": "r21" }, { "56": "s72" }, { "56": "r55" }, { "10": 70, "20": 73, "21": 75, "22": 76, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r56", "58": "s74" }, { "24": "r62", "28": "r62", "35": "r62", "36": "r62", "37": "r62", "38": "r62", "39": "r62", "40": "r62", "41": "r62", "42": "r62", "43": "r62", "44": "r62", "45": "r62", "56": "r62", "58": "r62" }, { "24": "r63", "28": "r63", "35": "r63", "36": "r63", "37": "r63", "38": "r63", "39": "r63", "40": "r63", "41": "r63", "42": "r63", "43": "r63", "44": "r63", "45": "r63", "56": "r63", "58": "r63" }, { "24": "r64", "28": "r64", "35": "r64", "36": "r64", "37": "r64", "38": "r64", "39": "r64", "40": "r64", "41": "r64", "42": "r64", "43": "r64", "44": "r64", "45": "r64", "56": "r64", "58": "r64" }, { "24": "r65", "28": "r65", "35": "r65", "36": "r65", "37": "r65", "38": "r65", "39": "r65", "40": "r65", "41": "r65", "42": "r65", "43": "r65", "44": "r65", "45": "r65", "56": "r65", "58": "r65" }, { "23": "r52", "24": "r52", "25": "r52", "26": "r52", "27": "r52", "28": "r52", "29": "r52", "30": "r52", "31": "r52", "32": "r52", "33": "r52", "34": "r52", "35": "r52", "36": "r52", "37": "r52", "38": "r52", "39": "r52", "40": "r52", "41": "r52", "42": "r52", "43": "r52", "44": "r52", "45": "r52", "46": "r52", "47": "r52", "48": "r52", "49": "r52", "50": "r52", "51": "r52", "52": "r52", "53": "r52", "54": "r52", "55": "r52", "57": "r52" }, { "56": "r57" }, { "10": 70, "21": 77, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r62", "58": "s68" }, { "56": "r59" }, { "10": 70, "20": 79, "21": 75, "22": 76, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r63", "58": "s80" }, { "10": 70, "18": 78, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "56": "r58" }, { "56": "r60" }, { "10": 70, "21": 81, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r62", "58": "s68" }, { "10": 70, "18": 82, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "56": "r61" }, { "56": "s84" }, { "23": "r53", "24": "r53", "25": "r53", "26": "r53", "27": "r53", "28": "r53", "29": "r53", "30": "r53", "31": "r53", "32": "r53", "33": "r53", "34": "r53", "35": "r53", "36": "r53", "37": "r53", "38": "r53", "39": "r53", "40": "r53", "41": "r53", "42": "r53", "43": "r53", "44": "r53", "45": "r53", "46": "r53", "47": "r53", "48": "r53", "49": "r53", "50": "r53", "51": "r53", "52": "r53", "53": "r53", "54": "r53", "55": "r53", "57": "r53" }, { "25": "s12", "31": "s86" }, { "23": "r49", "24": "r49", "25": "r49", "26": "r49", "27": "r49", "28": "r49", "29": "r49", "30": "r49", "31": "r49", "32": "r49", "33": "r49", "34": "r49", "35": "r49", "36": "r49", "37": "r49", "38": "r49", "39": "r49", "40": "r49", "41": "r49", "42": "r49", "43": "r49", "44": "r49", "45": "r49", "46": "r49", "47": "r49", "48": "r49", "49": "r49", "50": "r49", "51": "r49", "52": "r49", "53": "r49", "54": "r49", "55": "r49", "57": "r49" }, { "25": "s12", "31": "s88" }, { "23": "r50", "24": "r50", "25": "r50", "26": "r50", "27": "r50", "28": "r50", "29": "r50", "30": "r50", "31": "r50", "32": "r50", "33": "r50", "34": "r50", "35": "r50", "36": "r50", "37": "r50", "38": "r50", "39": "r50", "40": "r50", "41": "r50", "42": "r50", "43": "r50", "44": "r50", "45": "r50", "46": "r50", "47": "r50", "48": "r50", "49": "r50", "50": "r50", "51": "r50", "52": "r50", "53": "r50", "54": "r50", "55": "r50", "57": "r50" }, { "25": "s12", "31": "s90" }, { "23": "r51", "24": "r51", "25": "r51", "26": "r51", "27": "r51", "28": "r51", "29": "r51", "30": "r51", "31": "r51", "32": "r51", "33": "r51", "34": "r51", "35": "r51", "36": "r51", "37": "r51", "38": "r51", "39": "r51", "40": "r51", "41": "r51", "42": "r51", "43": "r51", "44": "r51", "45": "r51", "46": "r51", "47": "r51", "48": "r51", "49": "r51", "50": "r51", "51": "r51", "52": "r51", "53": "r51", "54": "r51", "55": "r51", "57": "r51" }];

/**
 * Parsing stack.
 */
var stack = [];

/**
 * Tokenizer instance.
 */
var tokenizer = void 0;
/**
 * Generic tokenizer used by the parser in the Syntax tool.
 *
 * https://www.npmjs.com/package/syntax-cli
 *
 * See `--custom-tokinzer` to skip this generation, and use a custom one.
 */

var lexRules = [[/^#[^\n]+/, function () {/* skip comments */}], [/^\s+/, function () {/* skip whitespace */}], [/^-/, function () {
  return 'DASH';
}], [/^\//, function () {
  return 'CHAR';
}], [/^#/, function () {
  return 'CHAR';
}], [/^\|/, function () {
  return 'CHAR';
}], [/^\./, function () {
  return 'CHAR';
}], [/^\{/, function () {
  return 'CHAR';
}], [/^\{\d+\}/, function () {
  return 'RANGE_EXACT';
}], [/^\{\d+,\}/, function () {
  return 'RANGE_OPEN';
}], [/^\{\d+,\d+\}/, function () {
  return 'RANGE_CLOSED';
}], [/^\\k<(([\u0041-\u005a\u0061-\u007a\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e-\u066f\u0671-\u06d3\u06d5\u06e5-\u06e6\u06ee-\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4-\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc-\u09dd\u09df-\u09e1\u09f0-\u09f1\u09fc\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0-\u0ae1\u0af9\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60-\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0-\u0ce1\u0cf1-\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32-\u0e33\u0e40-\u0e46\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2-\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065-\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae-\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5-\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a-\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd-\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5-\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\ude80-\ude9c\udea0-\uded0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf75\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00\ude10-\ude13\ude15-\ude17\ude19-\ude35\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee4\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd23\udf00-\udf1c\udf27\udf30-\udf45\udfe0-\udff6]|\ud804[\udc03-\udc37\udc83-\udcaf\udcd0-\udce8\udd03-\udd26\udd44\udd50-\udd72\udd76\udd83-\uddb2\uddc1-\uddc4\uddda\udddc\ude00-\ude11\ude13-\ude2b\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udede\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3d\udf50\udf5d-\udf61]|\ud805[\udc00-\udc34\udc47-\udc4a\udc5f\udc80-\udcaf\udcc4-\udcc5\udcc7\udd80-\uddae\uddd8-\udddb\ude00-\ude2f\ude44\ude80-\udeaa\udeb8\udf00-\udf1a]|\ud806[\udc00-\udc2b\udca0-\udcdf\udcff\udda0-\udda7\uddaa-\uddd0\udde1\udde3\ude00\ude0b-\ude32\ude3a\ude50\ude5c-\ude89\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc2e\udc40\udc72-\udc8f\udd00-\udd06\udd08-\udd09\udd0b-\udd30\udd46\udd60-\udd65\udd67-\udd68\udd6a-\udd89\udd98\udee0-\udef2]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\uded0-\udeed\udf00-\udf2f\udf40-\udf43\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf50\udf93-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb]|\ud838[\udd00-\udd2c\udd37-\udd3d\udd4e\udec0-\udeeb]|\ud83a[\udc00-\udcc4\udd00-\udd43\udd4b]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\}))(([\u0030-\u0039\u0041-\u005a\u005f\u0061-\u007a\u00aa\u00b5\u00b7\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u05d0-\u05ea\u05ef-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u07fd\u0800-\u082d\u0840-\u085b\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u08d3-\u08e1\u08e3-\u0963\u0966-\u096f\u0971-\u0983\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7-\u09c8\u09cb-\u09ce\u09d7\u09dc-\u09dd\u09df-\u09e3\u09e6-\u09f1\u09fc\u09fe\u0a01-\u0a03\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a3c\u0a3e-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0af9-\u0aff\u0b01-\u0b03\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47-\u0b48\u0b4b-\u0b4d\u0b56-\u0b57\u0b5c-\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82-\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c00-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56\u0c58-\u0c5a\u0c60-\u0c63\u0c66-\u0c6f\u0c80-\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5-\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1-\u0cf2\u0d00-\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d54-\u0d57\u0d5f-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82-\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2-\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18-\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1369-\u1371\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772-\u1773\u1780-\u17d3\u17d7\u17dc-\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1878\u1880-\u18aa\u18b0-\u18f5\u1900-\u191e\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19da\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1ab0-\u1abd\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1cd0-\u1cd2\u1cd4-\u1cfa\u1d00-\u1df9\u1dfb-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u203f-\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua827\ua840-\ua873\ua880-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua8fd-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\ua9e0-\ua9fe\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabea\uabec-\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe2f\ufe33-\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\uddfd\ude80-\ude9c\udea0-\uded0\udee0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf7a\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udca0-\udca9\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00-\ude03\ude05-\ude06\ude0c-\ude13\ude15-\ude17\ude19-\ude35\ude38-\ude3a\ude3f\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee6\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd27\udd30-\udd39\udf00-\udf1c\udf27\udf30-\udf50\udfe0-\udff6]|\ud804[\udc00-\udc46\udc66-\udc6f\udc7f-\udcba\udcd0-\udce8\udcf0-\udcf9\udd00-\udd34\udd36-\udd3f\udd44-\udd46\udd50-\udd73\udd76\udd80-\uddc4\uddc9-\uddcc\uddd0-\uddda\udddc\ude00-\ude11\ude13-\ude37\ude3e\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udeea\udef0-\udef9\udf00-\udf03\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3b-\udf44\udf47-\udf48\udf4b-\udf4d\udf50\udf57\udf5d-\udf63\udf66-\udf6c\udf70-\udf74]|\ud805[\udc00-\udc4a\udc50-\udc59\udc5e-\udc5f\udc80-\udcc5\udcc7\udcd0-\udcd9\udd80-\uddb5\uddb8-\uddc0\uddd8-\udddd\ude00-\ude40\ude44\ude50-\ude59\ude80-\udeb8\udec0-\udec9\udf00-\udf1a\udf1d-\udf2b\udf30-\udf39]|\ud806[\udc00-\udc3a\udca0-\udce9\udcff\udda0-\udda7\uddaa-\uddd7\uddda-\udde1\udde3-\udde4\ude00-\ude3e\ude47\ude50-\ude99\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc36\udc38-\udc40\udc50-\udc59\udc72-\udc8f\udc92-\udca7\udca9-\udcb6\udd00-\udd06\udd08-\udd09\udd0b-\udd36\udd3a\udd3c-\udd3d\udd3f-\udd47\udd50-\udd59\udd60-\udd65\udd67-\udd68\udd6a-\udd8e\udd90-\udd91\udd93-\udd98\udda0-\udda9\udee0-\udef6]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\ude60-\ude69\uded0-\udeed\udef0-\udef4\udf00-\udf36\udf40-\udf43\udf50-\udf59\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf4f-\udf87\udf8f-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99\udc9d-\udc9e]|\ud834[\udd65-\udd69\udd6d-\udd72\udd7b-\udd82\udd85-\udd8b\uddaa-\uddad\ude42-\ude44]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb\udfce-\udfff]|\ud836[\ude00-\ude36\ude3b-\ude6c\ude75\ude84\ude9b-\ude9f\udea1-\udeaf]|\ud838[\udc00-\udc06\udc08-\udc18\udc1b-\udc21\udc23-\udc24\udc26-\udc2a\udd00-\udd2c\udd30-\udd3d\udd40-\udd49\udd4e\udec0-\udef9]|\ud83a[\udc00-\udcc4\udcd0-\udcd6\udd00-\udd4b\udd50-\udd59]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d]|\udb40[\udd00-\uddef])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\})|[\u200c\u200d])*>/, function () {
  var groupName = yytext.slice(3, -1);
  validateUnicodeGroupName(groupName, this.getCurrentState());
  return 'NAMED_GROUP_REF';
}], [/^\\b/, function () {
  return 'ESC_b';
}], [/^\\B/, function () {
  return 'ESC_B';
}], [/^\\c[a-zA-Z]/, function () {
  return 'CTRL_CH';
}], [/^\\0\d{1,2}/, function () {
  return 'OCT_CODE';
}], [/^\\0/, function () {
  return 'DEC_CODE';
}], [/^\\\d{1,3}/, function () {
  return 'DEC_CODE';
}], [/^\\u[dD][89abAB][0-9a-fA-F]{2}\\u[dD][c-fC-F][0-9a-fA-F]{2}/, function () {
  return 'U_CODE_SURROGATE';
}], [/^\\u\{[0-9a-fA-F]{1,}\}/, function () {
  return 'U_CODE';
}], [/^\\u[0-9a-fA-F]{4}/, function () {
  return 'U_CODE';
}], [/^\\[pP]\{\w+(?:=\w+)?\}/, function () {
  return 'U_PROP_VALUE_EXP';
}], [/^\\x[0-9a-fA-F]{2}/, function () {
  return 'HEX_CODE';
}], [/^\\[tnrdDsSwWvf]/, function () {
  return 'META_CHAR';
}], [/^\\\//, function () {
  return 'ESC_CHAR';
}], [/^\\[ #]/, function () {
  return 'ESC_CHAR';
}], [/^\\[\^\$\.\*\+\?\(\)\\\[\]\{\}\|\/]/, function () {
  return 'ESC_CHAR';
}], [/^\\[^*?+\[()\\|]/, function () {
  var s = this.getCurrentState();
  if (s === 'u_class' && yytext === "\\-") {
    return 'ESC_CHAR';
  } else if (s === 'u' || s === 'xu' || s === 'u_class') {
    throw new SyntaxError('invalid Unicode escape ' + yytext);
  }
  return 'ESC_CHAR';
}], [/^\(/, function () {
  return 'CHAR';
}], [/^\)/, function () {
  return 'CHAR';
}], [/^\(\?=/, function () {
  return 'POS_LA_ASSERT';
}], [/^\(\?!/, function () {
  return 'NEG_LA_ASSERT';
}], [/^\(\?<=/, function () {
  return 'POS_LB_ASSERT';
}], [/^\(\?<!/, function () {
  return 'NEG_LB_ASSERT';
}], [/^\(\?:/, function () {
  return 'NON_CAPTURE_GROUP';
}], [/^\(\?<(([\u0041-\u005a\u0061-\u007a\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e-\u066f\u0671-\u06d3\u06d5\u06e5-\u06e6\u06ee-\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4-\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc-\u09dd\u09df-\u09e1\u09f0-\u09f1\u09fc\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0-\u0ae1\u0af9\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60-\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0-\u0ce1\u0cf1-\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32-\u0e33\u0e40-\u0e46\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2-\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065-\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae-\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5-\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a-\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd-\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5-\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\ude80-\ude9c\udea0-\uded0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf75\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00\ude10-\ude13\ude15-\ude17\ude19-\ude35\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee4\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd23\udf00-\udf1c\udf27\udf30-\udf45\udfe0-\udff6]|\ud804[\udc03-\udc37\udc83-\udcaf\udcd0-\udce8\udd03-\udd26\udd44\udd50-\udd72\udd76\udd83-\uddb2\uddc1-\uddc4\uddda\udddc\ude00-\ude11\ude13-\ude2b\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udede\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3d\udf50\udf5d-\udf61]|\ud805[\udc00-\udc34\udc47-\udc4a\udc5f\udc80-\udcaf\udcc4-\udcc5\udcc7\udd80-\uddae\uddd8-\udddb\ude00-\ude2f\ude44\ude80-\udeaa\udeb8\udf00-\udf1a]|\ud806[\udc00-\udc2b\udca0-\udcdf\udcff\udda0-\udda7\uddaa-\uddd0\udde1\udde3\ude00\ude0b-\ude32\ude3a\ude50\ude5c-\ude89\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc2e\udc40\udc72-\udc8f\udd00-\udd06\udd08-\udd09\udd0b-\udd30\udd46\udd60-\udd65\udd67-\udd68\udd6a-\udd89\udd98\udee0-\udef2]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\uded0-\udeed\udf00-\udf2f\udf40-\udf43\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf50\udf93-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb]|\ud838[\udd00-\udd2c\udd37-\udd3d\udd4e\udec0-\udeeb]|\ud83a[\udc00-\udcc4\udd00-\udd43\udd4b]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\}))(([\u0030-\u0039\u0041-\u005a\u005f\u0061-\u007a\u00aa\u00b5\u00b7\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u05d0-\u05ea\u05ef-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u07fd\u0800-\u082d\u0840-\u085b\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u08d3-\u08e1\u08e3-\u0963\u0966-\u096f\u0971-\u0983\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7-\u09c8\u09cb-\u09ce\u09d7\u09dc-\u09dd\u09df-\u09e3\u09e6-\u09f1\u09fc\u09fe\u0a01-\u0a03\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a3c\u0a3e-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0af9-\u0aff\u0b01-\u0b03\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47-\u0b48\u0b4b-\u0b4d\u0b56-\u0b57\u0b5c-\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82-\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c00-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56\u0c58-\u0c5a\u0c60-\u0c63\u0c66-\u0c6f\u0c80-\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5-\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1-\u0cf2\u0d00-\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d54-\u0d57\u0d5f-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82-\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2-\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18-\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1369-\u1371\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772-\u1773\u1780-\u17d3\u17d7\u17dc-\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1878\u1880-\u18aa\u18b0-\u18f5\u1900-\u191e\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19da\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1ab0-\u1abd\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1cd0-\u1cd2\u1cd4-\u1cfa\u1d00-\u1df9\u1dfb-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u203f-\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua827\ua840-\ua873\ua880-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua8fd-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\ua9e0-\ua9fe\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabea\uabec-\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe2f\ufe33-\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\uddfd\ude80-\ude9c\udea0-\uded0\udee0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf7a\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udca0-\udca9\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00-\ude03\ude05-\ude06\ude0c-\ude13\ude15-\ude17\ude19-\ude35\ude38-\ude3a\ude3f\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee6\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd27\udd30-\udd39\udf00-\udf1c\udf27\udf30-\udf50\udfe0-\udff6]|\ud804[\udc00-\udc46\udc66-\udc6f\udc7f-\udcba\udcd0-\udce8\udcf0-\udcf9\udd00-\udd34\udd36-\udd3f\udd44-\udd46\udd50-\udd73\udd76\udd80-\uddc4\uddc9-\uddcc\uddd0-\uddda\udddc\ude00-\ude11\ude13-\ude37\ude3e\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udeea\udef0-\udef9\udf00-\udf03\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3b-\udf44\udf47-\udf48\udf4b-\udf4d\udf50\udf57\udf5d-\udf63\udf66-\udf6c\udf70-\udf74]|\ud805[\udc00-\udc4a\udc50-\udc59\udc5e-\udc5f\udc80-\udcc5\udcc7\udcd0-\udcd9\udd80-\uddb5\uddb8-\uddc0\uddd8-\udddd\ude00-\ude40\ude44\ude50-\ude59\ude80-\udeb8\udec0-\udec9\udf00-\udf1a\udf1d-\udf2b\udf30-\udf39]|\ud806[\udc00-\udc3a\udca0-\udce9\udcff\udda0-\udda7\uddaa-\uddd7\uddda-\udde1\udde3-\udde4\ude00-\ude3e\ude47\ude50-\ude99\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc36\udc38-\udc40\udc50-\udc59\udc72-\udc8f\udc92-\udca7\udca9-\udcb6\udd00-\udd06\udd08-\udd09\udd0b-\udd36\udd3a\udd3c-\udd3d\udd3f-\udd47\udd50-\udd59\udd60-\udd65\udd67-\udd68\udd6a-\udd8e\udd90-\udd91\udd93-\udd98\udda0-\udda9\udee0-\udef6]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\ude60-\ude69\uded0-\udeed\udef0-\udef4\udf00-\udf36\udf40-\udf43\udf50-\udf59\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf4f-\udf87\udf8f-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99\udc9d-\udc9e]|\ud834[\udd65-\udd69\udd6d-\udd72\udd7b-\udd82\udd85-\udd8b\uddaa-\uddad\ude42-\ude44]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb\udfce-\udfff]|\ud836[\ude00-\ude36\ude3b-\ude6c\ude75\ude84\ude9b-\ude9f\udea1-\udeaf]|\ud838[\udc00-\udc06\udc08-\udc18\udc1b-\udc21\udc23-\udc24\udc26-\udc2a\udd00-\udd2c\udd30-\udd3d\udd40-\udd49\udd4e\udec0-\udef9]|\ud83a[\udc00-\udcc4\udcd0-\udcd6\udd00-\udd4b\udd50-\udd59]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d]|\udb40[\udd00-\uddef])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\})|[\u200c\u200d])*>/, function () {
  yytext = yytext.slice(3, -1);
  validateUnicodeGroupName(yytext, this.getCurrentState());
  return 'NAMED_CAPTURE_GROUP';
}], [/^\(/, function () {
  return 'L_PAREN';
}], [/^\)/, function () {
  return 'R_PAREN';
}], [/^[*?+[^$]/, function () {
  return 'CHAR';
}], [/^\\\]/, function () {
  return 'ESC_CHAR';
}], [/^\]/, function () {
  this.popState();return 'R_BRACKET';
}], [/^\^/, function () {
  return 'BOS';
}], [/^\$/, function () {
  return 'EOS';
}], [/^\*/, function () {
  return 'STAR';
}], [/^\?/, function () {
  return 'Q_MARK';
}], [/^\+/, function () {
  return 'PLUS';
}], [/^\|/, function () {
  return 'BAR';
}], [/^\./, function () {
  return 'ANY';
}], [/^\//, function () {
  return 'SLASH';
}], [/^[^*?+\[()\\|]/, function () {
  return 'CHAR';
}], [/^\[\^/, function () {
  var s = this.getCurrentState();this.pushState(s === 'u' || s === 'xu' ? 'u_class' : 'class');return 'NEG_CLASS';
}], [/^\[/, function () {
  var s = this.getCurrentState();this.pushState(s === 'u' || s === 'xu' ? 'u_class' : 'class');return 'L_BRACKET';
}]];
var lexRulesByConditions = { "INITIAL": [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 22, 23, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "u": [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "xu": [0, 1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "x": [0, 1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 22, 23, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "u_class": [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "class": [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 22, 23, 24, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51] };

var EOF_TOKEN = {
  type: EOF,
  value: ''
};

tokenizer = {
  initString: function initString(string) {
    this._string = string;
    this._cursor = 0;

    this._states = ['INITIAL'];
    this._tokensQueue = [];

    this._currentLine = 1;
    this._currentColumn = 0;
    this._currentLineBeginOffset = 0;

    /**
     * Matched token location data.
     */
    this._tokenStartOffset = 0;
    this._tokenEndOffset = 0;
    this._tokenStartLine = 1;
    this._tokenEndLine = 1;
    this._tokenStartColumn = 0;
    this._tokenEndColumn = 0;

    return this;
  },


  /**
   * Returns tokenizer states.
   */
  getStates: function getStates() {
    return this._states;
  },
  getCurrentState: function getCurrentState() {
    return this._states[this._states.length - 1];
  },
  pushState: function pushState(state) {
    this._states.push(state);
  },
  begin: function begin(state) {
    this.pushState(state);
  },
  popState: function popState() {
    if (this._states.length > 1) {
      return this._states.pop();
    }
    return this._states[0];
  },
  getNextToken: function getNextToken() {
    // Something was queued, return it.
    if (this._tokensQueue.length > 0) {
      return this.onToken(this._toToken(this._tokensQueue.shift()));
    }

    if (!this.hasMoreTokens()) {
      return this.onToken(EOF_TOKEN);
    }

    var string = this._string.slice(this._cursor);
    var lexRulesForState = lexRulesByConditions[this.getCurrentState()];

    for (var i = 0; i < lexRulesForState.length; i++) {
      var lexRuleIndex = lexRulesForState[i];
      var lexRule = lexRules[lexRuleIndex];

      var matched = this._match(string, lexRule[0]);

      // Manual handling of EOF token (the end of string). Return it
      // as `EOF` symbol.
      if (string === '' && matched === '') {
        this._cursor++;
      }

      if (matched !== null) {
        yytext = matched;
        yytext.length;
        var token = lexRule[1].call(this);

        if (!token) {
          return this.getNextToken();
        }

        // If multiple tokens are returned, save them to return
        // on next `getNextToken` call.

        if (Array.isArray(token)) {
          var tokensToQueue = token.slice(1);
          token = token[0];
          if (tokensToQueue.length > 0) {
            var _tokensQueue;

            (_tokensQueue = this._tokensQueue).unshift.apply(_tokensQueue, _toConsumableArray$7(tokensToQueue));
          }
        }

        return this.onToken(this._toToken(token, yytext));
      }
    }

    if (this.isEOF()) {
      this._cursor++;
      return EOF_TOKEN;
    }

    this.throwUnexpectedToken(string[0], this._currentLine, this._currentColumn);
  },


  /**
   * Throws default "Unexpected token" exception, showing the actual
   * line from the source, pointing with the ^ marker to the bad token.
   * In addition, shows `line:column` location.
   */
  throwUnexpectedToken: function throwUnexpectedToken(symbol, line, column) {
    var lineSource = this._string.split('\n')[line - 1];
    var lineData = '';

    if (lineSource) {
      var pad = ' '.repeat(column);
      lineData = '\n\n' + lineSource + '\n' + pad + '^\n';
    }

    throw new SyntaxError(lineData + 'Unexpected token: "' + symbol + '" ' + ('at ' + line + ':' + column + '.'));
  },
  getCursor: function getCursor() {
    return this._cursor;
  },
  getCurrentLine: function getCurrentLine() {
    return this._currentLine;
  },
  getCurrentColumn: function getCurrentColumn() {
    return this._currentColumn;
  },
  _captureLocation: function _captureLocation(matched) {
    var nlRe = /\n/g;

    // Absolute offsets.
    this._tokenStartOffset = this._cursor;

    // Line-based locations, start.
    this._tokenStartLine = this._currentLine;
    this._tokenStartColumn = this._tokenStartOffset - this._currentLineBeginOffset;

    // Extract `\n` in the matched token.
    var nlMatch = void 0;
    while ((nlMatch = nlRe.exec(matched)) !== null) {
      this._currentLine++;
      this._currentLineBeginOffset = this._tokenStartOffset + nlMatch.index + 1;
    }

    this._tokenEndOffset = this._cursor + matched.length;

    // Line-based locations, end.
    this._tokenEndLine = this._currentLine;
    this._tokenEndColumn = this._currentColumn = this._tokenEndOffset - this._currentLineBeginOffset;
  },
  _toToken: function _toToken(tokenType) {
    var yytext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    return {
      // Basic data.
      type: tokenType,
      value: yytext,

      // Location data.
      startOffset: this._tokenStartOffset,
      endOffset: this._tokenEndOffset,
      startLine: this._tokenStartLine,
      endLine: this._tokenEndLine,
      startColumn: this._tokenStartColumn,
      endColumn: this._tokenEndColumn
    };
  },
  isEOF: function isEOF() {
    return this._cursor === this._string.length;
  },
  hasMoreTokens: function hasMoreTokens() {
    return this._cursor <= this._string.length;
  },
  _match: function _match(string, regexp) {
    var matched = string.match(regexp);
    if (matched) {
      // Handle `\n` in the matched token to track line numbers.
      this._captureLocation(matched[0]);
      this._cursor += matched[0].length;
      return matched[0];
    }
    return null;
  },


  /**
   * Allows analyzing, and transforming token. Default implementation
   * just passes the token through.
   */
  onToken: function onToken(token) {
    return token;
  }
};

/**
 * Expose tokenizer so it can be accessed in semantic actions.
 */
yy.lexer = tokenizer;
yy.tokenizer = tokenizer;

/**
 * Global parsing options. Some options can be shadowed per
 * each `parse` call, if the optations are passed.
 *
 * Initalized to the `captureLocations` which is passed
 * from the generator. Other options can be added at runtime.
 */
yy.options = {
  captureLocations: true
};

/**
 * Parsing module.
 */
var yyparse = {
  /**
   * Sets global parsing options.
   */
  setOptions: function setOptions(options) {
    yy.options = options;
    return this;
  },


  /**
   * Returns parsing options.
   */
  getOptions: function getOptions() {
    return yy.options;
  },


  /**
   * Parses a string.
   */
  parse: function parse(string, parseOptions) {
    if (!tokenizer) {
      throw new Error('Tokenizer instance wasn\'t specified.');
    }

    tokenizer.initString(string);

    /**
     * If parse options are passed, override global parse options for
     * this call, and later restore global options.
     */
    var globalOptions = yy.options;
    if (parseOptions) {
      yy.options = Object.assign({}, yy.options, parseOptions);
    }

    /**
     * Allow callers to do setup work based on the
     * parsing string, and passed options.
     */
    yyparse.onParseBegin(string, tokenizer, yy.options);

    stack.length = 0;
    stack.push(0);

    var token = tokenizer.getNextToken();
    var shiftedToken = null;

    do {
      if (!token) {
        // Restore options.
        yy.options = globalOptions;
        unexpectedEndOfInput();
      }

      var state = stack[stack.length - 1];
      var column = tokens[token.type];

      if (!table[state].hasOwnProperty(column)) {
        yy.options = globalOptions;
        unexpectedToken(token);
      }

      var entry = table[state][column];

      // Shift action.
      if (entry[0] === 's') {
        var _loc2 = null;

        if (yy.options.captureLocations) {
          _loc2 = {
            startOffset: token.startOffset,
            endOffset: token.endOffset,
            startLine: token.startLine,
            endLine: token.endLine,
            startColumn: token.startColumn,
            endColumn: token.endColumn
          };
        }

        shiftedToken = this.onShift(token);

        stack.push({ symbol: tokens[shiftedToken.type], semanticValue: shiftedToken.value, loc: _loc2 }, Number(entry.slice(1)));

        token = tokenizer.getNextToken();
      }

      // Reduce action.
      else if (entry[0] === 'r') {
          var productionNumber = entry.slice(1);
          var production = productions[productionNumber];
          var hasSemanticAction = typeof production[2] === 'function';
          var semanticValueArgs = hasSemanticAction ? [] : null;

          var locationArgs = hasSemanticAction && yy.options.captureLocations ? [] : null;

          if (production[1] !== 0) {
            var rhsLength = production[1];
            while (rhsLength-- > 0) {
              stack.pop();
              var stackEntry = stack.pop();

              if (hasSemanticAction) {
                semanticValueArgs.unshift(stackEntry.semanticValue);

                if (locationArgs) {
                  locationArgs.unshift(stackEntry.loc);
                }
              }
            }
          }

          var reduceStackEntry = { symbol: production[0] };

          if (hasSemanticAction) {
            yytext = shiftedToken ? shiftedToken.value : null;
            shiftedToken ? shiftedToken.value.length : null;

            var semanticActionArgs = locationArgs !== null ? semanticValueArgs.concat(locationArgs) : semanticValueArgs;

            production[2].apply(production, _toConsumableArray$7(semanticActionArgs));

            reduceStackEntry.semanticValue = __;

            if (locationArgs) {
              reduceStackEntry.loc = __loc;
            }
          }

          var nextState = stack[stack.length - 1];
          var symbolToReduceWith = production[0];

          stack.push(reduceStackEntry, table[nextState][symbolToReduceWith]);
        }

        // Accept.
        else if (entry === 'acc') {
            stack.pop();
            var parsed = stack.pop();

            if (stack.length !== 1 || stack[0] !== 0 || tokenizer.hasMoreTokens()) {
              // Restore options.
              yy.options = globalOptions;
              unexpectedToken(token);
            }

            if (parsed.hasOwnProperty('semanticValue')) {
              yy.options = globalOptions;
              yyparse.onParseEnd(parsed.semanticValue);
              return parsed.semanticValue;
            }

            yyparse.onParseEnd();

            // Restore options.
            yy.options = globalOptions;
            return true;
          }
    } while (tokenizer.hasMoreTokens() || stack.length > 1);
  },
  setTokenizer: function setTokenizer(customTokenizer) {
    tokenizer = customTokenizer;
    return yyparse;
  },
  getTokenizer: function getTokenizer() {
    return tokenizer;
  },
  onParseBegin: function onParseBegin(string, tokenizer, options) {},
  onParseEnd: function onParseEnd(parsed) {},


  /**
   * Allows analyzing, and transforming shifted token. Default implementation
   * just passes the token through.
   */
  onShift: function onShift(token) {
    return token;
  }
};

/**
 * Tracks capturing groups.
 */
var capturingGroupsCount = 0;

/**
 * Tracks named groups.
 */
var namedGroups = {};

/**
 * Parsing string.
 */
var parsingString = '';

yyparse.onParseBegin = function (string, lexer) {
  parsingString = string;
  capturingGroupsCount = 0;
  namedGroups = {};

  var lastSlash = string.lastIndexOf('/');
  var flags = string.slice(lastSlash);

  if (flags.includes('x') && flags.includes('u')) {
    lexer.pushState('xu');
  } else {
    if (flags.includes('x')) {
      lexer.pushState('x');
    }
    if (flags.includes('u')) {
      lexer.pushState('u');
    }
  }
};

/**
 * On shifting `(` remember its number to used on reduce.
 */
yyparse.onShift = function (token) {
  if (token.type === 'L_PAREN' || token.type === 'NAMED_CAPTURE_GROUP') {
    token.value = new String(token.value);
    token.value.groupNumber = ++capturingGroupsCount;
  }
  return token;
};

/**
 * Extracts ranges from the range string.
 */
function getRange(text) {
  var range = text.match(/\d+/g).map(Number);

  if (Number.isFinite(range[1]) && range[1] < range[0]) {
    throw new SyntaxError('Numbers out of order in ' + text + ' quantifier');
  }

  return range;
}

/**
 * Checks class range
 */
function checkClassRange(from, to) {
  if (from.kind === 'control' || to.kind === 'control' || !isNaN(from.codePoint) && !isNaN(to.codePoint) && from.codePoint > to.codePoint) {
    throw new SyntaxError('Range ' + from.value + '-' + to.value + ' out of order in character class');
  }
}

// ---------------------- Unicode property -------------------------------------------

var unicodeProperties = parserUnicodeProperties;

/**
 * Unicode property.
 */
function UnicodeProperty(matched, loc) {
  var negative = matched[1] === 'P';
  var separatorIdx = matched.indexOf('=');

  var name = matched.slice(3, separatorIdx !== -1 ? separatorIdx : -1);
  var value = void 0;

  // General_Category allows using only value as a shorthand.
  var isShorthand = separatorIdx === -1 && unicodeProperties.isGeneralCategoryValue(name);

  // Binary propery name.
  var isBinaryProperty = separatorIdx === -1 && unicodeProperties.isBinaryPropertyName(name);

  if (isShorthand) {
    value = name;
    name = 'General_Category';
  } else if (isBinaryProperty) {
    value = name;
  } else {
    if (!unicodeProperties.isValidName(name)) {
      throw new SyntaxError('Invalid unicode property name: ' + name + '.');
    }

    value = matched.slice(separatorIdx + 1, -1);

    if (!unicodeProperties.isValidValue(name, value)) {
      throw new SyntaxError('Invalid ' + name + ' unicode property value: ' + value + '.');
    }
  }

  return Node({
    type: 'UnicodeProperty',
    name: name,
    value: value,
    negative: negative,
    shorthand: isShorthand,
    binary: isBinaryProperty,
    canonicalName: unicodeProperties.getCanonicalName(name) || name,
    canonicalValue: unicodeProperties.getCanonicalValue(value) || value
  }, loc);
}

// ----------------------------------------------------------------------------------


/**
 * Creates a character node.
 */
function Char(value, kind, loc) {
  var symbol = void 0;
  var codePoint = void 0;

  switch (kind) {
    case 'decimal':
      {
        codePoint = Number(value.slice(1));
        symbol = String.fromCodePoint(codePoint);
        break;
      }
    case 'oct':
      {
        codePoint = parseInt(value.slice(1), 8);
        symbol = String.fromCodePoint(codePoint);
        break;
      }
    case 'hex':
    case 'unicode':
      {
        if (value.lastIndexOf('\\u') > 0) {
          var _value$split$slice = value.split('\\u').slice(1),
              _value$split$slice2 = _slicedToArray$2(_value$split$slice, 2),
              lead = _value$split$slice2[0],
              trail = _value$split$slice2[1];

          lead = parseInt(lead, 16);
          trail = parseInt(trail, 16);
          codePoint = (lead - 0xd800) * 0x400 + (trail - 0xdc00) + 0x10000;

          symbol = String.fromCodePoint(codePoint);
        } else {
          var hex = value.slice(2).replace('{', '');
          codePoint = parseInt(hex, 16);
          if (codePoint > 0x10ffff) {
            throw new SyntaxError('Bad character escape sequence: ' + value);
          }

          symbol = String.fromCodePoint(codePoint);
        }
        break;
      }
    case 'meta':
      {
        switch (value) {
          case '\\t':
            symbol = '\t';
            codePoint = symbol.codePointAt(0);
            break;
          case '\\n':
            symbol = '\n';
            codePoint = symbol.codePointAt(0);
            break;
          case '\\r':
            symbol = '\r';
            codePoint = symbol.codePointAt(0);
            break;
          case '\\v':
            symbol = '\v';
            codePoint = symbol.codePointAt(0);
            break;
          case '\\f':
            symbol = '\f';
            codePoint = symbol.codePointAt(0);
            break;
          case '\\b':
            symbol = '\b';
            codePoint = symbol.codePointAt(0);
          case '\\0':
            symbol = '\0';
            codePoint = 0;
          case '.':
            symbol = '.';
            codePoint = NaN;
            break;
          default:
            codePoint = NaN;
        }
        break;
      }
    case 'simple':
      {
        symbol = value;
        codePoint = symbol.codePointAt(0);
        break;
      }
  }

  return Node({
    type: 'Char',
    value: value,
    kind: kind,
    symbol: symbol,
    codePoint: codePoint
  }, loc);
}

/**
 * Valid flags per current ECMAScript spec and
 * stage 3+ proposals.
 */
var validFlags = 'gimsuxy';

/**
 * Checks the flags are valid, and that
 * we don't duplicate flags.
 */
function checkFlags(flags) {
  var seen = new Set();

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = flags[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var flag = _step.value;

      if (seen.has(flag) || !validFlags.includes(flag)) {
        throw new SyntaxError('Invalid flags: ' + flags);
      }
      seen.add(flag);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return flags.split('').sort().join('');
}

/**
 * Parses patterns like \1, \2, etc. either as a backreference
 * to a group, or a deciaml char code.
 */
function GroupRefOrDecChar(text, textLoc) {
  var reference = Number(text.slice(1));

  if (reference > 0 && reference <= capturingGroupsCount) {
    return Node({
      type: 'Backreference',
      kind: 'number',
      number: reference,
      reference: reference
    }, textLoc);
  }

  return Char(text, 'decimal', textLoc);
}

/**
 * Unicode names.
 */
var uReStart = /^\\u[0-9a-fA-F]{4}/; // only matches start of string
var ucpReStart = /^\\u\{[0-9a-fA-F]{1,}\}/; // only matches start of string
var ucpReAnywhere = /\\u\{[0-9a-fA-F]{1,}\}/; // matches anywhere in string

/**
 * Validates Unicode group name.
 */
function validateUnicodeGroupName(name, state) {
  var isUnicodeName = ucpReAnywhere.test(name);
  var isUnicodeState = state === 'u' || state === 'xu' || state === 'u_class';

  if (isUnicodeName && !isUnicodeState) {
    throw new SyntaxError('invalid group Unicode name "' + name + '", use `u` flag.');
  }

  return name;
}

// Matches the following production: https://tc39.es/ecma262/#prod-RegExpUnicodeEscapeSequence
//
//  RegExpUnicodeEscapeSequence ::
//    `u` LeadSurrogate `\u` TrailSurrogate   # as 'leadSurrogate', 'trailSurrogate'
//    `u` LeadSurrogate                       # as 'leadSurrogateOnly'
//    `u` TrailSurrogate                      # as 'trailSurrogateOnly'
//    `u` NonSurrogate                        # as 'nonSurrogate'
//    `u` `{` CodePoint `}`                   # as 'codePoint'
//
//  LeadSurrogate ::
//    Hex4Digits but only if the SV of Hex4Digits is in the inclusive range 0xD800 to 0xDBFF        # [dD][89aAbB][0-9a-fA-F]{2}
//
//  TrailSurrogate ::
//    Hex4Digits but only if the SV of Hex4Digits is in the inclusive range 0xDC00 to 0xDFFF        # [dD][c-fC-F][0-9a-fA-F]{2}
//
//  NonSurrogate ::
//    Hex4Digits but only if the SV of Hex4Digits is not in the inclusive range 0xD800 to 0xDFFF    # [0-9a-ce-fA-CE-F][0-9a-fA-F]{3}|[dD][0-7][0-9a-fA-F]{2}
//
//  CodePoint ::
//    HexDigits but only if MV of HexDigits  0x10FFFF                                              # 0*(?:[0-9a-fA-F]{1,5}|10[0-9a-fA-F]{4})
//
var uidRe = /\\u(?:([dD][89aAbB][0-9a-fA-F]{2})\\u([dD][c-fC-F][0-9a-fA-F]{2})|([dD][89aAbB][0-9a-fA-F]{2})|([dD][c-fC-F][0-9a-fA-F]{2})|([0-9a-ce-fA-CE-F][0-9a-fA-F]{3}|[dD][0-7][0-9a-fA-F]{2})|\{(0*(?:[0-9a-fA-F]{1,5}|10[0-9a-fA-F]{4}))\})/;

function decodeUnicodeGroupName(name) {
  return name.replace(new RegExp(uidRe, 'g'), function (_, leadSurrogate, trailSurrogate, leadSurrogateOnly, trailSurrogateOnly, nonSurrogate, codePoint) {
    if (leadSurrogate) {
      return String.fromCodePoint(parseInt(leadSurrogate, 16), parseInt(trailSurrogate, 16));
    }
    if (leadSurrogateOnly) {
      return String.fromCodePoint(parseInt(leadSurrogateOnly, 16));
    }
    if (trailSurrogateOnly) {
      // TODO: Per the spec: https://tc39.es/ecma262/#prod-RegExpUnicodeEscapeSequence
      // > Each `\u` TrailSurrogate for which the choice of associated `u` LeadSurrogate is ambiguous shall be associated with the nearest possible `u` LeadSurrogate that would otherwise have no corresponding `\u` TrailSurrogate.
      return String.fromCodePoint(parseInt(trailSurrogateOnly, 16));
    }
    if (nonSurrogate) {
      return String.fromCodePoint(parseInt(nonSurrogate, 16));
    }
    if (codePoint) {
      return String.fromCodePoint(parseInt(codePoint, 16));
    }
    return _;
  });
}

/**
 * Extracts from `\k<foo>` pattern either a backreference
 * to a named capturing group (if it presents), or parses it
 * as a list of char: `\k`, `<`, `f`, etc.
 */
function NamedGroupRefOrChars(text, textLoc) {
  var referenceRaw = text.slice(3, -1);
  var reference = decodeUnicodeGroupName(referenceRaw);

  if (namedGroups.hasOwnProperty(reference)) {
    return Node({
      type: 'Backreference',
      kind: 'name',
      number: namedGroups[reference],
      reference: reference,
      referenceRaw: referenceRaw
    }, textLoc);
  }

  // Else `\k<foo>` should be parsed as a list of `Char`s.
  // This is really a 0.01% edge case, but we should handle it.

  var startOffset = null;
  var startLine = null;
  var endLine = null;
  var startColumn = null;

  if (textLoc) {
    startOffset = textLoc.startOffset;
    startLine = textLoc.startLine;
    endLine = textLoc.endLine;
    startColumn = textLoc.startColumn;
  }

  var charRe = /^[\w$<>]/;
  var loc = void 0;

  var chars = [
  // Init to first \k, taking 2 symbols.
  Char(text.slice(1, 2), 'simple', startOffset ? {
    startLine: startLine,
    endLine: endLine,
    startColumn: startColumn,
    startOffset: startOffset,
    endOffset: startOffset += 2,
    endColumn: startColumn += 2
  } : null)];

  // For \k
  chars[0].escaped = true;

  // Other symbols.
  text = text.slice(2);

  while (text.length > 0) {
    var matched = null;

    // Unicode, \u003B or \u{003B}
    if ((matched = text.match(uReStart)) || (matched = text.match(ucpReStart))) {
      if (startOffset) {
        loc = {
          startLine: startLine,
          endLine: endLine,
          startColumn: startColumn,
          startOffset: startOffset,
          endOffset: startOffset += matched[0].length,
          endColumn: startColumn += matched[0].length
        };
      }
      chars.push(Char(matched[0], 'unicode', loc));
      text = text.slice(matched[0].length);
    }

    // Simple char.
    else if (matched = text.match(charRe)) {
        if (startOffset) {
          loc = {
            startLine: startLine,
            endLine: endLine,
            startColumn: startColumn,
            startOffset: startOffset,
            endOffset: ++startOffset,
            endColumn: ++startColumn
          };
        }
        chars.push(Char(matched[0], 'simple', loc));
        text = text.slice(1);
      }
  }

  return chars;
}

/**
 * Creates an AST node with a location.
 */
function Node(node, loc) {
  if (yy.options.captureLocations) {
    node.loc = {
      source: parsingString.slice(loc.startOffset, loc.endOffset),
      start: {
        line: loc.startLine,
        column: loc.startColumn,
        offset: loc.startOffset
      },
      end: {
        line: loc.endLine,
        column: loc.endColumn,
        offset: loc.endOffset
      }
    };
  }
  return node;
}

/**
 * Creates location node.
 */
function loc(start, end) {
  if (!yy.options.captureLocations) {
    return null;
  }

  return {
    startOffset: start.startOffset,
    endOffset: end.endOffset,
    startLine: start.startLine,
    endLine: end.endLine,
    startColumn: start.startColumn,
    endColumn: end.endColumn
  };
}

function unexpectedToken(token) {
  if (token.type === EOF) {
    unexpectedEndOfInput();
  }

  tokenizer.throwUnexpectedToken(token.value, token.startLine, token.startColumn);
}

function unexpectedEndOfInput() {
  parseError('Unexpected end of input.');
}

function parseError(message) {
  throw new SyntaxError(message);
}

var regexpTree$3 = yyparse;

regexpTree$3.default;

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var regexpTreeParser = regexpTree$3;

/**
 * Original parse function.
 */
var generatedParseFn = regexpTreeParser.parse.bind(regexpTreeParser);

/**
 * Parses a regular expression.
 *
 * Override original `regexpTreeParser.parse` to convert a value to a string,
 * since in regexp-tree we may pass strings, and RegExp instance.
 */
regexpTreeParser.parse = function (regexp, options) {
  return generatedParseFn('' + regexp, options);
};

// By default do not capture locations; callers may override.
regexpTreeParser.setOptions({ captureLocations: false });

var parser = regexpTreeParser;

parser.default;

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var _createClass$6 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$6(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DEFAULT_COLLECTION_PROP = 'expressions';
var DEFAULT_SINGLE_PROP = 'expression';

/**
 * NodePath class encapsulates a traversing node,
 * its parent node, property name in the parent node, and
 * an index (in case if a node is part of a collection).
 * It also provides set of methods for AST manipulation.
 */

var NodePath$2 = function () {
  /**
   * NodePath constructor.
   *
   * @param Object node - an AST node
   * @param NodePath parentPath - a nullable parent path
   * @param string property - property name of the node in the parent
   * @param number index - index of the node in a collection.
   */
  function NodePath(node) {
    var parentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var property = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    _classCallCheck$6(this, NodePath);

    this.node = node;
    this.parentPath = parentPath;
    this.parent = parentPath ? parentPath.node : null;
    this.property = property;
    this.index = index;
  }

  _createClass$6(NodePath, [{
    key: '_enforceProp',
    value: function _enforceProp(property) {
      if (!this.node.hasOwnProperty(property)) {
        throw new Error('Node of type ' + this.node.type + ' doesn\'t have "' + property + '" collection.');
      }
    }

    /**
     * Sets a node into a children collection or the single child.
     * By default child nodes are supposed to be under `expressions` property.
     * An explicit property can be passed.
     *
     * @param Object node - a node to set into a collection or as single child
     * @param number index - index at which to set
     * @param string property - name of the collection or single property
     */

  }, {
    key: 'setChild',
    value: function setChild(node) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var property = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;


      var childPath = void 0;
      if (index != null) {
        if (!property) {
          property = DEFAULT_COLLECTION_PROP;
        }
        this._enforceProp(property);
        this.node[property][index] = node;
        childPath = NodePath.getForNode(node, this, property, index);
      } else {
        if (!property) {
          property = DEFAULT_SINGLE_PROP;
        }
        this._enforceProp(property);
        this.node[property] = node;
        childPath = NodePath.getForNode(node, this, property, null);
      }
      return childPath;
    }

    /**
     * Appends a node to a children collection.
     * By default child nodes are supposed to be under `expressions` property.
     * An explicit property can be passed.
     *
     * @param Object node - a node to set into a collection or as single child
     * @param string property - name of the collection or single property
     */

  }, {
    key: 'appendChild',
    value: function appendChild(node) {
      var property = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;


      if (!property) {
        property = DEFAULT_COLLECTION_PROP;
      }
      this._enforceProp(property);
      var end = this.node[property].length;
      return this.setChild(node, end, property);
    }

    /**
     * Inserts a node into a collection.
     * By default child nodes are supposed to be under `expressions` property.
     * An explicit property can be passed.
     *
     * @param Object node - a node to insert into a collection
     * @param number index - index at which to insert
     * @param string property - name of the collection property
     */

  }, {
    key: 'insertChildAt',
    value: function insertChildAt(node, index) {
      var property = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_COLLECTION_PROP;

      this._enforceProp(property);

      this.node[property].splice(index, 0, node);

      // If we inserted a node before the traversing index,
      // we should increase the later.
      if (index <= NodePath.getTraversingIndex()) {
        NodePath.updateTraversingIndex(1);
      }

      this._rebuildIndex(this.node, property);
    }

    /**
     * Removes a node.
     */

  }, {
    key: 'remove',
    value: function remove() {
      if (this.isRemoved()) {
        return;
      }
      NodePath.registry.delete(this.node);

      this.node = null;

      if (!this.parent) {
        return;
      }

      // A node is in a collection.
      if (this.index !== null) {
        this.parent[this.property].splice(this.index, 1);

        // If we remove a node before the traversing index,
        // we should increase the later.
        if (this.index <= NodePath.getTraversingIndex()) {
          NodePath.updateTraversingIndex(-1);
        }

        // Rebuild index.
        this._rebuildIndex(this.parent, this.property);

        this.index = null;
        this.property = null;

        return;
      }

      // A simple node.
      delete this.parent[this.property];
      this.property = null;
    }

    /**
     * Rebuilds child nodes index (used on remove/insert).
     */

  }, {
    key: '_rebuildIndex',
    value: function _rebuildIndex(parent, property) {
      var parentPath = NodePath.getForNode(parent);

      for (var i = 0; i < parent[property].length; i++) {
        var path = NodePath.getForNode(parent[property][i], parentPath, property, i);
        path.index = i;
      }
    }

    /**
     * Whether the path was removed.
     */

  }, {
    key: 'isRemoved',
    value: function isRemoved() {
      return this.node === null;
    }

    /**
     * Replaces a node with the passed one.
     */

  }, {
    key: 'replace',
    value: function replace(newNode) {
      NodePath.registry.delete(this.node);

      this.node = newNode;

      if (!this.parent) {
        return null;
      }

      // A node is in a collection.
      if (this.index !== null) {
        this.parent[this.property][this.index] = newNode;
      }

      // A simple node.
      else {
          this.parent[this.property] = newNode;
        }

      // Rebuild the node path for the new node.
      return NodePath.getForNode(newNode, this.parentPath, this.property, this.index);
    }

    /**
     * Updates a node inline.
     */

  }, {
    key: 'update',
    value: function update(nodeProps) {
      Object.assign(this.node, nodeProps);
    }

    /**
     * Returns parent.
     */

  }, {
    key: 'getParent',
    value: function getParent() {
      return this.parentPath;
    }

    /**
     * Returns nth child.
     */

  }, {
    key: 'getChild',
    value: function getChild() {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (this.node.expressions) {
        return NodePath.getForNode(this.node.expressions[n], this, DEFAULT_COLLECTION_PROP, n);
      } else if (this.node.expression && n == 0) {
        return NodePath.getForNode(this.node.expression, this, DEFAULT_SINGLE_PROP);
      }
      return null;
    }

    /**
     * Whether a path node is syntactically equal to the passed one.
     *
     * NOTE: we don't rely on `source` property from the `loc` data
     * (which would be the fastest comparison), since it might be unsync
     * after several modifications. We use here simple `JSON.stringify`
     * excluding the `loc` data.
     *
     * @param NodePath other - path to compare to.
     * @return boolean
     */

  }, {
    key: 'hasEqualSource',
    value: function hasEqualSource(path) {
      return JSON.stringify(this.node, jsonSkipLoc) === JSON.stringify(path.node, jsonSkipLoc);
    }

    /**
     * JSON-encodes a node skipping location.
     */

  }, {
    key: 'jsonEncode',
    value: function jsonEncode() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          format = _ref.format,
          useLoc = _ref.useLoc;

      return JSON.stringify(this.node, useLoc ? null : jsonSkipLoc, format);
    }

    /**
     * Returns previous sibling.
     */

  }, {
    key: 'getPreviousSibling',
    value: function getPreviousSibling() {
      if (!this.parent || this.index == null) {
        return null;
      }
      return NodePath.getForNode(this.parent[this.property][this.index - 1], NodePath.getForNode(this.parent), this.property, this.index - 1);
    }

    /**
     * Returns next sibling.
     */

  }, {
    key: 'getNextSibling',
    value: function getNextSibling() {
      if (!this.parent || this.index == null) {
        return null;
      }
      return NodePath.getForNode(this.parent[this.property][this.index + 1], NodePath.getForNode(this.parent), this.property, this.index + 1);
    }

    /**
     * Returns a NodePath instance for a node.
     *
     * The same NodePath can be reused in several places, e.g.
     * a parent node passed for all its children.
     */

  }], [{
    key: 'getForNode',
    value: function getForNode(node) {
      var parentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var prop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;

      if (!node) {
        return null;
      }

      if (!NodePath.registry.has(node)) {
        NodePath.registry.set(node, new NodePath(node, parentPath, prop, index == -1 ? null : index));
      }

      var path = NodePath.registry.get(node);

      if (parentPath !== null) {
        path.parentPath = parentPath;
        path.parent = path.parentPath.node;
      }

      if (prop !== null) {
        path.property = prop;
      }

      if (index >= 0) {
        path.index = index;
      }

      return path;
    }

    /**
     * Initializes the NodePath registry. The registry is a map from
     * a node to its NodePath instance.
     */

  }, {
    key: 'initRegistry',
    value: function initRegistry() {
      if (!NodePath.registry) {
        NodePath.registry = new Map();
      }
      NodePath.registry.clear();
    }

    /**
     * Updates index of a currently traversing collection.
     */

  }, {
    key: 'updateTraversingIndex',
    value: function updateTraversingIndex(dx) {
      return NodePath.traversingIndexStack[NodePath.traversingIndexStack.length - 1] += dx;
    }

    /**
     * Returns current traversing index.
     */

  }, {
    key: 'getTraversingIndex',
    value: function getTraversingIndex() {
      return NodePath.traversingIndexStack[NodePath.traversingIndexStack.length - 1];
    }
  }]);

  return NodePath;
}();

NodePath$2.initRegistry();

/**
 * Index of a currently traversing collection is stored on top of the
 * `NodePath.traversingIndexStack`. Remove/insert methods can adjust
 * this index.
 */
NodePath$2.traversingIndexStack = [];

// Helper function used to skip `loc` in JSON operations.
function jsonSkipLoc(prop, value) {
  if (prop === 'loc') {
    return undefined;
  }
  return value;
}

var nodePath = NodePath$2;

nodePath.default;

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var _createClass$5 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$5(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var generator = generator_1;

/**
 * Transform result.
 */

(function () {
  /**
   * Initializes a transform result for an AST.
   *
   * @param Object ast - an AST node
   * @param mixed extra - any extra data a transform may return
   */
  function TransformResult(ast) {
    var extra = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck$5(this, TransformResult);

    this._ast = ast;
    this._source = null;
    this._string = null;
    this._regexp = null;
    this._extra = extra;
  }

  _createClass$5(TransformResult, [{
    key: 'getAST',
    value: function getAST() {
      return this._ast;
    }
  }, {
    key: 'setExtra',
    value: function setExtra(extra) {
      this._extra = extra;
    }
  }, {
    key: 'getExtra',
    value: function getExtra() {
      return this._extra;
    }
  }, {
    key: 'toRegExp',
    value: function toRegExp() {
      if (!this._regexp) {
        this._regexp = new RegExp(this.getSource(), this._ast.flags);
      }
      return this._regexp;
    }
  }, {
    key: 'getSource',
    value: function getSource() {
      if (!this._source) {
        this._source = generator.generate(this._ast.body);
      }
      return this._source;
    }
  }, {
    key: 'getFlags',
    value: function getFlags() {
      return this._ast.flags;
    }
  }, {
    key: 'toString',
    value: function toString() {
      if (!this._string) {
        this._string = generator.generate(this._ast);
      }
      return this._string;
    }
  }]);

  return TransformResult;
})();

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to transform surrogate pairs into single unicode code point
 *
 * \ud83d\ude80 -> \u{1f680}
 */

var charSurrogatePairToSingleUnicodeTransform = {
  shouldRun: function shouldRun(ast) {
    return ast.flags.includes('u');
  },
  Char: function Char(path) {
    var node = path.node;

    if (node.kind !== 'unicode' || !node.isSurrogatePair || isNaN(node.codePoint)) {
      return;
    }
    node.value = '\\u{' + node.codePoint.toString(16) + '}';
    delete node.isSurrogatePair;
  }
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var UPPER_A_CP$1 = 'A'.codePointAt(0);
var UPPER_Z_CP$1 = 'Z'.codePointAt(0);
var LOWER_A_CP = 'a'.codePointAt(0);
var LOWER_Z_CP = 'z'.codePointAt(0);
var DIGIT_0_CP = '0'.codePointAt(0);
var DIGIT_9_CP = '9'.codePointAt(0);

/**
 * A regexp-tree plugin to transform coded chars into simple chars.
 *
 * \u0061 -> a
 */
var charCodeToSimpleCharTransform = {
  Char: function Char(path) {
    var node = path.node,
        parent = path.parent;

    if (isNaN(node.codePoint) || node.kind === 'simple') {
      return;
    }

    if (parent.type === 'ClassRange') {
      if (!isSimpleRange(parent)) {
        return;
      }
    }

    if (!isPrintableASCIIChar(node.codePoint)) {
      return;
    }

    var symbol = String.fromCodePoint(node.codePoint);
    var newChar = {
      type: 'Char',
      kind: 'simple',
      value: symbol,
      symbol: symbol,
      codePoint: node.codePoint
    };
    if (needsEscape(symbol, parent.type)) {
      newChar.escaped = true;
    }
    path.replace(newChar);
  }
};

/**
 * Checks if a range is included either in 0-9, a-z or A-Z
 * @param classRange
 * @returns {boolean}
 */
function isSimpleRange(classRange) {
  var from = classRange.from,
      to = classRange.to;

  return from.codePoint >= DIGIT_0_CP && from.codePoint <= DIGIT_9_CP && to.codePoint >= DIGIT_0_CP && to.codePoint <= DIGIT_9_CP || from.codePoint >= UPPER_A_CP$1 && from.codePoint <= UPPER_Z_CP$1 && to.codePoint >= UPPER_A_CP$1 && to.codePoint <= UPPER_Z_CP$1 || from.codePoint >= LOWER_A_CP && from.codePoint <= LOWER_Z_CP && to.codePoint >= LOWER_A_CP && to.codePoint <= LOWER_Z_CP;
}

/**
 * Checks if a code point in the range of printable ASCII chars
 * (DEL char excluded)
 * @param codePoint
 * @returns {boolean}
 */
function isPrintableASCIIChar(codePoint) {
  return codePoint >= 0x20 && codePoint <= 0x7e;
}

function needsEscape(symbol, parentType) {
  if (parentType === 'ClassRange' || parentType === 'CharacterClass') {
    return (/[\]\\^-]/.test(symbol)
    );
  }

  return (/[*[()+?^$./\\|{}]/.test(symbol)
  );
}

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var UPPER_A_CP = 'A'.codePointAt(0);
var UPPER_Z_CP = 'Z'.codePointAt(0);
/**
 * Transforms case-insensitive regexp to lowercase
 *
 * /AaBb/i -> /aabb/i
 */
var charCaseInsensitiveLowercaseTransform = {
  _AZClassRanges: null,
  _hasUFlag: false,
  init: function init(ast) {
    this._AZClassRanges = new Set();
    this._hasUFlag = ast.flags.includes('u');
  },
  shouldRun: function shouldRun(ast) {
    return ast.flags.includes('i');
  },
  Char: function Char(path) {
    var node = path.node,
        parent = path.parent;

    if (isNaN(node.codePoint)) {
      return;
    }

    // Engine support for case-insensitive matching without the u flag
    // for characters above \u1000 does not seem reliable.
    if (!this._hasUFlag && node.codePoint >= 0x1000) {
      return;
    }

    if (parent.type === 'ClassRange') {
      // The only class ranges we handle must be inside A-Z.
      // After the `from` char is processed, the isAZClassRange test
      // will be false, so we use a Set to keep track of parents and
      // process the `to` char.
      if (!this._AZClassRanges.has(parent) && !isAZClassRange(parent)) {
        return;
      }
      this._AZClassRanges.add(parent);
    }

    var lower = node.symbol.toLowerCase();
    if (lower !== node.symbol) {
      node.value = displaySymbolAsValue(lower, node);
      node.symbol = lower;
      node.codePoint = lower.codePointAt(0);
    }
  }
};

function isAZClassRange(classRange) {
  var from = classRange.from,
      to = classRange.to;
  // A-Z

  return from.codePoint >= UPPER_A_CP && from.codePoint <= UPPER_Z_CP && to.codePoint >= UPPER_A_CP && to.codePoint <= UPPER_Z_CP;
}

function displaySymbolAsValue(symbol, node) {
  var codePoint = symbol.codePointAt(0);
  if (node.kind === 'decimal') {
    return '\\' + codePoint;
  }
  if (node.kind === 'oct') {
    return '\\0' + codePoint.toString(8);
  }
  if (node.kind === 'hex') {
    return '\\x' + codePoint.toString(16);
  }
  if (node.kind === 'unicode') {
    if (node.isSurrogatePair) {
      var _getSurrogatePairFrom = getSurrogatePairFromCodePoint(codePoint),
          lead = _getSurrogatePairFrom.lead,
          trail = _getSurrogatePairFrom.trail;

      return '\\u' + '0'.repeat(4 - lead.length) + lead + '\\u' + '0'.repeat(4 - trail.length) + trail;
    } else if (node.value.includes('{')) {
      return '\\u{' + codePoint.toString(16) + '}';
    } else {
      var code = codePoint.toString(16);
      return '\\u' + '0'.repeat(4 - code.length) + code;
    }
  }
  // simple
  return symbol;
}

/**
 * Converts a code point to a surrogate pair.
 * Conversion algorithm is taken from The Unicode Standard 3.0 Section 3.7
 * (https://www.unicode.org/versions/Unicode3.0.0/ch03.pdf)
 * @param {number} codePoint - Between 0x10000 and 0x10ffff
 * @returns {{lead: string, trail: string}}
 */
function getSurrogatePairFromCodePoint(codePoint) {
  var lead = Math.floor((codePoint - 0x10000) / 0x400) + 0xd800;
  var trail = (codePoint - 0x10000) % 0x400 + 0xdc00;
  return {
    lead: lead.toString(16),
    trail: trail.toString(16)
  };
}

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to remove duplicates from character classes.
 */

var charClassRemoveDuplicatesTransform = {
  CharacterClass: function CharacterClass(path) {
    var node = path.node;

    var sources = {};

    for (var i = 0; i < node.expressions.length; i++) {
      var childPath = path.getChild(i);
      var source = childPath.jsonEncode();

      if (sources.hasOwnProperty(source)) {
        childPath.remove();

        // Since we remove the current node.
        // TODO: make it simpler for users with a method.
        i--;
      }

      sources[source] = true;
    }
  }
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * Flattens a nested disjunction node to a list.
 *
 * /a|b|c|d/
 *
 * {{{a, b}, c}, d} -> [a, b, c, d]
 */

function _toConsumableArray$6(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function disjunctionToList$1(node) {
  if (node.type !== 'Disjunction') {
    throw new TypeError('Expected "Disjunction" node, got "' + node.type + '"');
  }

  var list = [];

  if (node.left && node.left.type === 'Disjunction') {
    list.push.apply(list, _toConsumableArray$6(disjunctionToList$1(node.left)).concat([node.right]));
  } else {
    list.push(node.left, node.right);
  }

  return list;
}

/**
 * Builds a nested disjunction node from a list.
 *
 * /a|b|c|d/
 *
 * [a, b, c, d] -> {{{a, b}, c}, d}
 */
function listToDisjunction$1(list) {
  return list.reduce(function (left, right) {
    return {
      type: 'Disjunction',
      left: left,
      right: right
    };
  });
}

/**
 * Increases a quantifier by one.
 * Does not change greediness.
 * * -> +
 * + -> {2,}
 * ? -> {1,2}
 * {2} -> {3}
 * {2,} -> {3,}
 * {2,3} -> {3,4}
 */
function increaseQuantifierByOne$2(quantifier) {
  if (quantifier.kind === '*') {

    quantifier.kind = '+';
  } else if (quantifier.kind === '+') {

    quantifier.kind = 'Range';
    quantifier.from = 2;
    delete quantifier.to;
  } else if (quantifier.kind === '?') {

    quantifier.kind = 'Range';
    quantifier.from = 1;
    quantifier.to = 2;
  } else if (quantifier.kind === 'Range') {

    quantifier.from += 1;
    if (quantifier.to) {
      quantifier.to += 1;
    }
  }
}

var utils = {
  disjunctionToList: disjunctionToList$1,
  listToDisjunction: listToDisjunction$1,
  increaseQuantifierByOne: increaseQuantifierByOne$2
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var _require$5 = utils,
    increaseQuantifierByOne$1 = _require$5.increaseQuantifierByOne;

/**
 * A regexp-tree plugin to merge quantifiers
 *
 * a+a+ -> a{2,}
 * a{2}a{3} -> a{5}
 * a{1,2}a{2,3} -> a{3,5}
 */


var quantifiersMergeTransform = {
  Repetition: function Repetition(path) {
    var node = path.node,
        parent = path.parent;


    if (parent.type !== 'Alternative' || !path.index) {
      return;
    }

    var previousSibling = path.getPreviousSibling();

    if (!previousSibling) {
      return;
    }

    if (previousSibling.node.type === 'Repetition') {
      if (!previousSibling.getChild().hasEqualSource(path.getChild())) {
        return;
      }

      var _extractFromTo = extractFromTo(previousSibling.node.quantifier),
          previousSiblingFrom = _extractFromTo.from,
          previousSiblingTo = _extractFromTo.to;

      var _extractFromTo2 = extractFromTo(node.quantifier),
          nodeFrom = _extractFromTo2.from,
          nodeTo = _extractFromTo2.to;

      // It's does not seem reliable to merge quantifiers with different greediness
      // when none of both is a greedy open range


      if (previousSibling.node.quantifier.greedy !== node.quantifier.greedy && !isGreedyOpenRange(previousSibling.node.quantifier) && !isGreedyOpenRange(node.quantifier)) {
        return;
      }

      // a*a* -> a*
      // a*a+ -> a+
      // a+a+ -> a{2,}
      // a{2}a{4} -> a{6}
      // a{1,2}a{2,3} -> a{3,5}
      // a{1,}a{2,} -> a{3,}
      // a+a{2,} -> a{3,}

      // a??a{2,} -> a{2,}
      // a*?a{2,} -> a{2,}
      // a+?a{2,} -> a{3,}

      node.quantifier.kind = 'Range';
      node.quantifier.from = previousSiblingFrom + nodeFrom;
      if (previousSiblingTo && nodeTo) {
        node.quantifier.to = previousSiblingTo + nodeTo;
      } else {
        delete node.quantifier.to;
      }
      if (isGreedyOpenRange(previousSibling.node.quantifier) || isGreedyOpenRange(node.quantifier)) {
        node.quantifier.greedy = true;
      }

      previousSibling.remove();
    } else {
      if (!previousSibling.hasEqualSource(path.getChild())) {
        return;
      }

      increaseQuantifierByOne$1(node.quantifier);
      previousSibling.remove();
    }
  }
};

function isGreedyOpenRange(quantifier) {
  return quantifier.greedy && (quantifier.kind === '+' || quantifier.kind === '*' || quantifier.kind === 'Range' && !quantifier.to);
}

function extractFromTo(quantifier) {
  var from = void 0,
      to = void 0;
  if (quantifier.kind === '*') {
    from = 0;
  } else if (quantifier.kind === '+') {
    from = 1;
  } else if (quantifier.kind === '?') {
    from = 0;
    to = 1;
  } else {
    from = quantifier.from;
    if (quantifier.to) {
      to = quantifier.to;
    }
  }
  return { from: from, to: to };
}

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to replace different range-based quantifiers
 * with their symbol equivalents.
 *
 * a{0,} -> a*
 * a{1,} -> a+
 * a{1} -> a
 *
 * NOTE: the following is automatically handled in the generator:
 *
 * a{3,3} -> a{3}
 */

var quantifierRangeToSymbolTransform = {
  Quantifier: function Quantifier(path) {
    var node = path.node;


    if (node.kind !== 'Range') {
      return;
    }

    // a{0,} -> a*
    rewriteOpenZero(path);

    // a{1,} -> a+
    rewriteOpenOne(path);

    // a{1} -> a
    rewriteExactOne(path);
  }
};

function rewriteOpenZero(path) {
  var node = path.node;


  if (node.from !== 0 || node.to) {
    return;
  }

  node.kind = '*';
  delete node.from;
}

function rewriteOpenOne(path) {
  var node = path.node;


  if (node.from !== 1 || node.to) {
    return;
  }

  node.kind = '+';
  delete node.from;
}

function rewriteExactOne(path) {
  var node = path.node;


  if (node.from !== 1 || node.to !== 1) {
    return;
  }

  path.parentPath.replace(path.parentPath.node.expression);
}

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to simplify character classes
 * spanning only one or two chars.
 *
 * [a-a] -> [a]
 * [a-b] -> [ab]
 */

var charClassClassrangesToCharsTransform = {
  ClassRange: function ClassRange(path) {
    var node = path.node;


    if (node.from.codePoint === node.to.codePoint) {

      path.replace(node.from);
    } else if (node.from.codePoint === node.to.codePoint - 1) {

      path.getParent().insertChildAt(node.to, path.index + 1);
      path.replace(node.from);
    }
  }
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to replace standard character classes with
 * their meta symbols equivalents.
 */

function _toConsumableArray$5(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var charClassToMetaTransform = {
  _hasIFlag: false,
  _hasUFlag: false,
  init: function init(ast) {
    this._hasIFlag = ast.flags.includes('i');
    this._hasUFlag = ast.flags.includes('u');
  },
  CharacterClass: function CharacterClass(path) {
    // [0-9] -> \d
    rewriteNumberRanges(path);

    // [a-zA-Z_0-9] -> \w
    rewriteWordRanges(path, this._hasIFlag, this._hasUFlag);

    // [ \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff] -> \s
    rewriteWhitespaceRanges(path);
  }
};

/**
 * Rewrites number ranges: [0-9] -> \d
 */
function rewriteNumberRanges(path) {
  var node = path.node;


  node.expressions.forEach(function (expression, i) {
    if (isFullNumberRange(expression)) {
      path.getChild(i).replace({
        type: 'Char',
        value: '\\d',
        kind: 'meta'
      });
    }
  });
}

/**
 * Rewrites word ranges: [a-zA-Z_0-9] -> \w
 * Thus, the ranges may go in any order, and other symbols/ranges
 * are kept untouched, e.g. [a-z_\dA-Z$] -> [\w$]
 */
function rewriteWordRanges(path, hasIFlag, hasUFlag) {
  var node = path.node;


  var numberPath = null;
  var lowerCasePath = null;
  var upperCasePath = null;
  var underscorePath = null;
  var u017fPath = null;
  var u212aPath = null;

  node.expressions.forEach(function (expression, i) {
    // \d
    if (isMetaChar(expression, '\\d')) {
      numberPath = path.getChild(i);
    }

    // a-z
    else if (isLowerCaseRange(expression)) {
        lowerCasePath = path.getChild(i);
      }

      // A-Z
      else if (isUpperCaseRange(expression)) {
          upperCasePath = path.getChild(i);
        }

        // _
        else if (isUnderscore(expression)) {
            underscorePath = path.getChild(i);
          } else if (hasIFlag && hasUFlag && isCodePoint(expression, 0x017f)) {
            u017fPath = path.getChild(i);
          } else if (hasIFlag && hasUFlag && isCodePoint(expression, 0x212a)) {
            u212aPath = path.getChild(i);
          }
  });

  // If we found the whole pattern, replace it.
  if (numberPath && (lowerCasePath && upperCasePath || hasIFlag && (lowerCasePath || upperCasePath)) && underscorePath && (!hasUFlag || !hasIFlag || u017fPath && u212aPath)) {
    // Put \w in place of \d.
    numberPath.replace({
      type: 'Char',
      value: '\\w',
      kind: 'meta'
    });

    // Other paths are removed.
    if (lowerCasePath) {
      lowerCasePath.remove();
    }
    if (upperCasePath) {
      upperCasePath.remove();
    }
    underscorePath.remove();
    if (u017fPath) {
      u017fPath.remove();
    }
    if (u212aPath) {
      u212aPath.remove();
    }
  }
}

/**
 * Rewrites whitespace ranges: [ \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff] -> \s.
 */
var whitespaceRangeTests = [function (node) {
  return isChar(node, ' ');
}].concat(_toConsumableArray$5(['\\f', '\\n', '\\r', '\\t', '\\v'].map(function (char) {
  return function (node) {
    return isMetaChar(node, char);
  };
})), _toConsumableArray$5([0x00a0, 0x1680, 0x2028, 0x2029, 0x202f, 0x205f, 0x3000, 0xfeff].map(function (codePoint) {
  return function (node) {
    return isCodePoint(node, codePoint);
  };
})), [function (node) {
  return node.type === 'ClassRange' && isCodePoint(node.from, 0x2000) && isCodePoint(node.to, 0x200a);
}]);

function rewriteWhitespaceRanges(path) {
  var node = path.node;


  if (node.expressions.length < whitespaceRangeTests.length || !whitespaceRangeTests.every(function (test) {
    return node.expressions.some(function (expression) {
      return test(expression);
    });
  })) {
    return;
  }

  // If we found the whole pattern, replace it.

  // Put \s in place of \n.
  var nNode = node.expressions.find(function (expression) {
    return isMetaChar(expression, '\\n');
  });
  nNode.value = '\\s';
  nNode.symbol = undefined;
  nNode.codePoint = NaN;

  // Other paths are removed.
  node.expressions.map(function (expression, i) {
    return whitespaceRangeTests.some(function (test) {
      return test(expression);
    }) ? path.getChild(i) : undefined;
  }).filter(Boolean).forEach(function (path) {
    return path.remove();
  });
}

function isFullNumberRange(node) {
  return node.type === 'ClassRange' && node.from.value === '0' && node.to.value === '9';
}

function isChar(node, value) {
  var kind = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'simple';

  return node.type === 'Char' && node.value === value && node.kind === kind;
}

function isMetaChar(node, value) {
  return isChar(node, value, 'meta');
}

function isLowerCaseRange(node) {
  return node.type === 'ClassRange' && node.from.value === 'a' && node.to.value === 'z';
}

function isUpperCaseRange(node) {
  return node.type === 'ClassRange' && node.from.value === 'A' && node.to.value === 'Z';
}

function isUnderscore(node) {
  return node.type === 'Char' && node.value === '_' && node.kind === 'simple';
}

function isCodePoint(node, codePoint) {
  return node.type === 'Char' && node.kind === 'unicode' && node.codePoint === codePoint;
}

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to replace single char character classes with
 * just that character.
 *
 * [\d] -> \d, [^\w] -> \W
 */

var charClassToSingleCharTransform = {
  CharacterClass: function CharacterClass(path) {
    var node = path.node;


    if (node.expressions.length !== 1 || !hasAppropriateSiblings$1(path) || !isAppropriateChar(node.expressions[0])) {
      return;
    }

    var _node$expressions$ = node.expressions[0],
        value = _node$expressions$.value,
        kind = _node$expressions$.kind,
        escaped = _node$expressions$.escaped;


    if (node.negative) {
      // For negative can extract only meta chars like [^\w] -> \W
      // cannot do for [^a] -> a (wrong).
      if (!isMeta$1(value)) {
        return;
      }

      value = getInverseMeta(value);
    }

    path.replace({
      type: 'Char',
      value: value,
      kind: kind,
      escaped: escaped || shouldEscape(value)
    });
  }
};

function isAppropriateChar(node) {
  return node.type === 'Char' &&
  // We don't extract [\b] (backspace) since \b has different
  // semantics (word boundary).
  node.value !== '\\b';
}

function isMeta$1(value) {
  return (/^\\[dwsDWS]$/.test(value)
  );
}

function getInverseMeta(value) {
  return (/[dws]/.test(value) ? value.toUpperCase() : value.toLowerCase()
  );
}

function hasAppropriateSiblings$1(path) {
  var parent = path.parent,
      index = path.index;


  if (parent.type !== 'Alternative') {
    return true;
  }

  var previousNode = parent.expressions[index - 1];
  if (previousNode == null) {
    return true;
  }

  // Don't optimized \1[0] to \10
  if (previousNode.type === 'Backreference' && previousNode.kind === 'number') {
    return false;
  }

  // Don't optimized \2[0] to \20
  if (previousNode.type === 'Char' && previousNode.kind === 'decimal') {
    return false;
  }

  return true;
}

// Note: \{ and \} are always preserved to avoid `a[{]2[}]` turning
// into `a{2}`.
function shouldEscape(value) {
  return (/[*[()+?$./{}|]/.test(value)
  );
}

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to remove unnecessary escape.
 *
 * \e -> e
 *
 * [\(] -> [(]
 */

var charEscapeUnescapeTransform = {
  _hasXFlag: false,
  init: function init(ast) {
    this._hasXFlag = ast.flags.includes('x');
  },
  Char: function Char(path) {
    var node = path.node;


    if (!node.escaped) {
      return;
    }

    if (shouldUnescape(path, this._hasXFlag)) {
      delete node.escaped;
    }
  }
};

function shouldUnescape(path, hasXFlag) {
  var value = path.node.value,
      index = path.index,
      parent = path.parent;

  // In char class (, etc are allowed.

  if (parent.type !== 'CharacterClass' && parent.type !== 'ClassRange') {
    return !preservesEscape(value, index, parent, hasXFlag);
  }

  return !preservesInCharClass(value, index, parent);
}

/**
 * \], \\, \^, \-
 */
function preservesInCharClass(value, index, parent) {
  if (value === '^') {
    // Avoid [\^a] turning into [^a]
    return index === 0 && !parent.negative;
  }
  if (value === '-') {
    // Avoid [a\-z] turning into [a-z]
    return true;
  }
  return (/[\]\\]/.test(value)
  );
}

function preservesEscape(value, index, parent, hasXFlag) {
  if (value === '{') {
    return preservesOpeningCurlyBraceEscape(index, parent);
  }

  if (value === '}') {
    return preservesClosingCurlyBraceEscape(index, parent);
  }

  if (hasXFlag && /[ #]/.test(value)) {
    return true;
  }

  return (/[*[()+?^$./\\|]/.test(value)
  );
}

function consumeNumbers(startIndex, parent, rtl) {
  var i = startIndex;
  var siblingNode = (rtl ? i >= 0 : i < parent.expressions.length) && parent.expressions[i];

  while (siblingNode && siblingNode.type === 'Char' && siblingNode.kind === 'simple' && !siblingNode.escaped && /\d/.test(siblingNode.value)) {
    rtl ? i-- : i++;
    siblingNode = (rtl ? i >= 0 : i < parent.expressions.length) && parent.expressions[i];
  }

  return Math.abs(startIndex - i);
}

function isSimpleChar(node, value) {
  return node && node.type === 'Char' && node.kind === 'simple' && !node.escaped && node.value === value;
}

function preservesOpeningCurlyBraceEscape(index, parent) {
  // (?:\{) -> (?:{)
  if (index == null) {
    return false;
  }

  var nbFollowingNumbers = consumeNumbers(index + 1, parent);
  var i = index + nbFollowingNumbers + 1;
  var nextSiblingNode = i < parent.expressions.length && parent.expressions[i];

  if (nbFollowingNumbers) {
    // Avoid \{3} turning into {3}
    if (isSimpleChar(nextSiblingNode, '}')) {
      return true;
    }

    if (isSimpleChar(nextSiblingNode, ',')) {
      nbFollowingNumbers = consumeNumbers(i + 1, parent);
      i = i + nbFollowingNumbers + 1;
      nextSiblingNode = i < parent.expressions.length && parent.expressions[i];

      // Avoid \{3,} turning into {3,}
      return isSimpleChar(nextSiblingNode, '}');
    }
  }
  return false;
}

function preservesClosingCurlyBraceEscape(index, parent) {
  // (?:\{) -> (?:{)
  if (index == null) {
    return false;
  }

  var nbPrecedingNumbers = consumeNumbers(index - 1, parent, true);
  var i = index - nbPrecedingNumbers - 1;
  var previousSiblingNode = i >= 0 && parent.expressions[i];

  // Avoid {3\} turning into {3}
  if (nbPrecedingNumbers && isSimpleChar(previousSiblingNode, '{')) {
    return true;
  }

  if (isSimpleChar(previousSiblingNode, ',')) {
    nbPrecedingNumbers = consumeNumbers(i - 1, parent, true);
    i = i - nbPrecedingNumbers - 1;
    previousSiblingNode = i < parent.expressions.length && parent.expressions[i];

    // Avoid {3,\} turning into {3,}
    return nbPrecedingNumbers && isSimpleChar(previousSiblingNode, '{');
  }
  return false;
}

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to merge class ranges.
 *
 * [a-ec] -> [a-e]
 * [a-ec-e] -> [a-e]
 * [\w\da-f] -> [\w]
 * [abcdef] -> [a-f]
 */

var charClassClassrangesMergeTransform = {
  _hasIUFlags: false,
  init: function init(ast) {
    this._hasIUFlags = ast.flags.includes('i') && ast.flags.includes('u');
  },
  CharacterClass: function CharacterClass(path) {
    var node = path.node;

    var expressions = node.expressions;

    var metas = [];
    // Extract metas
    expressions.forEach(function (expression) {
      if (isMeta(expression)) {
        metas.push(expression.value);
      }
    });

    expressions.sort(sortCharClass);

    for (var i = 0; i < expressions.length; i++) {
      var expression = expressions[i];
      if (fitsInMetas(expression, metas, this._hasIUFlags) || combinesWithPrecedingClassRange(expression, expressions[i - 1]) || combinesWithFollowingClassRange(expression, expressions[i + 1])) {
        expressions.splice(i, 1);
        i--;
      } else {
        var nbMergedChars = charCombinesWithPrecedingChars(expression, i, expressions);
        expressions.splice(i - nbMergedChars + 1, nbMergedChars);
        i -= nbMergedChars;
      }
    }
  }
};

/**
 * Sorts expressions in char class in the following order:
 * - meta chars, ordered alphabetically by value
 * - chars (except `control` kind) and class ranges, ordered alphabetically (`from` char is used for class ranges)
 * - if ambiguous, class range comes before char
 * - if ambiguous between two class ranges, orders alphabetically by `to` char
 * - control chars, ordered alphabetically by value
 * @param {Object} a - Left Char or ClassRange node
 * @param {Object} b - Right Char or ClassRange node
 * @returns {number}
 */
function sortCharClass(a, b) {
  var aValue = getSortValue(a);
  var bValue = getSortValue(b);

  if (aValue === bValue) {
    // We want ClassRange before Char
    // [bb-d] -> [b-db]
    if (a.type === 'ClassRange' && b.type !== 'ClassRange') {
      return -1;
    }
    if (b.type === 'ClassRange' && a.type !== 'ClassRange') {
      return 1;
    }
    if (a.type === 'ClassRange' && b.type === 'ClassRange') {
      return getSortValue(a.to) - getSortValue(b.to);
    }
    if (isMeta(a) && isMeta(b) || isControl(a) && isControl(b)) {
      return a.value < b.value ? -1 : 1;
    }
  }
  return aValue - bValue;
}

/**
 * @param {Object} expression - Char or ClassRange node
 * @returns {number}
 */
function getSortValue(expression) {
  if (expression.type === 'Char') {
    if (expression.value === '-') {
      return Infinity;
    }
    if (expression.kind === 'control') {
      return Infinity;
    }
    if (expression.kind === 'meta' && isNaN(expression.codePoint)) {
      return -1;
    }
    return expression.codePoint;
  }
  // ClassRange
  return expression.from.codePoint;
}

/**
 * Checks if a node is a meta char from the set \d\w\s\D\W\S
 * @param {Object} expression - Char or ClassRange node
 * @param {?string} value
 * @returns {boolean}
 */
function isMeta(expression) {
  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  return expression.type === 'Char' && expression.kind === 'meta' && (value ? expression.value === value : /^\\[dws]$/i.test(expression.value));
}

/**
 * @param {Object} expression - Char or ClassRange node
 * @returns {boolean}
 */
function isControl(expression) {
  return expression.type === 'Char' && expression.kind === 'control';
}

/**
 * @param {Object} expression - Char or ClassRange node
 * @param {string[]} metas - Array of meta chars, e.g. ["\\w", "\\s"]
 * @param {boolean} hasIUFlags
 * @returns {boolean}
 */
function fitsInMetas(expression, metas, hasIUFlags) {
  for (var i = 0; i < metas.length; i++) {
    if (fitsInMeta(expression, metas[i], hasIUFlags)) {
      return true;
    }
  }
  return false;
}

/**
 * @param {Object} expression - Char or ClassRange node
 * @param {string} meta - e.g. "\\w"
 * @param {boolean} hasIUFlags
 * @returns {boolean}
 */
function fitsInMeta(expression, meta, hasIUFlags) {
  if (expression.type === 'ClassRange') {
    return fitsInMeta(expression.from, meta, hasIUFlags) && fitsInMeta(expression.to, meta, hasIUFlags);
  }

  // Special cases:
  // \S contains \w and \d
  if (meta === '\\S' && (isMeta(expression, '\\w') || isMeta(expression, '\\d'))) {
    return true;
  }
  // \D contains \W and \s
  if (meta === '\\D' && (isMeta(expression, '\\W') || isMeta(expression, '\\s'))) {
    return true;
  }
  // \w contains \d
  if (meta === '\\w' && isMeta(expression, '\\d')) {
    return true;
  }
  // \W contains \s
  if (meta === '\\W' && isMeta(expression, '\\s')) {
    return true;
  }

  if (expression.type !== 'Char' || isNaN(expression.codePoint)) {
    return false;
  }

  if (meta === '\\s') {
    return fitsInMetaS(expression);
  }
  if (meta === '\\S') {
    return !fitsInMetaS(expression);
  }
  if (meta === '\\d') {
    return fitsInMetaD(expression);
  }
  if (meta === '\\D') {
    return !fitsInMetaD(expression);
  }
  if (meta === '\\w') {
    return fitsInMetaW(expression, hasIUFlags);
  }
  if (meta === '\\W') {
    return !fitsInMetaW(expression, hasIUFlags);
  }
  return false;
}

/**
 * @param {Object} expression - Char node with codePoint
 * @returns {boolean}
 */
function fitsInMetaS(expression) {
  return expression.codePoint === 0x0009 || // \t
  expression.codePoint === 0x000a || // \n
  expression.codePoint === 0x000b || // \v
  expression.codePoint === 0x000c || // \f
  expression.codePoint === 0x000d || // \r
  expression.codePoint === 0x0020 || // space
  expression.codePoint === 0x00a0 || // nbsp
  expression.codePoint === 0x1680 || // part of Zs
  expression.codePoint >= 0x2000 && expression.codePoint <= 0x200a || // part of Zs
  expression.codePoint === 0x2028 || // line separator
  expression.codePoint === 0x2029 || // paragraph separator
  expression.codePoint === 0x202f || // part of Zs
  expression.codePoint === 0x205f || // part of Zs
  expression.codePoint === 0x3000 || // part of Zs
  expression.codePoint === 0xfeff; // zwnbsp
}

/**
 * @param {Object} expression - Char node with codePoint
 * @returns {boolean}
 */
function fitsInMetaD(expression) {
  return expression.codePoint >= 0x30 && expression.codePoint <= 0x39; // 0-9
}

/**
 * @param {Object} expression - Char node with codePoint
 * @param {boolean} hasIUFlags
 * @returns {boolean}
 */
function fitsInMetaW(expression, hasIUFlags) {
  return fitsInMetaD(expression) || expression.codePoint >= 0x41 && expression.codePoint <= 0x5a || // A-Z
  expression.codePoint >= 0x61 && expression.codePoint <= 0x7a || // a-z
  expression.value === '_' || hasIUFlags && (expression.codePoint === 0x017f || expression.codePoint === 0x212a);
}

/**
 * @param {Object} expression - Char or ClassRange node
 * @param {Object} classRange - Char or ClassRange node
 * @returns {boolean}
 */
function combinesWithPrecedingClassRange(expression, classRange) {
  if (classRange && classRange.type === 'ClassRange') {
    if (fitsInClassRange(expression, classRange)) {
      // [a-gc] -> [a-g]
      // [a-gc-e] -> [a-g]
      return true;
    } else if (
    // We only want \w chars or char codes to keep readability
    isMetaWCharOrCode(expression) && classRange.to.codePoint === expression.codePoint - 1) {
      // [a-de] -> [a-e]
      classRange.to = expression;
      return true;
    } else if (expression.type === 'ClassRange' && expression.from.codePoint <= classRange.to.codePoint + 1 && expression.to.codePoint >= classRange.from.codePoint - 1) {
      // [a-db-f] -> [a-f]
      // [b-fa-d] -> [a-f]
      // [a-cd-f] -> [a-f]
      if (expression.from.codePoint < classRange.from.codePoint) {
        classRange.from = expression.from;
      }
      if (expression.to.codePoint > classRange.to.codePoint) {
        classRange.to = expression.to;
      }
      return true;
    }
  }
  return false;
}

/**
 * @param {Object} expression - Char or ClassRange node
 * @param {Object} classRange - Char or ClassRange node
 * @returns {boolean}
 */
function combinesWithFollowingClassRange(expression, classRange) {
  if (classRange && classRange.type === 'ClassRange') {
    // Considering the elements were ordered alphabetically,
    // there is only one case to handle
    // [ab-e] -> [a-e]
    if (
    // We only want \w chars or char codes to keep readability
    isMetaWCharOrCode(expression) && classRange.from.codePoint === expression.codePoint + 1) {
      classRange.from = expression;
      return true;
    }
  }

  return false;
}

/**
 * @param {Object} expression - Char or ClassRange node
 * @param {Object} classRange - ClassRange node
 * @returns {boolean}
 */
function fitsInClassRange(expression, classRange) {
  if (expression.type === 'Char' && isNaN(expression.codePoint)) {
    return false;
  }
  if (expression.type === 'ClassRange') {
    return fitsInClassRange(expression.from, classRange) && fitsInClassRange(expression.to, classRange);
  }
  return expression.codePoint >= classRange.from.codePoint && expression.codePoint <= classRange.to.codePoint;
}

/**
 * @param {Object} expression - Char or ClassRange node
 * @param {Number} index
 * @param {Object[]} expressions - expressions in CharClass
 * @returns {number} - Number of characters combined with expression
 */
function charCombinesWithPrecedingChars(expression, index, expressions) {
  // We only want \w chars or char codes to keep readability
  if (!isMetaWCharOrCode(expression)) {
    return 0;
  }
  var nbMergedChars = 0;
  while (index > 0) {
    var currentExpression = expressions[index];
    var precedingExpresion = expressions[index - 1];
    if (isMetaWCharOrCode(precedingExpresion) && precedingExpresion.codePoint === currentExpression.codePoint - 1) {
      nbMergedChars++;
      index--;
    } else {
      break;
    }
  }

  if (nbMergedChars > 1) {
    expressions[index] = {
      type: 'ClassRange',
      from: expressions[index],
      to: expression
    };
    return nbMergedChars;
  }
  return 0;
}

function isMetaWCharOrCode(expression) {
  return expression && expression.type === 'Char' && !isNaN(expression.codePoint) && (fitsInMetaW(expression, false) || expression.kind === 'unicode' || expression.kind === 'hex' || expression.kind === 'oct' || expression.kind === 'decimal');
}

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var NodePath$1 = nodePath;

var _require$4 = utils,
    disjunctionToList = _require$4.disjunctionToList,
    listToDisjunction = _require$4.listToDisjunction;

/**
 * Removes duplicates from a disjunction sequence:
 *
 * /(ab|bc|ab)+(xy|xy)+/ -> /(ab|bc)+(xy)+/
 */


var disjunctionRemoveDuplicatesTransform = {
  Disjunction: function Disjunction(path) {
    var node = path.node;

    // Make unique nodes.

    var uniqueNodesMap = {};

    var parts = disjunctionToList(node).filter(function (part) {
      var encoded = part ? NodePath$1.getForNode(part).jsonEncode() : 'null';

      // Already recorded this part, filter out.
      if (uniqueNodesMap.hasOwnProperty(encoded)) {
        return false;
      }

      uniqueNodesMap[encoded] = part;
      return true;
    });

    // Replace with the optimized disjunction.
    path.replace(listToDisjunction(parts));
  }
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to replace single char group disjunction to char group
 *
 * a|b|c -> [abc]
 * [12]|3|4 -> [1234]
 * (a|b|c) -> ([abc])
 * (?:a|b|c) -> [abc]
 */

var groupSingleCharsToCharClass = {
  Disjunction: function Disjunction(path) {
    var node = path.node,
        parent = path.parent;


    if (!handlers[parent.type]) {
      return;
    }

    var charset = new Map();

    if (!shouldProcess(node, charset) || !charset.size) {
      return;
    }

    var characterClass = {
      type: 'CharacterClass',
      expressions: Array.from(charset.keys()).sort().map(function (key) {
        return charset.get(key);
      })
    };

    handlers[parent.type](path.getParent(), characterClass);
  }
};

var handlers = {
  RegExp: function RegExp(path, characterClass) {
    var node = path.node;


    node.body = characterClass;
  },
  Group: function Group(path, characterClass) {
    var node = path.node;


    if (node.capturing) {
      node.expression = characterClass;
    } else {
      path.replace(characterClass);
    }
  }
};

function shouldProcess(expression, charset) {
  if (!expression) {
    // Abort on empty disjunction part
    return false;
  }

  var type = expression.type;


  if (type === 'Disjunction') {
    var left = expression.left,
        right = expression.right;


    return shouldProcess(left, charset) && shouldProcess(right, charset);
  } else if (type === 'Char') {
    if (expression.kind === 'meta' && expression.symbol === '.') {
      return false;
    }

    var value = expression.value;


    charset.set(value, expression);

    return true;
  } else if (type === 'CharacterClass' && !expression.negative) {
    return expression.expressions.every(function (expression) {
      return shouldProcess(expression, charset);
    });
  }

  return false;
}

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to remove non-capturing empty groups.
 *
 * /(?:)a/ -> /a/
 * /a|(?:)/ -> /a|/
 */

var removeEmptyGroupTransform = {
  Group: function Group(path) {
    var node = path.node,
        parent = path.parent;

    var childPath = path.getChild();

    if (node.capturing || childPath) {
      return;
    }

    if (parent.type === 'Repetition') {

      path.getParent().replace(node);
    } else if (parent.type !== 'RegExp') {

      path.remove();
    }
  }
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A regexp-tree plugin to remove unnecessary groups.
 *
 * /(?:a)/ -> /a/
 */

function _toConsumableArray$4(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var ungroupTransform = {
  Group: function Group(path) {
    var node = path.node,
        parent = path.parent;

    var childPath = path.getChild();

    if (node.capturing || !childPath) {
      return;
    }

    // Don't optimize \1(?:0) to \10
    if (!hasAppropriateSiblings(path)) {
      return;
    }

    // Don't optimize /a(?:b|c)/ to /ab|c/
    // but /(?:b|c)/ to /b|c/ is ok
    if (childPath.node.type === 'Disjunction' && parent.type !== 'RegExp') {
      return;
    }

    // Don't optimize /(?:ab)+/ to /ab+/
    // but /(?:a)+/ to /a+/ is ok
    // and /(?:[a-d])+/ to /[a-d]+/ is ok too
    if (parent.type === 'Repetition' && childPath.node.type !== 'Char' && childPath.node.type !== 'CharacterClass') {
      return;
    }

    if (childPath.node.type === 'Alternative') {
      var parentPath = path.getParent();
      if (parentPath.node.type === 'Alternative') {
        // /abc(?:def)ghi/ When (?:def) is ungrouped its content must be merged with parent alternative

        parentPath.replace({
          type: 'Alternative',
          expressions: [].concat(_toConsumableArray$4(parent.expressions.slice(0, path.index)), _toConsumableArray$4(childPath.node.expressions), _toConsumableArray$4(parent.expressions.slice(path.index + 1)))
        });
      }
    } else {
      path.replace(childPath.node);
    }
  }
};

function hasAppropriateSiblings(path) {
  var parent = path.parent,
      index = path.index;


  if (parent.type !== 'Alternative') {
    return true;
  }

  var previousNode = parent.expressions[index - 1];
  if (previousNode == null) {
    return true;
  }

  // Don't optimized \1(?:0) to \10
  if (previousNode.type === 'Backreference' && previousNode.kind === 'number') {
    return false;
  }

  // Don't optimized \2(?:0) to \20
  if (previousNode.type === 'Char' && previousNode.kind === 'decimal') {
    return false;
  }

  return true;
}

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

function _toConsumableArray$3(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var NodePath = nodePath;

var _require$3 = utils,
    increaseQuantifierByOne = _require$3.increaseQuantifierByOne;

/**
 * A regexp-tree plugin to combine repeating patterns.
 *
 * /^abcabcabc/ -> /^abc{3}/
 * /^(?:abc){2}abc/ -> /^(?:abc){3}/
 * /^abc(?:abc){2}/ -> /^(?:abc){3}/
 */

var combineRepeatingPatternsTransform = {
  Alternative: function Alternative(path) {
    var node = path.node;

    // We can skip the first child

    var index = 1;
    while (index < node.expressions.length) {
      var child = path.getChild(index);
      index = Math.max(1, combineRepeatingPatternLeft(path, child, index));

      if (index >= node.expressions.length) {
        break;
      }

      child = path.getChild(index);
      index = Math.max(1, combineWithPreviousRepetition(path, child, index));

      if (index >= node.expressions.length) {
        break;
      }

      child = path.getChild(index);
      index = Math.max(1, combineRepetitionWithPrevious(path, child, index));

      index++;
    }
  }
};

// abcabc -> (?:abc){2}
function combineRepeatingPatternLeft(alternative, child, index) {
  var node = alternative.node;


  var nbPossibleLengths = Math.ceil(index / 2);
  var i = 0;

  while (i < nbPossibleLengths) {
    var startIndex = index - 2 * i - 1;
    var right = void 0,
        left = void 0;

    if (i === 0) {
      right = child;
      left = alternative.getChild(startIndex);
    } else {
      right = NodePath.getForNode({
        type: 'Alternative',
        expressions: [].concat(_toConsumableArray$3(node.expressions.slice(index - i, index)), [child.node])
      });

      left = NodePath.getForNode({
        type: 'Alternative',
        expressions: [].concat(_toConsumableArray$3(node.expressions.slice(startIndex, index - i)))
      });
    }

    if (right.hasEqualSource(left)) {
      for (var j = 0; j < 2 * i + 1; j++) {
        alternative.getChild(startIndex).remove();
      }

      child.replace({
        type: 'Repetition',
        expression: i === 0 && right.node.type !== 'Repetition' ? right.node : {
          type: 'Group',
          capturing: false,
          expression: right.node
        },
        quantifier: {
          type: 'Quantifier',
          kind: 'Range',
          from: 2,
          to: 2,
          greedy: true
        }
      });
      return startIndex;
    }

    i++;
  }

  return index;
}

// (?:abc){2}abc -> (?:abc){3}
function combineWithPreviousRepetition(alternative, child, index) {
  var node = alternative.node;


  var i = 0;
  while (i < index) {
    var previousChild = alternative.getChild(i);

    if (previousChild.node.type === 'Repetition' && previousChild.node.quantifier.greedy) {
      var left = previousChild.getChild();
      var right = void 0;

      if (left.node.type === 'Group' && !left.node.capturing) {
        left = left.getChild();
      }

      if (i + 1 === index) {
        right = child;
        if (right.node.type === 'Group' && !right.node.capturing) {
          right = right.getChild();
        }
      } else {
        right = NodePath.getForNode({
          type: 'Alternative',
          expressions: [].concat(_toConsumableArray$3(node.expressions.slice(i + 1, index + 1)))
        });
      }

      if (left.hasEqualSource(right)) {
        for (var j = i; j < index; j++) {
          alternative.getChild(i + 1).remove();
        }

        increaseQuantifierByOne(previousChild.node.quantifier);

        return i;
      }
    }

    i++;
  }
  return index;
}

// abc(?:abc){2} -> (?:abc){3}
function combineRepetitionWithPrevious(alternative, child, index) {
  var node = alternative.node;


  if (child.node.type === 'Repetition' && child.node.quantifier.greedy) {
    var right = child.getChild();
    var left = void 0;

    if (right.node.type === 'Group' && !right.node.capturing) {
      right = right.getChild();
    }

    var rightLength = void 0;
    if (right.node.type === 'Alternative') {
      rightLength = right.node.expressions.length;
      left = NodePath.getForNode({
        type: 'Alternative',
        expressions: [].concat(_toConsumableArray$3(node.expressions.slice(index - rightLength, index)))
      });
    } else {
      rightLength = 1;
      left = alternative.getChild(index - 1);
      if (left.node.type === 'Group' && !left.node.capturing) {
        left = left.getChild();
      }
    }

    if (left.hasEqualSource(right)) {
      for (var j = index - rightLength; j < index; j++) {
        alternative.getChild(index - rightLength).remove();
      }

      increaseQuantifierByOne(child.node.quantifier);

      return index - rightLength;
    }
  }
  return index;
}

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var transforms = new Map([
// \ud83d\ude80 -> \u{1f680}
['charSurrogatePairToSingleUnicode', charSurrogatePairToSingleUnicodeTransform],

// \u0061 -> a
['charCodeToSimpleChar', charCodeToSimpleCharTransform],

// /Aa/i -> /aa/i
['charCaseInsensitiveLowerCaseTransform', charCaseInsensitiveLowercaseTransform],

// [\d\d] -> [\d]
['charClassRemoveDuplicates', charClassRemoveDuplicatesTransform],

// a{1,2}a{2,3} -> a{3,5}
['quantifiersMerge', quantifiersMergeTransform],

// a{1,} -> a+, a{3,3} -> a{3}, a{1} -> a
['quantifierRangeToSymbol', quantifierRangeToSymbolTransform],

// [a-a] -> [a], [a-b] -> [ab]
['charClassClassrangesToChars', charClassClassrangesToCharsTransform],

// [0-9] -> [\d]
['charClassToMeta', charClassToMetaTransform],

// [\d] -> \d, [^\w] -> \W
['charClassToSingleChar', charClassToSingleCharTransform],

// \e -> e
['charEscapeUnescape', charEscapeUnescapeTransform],

// [a-de-f] -> [a-f]
['charClassClassrangesMerge', charClassClassrangesMergeTransform],

// (ab|ab) -> (ab)
['disjunctionRemoveDuplicates', disjunctionRemoveDuplicatesTransform],

// (a|b|c) -> [abc]
['groupSingleCharsToCharClass', groupSingleCharsToCharClass],

// (?:)a -> a
['removeEmptyGroup', removeEmptyGroupTransform],

// (?:a) -> a
['ungroup', ungroupTransform],

// abcabcabc -> (?:abc){3}
['combineRepeatingPatterns', combineRepeatingPatternsTransform]]);

transforms.default;

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * Epsilon, the empty string.
 */

var EPSILON$2 = '';

/**
 * Epsilon-closure.
 */
var EPSILON_CLOSURE$2 = EPSILON$2 + '*';

var specialSymbols = {
  EPSILON: EPSILON$2,
  EPSILON_CLOSURE: EPSILON_CLOSURE$2
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var _slicedToArray$1 = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass$4 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray$2(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck$4(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require$2 = specialSymbols,
    EPSILON$1 = _require$2.EPSILON,
    EPSILON_CLOSURE$1 = _require$2.EPSILON_CLOSURE;

/**
 * NFA fragment.
 *
 * NFA sub-fragments can be combined to a larger NFAs building
 * the resulting machine. Combining the fragments is done by patching
 * edges of the in- and out-states.
 *
 * 2-states implementation, `in`, and `out`. Eventually all transitions
 * go to the same `out`, which can further be connected via -transition
 * with other fragment.
 */


var NFA = function () {
  function NFA(inState, outState) {
    _classCallCheck$4(this, NFA);

    this.in = inState;
    this.out = outState;
  }

  /**
   * Tries to recognize a string based on this NFA fragment.
   */


  _createClass$4(NFA, [{
    key: 'matches',
    value: function matches(string) {
      return this.in.matches(string);
    }

    /**
     * Returns an alphabet for this NFA.
     */

  }, {
    key: 'getAlphabet',
    value: function getAlphabet() {
      if (!this._alphabet) {
        this._alphabet = new Set();
        var table = this.getTransitionTable();
        for (var state in table) {
          var transitions = table[state];
          for (var symbol in transitions) {
            if (symbol !== EPSILON_CLOSURE$1) {
              this._alphabet.add(symbol);
            }
          }
        }
      }
      return this._alphabet;
    }

    /**
     * Returns set of accepting states.
     */

  }, {
    key: 'getAcceptingStates',
    value: function getAcceptingStates() {
      if (!this._acceptingStates) {
        // States are determined during table construction.
        this.getTransitionTable();
      }
      return this._acceptingStates;
    }

    /**
     * Returns accepting state numbers.
     */

  }, {
    key: 'getAcceptingStateNumbers',
    value: function getAcceptingStateNumbers() {
      if (!this._acceptingStateNumbers) {
        this._acceptingStateNumbers = new Set();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.getAcceptingStates()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var acceptingState = _step.value;

            this._acceptingStateNumbers.add(acceptingState.number);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
      return this._acceptingStateNumbers;
    }

    /**
     * Builds and returns transition table.
     */

  }, {
    key: 'getTransitionTable',
    value: function getTransitionTable() {
      var _this = this;

      if (!this._transitionTable) {
        this._transitionTable = {};
        this._acceptingStates = new Set();

        var visited = new Set();
        var symbols = new Set();

        var visitState = function visitState(state) {
          if (visited.has(state)) {
            return;
          }

          visited.add(state);
          state.number = visited.size;
          _this._transitionTable[state.number] = {};

          if (state.accepting) {
            _this._acceptingStates.add(state);
          }

          var transitions = state.getTransitions();

          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = transitions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var _ref = _step2.value;

              var _ref2 = _slicedToArray$1(_ref, 2);

              var symbol = _ref2[0];
              var symbolTransitions = _ref2[1];

              var combinedState = [];
              symbols.add(symbol);
              var _iteratorNormalCompletion3 = true;
              var _didIteratorError3 = false;
              var _iteratorError3 = undefined;

              try {
                for (var _iterator3 = symbolTransitions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  var nextState = _step3.value;

                  visitState(nextState);
                  combinedState.push(nextState.number);
                }
              } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                  }
                } finally {
                  if (_didIteratorError3) {
                    throw _iteratorError3;
                  }
                }
              }

              _this._transitionTable[state.number][symbol] = combinedState;
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        };

        // Traverse the graph starting from the `in`.
        visitState(this.in);

        // Append epsilon-closure column.
        visited.forEach(function (state) {
          delete _this._transitionTable[state.number][EPSILON$1];
          _this._transitionTable[state.number][EPSILON_CLOSURE$1] = [].concat(_toConsumableArray$2(state.getEpsilonClosure())).map(function (s) {
            return s.number;
          });
        });
      }

      return this._transitionTable;
    }
  }]);

  return NFA;
}();

var nfa = NFA;

nfa.default;

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

// DFA minization.

/**
 * Map from state to current set it goes.
 */

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var currentTransitionMap = null;

/**
 * Takes a DFA, and returns a minimized version of it
 * compressing some states to groups (using standard, 0-, 1-,
 * 2-, ... N-equivalence algorithm).
 */
function minimize(dfa) {
  var table = dfa.getTransitionTable();
  var allStates = Object.keys(table);
  var alphabet = dfa.getAlphabet();
  var accepting = dfa.getAcceptingStateNumbers();

  currentTransitionMap = {};

  var nonAccepting = new Set();

  allStates.forEach(function (state) {
    state = Number(state);
    var isAccepting = accepting.has(state);

    if (isAccepting) {
      currentTransitionMap[state] = accepting;
    } else {
      nonAccepting.add(state);
      currentTransitionMap[state] = nonAccepting;
    }
  });

  // ---------------------------------------------------------------------------
  // Step 1: build equivalent sets.

  // All [1..N] equivalent sets.
  var all = [
  // 0-equivalent sets.
  [nonAccepting, accepting].filter(function (set) {
    return set.size > 0;
  })];

  var current = void 0;
  var previous = void 0;

  // Top of the stack is the current list of sets to analyze.
  current = all[all.length - 1];

  // Previous set (to check whether we need to stop).
  previous = all[all.length - 2];

  // Until we'll not have the same N and N-1 equivalent rows.

  var _loop = function _loop() {
    var newTransitionMap = {};

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = current[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var _set = _step3.value;

        // Handled states for this set.
        var handledStates = {};

        var _set2 = _toArray(_set),
            first = _set2[0],
            rest = _set2.slice(1);

        handledStates[first] = new Set([first]);

        // Have to compare each from the rest states with
        // the already handled states, and see if they are equivalent.
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          restSets: for (var _iterator4 = rest[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var state = _step4.value;
            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
              for (var _iterator5 = Object.keys(handledStates)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var handledState = _step5.value;

                // This and some previously handled state are equivalent --
                // just append this state to the same set.
                if (areEquivalent(state, handledState, table, alphabet)) {
                  handledStates[handledState].add(state);
                  handledStates[state] = handledStates[handledState];
                  continue restSets;
                }
              }
              // Else, this state is not equivalent to any of the
              // handled states -- allocate a new set for it.
            } catch (err) {
              _didIteratorError5 = true;
              _iteratorError5 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion5 && _iterator5.return) {
                  _iterator5.return();
                }
              } finally {
                if (_didIteratorError5) {
                  throw _iteratorError5;
                }
              }
            }

            handledStates[state] = new Set([state]);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        // Add these handled states to all states map.


        Object.assign(newTransitionMap, handledStates);
      }

      // Update current transition map for the handled row.
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    currentTransitionMap = newTransitionMap;

    var newSets = new Set(Object.keys(newTransitionMap).map(function (state) {
      return newTransitionMap[state];
    }));

    all.push([].concat(_toConsumableArray$1(newSets)));

    // Top of the stack is the current.
    current = all[all.length - 1];

    // Previous set.
    previous = all[all.length - 2];
  };

  while (!sameRow(current, previous)) {
    _loop();
  }

  // ---------------------------------------------------------------------------
  // Step 2: build minimized table from the equivalent sets.

  // Remap state numbers from sets to index-based.
  var remaped = new Map();
  var idx = 1;
  current.forEach(function (set) {
    return remaped.set(set, idx++);
  });

  // Build the minimized table from the calculated equivalent sets.
  var minimizedTable = {};

  var minimizedAcceptingStates = new Set();

  var updateAcceptingStates = function updateAcceptingStates(set, idx) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = set[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var state = _step.value;

        if (accepting.has(state)) {
          minimizedAcceptingStates.add(idx);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  };

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = remaped.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _ref = _step2.value;

      var _ref2 = _slicedToArray(_ref, 2);

      var set = _ref2[0];
      var _idx = _ref2[1];

      minimizedTable[_idx] = {};
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = alphabet[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var symbol = _step6.value;

          updateAcceptingStates(set, _idx);

          // Determine original transition for this symbol from the set.
          var originalTransition = void 0;
          var _iteratorNormalCompletion7 = true;
          var _didIteratorError7 = false;
          var _iteratorError7 = undefined;

          try {
            for (var _iterator7 = set[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
              var originalState = _step7.value;

              originalTransition = table[originalState][symbol];
              if (originalTransition) {
                break;
              }
            }
          } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion7 && _iterator7.return) {
                _iterator7.return();
              }
            } finally {
              if (_didIteratorError7) {
                throw _iteratorError7;
              }
            }
          }

          if (originalTransition) {
            minimizedTable[_idx][symbol] = remaped.get(currentTransitionMap[originalTransition]);
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }
    }

    // Update the table, and accepting states on the original DFA.
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  dfa.setTransitionTable(minimizedTable);
  dfa.setAcceptingStateNumbers(minimizedAcceptingStates);

  return dfa;
}

function sameRow(r1, r2) {
  if (!r2) {
    return false;
  }

  if (r1.length !== r2.length) {
    return false;
  }

  for (var i = 0; i < r1.length; i++) {
    var s1 = r1[i];
    var s2 = r2[i];

    if (s1.size !== s2.size) {
      return false;
    }

    if ([].concat(_toConsumableArray$1(s1)).sort().join(',') !== [].concat(_toConsumableArray$1(s2)).sort().join(',')) {
      return false;
    }
  }

  return true;
}

/**
 * Checks whether two states are N-equivalent, i.e. whether they go
 * to the same set on a symbol.
 */
function areEquivalent(s1, s2, table, alphabet) {
  var _iteratorNormalCompletion8 = true;
  var _didIteratorError8 = false;
  var _iteratorError8 = undefined;

  try {
    for (var _iterator8 = alphabet[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
      var symbol = _step8.value;

      if (!goToSameSet(s1, s2, table, symbol)) {
        return false;
      }
    }
  } catch (err) {
    _didIteratorError8 = true;
    _iteratorError8 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion8 && _iterator8.return) {
        _iterator8.return();
      }
    } finally {
      if (_didIteratorError8) {
        throw _iteratorError8;
      }
    }
  }

  return true;
}

/**
 * Checks whether states go to the same set.
 */
function goToSameSet(s1, s2, table, symbol) {
  if (!currentTransitionMap[s1] || !currentTransitionMap[s2]) {
    return false;
  }

  var originalTransitionS1 = table[s1][symbol];
  var originalTransitionS2 = table[s2][symbol];

  // If no actual transition on this symbol, treat it as positive.
  if (!originalTransitionS1 && !originalTransitionS2) {
    return true;
  }

  // Otherwise, check if they are in the same sets.
  return currentTransitionMap[s1].has(originalTransitionS1) && currentTransitionMap[s2].has(originalTransitionS2);
}

var dfaMinimizer = {
  minimize: minimize
};

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var _createClass$3 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DFAMinimizer = dfaMinimizer;

var _require$1 = specialSymbols,
    EPSILON_CLOSURE = _require$1.EPSILON_CLOSURE;

/**
 * DFA is build by converting from NFA (subset construction).
 */


var DFA = function () {
  function DFA(nfa) {
    _classCallCheck$3(this, DFA);

    this._nfa = nfa;
  }

  /**
   * Minimizes DFA.
   */


  _createClass$3(DFA, [{
    key: 'minimize',
    value: function minimize() {
      this.getTransitionTable();

      this._originalAcceptingStateNumbers = this._acceptingStateNumbers;
      this._originalTransitionTable = this._transitionTable;

      DFAMinimizer.minimize(this);
    }

    /**
     * Returns alphabet for this DFA.
     */

  }, {
    key: 'getAlphabet',
    value: function getAlphabet() {
      return this._nfa.getAlphabet();
    }

    /**
     * Returns accepting states.
     */

  }, {
    key: 'getAcceptingStateNumbers',
    value: function getAcceptingStateNumbers() {
      if (!this._acceptingStateNumbers) {
        // Accepting states are determined during table construction.
        this.getTransitionTable();
      }

      return this._acceptingStateNumbers;
    }

    /**
     * Returns original accepting states.
     */

  }, {
    key: 'getOriginaAcceptingStateNumbers',
    value: function getOriginaAcceptingStateNumbers() {
      if (!this._originalAcceptingStateNumbers) {
        // Accepting states are determined during table construction.
        this.getTransitionTable();
      }

      return this._originalAcceptingStateNumbers;
    }

    /**
     * Sets transition table.
     */

  }, {
    key: 'setTransitionTable',
    value: function setTransitionTable(table) {
      this._transitionTable = table;
    }

    /**
     * Sets accepting states.
     */

  }, {
    key: 'setAcceptingStateNumbers',
    value: function setAcceptingStateNumbers(stateNumbers) {
      this._acceptingStateNumbers = stateNumbers;
    }

    /**
     * DFA transition table is built from NFA table.
     */

  }, {
    key: 'getTransitionTable',
    value: function getTransitionTable() {
      var _this = this;

      if (this._transitionTable) {
        return this._transitionTable;
      }

      // Calculate from NFA transition table.
      var nfaTable = this._nfa.getTransitionTable();
      var nfaStates = Object.keys(nfaTable);

      this._acceptingStateNumbers = new Set();

      // Start state of DFA is E(S[nfa])
      var startState = nfaTable[nfaStates[0]][EPSILON_CLOSURE];

      // Init the worklist (states which should be in the DFA).
      var worklist = [startState];

      var alphabet = this.getAlphabet();
      var nfaAcceptingStates = this._nfa.getAcceptingStateNumbers();

      var dfaTable = {};

      // Determine whether the combined DFA state is accepting.
      var updateAcceptingStates = function updateAcceptingStates(states) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = nfaAcceptingStates[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var nfaAcceptingState = _step.value;

            // If any of the states from NFA is accepting, DFA's
            // state is accepting as well.
            if (states.indexOf(nfaAcceptingState) !== -1) {
              _this._acceptingStateNumbers.add(states.join(','));
              break;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      };

      while (worklist.length > 0) {
        var states = worklist.shift();
        var dfaStateLabel = states.join(',');
        dfaTable[dfaStateLabel] = {};

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = alphabet[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var symbol = _step2.value;

            var onSymbol = [];

            // Determine whether the combined state is accepting.
            updateAcceptingStates(states);

            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = states[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var state = _step3.value;

                var nfaStatesOnSymbol = nfaTable[state][symbol];
                if (!nfaStatesOnSymbol) {
                  continue;
                }

                var _iteratorNormalCompletion4 = true;
                var _didIteratorError4 = false;
                var _iteratorError4 = undefined;

                try {
                  for (var _iterator4 = nfaStatesOnSymbol[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    var nfaStateOnSymbol = _step4.value;

                    if (!nfaTable[nfaStateOnSymbol]) {
                      continue;
                    }
                    onSymbol.push.apply(onSymbol, _toConsumableArray(nfaTable[nfaStateOnSymbol][EPSILON_CLOSURE]));
                  }
                } catch (err) {
                  _didIteratorError4 = true;
                  _iteratorError4 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                      _iterator4.return();
                    }
                  } finally {
                    if (_didIteratorError4) {
                      throw _iteratorError4;
                    }
                  }
                }
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }

            var dfaStatesOnSymbolSet = new Set(onSymbol);
            var dfaStatesOnSymbol = [].concat(_toConsumableArray(dfaStatesOnSymbolSet));

            if (dfaStatesOnSymbol.length > 0) {
              var dfaOnSymbolStr = dfaStatesOnSymbol.join(',');

              dfaTable[dfaStateLabel][symbol] = dfaOnSymbolStr;

              if (!dfaTable.hasOwnProperty(dfaOnSymbolStr)) {
                worklist.unshift(dfaStatesOnSymbol);
              }
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }

      return this._transitionTable = this._remapStateNumbers(dfaTable);
    }

    /**
     * Remaps state numbers in the resulting table:
     * combined states '1,2,3' -> 1, '3,4' -> 2, etc.
     */

  }, {
    key: '_remapStateNumbers',
    value: function _remapStateNumbers(calculatedDFATable) {
      var newStatesMap = {};

      this._originalTransitionTable = calculatedDFATable;
      var transitionTable = {};

      Object.keys(calculatedDFATable).forEach(function (originalNumber, newNumber) {
        newStatesMap[originalNumber] = newNumber + 1;
      });

      for (var originalNumber in calculatedDFATable) {
        var originalRow = calculatedDFATable[originalNumber];
        var row = {};

        for (var symbol in originalRow) {
          row[symbol] = newStatesMap[originalRow[symbol]];
        }

        transitionTable[newStatesMap[originalNumber]] = row;
      }

      // Remap accepting states.
      this._originalAcceptingStateNumbers = this._acceptingStateNumbers;
      this._acceptingStateNumbers = new Set();

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this._originalAcceptingStateNumbers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _originalNumber = _step5.value;

          this._acceptingStateNumbers.add(newStatesMap[_originalNumber]);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return transitionTable;
    }

    /**
     * Returns original DFA table, where state numbers
     * are combined numbers from NFA.
     */

  }, {
    key: 'getOriginalTransitionTable',
    value: function getOriginalTransitionTable() {
      if (!this._originalTransitionTable) {
        // Original table is determined during table construction.
        this.getTransitionTable();
      }
      return this._originalTransitionTable;
    }

    /**
     * Checks whether this DFA accepts a string.
     */

  }, {
    key: 'matches',
    value: function matches(string) {
      var state = 1;
      var i = 0;
      var table = this.getTransitionTable();

      while (string[i]) {
        state = table[state][string[i++]];
        if (!state) {
          return false;
        }
      }

      if (!this.getAcceptingStateNumbers().has(state)) {
        return false;
      }

      return true;
    }
  }]);

  return DFA;
}();

var dfa = DFA;

dfa.default;

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * A generic FA State class (base for NFA and DFA).
 *
 * Maintains the transition map, and the flag whether
 * the state is accepting.
 */

var _createClass$2 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var State$1 = function () {
  function State() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$accepting = _ref.accepting,
        accepting = _ref$accepting === undefined ? false : _ref$accepting;

    _classCallCheck$2(this, State);

    /**
     * Outgoing transitions to other states.
     */
    this._transitions = new Map();

    /**
     * Whether the state is accepting.
     */
    this.accepting = accepting;
  }

  /**
   * Returns transitions for this state.
   */


  _createClass$2(State, [{
    key: 'getTransitions',
    value: function getTransitions() {
      return this._transitions;
    }

    /**
     * Creates a transition on symbol.
     */

  }, {
    key: 'addTransition',
    value: function addTransition(symbol, toState) {
      this.getTransitionsOnSymbol(symbol).add(toState);
      return this;
    }

    /**
     * Returns transitions set on symbol.
     */

  }, {
    key: 'getTransitionsOnSymbol',
    value: function getTransitionsOnSymbol(symbol) {
      var transitions = this._transitions.get(symbol);

      if (!transitions) {
        transitions = new Set();
        this._transitions.set(symbol, transitions);
      }

      return transitions;
    }
  }]);

  return State;
}();

var state = State$1;

state.default;

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var _createClass$1 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var State = state;

var _require = specialSymbols,
    EPSILON = _require.EPSILON;

/**
 * NFA state.
 *
 * Allows nondeterministic transitions to several states on the
 * same symbol, and also epsilon-transitions.
 */


var NFAState = function (_State) {
  _inherits(NFAState, _State);

  function NFAState() {
    _classCallCheck$1(this, NFAState);

    return _possibleConstructorReturn(this, (NFAState.__proto__ || Object.getPrototypeOf(NFAState)).apply(this, arguments));
  }

  _createClass$1(NFAState, [{
    key: 'matches',


    /**
     * Whether this state matches a string.
     *
     * We maintain set of visited epsilon-states to avoid infinite loops
     * when an epsilon-transition goes eventually to itself.
     *
     * NOTE: this function is rather "educational", since we use DFA for strings
     * matching. DFA is built on top of NFA, and uses fast transition table.
     */
    value: function matches(string) {
      var visited = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();

      // An epsilon-state has been visited, stop to avoid infinite loop.
      if (visited.has(this)) {
        return false;
      }

      visited.add(this);

      // No symbols left..
      if (string.length === 0) {
        // .. and we're in the accepting state.
        if (this.accepting) {
          return true;
        }

        // Check if we can reach any accepting state from
        // on the epsilon transitions.
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.getTransitionsOnSymbol(EPSILON)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var nextState = _step.value;

            if (nextState.matches('', visited)) {
              return true;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return false;
      }

      // Else, we get some symbols.
      var symbol = string[0];
      var rest = string.slice(1);

      var symbolTransitions = this.getTransitionsOnSymbol(symbol);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = symbolTransitions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _nextState = _step2.value;

          if (_nextState.matches(rest)) {
            return true;
          }
        }

        // If we couldn't match on symbol, check still epsilon-transitions
        // without consuming the symbol (i.e. continue from `string`, not `rest`).
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.getTransitionsOnSymbol(EPSILON)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _nextState2 = _step3.value;

          if (_nextState2.matches(string, visited)) {
            return true;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return false;
    }

    /**
     * Returns an -closure for this state:
     * self + all states following -transitions.
     */

  }, {
    key: 'getEpsilonClosure',
    value: function getEpsilonClosure() {
      var _this2 = this;

      if (!this._epsilonClosure) {
        (function () {
          var epsilonTransitions = _this2.getTransitionsOnSymbol(EPSILON);
          var closure = _this2._epsilonClosure = new Set();
          closure.add(_this2);
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = epsilonTransitions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var nextState = _step4.value;

              if (!closure.has(nextState)) {
                closure.add(nextState);
                var nextClosure = nextState.getEpsilonClosure();
                nextClosure.forEach(function (state) {
                  return closure.add(state);
                });
              }
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
        })();
      }

      return this._epsilonClosure;
    }
  }]);

  return NFAState;
}(State);

var nfaState = NFAState;

nfaState.default;

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * The `RegExpTree` class provides runtime support for `compat-transpiler`
 * module from `regexp-tree`.
 *
 * E.g. it tracks names of the capturing groups, in order to access the
 * names on the matched result.
 *
 * It's a thin-wrapper on top of original regexp.
 */

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function () {
  /**
   * Initializes a `RegExpTree` instance.
   *
   * @param RegExp - a regular expression
   *
   * @param Object state:
   *
   *   An extra state which may store any related to transformation
   *   data, for example, names of the groups.
   *
   *   - flags - original flags
   *   - groups - names of the groups, and their indices
   *   - source - original source
   */
  function RegExpTree(re, _ref) {
    var flags = _ref.flags,
        groups = _ref.groups,
        source = _ref.source;

    _classCallCheck(this, RegExpTree);

    this._re = re;
    this._groups = groups;

    // Original props.
    this.flags = flags;
    this.source = source || re.source;
    this.dotAll = flags.includes('s');

    // Inherited directly from `re`.
    this.global = re.global;
    this.ignoreCase = re.ignoreCase;
    this.multiline = re.multiline;
    this.sticky = re.sticky;
    this.unicode = re.unicode;
  }

  /**
   * Facade wrapper for RegExp `test` method.
   */


  _createClass(RegExpTree, [{
    key: 'test',
    value: function test(string) {
      return this._re.test(string);
    }

    /**
     * Facade wrapper for RegExp `compile` method.
     */

  }, {
    key: 'compile',
    value: function compile(string) {
      return this._re.compile(string);
    }

    /**
     * Facade wrapper for RegExp `toString` method.
     */

  }, {
    key: 'toString',
    value: function toString() {
      if (!this._toStringResult) {
        this._toStringResult = '/' + this.source + '/' + this.flags;
      }
      return this._toStringResult;
    }

    /**
     * Facade wrapper for RegExp `exec` method.
     */

  }, {
    key: 'exec',
    value: function exec(string) {
      var result = this._re.exec(string);

      if (!this._groups || !result) {
        return result;
      }

      result.groups = {};

      for (var group in this._groups) {
        var groupNumber = this._groups[group];
        result.groups[group] = result[groupNumber];
      }

      return result;
    }
  }]);

  return RegExpTree;
})();

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

/**
 * An API object for RegExp processing (parsing/transform/generation).
 */


var regexpTree$2 = {
  };

var regexpTree_1 = regexpTree$2;

/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

var regexpTree = regexpTree_1;

var regexpTree$1 = regexpTreeParser;

const notSimpleChar = ({type, kind}) => type !== 'Char' || kind !== 'simple';

const isSimpleRegExp = (regexp) => {
    let containsMoreThenSimpleChars = false;
    const ast = regexpTree$1.parse(regexp);
    
    if (ast.body.type !== 'Alternative')
        return false;
    
    regexpTree$1.traverse(ast, {
        RegExp({node}) {
            const {expressions} = node.body;
            containsMoreThenSimpleChars = Boolean(expressions.find(notSimpleChar));
        },
    });
    
    return !containsMoreThenSimpleChars;
};

const transformRegExp = (str, regExpTransformer) => {
    check$1(regExpTransformer);
    
    const {
        report,
        traverse,
        fix,
    } = regExpTransformer;
    
    const ast = regexpTree$1.parse(str, {
        captureLocations: true,
    });
    
    const places = [];
    
    const push = (path) => {
        const {start} = (path.path || path).node.loc;
        
        places.push({
            position: start,
            message: report(path),
        });
        
        fix(path);
    };
    
    regexpTree$1.traverse(ast, traverse({
        push,
    }));
    
    return [
        regexpTree$1.generate(ast),
        places,
    ];
};

function check$1(regExpTransformer) {
    if (!regExpTransformer)
        throw Error(' Looks like RegExpTransformer is missing');
}

const {
    isBlockStatement,
    isFunction,
    isLabeledStatement,
    isObjectPattern,
    isCallExpression,
    objectPattern,
    objectProperty,
} = lib_exports;

const {entries: entries$1} = Object;
const SHORTHAND = true;

const isCallOrStatement = (path) => path.isCallExpression() || path.isStatement();

const isCall = (path) => {
    return isCallExpression(path.find(isCallOrStatement));
};

const report$2 = ({name}) => `Argument '${name}' is missing`;

const addArgs = (args) => ({
    report: report$2,
    fix: fix$2,
    traverse: traverse(args),
});

const fix$2 = ({declaration, path, pattern, params, index}) => {
    const declarationNode = template$1.ast.fresh(declaration);
    
    if (isBlockStatement(declarationNode)) {
        const prop = createProperty(declarationNode.body[0]);
        pattern.properties.push(prop);
        
        if (!isObjectPattern(params[index]))
            return params.push(pattern);
        
        return;
    }
    
    path.scope.block.params = [
        declarationNode,
    ];
};

const traverse = (args) => ({push, options}) => {
    const allArgs = {
        ...options.args,
        ...args,
    };
    
    return {
        ReferencedIdentifier(path) {
            for (const [name, [declaration, pattern, exclude]] of entries$1(allArgs)) {
                if (path.node.name !== name)
                    continue;
                
                if (path.scope.hasBinding(name))
                    continue;
                
                if (!isCall(path))
                    continue;
                
                const fnPath = path.find(isFunction);
                
                if (!fnPath)
                    continue;
                
                const {block} = fnPath.scope;
                
                if (!compareAny(path.scope.path, pattern))
                    continue;
                
                if (compareAny(path.scope.path, exclude))
                    continue;
                
                const {params} = block;
                const [index, lastParam] = getObjectPattern(params);
                
                if (isObjectPattern(lastParam)) {
                    push({
                        name,
                        index,
                        declaration,
                        path,
                        params,
                        pattern: lastParam,
                    });
                    return;
                }
                
                if (params.length >= 3)
                    return;
                
                push({
                    name,
                    index,
                    declaration,
                    path,
                    params,
                    pattern: objectPattern([]),
                });
            }
        },
    };
};

function createProperty(node) {
    if (!isLabeledStatement(node)) {
        const {expression} = node;
        return objectProperty(expression, expression, false, SHORTHAND);
    }
    
    const {label, body} = node;
    
    return objectProperty(label, body.expression, false, SHORTHAND);
}

function getObjectPattern(params) {
    for (const [i, param] of params.entries()) {
        if (isObjectPattern(param))
            return [i, param];
    }
    
    return [
        -1,
        null,
    ];
}

const moduleDeclarations = [
    'import',
    'export',
    'assert',
    'with',
];

const declarations = [
    'const',
    'var',
    'let',
];

const conditions = ['if'];

const typescript = [
    'readonly',
    'implements',
    'declare',
    'module',
    'type',
    'namespace',
];

const typescriptReserved = [
    'interface',
    'static',
];

const expressions = [
    'as',
    'await',
    'new',
    'yield',
    'typeof',
    'function',
];

const statements = [
    ...conditions,
    ...declarations,
    ...moduleDeclarations,
    ...typescriptReserved,
    'async',
    'break',
    'continue',
    'debugger',
    'for',
    'else',
    'from',
    'return',
    'throw',
    'of',
    'while',
    'class',
    'extends',
    'default',
];

const keywords = [
    ...statements,
    ...expressions,
];

const isKeyword = (name) => {
    return keywords.includes(name);
};

const isDeclarationKeyword = (name) => {
    return declarations.includes(name);
};

const isModuleDeclarationKeyword = (name) => {
    return moduleDeclarations.includes(name);
};

const isConditionKeyword = (name) => {
    return conditions.includes(name);
};

const isStatementKeyword = (name) => {
    return statements.includes(name);
};

const isTSKeyword = (name) => {
    const ts = typescript.includes(name);
    const tsReserved = typescriptReserved.includes(name);
    
    return ts || tsReserved;
};

const findPlaces = (ast, source, opts) => {
    return transform(ast, source, {
        ...opts,
        fix: false,
    });
};

const findPlacesAsync = async (ast, source, opts) => {
    return await transformAsync(ast, source, {
        ...opts,
        fix: false,
    });
};

const isNegative = (a) => !a.indexOf('!');
const positive = (a) => a.replace(/^!/, '');

const ignores = (dirOpt, resolvedName, options = {}) => {
    const relativeName = relative(dirOpt, resolvedName);
    const ignorer = noop$3();
    const ignoreList = mergeIgnores(options.ignore || []);
    
    ignorer.add(ignoreList);
    
    return dirOpt && ignorer.ignores(relativeName);
};

function mergeIgnores(ignores) {
    for (const [i, str] of ignores.entries()) {
        const positiveIndex = ignores.indexOf(positive(str));
        
        if (isNegative(str) && positiveIndex > i)
            ignores[positiveIndex] = str;
    }
    
    const noDuplicates = new Set(ignores);
    
    return Array.from(noDuplicates);
}

const {join} = path;

const isObject = (a) => a && typeof a === 'object';
const {entries} = Object;
const report$1 = (path, {message}) => message;

const matchFiles = (options) => {
    const {filename} = options;
    const files = options.files ?? options;
    const exclude = options.exclude ?? [];
    
    check(files);
    
    const scan = createScan({
        defaultFilename: filename,
        files,
        exclude,
    });
    
    return {
        fix: fix$1,
        scan,
        report: report$1,
    };
};

function fix$1(inputFile, {dirPath, matchInputFilename, outputFilename, matchedJS, matchedAST, options}) {
    transform(matchedAST, matchedJS, options);
    
    const matchedJSON = magicPrint(outputFilename, matchedAST);
    const outputFile = getOutputFile({
        dirPath,
        matchInputFilename,
        outputFilename,
        inputFile,
    });
    
    writeFileContent(outputFile, matchedJSON);
    
    if (inputFile !== outputFile)
        removeFile(inputFile);
}

const createScan = ({files, exclude, defaultFilename}) => (mainPath, {push, progress, options}) => {
    const allFiles = [];
    const cwd = getFilename$2(mainPath);
    
    options.filename = options.filename ?? defaultFilename;
    
    for (const [filename, rawOptions] of entries(files)) {
        const [matchInputFilenameMask] = parseMatcher(filename, options);
        const inputFiles = findFile$2(mainPath, matchInputFilenameMask, exclude);
        
        for (const inputFile of inputFiles) {
            const dirPath = getParentDirectory(inputFile);
            const inputFilename = getFilename$2(inputFile);
            
            const [matchInputFilename, outputFilename = matchInputFilename] = parseMatcher(filename, {
                filename: inputFilename,
            });
            
            if (ignores(cwd, inputFilename, options))
                continue;
            
            allFiles.push({
                dirPath,
                matchInputFilename,
                rawOptions,
                inputFile,
                inputFilename,
                outputFilename,
            });
        }
    }
    
    const n = allFiles.length;
    
    for (const [i, current] of allFiles.entries()) {
        const {
            dirPath,
            matchInputFilename,
            inputFile,
            inputFilename,
            outputFilename,
            rawOptions,
        } = current;
        
        progress({
            i,
            n,
        });
        
        const fileContent = readFileContent(inputFile) || '{}';
        const [matchedJS, matchedAST] = magicParse(inputFilename, fileContent);
        
        const options = parseOptions(inputFilename, rawOptions);
        const places = findPlaces(matchedAST, matchedJS, options);
        
        if (!places.length)
            continue;
        
        const {message} = places[0];
        
        push(inputFile, {
            dirPath,
            matchInputFilename,
            
            outputFilename,
            message,
            options,
            
            matchedAST,
            matchedJS,
        });
    }
};

function magicParse(name, content) {
    if (name.endsWith('.json')) {
        const js = toJS(content);
        const ast = parse$2(js);
        
        return [js, ast];
    }
    
    if (/\.(c|m)?ts(x)?$/.test(name)) {
        const ast = parse$2(content, {
            isTS: true,
        });
        
        return [content, ast];
    }
    
    return [content, parse$2(content)];
}

function magicPrint(name, ast) {
    if (name.endsWith('.json')) {
        const js = print(ast);
        
        return fromJS(js);
    }
    
    return print(ast);
}

function check(files) {
    for (const [, plugin] of entries(files)) {
        if (!isObject(plugin))
            throw Error(` Looks like provided to 'matchFiles()' typeof of plugin is not an 'object' but '${typeof plugin}'`);
    }
}

function getOutputFile({dirPath, matchInputFilename, outputFilename, inputFile}) {
    if (matchInputFilename === outputFilename)
        return inputFile;
    
    const name = join(getFilename$2(dirPath), outputFilename);
    const [outputFile] = findFile$2(dirPath, name);
    
    if (outputFile)
        return outputFile;
    
    return createFile(dirPath, outputFilename);
}

function parseMatcher(matcher, options) {
    const {filename} = options;
    
    if (!filename)
        return matcher.split(' -> ');
    
    const {ext, name} = path.parse(filename);
    
    matcher = matcher.replaceAll(`__name`, name);
    matcher = matcher.replaceAll(`__ext`, ext);
    
    return matcher.split(' -> ');
}

function parseOptions(inputFilename, rawOptions) {
    if (rawOptions.plugins)
        return rawOptions;
    
    const name = `match-file: ${inputFilename}`;
    
    const plugins = [
        [name, rawOptions],
    ];
    
    return {
        plugins,
    };
}

const {parse} = JSON;

const renameFiles = ({type, mask, rename}) => ({
    report,
    fix,
    scan: scan({
        type,
        mask,
        rename,
    }),
});

const report = (file, {from, to}) => `Rename '${from}' to '${to}'`;

const fix = (file, {to}) => {
    renameFile(file, to);
};

const scan = ({type, mask, rename}) => (path, {push, trackFile}) => {
    for (const file of trackFile(path, mask)) {
        if (type && !checkType(type, file))
            continue;
        
        const from = getFilename$2(file);
        const to = rename(from);
        
        push(file, {
            from,
            to,
        });
    }
};

function checkType(type, file) {
    const packagePath = findUpPackage(file);
    
    if (type === 'commonjs' && !packagePath)
        return true;
    
    if (!packagePath)
        return false;
    
    const packageContent = readFileContent(packagePath);
    
    if (!packageContent)
        return false;
    
    const info = parse(packageContent);
    const infoType = info.type || 'commonjs';
    
    return infoType === type;
}

function findUpPackage(file) {
    let packageJSON;
    let dirPath = getParentDirectory(file);
    
    do {
        const dir = getFilename$2(dirPath);
        [packageJSON] = findFile$2(dirPath, join$1(dir, 'package.json'));
    } while (!packageJSON && (dirPath = getParentDirectory(dirPath)));
    
    return packageJSON;
}

const {stringLiteral} = lib_exports;
const getValue = ({value}) => value;

const ignore = (type, {name, property, list}) => {
    const [, collector] = type.split(/[()]/);
    
    return {
        report: createReport(name),
        match: createMatch({
            type,
            property,
            collector,
            list,
        }),
        replace: createReplace({
            type,
            property,
            collector,
            list,
        }),
    };
};

const createReport = (name) => () => `Add dotfiles to '${name}'`;

const createMatch = ({type, property, collector, list}) => ({options}) => {
    const {dismiss = []} = options;
    const newNames = filterNames(list, dismiss);
    
    return {
        [type]: (vars) => {
            const elements = parseElements(vars, {
                property,
                collector,
            });
            
            if (!elements)
                return false;
            
            const list = elements.map(getValue);
            
            for (const name of newNames) {
                if (!list.includes(name))
                    return true;
            }
            
            return false;
        },
    };
};

const createReplace = ({type, property, collector, list}) => ({options}) => {
    const {dismiss = []} = options;
    const newNames = filterNames(list, dismiss);
    
    return {
        [type]: (vars, path) => {
            const elements = parseElements(vars, {
                property,
                collector,
            });
            
            const list = elements.map(getValue);
            
            for (const name of newNames) {
                if (!list.includes(name))
                    elements.push(stringLiteral(name));
            }
            
            return path;
        },
    };
};

function filterNames(names, dismiss) {
    const newNames = [];
    
    for (const name of names) {
        if (dismiss.includes(name))
            continue;
        
        newNames.push(name);
    }
    
    return newNames;
}

function parseElements(vars, {property, collector}) {
    const node = vars[collector];
    
    if (!property)
        return node.elements;
    
    const [prop] = traverseProperties(node, property);
    
    if (!prop)
        return null;
    
    return prop.node.value.elements;
}

const {
    parenthesizedExpression,
    tsParenthesizedType,
} = lib_exports;

const addParens = (path) => {
    const printer = getPrinter(path);
    
    if (hasParens(path, printer))
        return path;
    
    if (printer !== 'babel') {
        const {extra = {}} = path.node;
        
        extra.parenthesized = true;
        path.node.extra = extra;
        
        return path;
    }
    
    const {node} = path;
    
    if (path.type.startsWith('TS'))
        return path.replaceWith(tsParenthesizedType(node));
    
    path.replaceWith(parenthesizedExpression(node));
    
    return path;
};

const removeParens = (path) => {
    const printer = getPrinter(path);
    
    if (!hasParens(path, printer))
        return path;
    
    if (printer !== 'babel') {
        path.node.extra.parenthesized = false;
        return path;
    }
    
    const {node} = path;
    path.parentPath.replaceWith(node);
    
    return path;
};

function getPrinter(path) {
    const scope = path.scope.getProgramParent();
    const programPath = scope.path;
    
    return programPath.node.extra.__putout_printer;
}

function hasParens(path, printer = getPrinter(path)) {
    if (printer !== 'babel')
        return path.node.extra?.parenthesized;
    
    const {type} = path.parentPath;
    
    return /^(TS)?Parenthesized(Expression|Type)?$/.test(type);
}

var operator = /*#__PURE__*/Object.freeze({
	__proto__: null,
	__filesystem: __filesystem,
	__filesystem_name: __filesystem_name$2,
	__ignore: __ignore,
	__ignore_name: __ignore_name,
	__json: __json,
	__json_name: __json_name,
	__toml: __toml,
	__toml_name: __toml_name,
	__yaml: __yaml,
	__yaml_name: __yaml_name,
	addArgs: addArgs,
	addAttribute: addAttribute,
	addAttributeValue: addAttributeValue,
	addClassName: addClassName,
	addParens: addParens,
	compare: compare,
	compareAll: compareAll,
	compareAny: compareAny,
	compute: compute,
	contains: contains,
	containsClassName: containsClassName,
	copyFile: copyFile,
	createDirectory: createDirectory$1,
	createFile: createFile,
	createNestedDirectory: createNestedDirectory,
	declare: declare$1,
	deinit: deinit,
	extract: extract,
	findBinding: findBinding,
	findFile: findFile$2,
	findVarsWays: findVarsWays,
	fromJS: fromJS,
	getAttributeNode: getAttributeNode,
	getAttributePath: getAttributePath,
	getAttributeValue: getAttributeValue,
	getBinding: getBinding,
	getBindingPath: getBindingPath,
	getClassName: getClassName,
	getExportDefault: getExportDefault,
	getFileContent: getFileContent,
	getFileType: getFileType$2,
	getFilename: getFilename$2,
	getLiteralRaw: getLiteralRaw,
	getParentDirectory: getParentDirectory,
	getPathAfterImports: getPathAfterImports,
	getPathAfterRequires: getPathAfterRequires,
	getProperties: getProperties,
	getProperty: getProperty$2,
	getRootDirectory: getRootDirectory,
	getTemplateValues: getTemplateValues,
	getValues: getValues,
	hasAttributeValue: hasAttributeValue,
	hasDataName: hasDataName,
	hasParens: hasParens,
	hasTagName: hasTagName,
	ignore: ignore,
	init: init,
	insertAfter: insertAfter,
	insertBefore: insertBefore,
	isConditionKeyword: isConditionKeyword,
	isDeclarationKeyword: isDeclarationKeyword,
	isESM: isESM,
	isJSON: isJSON,
	isKeyword: isKeyword,
	isModuleDeclarationKeyword: isModuleDeclarationKeyword,
	isModuleExports: isModuleExports,
	isSimple: isSimple,
	isSimpleRegExp: isSimpleRegExp,
	isStatementKeyword: isStatementKeyword,
	isTSKeyword: isTSKeyword,
	isTemplate: isTemplate,
	matchFiles: matchFiles,
	moveFile: moveFile,
	parseTemplate: parseTemplate,
	pause: pause,
	readDirectory: readDirectory,
	readFileContent: readFileContent,
	remove: remove,
	removeAttributeValue: removeAttributeValue,
	removeClassName: removeClassName,
	removeEmptyDirectory: removeEmptyDirectory,
	removeFile: removeFile,
	removeParens: removeParens,
	rename: rename,
	renameFile: renameFile,
	renameFiles: renameFiles,
	renameProperty: renameProperty,
	replaceWith: replaceWith$2,
	replaceWithMultiple: replaceWithMultiple,
	setAttributeValue: setAttributeValue,
	setLiteralValue: setLiteralValue,
	setValues: setValues,
	start: start,
	toExpression: toExpression,
	toJS: toJS,
	transformRegExp: transformRegExp,
	traverse: traverse$1,
	traverseProperties: traverseProperties,
	writeFileContent: writeFileContent
});

const codeframe = ({source, error, highlightCode = true}) => {
    const {message, loc} = error;
    
    if (!loc)
        return message;
    
    const location = {
        start: loc,
    };
    
    return codeFrameColumns(source, location, {
        highlightCode,
        message,
    });
};

var exports$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	codeframe: codeframe,
	findPlaces: findPlaces,
	findPlacesAsync: findPlacesAsync,
	generate: generate,
	operator: operator,
	parse: parse$2,
	print: print,
	putoutAsync: putoutAsync,
	template: template$1,
	transform: transform,
	transformAsync: transformAsync,
	traverse: traverse3,
	types: lib_exports
});

Object.assign(putout, exports$1);

export { codeframe, putout as default, findPlaces, findPlacesAsync, generate, operator, parse$2 as parse, print, putout, putoutAsync, template$1 as template, transform, transformAsync, traverse3 as traverse, lib_exports as types };
